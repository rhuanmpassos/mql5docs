<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©todos matriciais e vetoriais - MQL5 Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>MQL5 Docs</h1>
            <p>Documenta√ß√£o Completa</p>
        </div>
        <div class="search-box">
            <input type="text" id="search" placeholder="Buscar..." onkeyup="filterNav()">
        </div>
        <ul class="nav-list" id="nav-list">
            <li class=""><a href="index.html">üìö √çndice</a></li>
            <li class=""><a href="introducao.html">Introducao</a></li>
<li class=""><a href="refer√™ncia_mql5.html">Refer√™ncia MQL5</a></li>
<li class=""><a href="elementos_b√°sicos_da_linguagem.html">Elementos B√°sicos da Linguagem</a></li>
<li class=""><a href="constantes,_enumeradores_e_estruturas.html">Constantes, Enumeradores e Estruturas</a></li>
<li class=""><a href="programas_mql5.html">Programas MQL5</a></li>
<li class=""><a href="vari√°veis_predefinidas.html">Vari√°veis Predefinidas</a></li>
<li class=""><a href="fun√ß√µes_comuns.html">Fun√ß√µes Comuns</a></li>
<li class=""><a href="fun√ß√µes_para_array.html">Fun√ß√µes para Array</a></li>
<li class="active"><a href="m√©todos_matriciais_e_vetoriais.html">M√©todos matriciais e vetoriais</a></li>
<li class=""><a href="fun√ß√µes_de_convers√£o.html">Fun√ß√µes de Convers√£o</a></li>
<li class=""><a href="fun√ß√µes_matem√°ticas.html">Fun√ß√µes Matem√°ticas</a></li>
<li class=""><a href="fun√ß√µes_de_string.html">Fun√ß√µes de String</a></li>
<li class=""><a href="data_e_hora.html">Data e Hora</a></li>
<li class=""><a href="informa√ß√µes_de_conta.html">Informa√ß√µes de Conta</a></li>
<li class=""><a href="verificando_estado.html">Verificando Estado</a></li>
<li class=""><a href="manipula√ß√£o_de_eventos.html">Manipula√ß√£o de eventos</a></li>
<li class=""><a href="informa√ß√µes_de_mercado.html">Informa√ß√µes de Mercado</a></li>
<li class=""><a href="calend√°rio_econ√¥mico.html">Calend√°rio econ√¥mico</a></li>
<li class=""><a href="s√©ries_temporais_e_acesso_a_indicadores.html">S√©ries Temporais e Acesso a Indicadores</a></li>
<li class=""><a href="s√≠mbolos_personalizados.html">S√≠mbolos personalizados</a></li>
<li class=""><a href="opera√ß√µes_de_gr√°ficos.html">Opera√ß√µes de Gr√°ficos</a></li>
<li class=""><a href="fun√ß√µes_de_negocia√ß√£o.html">Fun√ß√µes de Negocia√ß√£o</a></li>
<li class=""><a href="gerenciamento_de_sinais.html">Gerenciamento de sinais</a></li>
<li class=""><a href="fun√ß√µes_de_rede.html">Fun√ß√µes de rede</a></li>
<li class=""><a href="vari√°veis_globais_do_terminal.html">Vari√°veis Globais do Terminal</a></li>
<li class=""><a href="fun√ß√µes_de_arquivo.html">Fun√ß√µes de Arquivo</a></li>
<li class=""><a href="indicadores_customizados.html">Indicadores Customizados</a></li>
<li class=""><a href="fun√ß√µes_de_objeto.html">Fun√ß√µes de Objeto</a></li>
<li class=""><a href="indicadores_t√©cnicos.html">Indicadores T√©cnicos</a></li>
<li class=""><a href="trabalhando_com_resultados_de_otimiza√ß√£o.html">Trabalhando com Resultados de Otimiza√ß√£o</a></li>
<li class=""><a href="trabalhando_com_eventos.html">Trabalhando com Eventos</a></li>
<li class=""><a href="trabalhando_com_opencl.html">Trabalhando com OpenCL</a></li>
<li class=""><a href="trabalhar_com_bancos_de_dados.html">Trabalhar com bancos de dados</a></li>
<li class=""><a href="trabalho_com_directx.html">Trabalho com DirectX</a></li>
<li class=""><a href="metatrader_para_python.html">MetaTrader para Python</a></li>
<li class=""><a href="modelos_onnx.html">Modelos ONNX</a></li>
<li class=""><a href="biblioteca_padr√£o.html">Biblioteca Padr√£o</a></li>
<li class=""><a href="migrando_do_mql4.html">Migrando do MQL4</a></li>
<li class=""><a href="lista_de_fun√ß√µes_mql5.html">Lista de Fun√ß√µes MQL5</a></li>
<li class=""><a href="lista_de_constantes_mql5.html">Lista de Constantes MQL5</a></li>

        </ul>
    </nav>
    
    <main class="content">
        <header>
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1>M√©todos matriciais e vetoriais</h1>
        </header>
        
        <article>
            <p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1307
<h3>Matrizes e vetores</h3>
Uma matriz √© um array bidimensional de n√∫meros do tipo double, float ou complex.
Um vetor √© uma matriz unidimensional de n√∫meros do tipo double, float ou complex. O vetor n√£o tem
indica√ß√£o de se √© vertical ou horizontal. Essa informa√ß√£o √© sabido a partir do contexto de uso, por
exemplo, a opera√ß√£o vetorial Dot assume que o vetor esquerdo √© horizontal, o vetor direito √© vertical.
Se for necess√°ria uma precis√£o absoluta, podem ser usadas matrizes de uma √∫nica linha ou coluna,
mas geralmente isto n√£o √© necess√°rio.
Matrizes e vetores alocam mem√≥ria para dados dinamicamente. Na verdade, matrizes e vetores s√£o
objetos que possuem certas propriedades, como o tipo de dados que cont√™m e as dimens√µes.
Propriedades de matrizes e vetores podem ser obtidas usando m√©todos como, vector_a.Size(),
matrix_b.Rows(), vector_c.Norm(), matrix_d.Cond() e por a√≠ fora. E a dimens√£o pode ser alterada.
Ao criar e inicializar matrizes, s√£o utilizados os chamados m√©todos est√°ticos (estes s√£o como os
m√©todos de classe est√°tica), por exemplo: matrix::Eye(), matrix::Identity(), matrix::Ones(),
vector::Ones(), matrix::Zeros(), vector::Zeros(), matrix::Full(), vector::Full(), matrix::Tri().
No momento, as opera√ß√µes sobre matrizes e vetores n√£o envolvem o uso de um tipo de dado complexo
- este ainda √© um trabalho em andamento.
MQL5 suporta a passagem de matrizes e vetores para DLLs. Assim, fun√ß√µes que usam esse tipo de
dados s√£o importadas a partir de bibliotecas externas.
Matrizes e vetores s√£o passados para DLL como um ponteiro para um buffer. Por exemplo, para passar
uma matriz do tipo float, o par√¢metro correspondente da fun√ß√£o DLL exportada deve levar um
ponteiro para um buffer do tipo float.
<h3>MQL5</h3>
#import &quot;mmlib.dll&quot;
</p>
<pre><code class="language-mql5">
bool sgemm(uint flags, matrix&lt;float&gt; &amp;C, const matrix&lt;float&gt; &amp;A, const matrix&lt;float&gt; &amp;
</code></pre>
<p>
#import
<h3>C++</h3>
</p>
<pre><code class="language-mql5">
extern &quot;C&quot; __declspec(dllexport) bool sgemm(UINT flags, float *C, const float *A, cons
</code></pre>
<p>
Para um processamento adequado de matrizes e vetores, al√©m de seus buffers, devem ser passados
seus tamanhos.
Todos os m√©todos matriciais e vetoriais est√£o listados abaixo em ordem alfab√©tica.
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
<h3>Activation</h3>
<h3>Calcula os valores da fun√ß√£o de</h3>
ativa√ß√£o 
e 
registra 
no
vetor/matriz passado
<h3>Aprendizado de m√°quina</h3>
<h3>ArgMax</h3>
<h3>Retorna</h3>
o 
√≠ndice 
do 
valor
m√°ximo
<h3>Estat√≠sticas</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1308
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
<h3>ArgMin</h3>
<h3>Retorna</h3>
o 
√≠ndice 
do 
valor
m√≠nimo
<h3>Estat√≠sticas</h3>
<h3>ArgSort</h3>
<h3>Retorna o √≠ndice classificado</h3>
<h3>Atribui√ß√µes</h3>
<h3>Assign</h3>
<h3>Copia uma matriz, vetor ou</h3>
array com convers√£o autom√°tica
<h3>Inicializa√ß√£o</h3>
<h3>Average</h3>
<h3>Calcula a m√©dia ponderada dos</h3>
valores da matriz/vetor
<h3>Estat√≠sticas</h3>
<h3>Cholesky</h3>
<h3>Calcula</h3>
a 
decomposi√ß√£o 
de
<h3>Cholesky</h3>
<h3>Convers√µes</h3>
<h3>Clip</h3>
<h3>Limita os elementos de uma</h3>
matriz/vetor a um determinado
intervalo de valores v√°lidos
<h3>Atribui√ß√µes</h3>
<h3>Col</h3>
<h3>Retorna um vetor coluna. Grava</h3>
um vetor na coluna especificada
<h3>Atribui√ß√µes</h3>
<h3>Cols</h3>
<h3>Retorna o n√∫mero de colunas em</h3>
uma matriz
<h3>Caracter√≠sticas</h3>
<h3>Compare</h3>
<h3>Compara os elementos de duas</h3>
matrizes/vetores 
com 
uma
determinada precis√£o
<h3>Atribui√ß√µes</h3>
<h3>CompareByDigits</h3>
<h3>Compara se os elementos de</h3>
duas 
matrizes/vetores
correspondem, 
levando 
em
conta d√≠gitos significativos
<h3>Atribui√ß√µes</h3>
<h3>Cond</h3>
<h3>Calcula o n√∫mero condicional de</h3>
uma matriz
<h3>Caracter√≠sticas</h3>
<h3>Convolve</h3>
<h3>Retorna a convolu√ß√£o linear</h3>
discreta de dois vetores
<h3>Produtos</h3>
<h3>Copy</h3>
<h3>Retorna</h3>
uma 
c√≥pia 
da
matriz/vetor fornecida
<h3>Atribui√ß√µes</h3>
<h3>Concat</h3>
<h3>Une 2 submatrizes em uma</h3>
matriz. Une 2 vetores em um
s√≥.
<h3>Atribui√ß√µes</h3>
<h3>CopyIndicatorBuffer</h3>
<h3>Obt√©m no vetor dados do buffer</h3>
especificado 
do 
indicador
especificado com a quantidade
indicada
<h3>Inicializa√ß√£o</h3>
<h3>CopyRates</h3>
<h3>Obt√©m em uma matriz ou vetor</h3>
a s√©rie hist√≥rica da estrutura
<h3>MqlRates</h3>
do 
per√≠odo-s√≠mbolo
<h3>Inicializa√ß√£o</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1309
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
especificado 
na 
quantidade
especificada
<h3>CopyTicks</h3>
<h3>Obt√©m na matriz ou vetor os</h3>
ticks a partir da estrutura
<h3>MqlTick</h3>
<h3>Inicializa√ß√£o</h3>
<h3>CopyTicksRange</h3>
<h3>Obt√©m na matriz ou vetor os</h3>
ticks a partir da estrutura
<h3>MqlTick dentro do intervalo de</h3>
datas especificado
<h3>Inicializa√ß√£o</h3>
<h3>CorrCoef</h3>
<h3>Calcula</h3>
o 
coeficiente 
de
correla√ß√£o 
de 
<h3>Pearson</h3>
(coeficiente 
de 
correla√ß√£o
linear)
<h3>Produtos</h3>
<h3>Correlate</h3>
<h3>Calcula a correla√ß√£o cruzada de</h3>
dois vetores
<h3>Produtos</h3>
<h3>Cov</h3>
<h3>Calcula a matriz de covari√¢ncia</h3>
<h3>Produtos</h3>
<h3>CumProd</h3>
<h3>Retorna o produto cumulativo</h3>
dos 
elementos 
de 
uma
matriz/vetor, 
incluindo 
os
elementos ao longo do eixo dado
<h3>Estat√≠sticas</h3>
<h3>CumSum</h3>
<h3>Retorna a soma cumulativa dos</h3>
elementos de uma matriz/vetor,
incluindo elementos ao longo de
um determinado eixo
<h3>Estat√≠sticas</h3>
<h3>Derivative</h3>
<h3>Calcula os valores da derivada</h3>
da fun√ß√£o de ativa√ß√£o e escreve
no vetor/matriz passado
<h3>Aprendizado de m√°quina</h3>
<h3>Det</h3>
<h3>Calcula o determinante de uma</h3>
matriz 
quadrada 
n√£o
degenerada
<h3>Caracter√≠sticas</h3>
<h3>Diag</h3>
<h3>Extrai uma diagonal ou constr√≥i</h3>
uma matriz diagonal
<h3>Atribui√ß√µes</h3>
<h3>Dot</h3>
<h3>Produto escalar de dois vetores</h3>
<h3>Produtos</h3>
<h3>Eig</h3>
<h3>Calcula os valores pr√≥prios e os</h3>
vetores pr√≥prios direitos de uma
matriz quadrada
<h3>Convers√µes</h3>
<h3>EigVals</h3>
<h3>Calcula os valores pr√≥prios de</h3>
uma matriz comum
<h3>Convers√µes</h3>
<h3>Eye</h3>
<h3>Retorna uma matriz com uns na</h3>
diagonal e zeros nos outros
<h3>Inicializa√ß√£o</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1310
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
lugares
<h3>Fill</h3>
<h3>Preenche uma matriz ou vetor</h3>
existente com o valor fornecido
<h3>Inicializa√ß√£o</h3>
<h3>Flat</h3>
<h3>Permite acessar um elemento da</h3>
matriz por meio de um √≠ndice
em vez de dois
<h3>Atribui√ß√µes</h3>
<h3>Full</h3>
<h3>Cria e retorna uma nova matriz</h3>
preenchida 
com 
o 
valor
fornecido
<h3>Inicializa√ß√£o</h3>
<h3>GeMM</h3>
<h3>Produto matricial geral de duas</h3>
matrizes 
(General 
<h3>Matrix</h3>
<h3>Multiply)</h3>
<h3>Produtos</h3>
<h3>HasNan</h3>
<h3>Retorna o n√∫mero de valores</h3>
<h3>NaN na matriz/vetor</h3>
<h3>Atribui√ß√µes</h3>
<h3>Hsplit</h3>
<h3>Divis√£o</h3>
horizontal 
de 
uma
matriz em v√°rias submatrizes.
<h3>O mesmo que Split com axis=0</h3>
<h3>Atribui√ß√µes</h3>
<h3>Identity</h3>
<h3>Cria uma matriz de identidade</h3>
do tamanho especificado
<h3>Inicializa√ß√£o</h3>
<h3>Init</h3>
<h3>Inicializa√ß√£o de matriz ou vetor</h3>
<h3>Inicializa√ß√£o</h3>
<h3>Inner</h3>
<h3>Produto</h3>
interno 
de 
duas
matrizes
<h3>Produtos</h3>
<h3>Inv</h3>
<h3>Calcula</h3>
o 
inverso
(multiplicativo) de uma matriz
quadrada 
n√£o 
degenerada
usando o m√©todo Gauss-Jordan
<h3>Solu√ß√µes</h3>
<h3>Kron</h3>
<h3>Retorna o produto Kronecker de</h3>
duas matrizes, uma matriz e um
vetor, um vetor e uma matriz
ou dois vetores
<h3>Produtos</h3>
<h3>LinearRegression</h3>
<h3>Calcula o vetor/matriz com os</h3>
valores 
de 
regress√£o 
linear
calculados
<h3>Estat√≠sticas</h3>
<h3>Loss</h3>
<h3>Calcula os valores da fun√ß√£o de</h3>
perda e grava no vetor/matriz
passado
<h3>Aprendizado de m√°quina</h3>
<h3>LstSq</h3>
<h3>Retorna a solu√ß√£o de m√≠nimos</h3>
quadrados 
de 
equa√ß√µes
alg√©bricas 
lineares 
(para
<h3>Solu√ß√µes</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1311
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
matrizes 
n√£o 
quadradas 
ou
singulares)
<h3>LU</h3>
<h3>Decomposi√ß√£o LU de uma matriz</h3>
como um produto de uma matriz
triangular inferior e uma matriz
triangular superior
<h3>Convers√µes</h3>
<h3>LUP</h3>
<h3>Fatoriza√ß√£o</h3>
<h3>LUP</h3>
com
permuta√ß√£o 
parcial, 
que 
se
refere 
√† 
decomposi√ß√£o 
<h3>LU</h3>
apenas com 
permuta√ß√£o 
de
linhas: PA=LU
<h3>Convers√µes</h3>
<h3>MatMul</h3>
<h3>Produto de matriz de duas</h3>
matrizes
<h3>Produtos</h3>
<h3>Max</h3>
<h3>Retorna o valor m√°ximo em uma</h3>
matriz/vetor
<h3>Estat√≠sticas</h3>
<h3>Mean</h3>
<h3>Calcula a m√©dia aritm√©tica dos</h3>
valores dos elementos
<h3>Estat√≠sticas</h3>
<h3>Median</h3>
<h3>Calcula</h3>
a 
mediana 
dos
elementos de uma matriz/vetor
<h3>Estat√≠sticas</h3>
<h3>Min</h3>
<h3>Retorna o valor m√≠nimo em uma</h3>
matriz/vetor
<h3>Estat√≠sticas</h3>
<h3>Norm</h3>
<h3>Retorna a norma de uma matriz</h3>
ou vetor
<h3>Caracter√≠sticas</h3>
<h3>Ones</h3>
<h3>Cria e retorna uma nova matriz</h3>
preenchida com uns
<h3>Inicializa√ß√£o</h3>
<h3>Outer</h3>
<h3>Calcula o produto externo de</h3>
duas matrizes ou dois vetores
<h3>Produtos</h3>
<h3>Percentile</h3>
<h3>Retorna o percentil especificado</h3>
de valores de elemento de
matriz/vetor ou elementos ao
longo do eixo especificado
<h3>Estat√≠sticas</h3>
<h3>PInv</h3>
<h3>Calcula o pseudoinverso pelo</h3>
m√©todo Moore-Penrose
<h3>Solu√ß√µes</h3>
<h3>Power</h3>
<h3>Eleva uma matriz quadrada a</h3>
uma pot√™ncia inteira
<h3>Produtos</h3>
<h3>Prod</h3>
<h3>Retorna</h3>
o 
produto 
dos
elementos da matriz/vetor, que
tamb√©m pode ser realizado para
o eixo dado
<h3>Estat√≠sticas</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1312
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
<h3>Ptp</h3>
<h3>Retorna o intervalo de valores</h3>
de uma matriz/vetor ou um
determinado eixo de uma matriz
<h3>Estat√≠sticas</h3>
<h3>QR</h3>
<h3>Calcula a fatora√ß√£o qr de uma</h3>
matriz
<h3>Convers√µes</h3>
<h3>Quantile</h3>
<h3>Retorna o quantil especificado</h3>
dos valores dos elementos da
matriz/vetor ou dos elementos
ao longo do eixo especificado
<h3>Estat√≠sticas</h3>
<h3>Random</h3>
<h3>Fun√ß√£o est√°tica. Cria e retorna</h3>
uma nova matriz ou vetor
preenchido 
com 
valores
aleat√≥rios. Os valores aleat√≥rios
s√£o 
gerados 
uniformemente
dentro 
do 
intervalo
especificado.
<h3>Inicializa√ß√£o</h3>
<h3>Rank</h3>
<h3>Retorna o posto de uma matriz</h3>
usando o m√©todo de Gauss
<h3>Caracter√≠sticas</h3>
<h3>RegressionMetric</h3>
<h3>Calcula a m√©trica de regress√£o</h3>
como o erro de desvio da linha
de regress√£o criada na matriz
de dados especificada
<h3>Estat√≠sticas</h3>
<h3>Reshape</h3>
<h3>Altera√ß√£o da forma de uma</h3>
matriz sem alterar seus dados
<h3>Atribui√ß√µes</h3>
<h3>Resize</h3>
<h3>Retorna uma nova matriz com</h3>
forma e tamanho modificados
<h3>Atribui√ß√µes</h3>
<h3>Row</h3>
<h3>Retorna um vetor linha. Grava</h3>
um vetor na string especificada
<h3>Atribui√ß√µes</h3>
<h3>Rows</h3>
<h3>Retorna o n√∫mero de linhas em</h3>
uma matriz
<h3>Caracter√≠sticas</h3>
<h3>Set</h3>
<h3>Define o valor de um elemento</h3>
vetorial pelo √≠ndice especificado
<h3>Atribui√ß√µes</h3>
<h3>Size</h3>
<h3>Retorna o tamanho do vetor</h3>
<h3>Caracter√≠sticas</h3>
<h3>Set</h3>
<h3>Define o valor de um elemento</h3>
vetorial pelo √≠ndice especificado
<h3>Atribui√ß√µes</h3>
<h3>SLogDet</h3>
Calcula o sinal e o logaritmo do
determinante de uma matriz
<h3>Caracter√≠sticas</h3>
<h3>Solve</h3>
<h3>Resolve uma equa√ß√£o de matriz</h3>
linear 
ou 
um 
sistema 
de
equa√ß√µes alg√©bricas lineares
<h3>Solu√ß√µes</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1313
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
<h3>Sort</h3>
<h3>Classifica√ß√£o por lugar</h3>
<h3>Atribui√ß√µes</h3>
<h3>Spectrum</h3>
<h3>Calcula o espectro de uma</h3>
matriz como o conjunto de seus
autovalores do produto AT*A
<h3>Caracter√≠sticas</h3>
<h3>Split</h3>
<h3>Divis√£o de uma matriz em</h3>
v√°rias submatrices
<h3>Atribui√ß√µes</h3>
<h3>Std</h3>
<h3>Retorna o desvio padr√£o dos</h3>
valores dos elementos de uma
matriz/vetor ou elementos ao
longo de um determinado eixo
<h3>Estat√≠sticas</h3>
<h3>Sum</h3>
<h3>Retorna a soma dos elementos</h3>
da matriz/vetor, o que tamb√©m
pode ser feito para o(s) eixo(s)
especificado(s)
<h3>Estat√≠sticas</h3>
<h3>SVD</h3>
<h3>Decomposi√ß√£o</h3>
em 
valores
singulares
<h3>Convers√µes</h3>
<h3>SwapCols</h3>
<h3>Troca colunas em uma matriz</h3>
<h3>Atribui√ß√µes</h3>
<h3>SwapRows</h3>
<h3>Troca linhas em uma matriz</h3>
<h3>Atribui√ß√µes</h3>
<h3>Trace</h3>
<h3>Retorna a soma das diagonais</h3>
de uma matriz
<h3>Caracter√≠sticas</h3>
<h3>Transpose</h3>
<h3>Transp√µe (inverte os eixos) e</h3>
retorna a matriz modificada
<h3>Atribui√ß√µes</h3>
<h3>Tri</h3>
<h3>Constr√≥i uma matriz com uns</h3>
em uma determinada diagonal e
abaixo, e zeros nos outros
lugares
<h3>Inicializa√ß√£o</h3>
<h3>TriL</h3>
<h3>Retorna uma c√≥pia da matriz</h3>
zerada 
acima 
da 
k-√©sima
diagonal. 
<h3>Matriz</h3>
triangular
inferior
<h3>Atribui√ß√µes</h3>
<h3>TriU</h3>
<h3>Retorna uma c√≥pia da matriz</h3>
com elementos zerados abaixo
da 
k-√©sima 
diagonal 
<h3>Matriz</h3>
triangular superior
<h3>Atribui√ß√µes</h3>
<h3>Var</h3>
<h3>Calcula a vari√¢ncia dos valores</h3>
dos 
elementos 
de 
uma
matriz/vetor
<h3>Estat√≠sticas</h3>
<h3>Vsplit</h3>
<h3>Divis√£o vertical de uma matriz</h3>
em 
v√°rias 
submatrizes. 
<h3>O</h3>
mesmo que Split com axis=1
<h3>Atribui√ß√µes</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1314
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Categoria</h3>
<h3>Zeros</h3>
<h3>Cria e retorna uma nova matriz</h3>
preenchida com zeros
<h3>Inicializa√ß√£o</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1315
<h3>Tipos de matrizes e vetores</h3>
matrix –∏ vector ‚Äî s√£o tipos de dados especiais em MQL5 projetados para realizar opera√ß√µes a partir
de √°lgebra linear. Existem os seguintes tipos de dados:
¬∑ matrix ‚Äî matriz contendo elementos do tipo double
¬∑ matrixf ‚Äî matriz contendo elementos do tipo float
¬∑ matrixc ‚Äî matriz contendo elementos do tipo complex.
¬∑ vector ‚Äî vetor contendo elementos do tipo double
¬∑ vectorf ‚Äî vetor contendo elementos do tipo float
¬∑ vectorc ‚Äî vetor contendo elementos do tipo complex
Para uso em fun√ß√µes de modelo, √© poss√≠vel usar a entrada matrix&lt;double&gt;, matrix&lt;float&gt;,
matrix&lt;complex&gt;, vector&lt;double&gt;, vector&lt;float&gt;, vector&lt;complex&gt; em vez dos tipos correspondentes.
MQL5 suporta a passagem de matrizes e vetores para DLLs. Assim, fun√ß√µes que usam esse tipo de
dados s√£o importadas a partir de bibliotecas externas.
Matrizes e vetores s√£o passados para DLL como um ponteiro para um buffer. Por exemplo, para passar
uma matriz do tipo float, o par√¢metro correspondente da fun√ß√£o DLL exportada deve levar um
ponteiro para um buffer do tipo float.
<h3>MQL5</h3>
#import &quot;mmlib.dll&quot;
</p>
<pre><code class="language-mql5">
bool sgemm(uint flags, matrix&lt;float&gt; &amp;C, const matrix&lt;float&gt; &amp;A, const matrix&lt;float&gt; &amp;
</code></pre>
<p>
#import
<h3>C++</h3>
</p>
<pre><code class="language-mql5">
extern &quot;C&quot; __declspec(dllexport) bool sgemm(UINT flags, float *C, const float *A, cons
</code></pre>
<p>
Para um processamento adequado de matrizes e vetores, al√©m de seus buffers, devem ser passados
seus tamanhos.
M√©todos de inicializa√ß√£o de matrizes e vetores
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Assign</h3>
Copia uma matriz, vetor ou array com convers√£o autom√°tica
<h3>CopyRates</h3>
Obt√©m em uma matriz ou vetor a s√©rie hist√≥rica da estrutura
<h3>MqlRates</h3>
do 
per√≠odo-s√≠mbolo 
especificado 
na 
quantidade
especificada
<h3>Eye</h3>
Retorna uma matriz com uns na diagonal principal e zeros em todas
as outras posi√ß√µes.
<h3>Identity</h3>
Cria uma matriz de identidade do tamanho especificado
<h3>Ones</h3>
Cria e retorna uma nova matriz preenchida com uns
<h3>Zeros</h3>
Cria e retorna uma nova matriz preenchida com zeros</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1316
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Full</h3>
Cria e retorna uma nova matriz preenchida com os valores fornecidos
<h3>Tri</h3>
Cria uma matriz com uns na diagonal indicada e abaixo e zeros em
todas as outras posi√ß√µes
<h3>Init</h3>
<h3>Inicializa uma matriz ou vetor</h3>
<h3>Fill</h3>
Preenche uma matriz ou vetor existente com o valor fornecido</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1317
<h3>Enumera√ß√µes para manusear matrizes e vetores</h3>
Esta se√ß√£o descreve as enumera√ß√µes que s√£o usadas nos v√°rios m√©todos matriciais e vetoriais.
<h3>ENUM_AVERAGE_MODE</h3>
Enumera√ß√£o de tipos de c√°lculo de m√©dia.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>AVERAGE_NONE</h3>
Sem m√©dia. Os resultados s√£o fornecidos para cada r√≥tulo
separadamente
<h3>AVERAGE_BINARY</h3>
Resultado do marcador 1 para classifica√ß√£o bin√°ria
<h3>AVERAGE_MICRO</h3>
Resultado da m√©dia da matriz de erros (confusion matrix)
<h3>AVERAGE_MACRO</h3>
Resultado m√©dio dos resultados das matrizes de erro de cada
r√≥tulo
<h3>AVERAGE_WEIGHTED</h3>
<h3>Resultado m√©dio ponderado</h3>
<h3>ENUM_VECTOR_NORM</h3>
Enumera√ß√£o de normas vetoriais para vector::Norm.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>VECTOR_NORM_INF</h3>
<h3>Norma Infinita</h3>
<h3>VECTOR_NORM_MINUS_INF</h3>
<h3>Norma infinita negativa</h3>
<h3>VECTOR_NORM_P</h3>
<h3>Norma-p</h3>
<h3>ENUM_MATRIX_NORM</h3>
Enumera√ß√£o de normas matriciais para matrix::Norm e para obter o n√∫mero de condicionalidade da
matriz matrix::Cond.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>MATRIX_NORM_FROBENIUS</h3>
norma de Frobenius
<h3>MATRIX_NORM_SPECTRAL</h3>
<h3>Norma espectral</h3>
<h3>MATRIX_NORM_NUCLEAR</h3>
<h3>Norma nuclear</h3>
<h3>MATRIX_NORM_INF</h3>
<h3>Norma Infinita</h3>
<h3>MATRIX_NORM_P1</h3>
<h3>Norma P1</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1318
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>MATRIX_NORM_P2</h3>
<h3>Norma P2</h3>
<h3>MATRIX_NORM_MINUS_INF</h3>
<h3>Norma infinita negativa</h3>
<h3>MATRIX_NORM_MINUS_P1</h3>
<h3>Norma negativa P1</h3>
<h3>MATRIX_NORM_MINUS_P2</h3>
<h3>Norma negativa P2</h3>
<h3>ENUM_VECTOR_CONVOLVE</h3>
Enumera√ß√£o para a convolu√ß√£o vector::Convolve e correla√ß√£o cruzada vector::Correlate.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>VECTOR_CONVOLVE_FULL</h3>
<h3>Convolu√ß√£o completa</h3>
<h3>VECTOR_CONVOLVE_SAME</h3>
<h3>Convolu√ß√£o com tipo same</h3>
<h3>VECTOR_CONVOLVE_VALID</h3>
<h3>Convolu√ß√£o com tipo valid</h3>
<h3>ENUM_REGRESSION_METRIC</h3>
Enumera√ß√£o de m√©tricas de regress√£o para vector::RegressionMetric.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>REGRESSION_MAE</h3>
<h3>Erro absoluto m√©dio</h3>
<h3>REGRESSION_MSE</h3>
<h3>Erro quadr√°tico m√©dio</h3>
<h3>REGRESSION_RMSE</h3>
<h3>Raiz quadrada do erro</h3>
<h3>REGRESSION_R2</h3>
<h3>R-quadrado</h3>
<h3>REGRESSION_MAPE</h3>
<h3>Erro absoluto m√©dio em porcentagem</h3>
<h3>REGRESSION_MSPE</h3>
<h3>Erro quadr√°tico m√©dio em porcentagem</h3>
<h3>REGRESSION_RMSLE</h3>
<h3>Raiz do erro quadr√°tico m√©dio logar√≠tmico</h3>
<h3>REGRESSION_SMAPE</h3>
<h3>Erro absoluto m√©dio sim√©trico em porcentagem</h3>
<h3>REGRESSION_MAXE</h3>
<h3>Erro absoluto m√°ximo</h3>
<h3>REGRESSION_MEDE</h3>
<h3>Erro absoluto mediano</h3>
<h3>REGRESSION_MPD</h3>
<h3>Desvio m√©dio de Poisson</h3>
<h3>REGRESSION_MGD</h3>
<h3>Desvio gama m√©dio</h3>
<h3>REGRESSION_EXPV</h3>
<h3>Vari√¢ncia explicada</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1319
<h3>ENUM_CLASSIFICATION_METRIC</h3>
Enumera√ß√£o de m√©tricas para tarefas de classifica√ß√£o.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>CLASSIFICATION_ACCURACY</h3>
Qualidade do modelo em termos de fidelidade das
previs√µes em todas as classes
<h3>CLASSIFICATION_AVERAGE_PRECISION</h3>
<h3>Precis√£o m√©dia do modelo</h3>
<h3>CLASSIFICATION_BALANCED_ACCURACY</h3>
<h3>Precis√£o de previs√µes balanceada</h3>
<h3>CLASSIFICATION_F1</h3>
Medida-F1. 
<h3>M√©dia</h3>
harm√¥nica 
entre 
precis√£o
(precision) e recupera√ß√£o (recall) do modelo
<h3>CLASSIFICATION_JACCARD</h3>
<h3>√çndice Jaccard</h3>
<h3>CLASSIFICATION_PRECISION</h3>
Precis√£o do modelo na previs√£o de verdadeiros
positivos para a classe-alvo
<h3>CLASSIFICATION_RECALL</h3>
<h3>Integridade do modelo</h3>
<h3>CLASSIFICATION_ROC_AUC</h3>
<h3>√Årea sob a curva de erro</h3>
<h3>CLASSIFICATION_TOP_K_ACCURACY</h3>
Frequ√™ncia de ocorr√™ncia do r√≥tulo correto no topo dos
r√≥tulos K previstos
<h3>ENUM_LOSS_FUNCTION</h3>
Enumera√ß√£o para o c√°lculo da fun√ß√£o de perda vector::Loss.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>LOSS_MSE</h3>
<h3>Erro quadr√°tico m√©dio</h3>
<h3>LOSS_MAE</h3>
<h3>Erro absoluto m√©dio</h3>
<h3>LOSS_CCE</h3>
<h3>Entropia cruzada categ√≥rica</h3>
<h3>LOSS_BCE</h3>
<h3>Entropia cruzada bin√°ria</h3>
<h3>LOSS_MAPE</h3>
<h3>Erro absoluto m√©dio em porcentagem</h3>
<h3>LOSS_MSLE</h3>
<h3>Erro logar√≠tmico quadr√°tico m√©dio</h3>
<h3>LOSS_KLD</h3>
<h3>Diverg√™ncia de Kullback-Leibler</h3>
<h3>LOSS_COSINE</h3>
<h3>Semelhan√ßa/proximidade de cosseno</h3>
<h3>LOSS_POISSON</h3>
<h3>Fun√ß√£o de perda de Poisson</h3>
<h3>LOSS_HINGE</h3>
Fun√ß√£o de perda linear por partes (Hinge loss)</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1320
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>LOSS_SQ_HINGE</h3>
Fun√ß√£o de perda linear por partes quadr√°tica
<h3>LOSS_CAT_HINGE</h3>
Fun√ß√£o de perda linear por partes categ√≥rica
<h3>LOSS_LOG_COSH</h3>
<h3>Logaritmo de cosseno hiperb√≥lico</h3>
<h3>LOSS_HUBER</h3>
<h3>Fun√ß√£o de perda de Huber</h3>
<h3>ENUM_ACTIVATION_FUNCTION</h3>
Enumera√ß√£o para a fun√ß√£o de ativa√ß√£o vector::Activation e a derivada da fun√ß√£o de ativa√ß√£o
vector::Derivative.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>P</h3>
a
r
√¢
m
e
t
r
o
s
<h3>AF_NONE</h3>
A fun√ß√£o de ativa√ß√£o n√£o √© usada, o valor na entrada √© passado para
a sa√≠da
<h3>AF_ELU</h3>
<h3>Unidade linear exponencial</h3>
<h3>AF_EXP</h3>
<h3>Exponencial</h3>
<h3>AF_GELU</h3>
<h3>Unidade linear gaussiana de erro</h3>
<h3>AF_HARD_SIGMOID</h3>
<h3>Sigm√≥ide r√≠gido</h3>
<h3>AF_LINEAR</h3>
<h3>Linear</h3>
<h3>AF_LRELU</h3>
<h3>Retificador linear com &quot;vazamento&quot; (Leaky ReLU)</h3>
<h3>AF_RELU</h3>
<h3>Transforma√ß√£o linear truncada ReLU</h3>
<h3>AF_SELU</h3>
<h3>Fun√ß√£o linear exponencial escalada (Scaled ELU)</h3>
<h3>AF_SIGMOID</h3>
<h3>Sigmoide</h3>
<h3>AF_SOFTMAX</h3>
<h3>Softmax</h3>
<h3>AF_SOFTPLUS</h3>
<h3>Softplus</h3>
<h3>AF_SOFTSIGN</h3>
<h3>Softsign</h3>
<h3>AF_SWISH</h3>
<h3>Fun√ß√£o Swish</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1321
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>P</h3>
a
r
√¢
m
e
t
r
o
s
<h3>AF_TANH</h3>
<h3>Tangente hiperb√≥lica</h3>
<h3>AF_TRELU</h3>
<h3>Retificador linear com limiar</h3>
<h3>ENUM_SORT_MODE</h3>
Enumera√ß√£o dos tipos de classifica√ß√£o para a fun√ß√£o Sort.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>SORT_ASCENDING</h3>
<h3>Classifica√ß√£o ascendente</h3>
<h3>SORT_DESCENDING</h3>
<h3>Classifica√ß√£o decrescente</h3>
<h3>ENUM_MATRIX_AXIS</h3>
Enumera√ß√£o para indicar o eixo em todas as fun√ß√µes estat√≠sticas para matrizes.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>AXIS_NONE</h3>
O eixo n√£o √© definido, o c√°lculo √© realizado em todos os
elementos da matriz, como se fosse um vetor (consulte o
m√©todo Flat).
<h3>AXIS_HORZ</h3>
<h3>Eixo horizontal</h3>
<h3>AXIS_VERT</h3>
<h3>Eixo vertical</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1322
<h3>Inicializa√ß√£o</h3>
Existem v√°rias maneiras de declarar e inicializar matrizes e vetores.
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Assign</h3>
Copia uma matriz, vetor ou array com convers√£o autom√°tica
<h3>CopyIndicatorBuffer</h3>
Obt√©m no vetor dados do buffer especificado do indicador
especificado com a quantidade indicada
<h3>CopyRates</h3>
Obt√©m em uma matriz ou vetor a s√©rie hist√≥rica da estrutura
<h3>MqlRates</h3>
do 
per√≠odo-s√≠mbolo 
especificado 
na 
quantidade
especificada
<h3>CopyTicks</h3>
Obt√©m na matriz ou vetor os ticks a partir da estrutura MqlTick
<h3>CopyTicksRange</h3>
Obt√©m na matriz ou vetor os ticks a partir da estrutura MqlTick
dentro do intervalo de datas especificado
<h3>Eye</h3>
Retorna uma matriz com uns na diagonal principal e zeros em todas
as outras posi√ß√µes.
<h3>Identity</h3>
Cria uma matriz de identidade do tamanho especificado
<h3>Ones</h3>
Cria e retorna uma nova matriz preenchida com uns
<h3>Zeros</h3>
Cria e retorna uma nova matriz preenchida com zeros
<h3>Full</h3>
Cria e retorna uma nova matriz preenchida com os valores fornecidos
<h3>Tri</h3>
Cria uma matriz com uns na diagonal indicada e abaixo e zeros em
todas as outras posi√ß√µes
<h3>Init</h3>
<h3>Inicializa uma matriz ou vetor</h3>
<h3>Fill</h3>
Preenche uma matriz ou vetor existente com o valor fornecido
<h3>Random</h3>
Fun√ß√£o est√°tica. Cria e retorna uma nova matriz ou vetor preenchido
com valores aleat√≥rios. Os valores aleat√≥rios s√£o 
gerados
uniformemente dentro do intervalo especificado.
Declara√ß√£o sem especificar um tamanho (sem aloca√ß√£o de mem√≥ria de dados):
  matrix         matrix_a;   // matriz do tipo double
  matrix&lt;double&gt; matrix_a1;  // outra forma de declarar uma matriz de tipo double, e √©
  matrixf        matrix_a2;  // matriz do tipo float
  matrix&lt;float&gt;  matrix_a3;  // matriz do tipo float
  vector         vector_a;   // vetor do tipo double
  vector&lt;double&gt; vector_a1;
  vectorf        vector_a2;  // vetor do tipo float
  vector&lt;float&gt;  vector_a3;
Declara√ß√£o de tamanho (com aloca√ß√£o de mem√≥ria para dados, mas sem nenhuma inicializa√ß√£o):</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1323
  matrix         matrix_a(128,128);           // podem ser especificados como par√¢metr
  matrix&lt;double&gt; matrix_a1(InpRows,InpCols);  // ou vari√°veis
  matrixf        matrix_a2(1,128);            // an√°logo de um vetor horizontal
  matrix&lt;float&gt;  matrix_a3(InpRows,1);        // an√°logo de um vetor vertical
  vector         vector_a(256);
  vector&lt;double&gt; vector_a1(InpSize);
  vectorf        vector_a2(SomeFunc());       // a fun√ß√£o SomeFunc retorna um n√∫mero d
  vector&lt;float&gt;  vector_a3(InpSize+16);       // a express√£o pode ser usada como um pa
Declara√ß√£o com inicializa√ß√£o (os tamanhos das matrizes e vetores neste caso s√£o determinados
pela sequ√™ncia de inicializa√ß√£o):
  matrix         matrix_a={{0.1,0.2,0.3},{0.4,0.5,0.6}};
  matrix&lt;double&gt; matrix_a1=matrix_a;                      // devem ser matrizes do mes
  matrixf        matrix_a2={{1,0,0},{0,1,0},{0,0,1}};
  matrix&lt;float&gt;  matrix_a3={{1,2},{3,4}};
  vector         vector_a={-5,-4,-3,-2,-1,0,1,2,3,4,5};
  vector&lt;double&gt; vector_a1={1,5,2.4,3.3};
  vectorf        vector_a2={0,1,2,3};
  vector&lt;float&gt;  vector_a3=vector_a2;                     // devem ser vetores do mesm
<h3>Declara√ß√£o com inicializa√ß√£o:</h3>
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
void MatrixArange(matrix&lt;T&gt; &amp;mat,T value=0.0,T step=1.0)
  {
   for(ulong i=0; i&lt;mat.Rows(); i++)
     {
      for(ulong j=0; j&lt;mat.Cols(); j++,value+=step)
         mat[i][j]=value;
     }
</code></pre>
<p>
  }
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
void VectorArange(vector&lt;T&gt; &amp;vec,T value=0.0,T step=1.0)
  {
   for(ulong i=0; i&lt;vec.Size(); i++,value+=step)
      vec[i]=value;
</code></pre>
<p>
  }
...
  matrix  matrix_a(size_m,size_k,MatrixArange,-M_PI,0.1); // primeiro √© criada uma mat
  matrixf matrix_a1(10,20,MatrixArange);                  // ap√≥s a cria√ß√£o da matriz,
  vector  vector_a(size,VectorArange,-10.0);              // Ap√≥s a cria√ß√£o de um veto
  vectorf vector_a1(128,VectorArange);</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1324
√â importante notar que as dimens√µes de uma matriz ou vetor podem ser alteradas, pois a mem√≥ria de
dados √© sempre din√¢mica.
<h3>M√©todos est√°ticos</h3>
M√©todos est√°ticos para criar matrizes e vetores do tamanho especificado, inicializados de uma
determinada maneira:
  matrix         matrix_a =matrix::Eye(4,5,1);
  matrix&lt;double&gt; matrix_a1=matrix::Full(3,4,M_PI);
  matrixf        matrix_a2=matrixf::Identity(5,5);
  matrixf&lt;float&gt; matrix_a3=matrixf::Ones(5,5);
  matrix         matrix_a4=matrix::Tri(4,5,-1);
  vector         vector_a =vector::Ones(256);
  vectorf        vector_a1=vector&lt;float&gt;::Zeros(16);
  vector&lt;float&gt;  vector_a2=vectorf::Full(128,float_value);
M√©todos para inicializar matrizes e vetores j√° criados:
  matrix  matrix_a;
  matrix_a.Init(size_m,size_k,MatrixArange,-M_PI,0.1);
  matrixf matrix_a1(3,4);
  matrix_a1.Init(10,20,MatrixArange);
  vector  vector_a;
  vector_a.Init(128,VectorArange);
  vectorf vector_a1(10);
  vector_a1.Init(vector_size,VectorArange,start_value,step);
  matrix_a.Fill(double_value);
  vector_a1.Fill(FLT_MIN);
  matrix_a1.Identity();</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1325
<h3>Assign</h3>
Copia uma matriz, vetor ou array com convers√£o autom√°tica.
</p>
<pre><code class="language-mql5">
bool matrix::Assign(
</code></pre>
<p>
¬† const matrix&lt;T&gt;  &amp;mat¬†    //¬†matriz a ser copiada
</p>
<pre><code class="language-mql5">
   );
bool matrix::Assign(
</code></pre>
<p>
¬† const void¬†      &amp;array[]¬†//¬†matriz a ser copiada
</p>
<pre><code class="language-mql5">
   );
bool vector::Assign(
</code></pre>
<p>
¬† const vector&lt;T&gt;¬† &amp;vec¬†    //¬†vetor a ser copiado
</p>
<pre><code class="language-mql5">
   );
bool vector::Assign(
</code></pre>
<p>
¬† const void¬†      &amp;array[]¬†//¬†matriz a ser copiada
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
m, v ou array
[in]  Matriz, vetor ou array de onde os valores s√£o copiados.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Ao inv√©s de Copy, o m√©todo Assign permite tamb√©m copiar arrays. Ao mesmo tempo, √© feita
automaticamente uma convers√£o de tipo, e a matriz ou vetor resultante √© ajustado ao tamanho do
array que est√° sendo copiado. 
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- c√≥pia da matriz
</code></pre>
<p>
  matrix a= {{2, 2}, {3, 3}, {4, 4}};
  matrix b=a+2;
  matrix c;
<h3>Print(&quot;matrix a \n&quot;, a);</h3>
<h3>Print(&quot;matrix b \n&quot;, b);</h3>
  c.Assign(b);
<h3>Print(&quot;matrix c \n&quot;, a);</h3>
</p>
<pre><code class="language-mql5">
//--- c√≥pia do array para a matriz
</code></pre>
<p>
  matrix double_matrix=matrix::Full(2,10,3.14);
  Print(&quot;double_matrix before Assign() \n&quot;, double_matrix);
  int int_arr[5][5]= {{1, 2}, {3, 4}, {5, 6}};
<h3>Print(&quot;int_arr: &quot;);</h3>
<h3>ArrayPrint(int_arr);</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1326
  double_matrix.Assign(int_arr);
  Print(&quot;double_matrix after Assign(int_arr) \n&quot;, double_matrix);  
</p>
<pre><code class="language-mql5">
  /*
   matrix a
   [[2,2]
    [3,3]
    [4,4]]
   matrix b
   [[4,4]
    [5,5]
    [6,6]]
   matrix c
   [[2,2]
    [3,3]
    [4,4]]
   double_matrix before Assign() 
   [[3.14,3.14,3.14,3.14,3.14,3.14,3.14,3.14,3.14,3.14]
    [3.14,3.14,3.14,3.14,3.14,3.14,3.14,3.14,3.14,3.14]]
    
   int_arr: 
       [,0][,1][,2][,3][,4]
   [0,]   1   2   0   0   0
   [1,]   3   4   0   0   0
   [2,]   5   6   0   0   0
   [3,]   0   0   0   0   0
   [4,]   0   0   0   0   0
   
   double_matrix after Assign(int_arr) 
   [[1,2,0,0,0]
    [3,4,0,0,0]
    [5,6,0,0,0]
    [0,0,0,0,0]
    [0,0,0,0,0]]
</code></pre>
<p>
  */
<h3>Ver tamb√©m</h3>
<h3>Copy</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1327
<h3>CopyIndicatorBuffer</h3>
Obt√©m no vetor dados do buffer especificado do indicador especificado com a quantidade indicada. 
Os dados no vetor s√£o copiados de forma que o elemento mais antigo no tempo esteja no in√≠cio da
mem√≥ria f√≠sica alocada para o vetor. Existem tr√™s alternativas para a fun√ß√£o.
Manuseio por posi√ß√£o inicial e n√∫mero de itens necess√°rios
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyIndicatorBuffer(
   long      indicator_handle,¬†    // identificador do indicador
   ulong     buffer_index,¬†        // n√∫mero do buffer do indicador
   ulong     start_pos,¬†           // ponto de partida 
   ulong     count¬†                // quantidade que copiamos
   );
</code></pre>
<p>
Manuseio por data inicial e n√∫mero de itens necess√°rios
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyIndicatorBuffer(
   long      indicator_handle,¬†    // identificador do indicador
   ulong     buffer_index,¬†        // n√∫mero do buffer do indicador
   datetime¬† start_time,¬†          // data de in√≠cio
   ulong     count ¬†               // quantidade que copiamos
   );
</code></pre>
<p>
Manuseio por datas de in√≠cio e t√©rmino do intervalo de tempo necess√°rio
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyIndicatorBuffer(
   long      indicator_handle,¬†    // identificador do indicador
   ulong     buffer_index,¬†        // n√∫mero do buffer do indicador
   datetime¬† start_time,¬†          // data de in√≠cio
   datetime¬† stop_time ¬†           // data de t√©rmino
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
indicator_handle
[in]  Identificador do indicador obtido pela fun√ß√£o de indicador apropriada.
buffer_index
[in]  N√∫mero do buffer de indicador.
start_pos
[in]  N√∫mero do primeiro item a ser copiado.
count
[in]  N√∫mero de itens a serem copiados.
start_time
[in]  Tempo de barra correspondente ao primeiro item.
stop_time
[in]  Tempo de barra correspondente ao √∫ltimo item.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1328
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido; caso contr√°rio, false se estiver incorreto.
<h3>Observa√ß√£o</h3>
Os elementos de dados a serem copiados (buffer do indicador com √≠ndice buffer_index) s√£o contados
a partir da posi√ß√£o inicial do presente para o passado, ou seja, uma posi√ß√£o inicial igual a 0
representa a barra atual (valor do indicador para a barra atual).
Ao copiar antecipadamente uma quantidade desconhecida de dados, √© recomend√°vel declarar um
vetor sem especificar o tamanho (sem alocar mem√≥ria para os dados), pois a fun√ß√£o CopyBuffer()
tenta alocar o tamanho do vetor receptor de acordo com o tamanho dos dados que est√£o sendo
copiados.
Se for necess√°ria uma c√≥pia parcial dos valores do indicador, um vetor intermedi√°rio dever√° ser
usado para essa finalidade, vetor esse que receber√° a c√≥pia da quantidade necess√°ria. E j√° a partir
desse vetor intermedi√°rio, √© feita a c√≥pia item por item do n√∫mero necess√°rio de valores para os
locais corretos do vetor receptor.
Se uma quantidade predefinida de dados tiver que ser copiada, √© melhor declarar um vetor com
tamanho especificado antecipadamente para evitar a aloca√ß√£o desnecess√°ria de mem√≥ria.
Ao solicitar dados de um indicador, se a s√©rie temporal solicitada ainda n√£o tiver sido criada ou
precisar ser baixada do servidor, a fun√ß√£o retornar√° imediatamente false, mas o pr√≥prio processo
de download/cria√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, ele iniciar√° o carregamento a partir do servidor
se o terminal n√£o tiver esses dados localmente ou come√ßar√° a criar as s√©ries temporais necess√°rias
se os dados puderem ser criados a partir do hist√≥rico local, mas ainda n√£o estiverem prontos. A
fun√ß√£o retornar√° a quantidade de dados que estar√£o prontos quando o tempo limite expirar.
<h3>Veja tamb√©m</h3>
<h3>CopyBuffer</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1329
<h3>CopyRates</h3>
Obt√©m na matriz ou vetor as s√©ries hist√≥ricas da estrutura MqlRates do per√≠odo-s√≠mbolo especificado
com a quantidade especificada. Os itens da posi√ß√£o inicial s√£o contados do presente para o passado,
ou seja, uma posi√ß√£o inicial de 0 significa a barra atual.
Al√©m disso, os dados ser√£o copiados de tal forma que o elemento mais antigo no tempo seja colocado
no in√≠cio da matriz/vetor. Existem 3 variantes do m√©todo.
Acesso atrav√©s da posi√ß√£o inicial e n√∫mero de itens necess√°rios.
</p>
<pre><code class="language-mql5">
bool¬† matrix::CopyRates(
   string¬†          symbol,¬†      // nome do s√≠mbolo
   ENUM_TIMEFRAMES¬† period,¬†      // per√≠odo
   ulong¬†           rates_mask,¬†  // combina√ß√£o de sinalizadores para indicar a s√©rie 
   ulong¬†           start,¬†       // n√∫mero da barra inicial a partir da qual come√ßar 
   ulong¬†           count ¬†       // quantidade a copiar
   );
</code></pre>
<p>
Acesso atrav√©s da data inicial e n√∫mero de itens necess√°rios.
</p>
<pre><code class="language-mql5">
bool¬† matrix::CopyRates(
   string¬†          symbol,¬†      // nome do s√≠mbolo
   ENUM_TIMEFRAMES¬† period,¬†      // per√≠odo
   ulong¬†           rates_mask,¬†  // combina√ß√£o de sinalizadores para indicar a s√©rie 
   datetime¬†        from,         // desde que data 
   ulong¬†           count ¬†       // quantidade a copiar
   );
</code></pre>
<p>
Acesso atrav√©s das datas inicial e final dentro de um intervalo de tempo.
</p>
<pre><code class="language-mql5">
bool¬† matrix::CopyRates(
   string¬†          symbol,¬†      // nome do s√≠mbolo
   ENUM_TIMEFRAMES¬† period,¬†      // per√≠odo
   ulong¬†           rates_mask,¬†  // combina√ß√£o de sinalizadores para indicar a s√©rie 
   datetime¬†        from,         // desde que data 
   datetime¬†        to    ¬†       // at√© que data
   );
</code></pre>
<p>
Para um vetor, os m√©todos s√£o semelhantes.
Acesso atrav√©s da posi√ß√£o inicial e n√∫mero de itens necess√°rios.
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyRates(
   string¬†          symbol,¬†      // nome do s√≠mbolo
   ENUM_TIMEFRAMES¬† period,¬†      // per√≠odo
   ulong¬†           rates_mask,¬†  // combina√ß√£o de sinalizadores para indicar a s√©rie 
   ulong¬†           start,¬†       // n√∫mero da barra inicial a partir da qual come√ßar 
   ulong¬†           count ¬†       // quantidade a copiar
   );
</code></pre>
<p>
Acesso atrav√©s da data inicial e n√∫mero de itens necess√°rios.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1330
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyRates(
   string¬†          symbol,¬†      // nome do s√≠mbolo
   ENUM_TIMEFRAMES¬† period,¬†      // per√≠odo
   ulong¬†           rates_mask,¬†  // combina√ß√£o de sinalizadores para indicar a s√©rie 
   datetime¬†        from,         // desde que data 
   ulong¬†           count ¬†       // quantidade a copiar
   );
</code></pre>
<p>
Acesso atrav√©s das datas inicial e final dentro de um intervalo de tempo.
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyRates(
   string¬†          symbol,¬†      // nome do s√≠mbolo
   ENUM_TIMEFRAMES¬† period,¬†      // per√≠odo
   ulong¬†           rates_mask,¬†  // combina√ß√£o de sinalizadores para indicar a s√©rie 
   datetime¬†        from,         // desde que data 
   datetime¬†        to    ¬†       // at√© que data
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  S√≠mbolo.
period
[in]  Per√≠odo.
rates_mask
[in]  Combina√ß√£o de sinalizadores provenientes da enumera√ß√£o ENUM_RATES que indicam o tipo
de s√©rie solicitada.  Ao copiar para um vetor, apenas um valor da enumera√ß√£o ENUM_RATES pode
ser especificado, caso contr√°rio, ocorrer√° um erro.
start
[in]  N√∫mero do primeiro item copiado.
count
[in]  N√∫mero de itens a serem copiados.
from
[in]  Tempo de barra correspondente ao primeiro item.
to
[in]  Tempo de barra correspondente ao √∫ltimo item.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false se for erro.
<h3>Observa√ß√£o</h3>
Se o intervalo de dados solicitado estiver totalmente fora dos dados dispon√≠veis no servidor, a
fun√ß√£o retorna false. Se os dados forem solicitados fora de TERMINAL_MAXBARS (n√∫mero m√°ximo
de barras no gr√°fico), a fun√ß√£o tamb√©m retornar√° false.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1331
Ao solicitar dados de um EA ou script, ser√° iniciada um carregamento desde o servidor se o terminal
n√£o tiver esses dados localmente, ou ser√° iniciada a constru√ß√£o da s√©rie temporal necess√°ria se os
dados puderem ser constru√≠dos a partir do hist√≥rico local, mas ainda n√£o estiverem prontos. A
fun√ß√£o retornar√° a quantidade de dados que estar√£o prontos quando o tempo expirar, mas o
carregamento do hist√≥rico continuar√°, e na pr√≥xima vez que uma solicita√ß√£o semelhante for feita a
fun√ß√£o retornar√° mais dados.
Ao solicitar dados por data de in√≠cio e n√∫mero de itens necess√°rios, somente os dados com data
menor que (antes) ou igual √† data especificada s√£o devolvidos. O intervalo √© definido e considerado
com uma precis√£o de segundos. Ou seja, a data de abertura de qualquer barra para a qual um valor
√© retornado (volume, spread, pre√ßo de abertura, m√°ximo, m√≠nimo, fechamento ou hora) √© sempre
igual ou menor que o especificado.
Ao solicitar dados em um determinado intervalo de datas, apenas os dados que se enquadram no
intervalo solicitado s√£o retornados, enquanto o intervalo √© definido e considerado com precis√£o de
at√© um segundo. Ou seja, o tempo de abertura de qualquer barra para a qual um valor √© retornado
(volume, spread, valor no buffer do indicador, pre√ßo de abertura, m√°ximo, m√≠nimo, fechamento ou
tempo) est√° sempre dentro do intervalo solicitado.
Assim, se o dia da semana atual for s√°bado, quando voc√™ tentar copiar dados no per√≠odo semanal,
especificando start_time=ultima_ter√ßa-feira e stop_time=ultima_sexta-feira a fun√ß√£o retornar√° 0,
pois o hor√°rio de abertura no per√≠odo semanal sempre cai no domingo, mas nenhuma barra semanal
est√° dentro do intervalo especificado.
Se voc√™ precisar obter o valor correspondente √† barra incompleta atual, poder√° usar a primeira
forma da chamada, indicando start_pos=0 –∏ count=1.
<h3>ENUM_COPY_RATES</h3>
A enumera√ß√£o ENUM_COPY_RATES cont√©m sinalizadores para especificar o tipo de dados a ser passado
para a matriz ou array. A combina√ß√£o de sinalizadores permite obter v√°rias s√©ries do hist√≥rico em
uma solicita√ß√£o. Nesse caso, a ordem das linhas na matriz corresponder√° √† ordem dos valores na
enumera√ß√£o ENUM_COPY_RATES, ou seja, a linha com dados High ser√° sempre maior na matriz do que
a linha com dados Low.
<h3>Identificador</h3>
<h3>Valor</h3>
<h3>Descri√ß√£o</h3>
<h3>COPY_RATES_OPEN</h3>
1
<h3>S√©rie de pre√ßos Open</h3>
<h3>COPY_RATES_HIGH</h3>
2
<h3>S√©rie de pre√ßos High</h3>
<h3>COPY_RATES_LOW</h3>
4
<h3>S√©rie de pre√ßos Low</h3>
<h3>COPY_RATES_CLOSE</h3>
8
<h3>S√©rie de pre√ßos Close</h3>
<h3>COPY_RATES_TIME</h3>
16
S√©rie Time (hora de abertura da barra)
A obten√ß√£o de tempo no valor float do vetor
e matriz (vectord e matrixf) acarreta a
perda de ~100 segundos, em outras palavras
a precis√£o do valor float √© fortemente
limitado, e inteiros com um valor superior a</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1332
<h3>Identificador</h3>
<h3>Valor</h3>
<h3>Descri√ß√£o</h3>
1&lt;&lt;24 n√£o podem ser representados com
precis√£o em um valor float.
<h3>COPY_RATES_VOLUME_TICK</h3>
32
<h3>Volumes de ticks</h3>
<h3>COPY_RATES_VOLUME_REAL</h3>
64
<h3>Volumes de negocia√ß√£o</h3>
<h3>COPY_RATES_SPREAD</h3>
128
<h3>Spreads</h3>
<h3>Combina√ß√£o</h3>
<h3>COPY_RATES_OHLC</h3>
15
<h3>S√©ries Open, High, Low e Close</h3>
<h3>COPY_RATES_OHLCT</h3>
31
S√©rie Open, Hilgh, Low, Close e Time
<h3>Disposi√ß√£o dos dados</h3>
<h3>COPY_RATES_VERTICAL</h3>
32768
As s√©ries s√£o copiadas na matriz ao longo
do eixo vertical. Isso implica que os valores
das s√©ries na matriz s√£o organizados de
forma vertical, ou seja, os dados mais
antigos s√£o apresentados na primeira linha
e os mais recentes, na √∫ltima.
Por padr√£o, ao copiar para uma matriz, as
s√©ries s√£o adicionadas ao longo do eixo
horizontal.
O sinalizador s√≥ √© relevante ao copiar para
uma matriz.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
 {
//--- obtemos as cota√ß√µes na matriz
</code></pre>
<p>
  matrix matrix_rates;
  if(matrix_rates.CopyRates(Symbol(), PERIOD_CURRENT, COPY_RATES_OHLCT, 1, 10))
</p>
<pre><code class="language-mql5">
    Print(&quot;matrix rates: \n&quot;, matrix_rates);
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;matrix_rates.CopyRates failed. Error &quot;, GetLastError());
//--- verifica√ß√£o
</code></pre>
<p>
<h3>MqlRates mql_rates[];</h3>
  if(CopyRates(Symbol(), PERIOD_CURRENT, 1, 10, mql_rates)&gt;0)
</p>
<pre><code class="language-mql5">
   {
    Print(&quot;mql_rates array:&quot;);
    ArrayPrint(mql_rates);
   }
</code></pre>
<p>
  else</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1333
</p>
<pre><code class="language-mql5">
    Print(&quot;CopyRates(Symbol(), PERIOD_CURRENT,1, 10, mql_rates). Error &quot;, GetLastError
//--- obtemos cota√ß√µes no vetor = chamada errada
</code></pre>
<p>
  vector vector_rates;
  if(vector_rates.CopyRates(Symbol(), PERIOD_CURRENT, COPY_RATES_OHLC, 1, 15))
</p>
<pre><code class="language-mql5">
    Print(&quot;vector_rates COPY_RATES_OHLC: \n&quot;, vector_rates);
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;vector_rates.CopyRates COPY_RATES_OHLC failed. Error &quot;, GetLastError());
//--- obtemos os pre√ßos de fechamento no vetor
</code></pre>
<p>
  if(vector_rates.CopyRates(Symbol(), PERIOD_CURRENT, COPY_RATES_CLOSE, 1, 15))
</p>
<pre><code class="language-mql5">
    Print(&quot;vector_rates COPY_RATES_CLOSE: \n&quot;, vector_rates);
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;vector_rates.CopyRates failed. Error &quot;, GetLastError());
</code></pre>
<p>
 };
</p>
<pre><code class="language-mql5">
/*
   matrix rates:
   [[0.99686,0.99638,0.99588,0.99441,0.99464,0.99594,0.99698,0.99758,0.99581,0.9952800
    [0.99708,0.99643,0.99591,0.9955000000000001,0.99652,0.99795,0.99865,0.99764,0.9960
    [0.9961100000000001,0.99491,0.99426,0.99441,0.99448,0.99494,0.9964499999999999,0.9
    [0.99641,0.99588,0.99441,0.99464,0.99594,0.99697,0.99758,0.99581,0.995280000000000
    [1662436800,1662440400,1662444000,1662447600,1662451200,1662454800,1662458400,1662
   mql_rates array:
                    [time]  [open]  [high]   [low] [close] [tick_volume] [spread] [rea
   [0] 2022.09.06 04:00:00 0.99686 0.99708 0.99611 0.99641          4463        0     
   [1] 2022.09.06 05:00:00 0.99638 0.99643 0.99491 0.99588          4519        0     
   [2] 2022.09.06 06:00:00 0.99588 0.99591 0.99426 0.99441          3060        0     
   [3] 2022.09.06 07:00:00 0.99441 0.99550 0.99441 0.99464          3867        0     
   [4] 2022.09.06 08:00:00 0.99464 0.99652 0.99448 0.99594          5280        0     
   [5] 2022.09.06 09:00:00 0.99594 0.99795 0.99494 0.99697          7227        0     
   [6] 2022.09.06 10:00:00 0.99698 0.99865 0.99645 0.99758         10130        0     
   [7] 2022.09.06 11:00:00 0.99758 0.99764 0.99472 0.99581          7012        0     
   [8] 2022.09.06 12:00:00 0.99581 0.99604 0.99360 0.99528          6166        0     
   [9] 2022.09.06 13:00:00 0.99528 0.99570 0.99220 0.99259          6950        0     
   vector_rates.CopyRates COPY_RATES_OHLC failed. Error 4003
   vector_rates COPY_RATES_CLOSE:
   [0.9931,0.99293,0.99417,0.99504,0.9968399999999999,0.99641,0.99588,0.99441,0.99464,
</code></pre>
<p>
*/
<h3>Ver tamb√©m</h3>
Acesso a s√©ries temporais e indicadores,  CopyRates</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1334
<h3>CopyTicks</h3>
Obt√©m em uma matriz ou vetor os ticks a partir da estrutura MqlTick. Os elementos da posi√ß√£o inicial
s√£o contados do passado para o presente, ou seja, o tick com √≠ndice 0 √© o mais antigo. Para analisar
um tick √© necess√°rio verificar o campo flags, que notifica exatamente o que foi alterado no tick em
quest√£o.
</p>
<pre><code class="language-mql5">
bool¬† matrix::CopyTicks(
   string¬†          symbol,¬†               // nome do s√≠mbolo
   ulong¬†           flags,                 // sinalizador que define o tipo de ticks r
   ulong¬†           from_msc,              // momento a partir do qual os ticks s√£o so
   ulong¬†           count   ¬†              // n√∫mero de ticks a serem obtidos
   );
</code></pre>
<p>
<h3>M√©todo vetorial</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyTicks(
   string¬†          symbol,¬†               // nome do s√≠mbolo
   ulong¬†           flags,                 // sinalizador que define o tipo de ticks r
   ulong¬†           from_msc,              // momento a partir do qual os ticks s√£o so
   ulong¬†           count   ¬†              // n√∫mero de ticks a serem obtidos
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  S√≠mbolo.
flags
[in]  Combina√ß√£o de sinalizadores a partir da enumera√ß√£o ENUM_COPY_TICKS, que indica a
composi√ß√£o dos dados solicitados. Ao copiar em um vetor, apenas um valor da enumera√ß√£o pode
ser especificado a partir da enumera√ß√£o ENUM_COPY_TICKS, caso contr√°rio, haver√° um erro.
from_msc
[in]  momento a partir do qual os ticks s√£o solicitados. Indicado em milissegundos a partir de
01.01.1970. Se o par√¢metro from_msc=0, ent√£o √© dada a √∫ltima count de ticks.
count
[in]  N√∫mero de ticks solicitados. Se os par√¢metros from_msc e count n√£o forem especificados,
todos os √∫ltimos ticks dispon√≠veis ser√£o registrados, mas n√£o mais do que 2000.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false se for erro.
<h3>Observa√ß√£o</h3>
A primeira chamada a CopyTicks() inicia uma sincroniza√ß√£o do banco de dados de ticks armazenados
no disco r√≠gido para um determinado s√≠mbolo. Se n√£o houver ticks suficientes no banco de dados
local, os ticks ausentes ser√£o baixados automaticamente do servidor de negocia√ß√£o. Neste caso, os
ticks s√£o sincronizados a partir do momento from_msc, especificado em¬†CopyTicks(), at√© o</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1335
momento. Ap√≥s essa opera√ß√£o, todos os ticks recebidos para esse s√≠mbolo ser√£o armazenados no
banco de dados de ticks, mantendo-o atualizado em tempo real e em sincronia.
Se os par√¢metros from_msc e count n√£o forem especificados, ent√£o todos os ticks dispon√≠veis ser√£o
escritos para a matriz/vetor, mas n√£o mais do que 2000. 
Nos indicadores, o m√©todo CopyTicks() retorna o resultado imediatamente: Quando chamado a
partir do indicador CopyTick() retornar√° imediatamente os ticks dispon√≠veis por s√≠mbolo, e tamb√©m
iniciar√° a sincroniza√ß√£o do banco de dados de ticks se houver dados insuficientes. Todos os
indicadores de um mesmo s√≠mbolo operam em um fluxo comum, portanto, um indicador n√£o deve
aguardar a conclus√£o da sincroniza√ß√£o para continuar funcionando. Ap√≥s o t√©rmino da sincroniza√ß√£o,
a pr√≥xima chamada a CopyTicks() retornar√° todos os ticks solicitados. A fun√ß√£o OnCalculate() nos
indicadores √© chamada ap√≥s a recep√ß√£o de cada tick. 
Em EAs e scripts, o m√©todo CopyTicks() pode esperar at√© 45 segundos por um resultado: Ao
contr√°rio de um indicador, cada EA e script trabalha em seu pr√≥prio fluxo e pode, portanto, esperar
at√© 45 segundos para que a sincroniza√ß√£o seja conclu√≠da. Se durante esse tempo os ticks n√£o forem
sincronizados na medida necess√°ria, ent√£o CopyTicks() retornar√° apenas os ticks dispon√≠veis por
timeout, enquanto a sincroniza√ß√£o continuar√°. A fun√ß√£o OnTick() nos EAs n√£o √© um manipulador de
cada tick, ela apenas notifica o EA sobre as mudan√ßas no mercado. As mudan√ßas no mercado podem
ocorrer em lotes, ou seja, diversos ticks podem ser recebidos pelo terminal simultaneamente.
Entretanto, a fun√ß√£o OnTick() ser√° chamada apenas uma vez para notificar o Expert Advisor sobre a
√∫ltima condi√ß√£o do mercado. 
Taxa de sa√≠da: o terminal mant√©m em cache os √∫ltimos 4096 ticks de cada s√≠mbolo (65536 ticks
para s√≠mbolos com a pilha em execu√ß√£o) para acesso r√°pido, o que permite consultas mais r√°pidas
aos dados hist√≥ricos. Quando s√£o solicitados ticks da sess√£o de negocia√ß√£o atual que n√£o est√£o
armazenados em cache, a fun√ß√£o CopyTicks() acessa diretamente os ticks armazenados na mem√≥ria
do terminal. No entanto, essas solicita√ß√µes podem levar mais tempo para serem executadas. As
solicita√ß√µes de ticks de outros dias s√£o as mais lentas, pois nesse caso os dados s√£o lidos do disco,
o que leva mais tempo para serem recuperados e processados.
<h3>ENUM_COPY_TICKS</h3>
A enumera√ß√£o ENUM_COPY_TICKS cont√©m sinalizadores para especificar o tipo de dados a ser passado
para a matriz ou array. A combina√ß√£o de sinalizadores permite obter v√°rias s√©ries do hist√≥rico em
uma solicita√ß√£o. Nesse caso, a ordem das linhas na matriz corresponder√° √† ordem dos valores na
enumera√ß√£o ENUM_COPY_TICKS, ou seja, a linha com dados High ser√° sempre maior na matriz do que
a linha com dados Low.
<h3>Identificador</h3>
<h3>Valor</h3>
<h3>Descri√ß√£o</h3>
<h3>COPY_TICKS_INFO</h3>
1
<h3>COPY_TICKS_TRADE</h3>
2
<h3>COPY_TICKS_ALL</h3>
3
<h3>COPY_TICKS_TIME_MS</h3>
1&lt;&lt;8
<h3>Tempo de tick em milissegundos</h3>
<h3>COPY_TICKS_BID</h3>
1&lt;&lt;9
<h3>Pre√ßo Bid</h3>
<h3>COPY_TICKS_ASK</h3>
1&lt;&lt;10
<h3>Pre√ßo Ask</h3>
<h3>COPY_TICKS_LAST</h3>
1&lt;&lt;11
<h3>Pre√ßo Last (pre√ßo da √∫ltima negocia√ß√£o)</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1336
<h3>Identificador</h3>
<h3>Valor</h3>
<h3>Descri√ß√£o</h3>
<h3>COPY_TICKS_VOLUME</h3>
1&lt;&lt;12
<h3>Volume para o pre√ßo Last</h3>
<h3>COPY_TICKS_FLAGS</h3>
1&lt;&lt;13
<h3>Sinalizador de ticks</h3>
<h3>Disposi√ß√£o dos dados</h3>
<h3>COPY_TICKS_VERTICAL</h3>
1&lt;&lt;15
Os ticks s√£o copiados na matriz ao longo do
eixo vertical. Isso implica que os ticks na
matriz s√£o organizados de forma vertical,
ou seja, os ticks mais 
antigos 
s√£o
apresentados na primeira linha e os mais
recentes, na √∫ltima.
Por padr√£o, ao copiar para uma matriz, os
ticks s√£o adicionadas ao longo do eixo
horizontal.
O sinalizador s√≥ √© relevante ao copiar para
uma matriz.
Para saber exatamente quais dados foram alterados com o tick atual, analise seus sinalizadores:
¬∑ TICK_FLAG_BID ‚Äì tick mudou o pre√ßo Bid
¬∑ TICK_FLAG_ASK  ‚Äì tick mudou o pre√ßo Ask
¬∑ TICK_FLAG_LAST ‚Äì tick mudou o pre√ßo da √∫ltima negocia√ß√£o
¬∑ TICK_FLAG_VOLUME ‚Äì tick modou o volume
¬∑ TICK_FLAG_BUY ‚Äì tick surgiu como resultado de uma negocia√ß√£o de compra
¬∑ TICK_FLAG_SELL ‚Äì tick surgiu como resultado de uma negocia√ß√£o de venda
<h3>Ver tamb√©m</h3>
Acesso a s√©ries temporais e indicadores,  CopyTicks</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1337
<h3>CopyTicksRange</h3>
Obt√©m em uma matriz ou vetor os ticks a partir da estrutura MqlTick na faixa de datas indicada. Os
elementos da posi√ß√£o inicial s√£o contados do passado para o presente, ou seja, o tick com √≠ndice 0 √© o
mais antigo. Para analisar um tick √© necess√°rio verificar o campo flags, que notifica exatamente o
que foi alterado no tick em quest√£o.
</p>
<pre><code class="language-mql5">
bool¬† matrix::CopyTicksRange(
   string¬†          symbol,¬†               // nome do s√≠mbolo
   ulong¬†           flags,                 // sinalizador que define o tipo de ticks r
   ulong¬†           from_msc,              // momento a partir do qual os ticks s√£o so
   ulong¬†           to_msc                 // momento a partir do qual os ticks s√£o so
   );
</code></pre>
<p>
<h3>M√©todo vetorial</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::CopyTicksRange(
   string¬†          symbol,¬†               // nome do s√≠mbolo
   ulong¬†           flags,                 // sinalizador que define o tipo de ticks r
   ulong¬†           from_msc,              // momento a partir do qual os ticks s√£o so
   ulong¬†           to_msc                 // momento a partir do qual os ticks s√£o so
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  S√≠mbolo.
flags
[in]  Combina√ß√£o de sinalizadores a partir da enumera√ß√£o ENUM_COPY_TICKS, que indica a
composi√ß√£o dos dados solicitados. Ao copiar em um vetor, apenas um valor da enumera√ß√£o pode
ser especificado a partir da enumera√ß√£o ENUM_COPY_TICKS, caso contr√°rio, haver√° um erro.
from_msc
[in]  momento a partir do qual os ticks s√£o solicitados. Indicado em milissegundos a partir de
01.01.1970. Se o par√¢metro from_msc n√£o for especificado, os ticks ser√£o fornecidos desde o
in√≠cio do hist√≥rico. S√£o entregados ticks com a data &gt;= from_msc.
to_msc
[in]  Momento a partir do qual s√£o solicitados os ticks. Indicado em milissegundos a partir de
01.01.1970. S√£o entregados ticks com a data &lt;= to_msc. Se o par√¢metro to_msc n√£o √©
especificado, ent√£o todos os ticks s√£o dados at√© o final do hist√≥rico.
<h3>Valor retornado</h3>
Retorna true se bem sucedido, caso contr√°rio false. GetLastError() pode retornar os seguintes erros:
¬∑ ERR_HISTORY_TIMEOUT ‚Äì o tempo de espera para a sincroniza√ß√£o dos ticks expirou, a fun√ß√£o
entregou tudo o que tinha.
¬∑ ERR_HISTORY_SMALL_BUFFER ‚Äì o buffer est√°tico √© muito pequeno, apenas entregou o que cabia
na matriz.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1338
¬∑ ERR_NOT_ENOUGH_MEMORY ‚Äì mem√≥ria insuficiente para obter o hist√≥rico do intervalo
especificado em uma matriz din√¢mica de ticks. Falha ao alocar a quantidade necess√°ria de
mem√≥ria para a matriz de ticks.
Para saber exatamente quais dados foram alterados com o tick atual, analise seus sinalizadores:
¬∑ TICK_FLAG_BID ‚Äì tick mudou o pre√ßo Bid
¬∑ TICK_FLAG_ASK  ‚Äì tick mudou o pre√ßo Ask
¬∑ TICK_FLAG_LAST ‚Äì tick mudou o pre√ßo da √∫ltima negocia√ß√£o
¬∑ TICK_FLAG_VOLUME ‚Äì tick modou o volume
¬∑ TICK_FLAG_BUY ‚Äì tick surgiu como resultado de uma negocia√ß√£o de compra
¬∑ TICK_FLAG_SELL ‚Äì tick surgiu como resultado de uma negocia√ß√£o de venda
<h3>Observa√ß√£o</h3>
O m√©todo CopyTicksRange() √© projetado para solicitar ticks de uma faixa estritamente
especificada, por exemplo, para um dia em particular do hist√≥rico. Enquanto CopyTicks() permite
especificar apenas uma data de in√≠cio, como por exemplo receber todos os ticks desde o in√≠cio do
m√™s at√© a hora atual.
<h3>Ver tamb√©m</h3>
Acesso a s√©ries temporais e indicadores,  CopyTicksRange</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1339
<h3>Eye</h3>
A fun√ß√£o est√°tica cria uma matriz do tamanho especificado com uns na diagonal especificada e zeros
fora da diagonal. Retorna uma matriz com uns ao longo da diagonal e zeros em todas as outras
posi√ß√µes.
static matrix matrix::Eye(
¬† const ulong¬† rows,¬†       //¬†n√∫mero de filas
¬† const ulong¬† cols,¬†       //¬†n√∫mero de colunas
¬† const int¬†   ndiag=0¬†     //¬†√≠ndice diagonal
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  N√∫mero de linhas de sa√≠da.
cols
[in]  N√∫mero de colunas de sa√≠da.
ndiag=0
[in] √çndice da diagonal: 0 (padr√£o) representa a diagonal principal, um valor positivo representa
uma diagonal superior e um valor negativo representa uma diagonal inferior.
<h3>Valor retornado</h3>
Matriz na qual todos os elementos s√£o iguais a zero, exceto a k-√©sima diagonal, cujos valores s√£o
iguais a um.
<h3>Exemplo em MQL5:</h3>
  matrix eye=matrix::Eye(3, 3);
<h3>Print(&quot;eye = \n&quot;, eye);</h3>
  
  eye=matrix::Eye(4, 4,1);
<h3>Print(&quot;eye = \n&quot;, eye);</h3>
</p>
<pre><code class="language-mql5">
  /*
   eye = 
   [[1,0,0]
    [0,1,0]
    [0,0,1]]
   eye = 
   [[0,1,0,0]
    [0,0,1,0]
    [0,0,0,1]
    [0,0,0,0]]   
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
np.eye(3, dtype=int)</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1340
array([[1, 0, 0],
</p>
<pre><code class="language-mql5">
       [0, 1, 0],
       [0, 0, 1]])
</code></pre>
<p>
np.eye(4, k=1)
array([[0., 1., 0., 0.],
</p>
<pre><code class="language-mql5">
       [0., 0., 1., 0.],
       [0., 0., 0., 1.],
       [0., 0., 0., 0.]])</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1341
<h3>Identity</h3>
A fun√ß√£o est√°tica cria uma matriz identidade do tamanho especificado (n√£o necessariamente
quadrada). A matriz identidade cont√©m uns na diagonal principal e zeros fora da diagonal principal. A
diagonal principal consiste nos elementos de uma matriz cujos √≠ndices de linha e coluna s√£o iguais, ou
seja, [0,0],[1,1],[2,2], etc. Cria uma nova matriz de identidade.
Existe tamb√©m um m√©todo Identity que converte uma matriz j√° existente em uma identidade.
static matrix matrix::Identity(
¬† const ulong¬† rows,¬†       //¬†n√∫mero de filas
¬† const ulong¬† cols,¬†       //¬†n√∫mero de colunas
</p>
<pre><code class="language-mql5">
   );
void¬†matrix::Identity();
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  N√∫mero de linhas (e colunas) em uma matriz n x n.
<h3>Valor retornado</h3>
Retorna a matriz identidade. A matriz identidade √© uma matriz quadrada com uns na diagonal
principal.
<h3>Exemplo em MQL5:</h3>
  matrix identity=matrix::Identity(3,3);
<h3>Print(&quot;identity = \n&quot;, identity);</h3>
</p>
<pre><code class="language-mql5">
/* 
   identity = 
   [[1,0,0]
    [0,1,0]
    [0,0,1]]
</code></pre>
<p>
*/
  matrix identity2(3,5);
  identity2.Identity();
<h3>Print(&quot;identity2 = \n&quot;, identity2);</h3>
</p>
<pre><code class="language-mql5">
/* 
   identity2 = 
   [[1,0,0,0,0]
    [0,1,0,0,0]
    [0,0,1,0,0]]
</code></pre>
<p>
*/ 
<h3>Exemplo em Python:</h3>
np.identity(3)</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1342
array([[1.,  0.,  0.],
</p>
<pre><code class="language-mql5">
       [0.,  1.,  0.],
       [0.,  0.,  1.]])</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1343
<h3>Ones</h3>
Fun√ß√£o est√°tica. Cria e retorna uma nova matriz preenchida com uns.
static matrix matrix::Ones(
¬† const ulong¬† rows,¬†    //¬†n√∫mero de linhas
¬† const ulong¬† cols¬†     //¬†n√∫mero de colunas
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
static vector vector::Ones(
¬† const ulong¬† size,¬†    //¬†tamanho do vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  N√∫mero de filas.
cols
[in]  N√∫mero de colunas.
<h3>Valor retornado</h3>
Retorna uma nova matriz a partir das linhas e colunas dadas, matriz essa preenchida com uns.
<h3>Exemplo em MQL5:</h3>
  matrix ones=matrix::Ones(4, 4);
<h3>Print(&quot;ones = \n&quot;, ones);</h3>
</p>
<pre><code class="language-mql5">
/*
</code></pre>
<p>
ones = 
</p>
<pre><code class="language-mql5">
   [[1,1,1,1]
    [1,1,1,1]
    [1,1,1,1]
    [1,1,1,1]]
</code></pre>
<p>
*/
<h3>Exemplo em Python:</h3>
np.ones((4, 1))
array([[1.],
</p>
<pre><code class="language-mql5">
       [1.]])</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1344
<h3>Zeros</h3>
Fun√ß√£o est√°tica. Cria e retorna uma nova matriz preenchida com zeros.
static matrix matrix::Zeros(
¬† const ulong¬† rows,¬†    //¬†n√∫mero de linhas
¬† const ulong¬† cols¬†     //¬†n√∫mero de colunas
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
static vector vector::Zeros(
¬† const ulong¬† size,¬†    //¬†tamanho do vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  N√∫mero de filas.
cols
[in]  N√∫mero de colunas.
<h3>Valor retornado</h3>
Retorna uma nova matriz a partir das linhas e colunas dadas, matriz essa preenchida com zeros.
<h3>Exemplo em MQL5:</h3>
  matrix zeros=matrix::Zeros(3, 4);
<h3>Print(&quot;zeros = \n&quot;, zeros);</h3>
</p>
<pre><code class="language-mql5">
/*
</code></pre>
<p>
zeros = 
</p>
<pre><code class="language-mql5">
   [[0,0,0,0]
    [0,0,0,0]
    [0,0,0,0]]
</code></pre>
<p>
*/
<h3>Exemplo em Python:</h3>
np.zeros((2, 1))
array([[ 0.],
</p>
<pre><code class="language-mql5">
       [ 0.]])</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1345
<h3>Full</h3>
Fun√ß√£o est√°tica. Cria e retorna uma nova matriz preenchida com o valor especificado.
static matrix matrix::Full(
¬† const ulong   rows,¬†     //¬†n√∫mero de linhas
¬† const ulong   cols,¬†     //¬†n√∫mero de colunas
¬† const double¬† value¬†     //¬†valor para preenchimento
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
static vector vector::Full(
¬† const ulong¬†  size,¬†     //¬†tamanho do vetor
¬† const double¬† value¬†     //¬†valor para preenchimento
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  N√∫mero de filas.
cols
[in]  N√∫mero de colunas.
value
[in]  Valor com o qual todos os elementos da matriz ser√£o preenchidos.
<h3>Valor retornado</h3>
Retorna uma nova matriz a partir das linhas e colunas fornecidas, matriz essa preenchida com o
valor especificado.
<h3>Exemplo em MQL5:</h3>
  matrix full=matrix::Full(3,4,10);
<h3>Print(&quot;full = \n&quot;, full);</h3>
</p>
<pre><code class="language-mql5">
/*
</code></pre>
<p>
full = 
</p>
<pre><code class="language-mql5">
   [[10,10,10,10]
    [10,10,10,10]
    [10,10,10,10]]
</code></pre>
<p>
*/
<h3>Exemplo:</h3>
np.full((2, 2), 10)
array([[10, 10],
</p>
<pre><code class="language-mql5">
       [10, 10]])</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1346
<h3>Tri</h3>
Fun√ß√£o est√°tica. Cria uma matriz com uns na diagonal indicada e abaixo e zeros em todas as outras
posi√ß√µes.
static matrix matrix::Tri(
¬† const ulong¬†rows,¬†       //¬†n√∫mero de linhas
¬† const ulong¬†cols,¬†       //¬†n√∫mero de colunas
¬† const int¬†  ndiag=0¬†     //¬†n√∫mero de diagonais
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  N√∫mero de linhas na matriz.
cols
[in]  N√∫mero de colunas na matriz.
ndiag=0
[in]  A subdiagonal da matriz que, junto com as demais abaixo dela, ser√° preenchida. k = 0 ‚Äî
diagonal principal, k &lt; 0 ‚Äî diagonais abaixo da diagonal principal, k &gt; 0 ‚Äî acima. Por padr√£o √© 0.
<h3>Valor retornado</h3>
Uma matriz cujo tri√¢ngulo inferior √© preenchido com uns e todos os demais elementos com zeros.
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a=matrix::Tri(3,4,1);
   Print(&quot;Tri(3,4,1)\n&quot;,matrix_a);
   matrix_a=matrix::Tri(4,3,-1);
   Print(&quot;Tri(4,3,-1)\n&quot;,matrix_a);
/*
   Tri(3,4,1)
   [[1,1,0,0]
    [1,1,1,0]
    [1,1,1,1]]
   Tri(4,3,-1)
   [[0,0,0]
    [1,0,0]
    [1,1,0]
    [1,1,1]]
</code></pre>
<p>
*/
<h3>Exemplo:</h3>
np.tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
</p>
<pre><code class="language-mql5">
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1347
<h3>Init</h3>
Inicializa uma matriz ou vetor.
</p>
<pre><code class="language-mql5">
void¬†matrix::Init(
</code></pre>
<p>
¬† const ulong¬† rows,¬†           //¬†n√∫mero de linhas
¬† const ulong¬† cols,            //¬†n√∫mero de colunas
</p>
<pre><code class="language-mql5">
   func_name   init_func=NULL,  //¬†fun√ß√£o de inicializa√ß√£o colocada em algum √°rea de v
   ...         parameters
   );
void¬†vector::Init(
</code></pre>
<p>
¬† const ulong¬† size,¬†           //¬†tamanho do vetor
  func_name    init_func=NULL,  //¬†fun√ß√£o de inicializa√ß√£o colocada em alguma √°rea de 
</p>
<pre><code class="language-mql5">
   ...         parameters
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  N√∫mero de filas.
cols
[in]  N√∫mero de colunas.
func_name
[in]  Fun√ß√£o de inicializa√ß√£o.
...
[in]  Par√¢metros da fun√ß√£o de inicializa√ß√£o.
<h3>Valor retornado</h3>
N√£o h√° valor de retorno.
<h3>Exemplo:</h3>
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
void MatrixArange(matrix&lt;T&gt; &amp;mat,T value=0.0,T step=1.0)
  {
   for(ulong i=0; i&lt;mat.Rows(); i++)
     {
      for(ulong j=0; j&lt;mat.Cols(); j++,value+=step)
         mat[i][j]=value;
     }
</code></pre>
<p>
  }
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
void VectorArange(vector&lt;T&gt; &amp;vec,T value=0.0,T step=1.0)
  {</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1348
</p>
<pre><code class="language-mql5">
   for(ulong i=0; i&lt;vec.Size(); i++,value+=step)
      vec[i]=value;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
</code></pre>
<p>
  int size_m=3, size_k=4;
  matrix  m(size_m,size_k,MatrixArange,-2.,0.1); // primeiro cria uma matriz n√£o-inici
  Print(&quot;matrix m \n&quot;,m);                        // em seguida, a fun√ß√£o MatrixArange 
  matrixf m_float(5,5,MatrixArange,-2.f,0.1f);   // ap√≥s a cria√ß√£o de uma matriz do ti
<h3>Print(&quot;matrix m_float \n&quot;,m_float);</h3>
  vector  v(size_k,VectorArange,-10.0);          // ap√≥s a cria√ß√£o de um vetor, Vector
<h3>Print(&quot;vector v \n&quot;,v);</h3>
</p>
<pre><code class="language-mql5">
  /*
   matrix m 
   [[-2,-1.9,-1.8,-1.7]
    [-1.6,-1.5,-1.399999999999999,-1.299999999999999]
    [-1.199999999999999,-1.099999999999999,-0.9999999999999992,-0.8999999999999992]]
   matrix m_float 
   [[-2,-1.9,-1.8,-1.6999999,-1.5999999]
    [-1.4999999,-1.3999999,-1.2999998,-1.1999998,-1.0999998]
    [-0.99999976,-0.89999974,-0.79999971,-0.69999969,-0.59999967]
    [-0.49999967,-0.39999968,-0.29999968,-0.19999969,-0.099999689]
    [3.1292439e-07,0.10000031,0.20000032,0.30000031,0.4000003]]
   vector v 
   [-10,-9,-8,-7]
</code></pre>
<p>
  */ 
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1349
<h3>Fill</h3>
Preenche uma matriz ou vetor existente com o valor fornecido.
</p>
<pre><code class="language-mql5">
void¬†matrix::Fill(
</code></pre>
<p>
¬† const double¬† value¬†     //¬†valor para preenchimento
</p>
<pre><code class="language-mql5">
   );
void¬†vector::Fill(
</code></pre>
<p>
¬† const double¬† value¬†     //¬†valor para preenchimento
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
value
[in]  Valor com o qual todos os elementos da matriz ser√£o preenchidos.
<h3>Valor retornado</h3>
N√£o h√° valor de retorno. A matriz √© preenchida com o valor especificado localmente.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a(2,2);
   matrix_a.Fill(10);
   Print(&quot;matrix_a\n&quot;,matrix_a);
/*
</code></pre>
<p>
  matrix_a
  [[10,10]
</p>
<pre><code class="language-mql5">
   [10,10]]
</code></pre>
<p>
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1350
<h3>Random</h3>
Fun√ß√£o est√°tica. Cria e retorna uma nova matriz ou vetor preenchido com valores aleat√≥rios. Os
valores aleat√≥rios s√£o gerados uniformemente dentro do intervalo especificado.
static vector vector::Random(
¬† const ulong¬†  size,¬†      //¬†comprimento do vetor
¬† const double¬† min=0.0,    //¬†valor m√≠nimo
¬† const double¬† max=1.0¬†    //¬†valor m√°ximo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
static matrix matrix::Random(
¬† const ulong¬†  rows,¬†      //¬†quantidade de linhas
¬† const ulong¬†  cols¬†       //¬†quantidade de colunas
¬† const float ¬† min=0.0,    //¬†valor m√≠nimo
¬† const float ¬† max=1.0¬†    //¬†valor m√°ximo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Fun√ß√£o para preencher uma matriz ou vetor existente com valores aleat√≥rios. Os valores aleat√≥rios
s√£o gerados uniformemente dentro do intervalo especificado.
</p>
<pre><code class="language-mql5">
void  vector::Random(
</code></pre>
<p>
¬† const double¬† min=0.0,    //¬†valor m√≠nimo
¬† const double¬† max=1.0¬†    //¬†valor m√°ximo
</p>
<pre><code class="language-mql5">
   );
void  matrix::Random(
</code></pre>
<p>
¬† const float ¬† min=0.0,    //¬†valor m√≠nimo
¬† const float ¬† max=1.0¬†    //¬†valor m√°ximo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  Quantidade de linhas.
cols
[in]  Quantidade de colunas.
size
[in]  Comprimento do vetor.
min=0.0
[in]  Valor m√≠nimo na amostra de n√∫meros aleat√≥rios gerada.
max=1.0
[in]  Valor m√°ximo na amostra de n√∫meros aleat√≥rios gerada.
<h3>Valor retornado</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1351
Retorna uma nova matriz com a quantidade especificada de linhas e colunas, preenchida com
valores aleat√≥rios.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   vector v1= vector::Random(6,0,4);
   Print(&quot;vector v1 \n&quot;, v1);  
   /*
   vector v1 
   [3.340834286841758,0.9073984578501895,3.15598511117417,0.7106475841045956,2.2940100
   */
      
   vector v2(4);
   v2.Random(-3,3);
   Print(&quot;vector v2 \n&quot;, v2);      
   /*
   vector v2 
   [-2.642032080246609,1.008521607147651,1.340623848219547,-2.789016363161853]
   */
   matrix m1 = matrix::Random(5, 5, -1, 3);
   Print(&quot;matrix m1 \n&quot;, m1);
   /*
   matrix m1 
   [[1.468433369525809,1.199383023707052,0.6154667729547869,2.830012157519816,-0.06995
    [2.638591175814763,2.966658948912904,2.001837257994767,-0.08570802469870731,0.8260
    [0.982665140643405,0.5825661973987162,-0.6615881071569371,0.4069533109215444,-0.16
    [-0.5791836119208447,-0.9332020478167575,2.801898707589577,-0.09887318478405316,-0
    [-0.1069569017521471,-0.04576879345014895,0.6320100840255642,-0.3805729270401813,0
   */
   matrix m2(3, 3);
   m2.Random(-2, 2);
   Print(&quot;matrix m2 \n&quot;, m2);
   /*
   matrix m2 
   [[-1.928191291151613,-1.222873445419332,-1.965333905062949]
    [-1.077723600686929,1.053317863273741,-0.1786824246353196]
    [-1.965241401448204,1.620956906029246,-1.696386492740453]]
   */   
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1352
Manuseio de matrizes e vetores.
M√©todos para manipula√ß√£o b√°sica de matrizes, incluindo preenchimento, c√≥pia, obten√ß√£o de
submatrizes, transposi√ß√£o, divis√£o e classifica√ß√£o.
Existem tamb√©m v√°rios m√©todos para trabalhar com as linhas e colunas de uma matriz.
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>HasNan</h3>
Retorna o n√∫mero de valores NaN na matriz/vetor
<h3>Transpose</h3>
Expande ou reorganiza os eixos de uma matriz, retorna a matriz
modificada
<h3>TransposeConjugate</h3>
Transposi√ß√£o de uma matriz complexa com conjuga√ß√£o. Desenvolve
ou reorganiza os eixos da matriz alterando o sinal da parte
imagin√°ria dos n√∫meros complexos, retornando a matriz modificada
<h3>TriL</h3>
Retorna uma c√≥pia da matriz, substituindo todos os elementos acima
da k-√©sima diagonal por zeros. Matriz triangular inferior
<h3>TriU</h3>
Retorna uma c√≥pia da matriz, substituindo todos os elementos
abaixo da k-√©sima diagonal por zeros. Matriz triangular superior
<h3>Diag</h3>
Extrai uma diagonal ou cria uma matriz diagonal
<h3>Row</h3>
Retorna um vetor linha. Grava um vetor na string especificada
<h3>Col</h3>
Retorna um vetor coluna. Grava um vetor na coluna especificada
<h3>Copy</h3>
Devolve uma c√≥pia da matriz/vetor em quest√£o
<h3>Concat</h3>
Une 2 submatrizes em uma matriz. Une 2 vetores em um s√≥.
<h3>Compare</h3>
Compara os elementos de duas matrizes/vetores com a precis√£o
especificada
<h3>CompareByDigits</h3>
Compara se os elementos de duas matrizes/vetores correspondem,
levando em conta d√≠gitos significativos
<h3>CompareEqual</h3>
Executa uma compara√ß√£o absoluta de duas matrizes, transformando
suas linhas sequenciais em vetores unidimensionais
<h3>Flat</h3>
Permite endere√ßar um elemento da matriz por meio de um √≠ndice, e
n√£o por meio de dois
<h3>Clip</h3>
Limita os elementos de uma matriz/vetor a um intervalo
especificado de valores v√°lidos
<h3>Reshape</h3>
Altera a forma de uma matriz sem mudar seus dados
<h3>Resize</h3>
Retorna uma nova matriz da forma e tamanho especificados
<h3>SwapRows</h3>
<h3>Troca linhas em uma matriz</h3>
<h3>SwapCols</h3>
<h3>Troca colunas em uma matriz</h3>
<h3>Split</h3>
Divis√£o de uma matriz em v√°rias submatrices</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1353
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Hsplit</h3>
Divis√£o horizontal de uma matriz em v√°rias submatrizes. O mesmo
que Split —Å axis=0
<h3>Vsplit</h3>
Divis√£o vertical de uma matriz em v√°rias submatrizes. O mesmo que
<h3>Split —Å axis=1</h3>
<h3>ArgSort</h3>
Executa uma classifica√ß√£o indireta em uma matriz ou vetor.
<h3>Sort</h3>
Classifica no local uma matriz ou vetor.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1354
<h3>HasNan</h3>
Retorna o n√∫mero de valores NaN na matriz/vetor.
ulong vector::HasNan();
ulong matrix::HasNan();
<h3>Valor retornado</h3>
N√∫mero de elementos de matriz/vetor que cont√™m um valor NaN.
<h3>Observa√ß√£o</h3>
Os m√©todos Compare e CompareByDigits, ao comparar um par de elementos correspondentes com
valores NaN, consideram esses elementos iguais, enquanto em uma compara√ß√£o normal de ponto
flutuante NaN != NaN.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart(void)
  {
   double x=sqrt(-1);
   Print(&quot;single: &quot;,x==x);
   vector&lt;double&gt; v1={x};
   vector&lt;double&gt; v2={x};
   Print(&quot;vector: &quot;, v1.Compare(v2,0)==0);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
/* Resultado:
 
</code></pre>
<p>
 single: false
 vector: true
*/
<h3>Veja tamb√©m</h3>
<h3>MathClassify, Compare, CompareByDigits</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1355
<h3>Transpose</h3>
Transposi√ß√£o de matrizes. Expande ou reorganiza os eixos de uma matriz, retorna a matriz
modificada.
matrix¬†matrix::Transpose()
<h3>Valor retornado</h3>
Matriz transposta.
Algoritmo simples da transposi√ß√£o de matriz em MQL5:
matrix MatrixTranspose(const matrix&amp; matrix_a)
</p>
<pre><code class="language-mql5">
  {
   matrix matrix_c(matrix_a.Cols(),matrix_a.Rows());
   for(ulong i=0; i&lt;matrix_c.Rows(); i++)
      for(ulong j=0; j&lt;matrix_c.Cols(); j++)
         matrix_c[i][j]=matrix_a[j][i];
   return(matrix_c);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
  matrix a= {{0, 1, 2}, {3, 4, 5}};
<h3>Print(&quot;matrix a \n&quot;, a);</h3>
<h3>Print(&quot;a.Transpose() \n&quot;, a.Transpose());</h3>
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  matrix a
  [[0,1,2]
</p>
<pre><code class="language-mql5">
   [3,4,5]]
</code></pre>
<p>
  a.Transpose()
  [[0,3]
</p>
<pre><code class="language-mql5">
   [1,4]
   [2,5]]
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
import numpy as np
a = np.arange(6).reshape((2,3))
print(&quot;a \n&quot;,a)
print(&quot;np.transpose(a) \n&quot;,np.transpose(a))</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1356
a 
 [[0 1 2]
 [3 4 5]]
np.transpose(a) 
 [[0 3]
 [1 4]
 [2 5]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1357
<h3>TransposeConjugate</h3>
Transposi√ß√£o de uma matriz complexa com conjuga√ß√£o. Desenvolve ou reorganiza os eixos da matriz
alterando o sinal da parte imagin√°ria dos n√∫meros complexos, retornando a matriz modificada.
matrix¬†matrix::TransposeConjugate()
<h3>Valor retornado</h3>
Matriz transposta e conjugada complexa.
Algoritmo simples de transposi√ß√£o de uma matriz complexa com conjuga√ß√£o ‚Äî explica√ß√£o do m√©todo
</p>
<pre><code class="language-mql5">
//--- Fun√ß√£o de transposi√ß√£o de uma matriz complexa com conjuga√ß√£o
</code></pre>
<p>
matrix MatrixTranspose(const matrix&amp; matrix_a) {
</p>
<pre><code class="language-mql5">
    //--- criamos uma nova matriz matrix_c com dimens√µes invertidas em rela√ß√£o √† matri
    matrix matrix_c(matrix_a.Cols(), matrix_a.Rows());
    //--- percorremos todas as linhas da nova matriz
    for (ulong i = 0; i &lt; matrix_c.Rows(); i++) {
        //--- percorremos todas as colunas da nova matriz
        for (ulong j = 0; j &lt; matrix_c.Cols(); j++) {
            //--- transferimos a parte real do elemento, transpondo o √≠ndice
            matrix_c[i][j].real = matrix_a[j][i].real;
            
            //--- transferimos a parte imagin√°ria do elemento, mudando o sinal (conjug
            matrix_c[i][j].imag = -matrix_a[j][i].imag;
        }
    }
    //--- retornamos a matriz transposta e conjugada
    return (matrix_c);
}</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1358
<h3>TriL</h3>
Retorna uma c√≥pia da matriz, substituindo todos os elementos acima da k-√©sima diagonal por zeros.
Matriz triangular inferior.
matrix matrix::Tril(
¬† const int¬†    ndiag=0¬†     //¬†√≠ndice diagonal
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
ndiag=0
[in]  A diagonal acima da qual os elementos s√£o substitu√≠dos por zeros. ndiag = 0 (por padr√£o) ‚Äî
diagonal principal, ndiag &lt; 0 ‚Äî abaixo, j√° ndiag &gt; 0 ‚Äî acima da diagonal principal.
<h3>Valor retornado</h3>
Uma matriz cujo tri√¢ngulo inferior √© preenchido com uns e todos os demais elementos com zeros.
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   matrix a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   matrix b=a.TriL(-1);
   Print(&quot;matrix b \n&quot;,b);
  /*
</code></pre>
<p>
  matrix_c
  [[0,0,0]
  [4,0,0]
  [7,8,0]
  [10,11,12]]
  */
<h3>Exemplo em Python:</h3>
import numpy as np
a=np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
[[ 0  0  0]
 [ 4  0  0]
 [ 7  8  0]
 [10 11 12]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1359
<h3>TriU</h3>
Retorna uma c√≥pia da matriz, substituindo todos os elementos abaixo da k-√©sima diagonal por zeros.
Matriz triangular superior.
matrix matrix::Triu(
¬† const int¬†    ndiag=0¬†     //¬†√≠ndice diagonal
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
ndiag=0
[in]  Diagonal abaixo da qual os elementos s√£o substitu√≠dos por zeros. ndiag = 0 (por padr√£o) ‚Äî
diagonal principal, ndiag &lt; 0 ‚Äî abaixo, j√° ndiag &gt; 0 ‚Äî acima da diagonal principal.
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   matrix a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   matrix b=a.TriU(-1);
   Print(&quot;matrix b \n&quot;,b);
  /*
</code></pre>
<p>
  matrix b
  [[1,2,3]
</p>
<pre><code class="language-mql5">
   [4,5,6]
   [0,8,9]
   [0,0,12]]
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
import numpy as np
a=np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
print(a)
[[ 1  2  3]
 [ 4  5  6]
 [ 0  8  9]
 [ 0  0 12]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1360
<h3>Diag</h3>
Extrai a diagonal ou cria uma matriz diagonal.
vector matrix::Diag(
¬† const int¬†    ndiag=0¬†     //¬†n√∫mero diagonal
</p>
<pre><code class="language-mql5">
   );
void matrix::Diag(
</code></pre>
<p>
¬† const vector¬† v,¬†          //¬†vetor diagonal
¬† const int¬†    ndiag=0¬†     //¬†n√∫mero diagonal
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
v
[in]  Vetor cujos elementos devem ser inseridos na diagonal correspondente (ndiag=0 ‚Äî diagonal
principal).
ndiag=0
[in]  Diagonal. Por padr√£o √© 0. Para diagonais acima da diagonal principal, √© especificado ndiag&gt;0,
para diagonais abaixo √© ndiag&lt;0.
<h3>Observa√ß√£o</h3>
A diagonal pode ser definida para matrizes n√£o distribu√≠das (n√£o dimensionadas). Neste caso, ser√°
criada uma matriz nula do tamanho do vetor diagonal correspondente, ap√≥s a qual os valores dos
elementos vetoriais ser√£o inseridos na diagonal correspondente. Se uma diagonal for definida em
uma matriz existente, as dimens√µes da matriz permanecer√£o as mesmas e os valores dos elementos
da matriz fora do vetor diagonal n√£o ser√£o alterados.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector v1={1,2,3};
   matrix m1;
   m1.Diag(v1);
   Print(&quot;m1\n&quot;,m1);
   matrix m2;
   m2.Diag(v1,-1);
   Print(&quot;m2\n&quot;,m2);
   matrix m3;
   m3.Diag(v1,1);
   Print(&quot;m3\n&quot;,m3);
   matrix m4=matrix::Full(4,5,9);
   m4.Diag(v1,1);
   Print(&quot;m4\n&quot;,m4);
   
   Print(&quot;diag -1 - &quot;,m4.Diag(-1));</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1361
</p>
<pre><code class="language-mql5">
   Print(&quot;diag 0 - &quot;,m4.Diag());
   Print(&quot;diag 1 - &quot;,m4.Diag(1));
  /*
</code></pre>
<p>
  m1
  [[1,0,0]
  [0,2,0]
  [0,0,3]]
  m2
  [[0,0,0]
  [1,0,0]
  [0,2,0]
  [0,0,3]]
  m3
  [[0,1,0,0]
  [0,0,2,0]
  [0,0,0,3]]
  m4
  [[9,1,9,9,9]
  [9,9,2,9,9]
  [9,9,9,3,9]
  [9,9,9,9,9]]
  diag -1 - [9,9,9]
  diag 0 - [9,9,9,9]
  diag 1 - [1,2,3,9]
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1362
<h3>Row</h3>
Retorna um vetor linha. Grava um vetor na string especificada.
vector matrix::Row(
¬† const ulong¬†  nrow¬†     //¬†n√∫mero da linha
</p>
<pre><code class="language-mql5">
   );
void matrix::Row(
</code></pre>
<p>
¬† const vector¬† v,¬†       //¬†vetor da linha
¬† const ulong¬†  nrow¬†     //¬†n√∫mero da linha
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
nrow
[in]  N√∫mero da linha.
<h3>Valor retornado</h3>
Vetor.
<h3>Observa√ß√£o</h3>
A linha pode ser definida para matrizes n√£o distribu√≠das (sem dimens√µes definidas). Nesse caso,
ser√° criada uma matriz com todos os elementos iguais a zero, com tamanho (n√∫mero de linhas + 1)
x tamanho do vetor, ap√≥s o que os valores dos elementos do vetor ser√£o inseridos na linha
correspondente. Se a linha for definida para uma matriz j√° existente, as dimens√µes da matriz n√£o
ser√£o alteradas e os valores dos elementos da matriz fora do vetor da linha n√£o ser√£o alterados.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector v1={1,2,3};
   matrix m1;
   m1.Row(v1,1);
   Print(&quot;m1\n&quot;,m1);
   matrix m2=matrix::Full(4,5,7);
   m2.Row(v1,2);
   Print(&quot;m2\n&quot;,m2);
   
   Print(&quot;row 1 - &quot;,m2.Row(1));
   Print(&quot;row 2 - &quot;,m2.Row(2));
  /*
</code></pre>
<p>
  m1
  [[0,0,0]
  [1,2,3]]
  m2
  [[7,7,7,7,7]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1363
  [7,7,7,7,7]
  [1,2,3,7,7]
  [7,7,7,7,7]]
  row 1 - [7,7,7,7,7]
  row 2 - [1,2,3,7,7]
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1364
<h3>Col</h3>
Retorna um vetor coluna. Grava um vetor na coluna especificada.
vector matrix::Col(
¬† const ulong¬†  ncol¬†     //¬†n√∫mero da coluna
</p>
<pre><code class="language-mql5">
   );
void matrix::Col(
</code></pre>
<p>
¬† const vector¬† v,¬†       //¬†vetor da coluna
¬† const ulong¬†  ncol¬†     //¬†n√∫mero da coluna
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
ncol
[in]  N√∫mero da coluna.
<h3>Valor retornado</h3>
Vetor.
<h3>Observa√ß√£o</h3>
Uma coluna pode ser definida para matrizes n√£o resolvidas (sem dimens√µes). Nesse caso, ser√°
criada uma matriz nula com tamanho tamanho do vetor x (n√∫mero de colunas + 1), ap√≥s o que os
valores dos elementos do vetor ser√£o inseridos na coluna correspondente. Se a coluna for definida
para uma matriz j√° existente, as dimens√µes da matriz n√£o ser√£o alteradas e os valores dos
elementos da matriz fora do vetor da coluna n√£o ser√£o alterados.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector v1={1,2,3};
   matrix m1;
   m1.Col(v1,1);
   Print(&quot;m1\n&quot;,m1);
   matrix m2=matrix::Full(4,5,8);
   m2.Col(v1,2);
   Print(&quot;m2\n&quot;,m2);
   
   Print(&quot;col 1 - &quot;,m2.Col(1));
   Print(&quot;col 2 - &quot;,m2.Col(2));
  /*
</code></pre>
<p>
  m1
  [[0,1]
  [0,2]
  [0,3]]
  m2
  [[8,8,1,8,8]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1365
  [8,8,2,8,8]
  [8,8,3,8,8]
  [8,8,8,8,8]]
  col 1 - [8,8,8,8]
  col 2 - [1,2,3,8]
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1366
<h3>Copy</h3>
Cria uma c√≥pia da matriz/vetor fornecido.
</p>
<pre><code class="language-mql5">
bool matrix::Copy(
</code></pre>
<p>
¬† const matrix&amp;¬† a¬†    //¬†matriz de c√≥pia
</p>
<pre><code class="language-mql5">
   );
bool vector::Copy(
</code></pre>
<p>
¬† const vector&amp;¬† v¬†    //¬†vetor de c√≥pia
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
v
[in]  Matriz ou vetor a ser copiado.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Exemplo em MQL5:</h3>
  matrix a=matrix::Eye(3, 4);
  matrix b;
  b.Copy(a);
  matrix c=a;
<h3>Print(&quot;matrix b \n&quot;, b);</h3>
<h3>Print(&quot;matrix_c \n&quot;, c);</h3>
</p>
<pre><code class="language-mql5">
  /*
  /*
</code></pre>
<p>
  matrix b
  [[1,0,0,0]
  [0,1,0,0]
  [0,0,1,0]]
  matrix_c
  [[1,0,0,0]
  [0,1,0,0]
  [0,0,1,0]]
  */
  */
<h3>Exemplo em Python:</h3>
import numpy as np
a = np.eye(3,4)
print(&#x27;a \n&#x27;,a)
b = a</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1367
print(&#x27;b \n&#x27;,b)
c = np.copy(a)
print(&#x27;c \n&#x27;,c)
a 
 [[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]]
b 
 [[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]]
c 
 [[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]]
<h3>Ver tamb√©m</h3>
<h3>Assign</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1368
<h3>Concat</h3>
Une 2 submatrizes em uma matriz. Une 2 vetores em um s√≥.
vector vector::Concat(
  const vector&amp;  second_part      //¬†segundo vetor para uni√£o
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
vector matrix::Concat(
  const matrix&amp;  second_part      //¬†segunda matriz para uni√£o
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix matrix::Split(
  const matrix&amp;  second_part      //¬†segunda matriz para uni√£o
¬† const int¬†     axis ¬†           //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
second_part
[in] Segundo vetor ou matriz para uni√£o. Se as matrizes forem unidas ao longo de algum eixo, os
tamanhos das matrizes devem coincidir nesse eixo.
axis
[in]  Eixo. 0 - eixo horizontal, 1 - eixo vertical.
<h3>Valor retornado</h3>
Retorna um vetor se os vetores ou matrizes forem unidos sem o par√¢metro de eixo, ou se as
matrizes forem unidas ao longo do eixo horizontal ou vertical.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector vector_a={1,2,3,4};
   vector vector_b={5,6,7};
   vector vector_c=vector_a.Concat(vector_b);
   Print(&quot;vector_c=&quot;,vector_c);
   matrix matrix_a={{1,2,3},{4,5,6}};
   matrix matrix_b={{7,8,9},{10,11,12}};
   vector_c=matrix_a.Concat(matrix_b);
   Print(&quot;vector_c=&quot;,vector_c);
   matrix matrix_c0=matrix_a.Concat(matrix_b,0);
   Print(&quot;matrix_c0=\n&quot;,matrix_c0);
   matrix matrix_c1=matrix_a.Concat(matrix_b,1);
   Print(&quot;matrix_c1=\n&quot;,matrix_c1);
  /*</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1369
  vector_c=[1,2,3,4,5,6,7]
  vector_c=[1,2,3,4,5,6,7,8,9,10,11,12]
  matrix_c0=
  [[1,2,3]
</p>
<pre><code class="language-mql5">
   [4,5,6]
   [7,8,9]
   [10,11,12]]
</code></pre>
<p>
  matrix_c1=
  [[1,2,3,7,8,9]
</p>
<pre><code class="language-mql5">
   [4,5,6,10,11,12]]
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1370
<h3>Compare</h3>
Compara os elementos de duas matrizes/vetores com a precis√£o especificada.
ulong vector::Compare(
¬† const vector&amp; vec,          //¬†vetor de compara√ß√£o
¬† const double¬† epsilon¬†      //¬†precis√£o
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
ulong matrix::Compare(
¬† const matrix&amp; mat,          //¬†matriz de compara√ß√£o
¬† const double¬† epsilon¬†      //¬†precis√£o
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vector_b
[in]  Vetor de compara√ß√£o.
vector_b
[in]  Vetor de compara√ß√£o.
epsilon
[in]  Precis√£o.
<h3>Valor retornado</h3>
Retorna o n√∫mero de elementos diferentes entre as matrizes ou vetores comparados, ou seja, 0 se
as matrizes forem iguais, caso contr√°rio, o valor ser√° maior que 0.
Para matrizes/vetores complexos, a compara√ß√£o √© para estimar a dist√¢ncia entre n√∫meros
complexos. A dist√¢ncia √© calculada usando a f√≥rmula sqrt(pow(r1-r2, 2) + pow(i1-i2, 2) e √© um
n√∫mero real que j√° pode ser comparado a epsilon.
<h3>Observa√ß√£o</h3>
Os operadores de compara√ß√£o == ou != produzem uma compara√ß√£o exata elemento por elemento. √â
conhecido que a compara√ß√£o exata de n√∫meros reais tem sua aplica√ß√£o limitada, por isso foi
adicionado o m√©todo de compara√ß√£o com epsilon. Existem casos em que dentro da mesma matriz
existem elementos no intervalo, por exemplo, de 1e-20 a 1e+20. Para isso, √© fornecida uma
compara√ß√£o elemento a elemento, levando em considera√ß√£o d√≠gitos significativos.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4}};
   matrix matrix_i=matrix::Identity(3,3);
   matrix matrix_c=matrix_a.Inv();
   matrix matrix_check=matrix_a.MatMul(matrix_c);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1371
</p>
<pre><code class="language-mql5">
   Print(&quot;matrix_check\n&quot;,matrix_check);
   ulong errors=matrix_check.Compare(matrix::Identity(3,3),1e-15);
   Print(&quot;errors=&quot;,errors);
  /*
</code></pre>
<p>
  matrix_check
  [[1,0,0]
  [4.440892098500626e-16,1,8.881784197001252e-16]
  [4.440892098500626e-16,2.220446049250313e-16,0.9999999999999996]]
  errors=0
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1372
<h3>CompareByDigits</h3>
Compara os elementos de duas matrizes/vetores para verificar se correspondem com uma precis√£o de
d√≠gitos significativos.
ulong vector::CompareByDigits(
¬† const vector&amp;  vec,          //¬†vetor de compara√ß√£o
  const int¬†    digits¬†        //¬†n√∫mero de d√≠gitos significativos
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
ulong matrix::CompareByDigits(
¬† const matrix&amp;  mat,          //¬†matriz de compara√ß√£o
  const int¬†     digits¬†       //¬†n√∫mero de d√≠gitos significativos
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vector_b
[in]  Vetor de compara√ß√£o.
digits
[in]  N√∫mero de d√≠gitos significativos para compara√ß√£o.
epsilon
[in]  Precis√£o da compara√ß√£o. Se a diferen√ßa absoluta entre dois valores for menor do que a
precis√£o especificada, eles ser√£o considerados iguais.
<h3>Valor retornado</h3>
Retorna o n√∫mero de elementos diferentes entre as matrizes ou vetores comparados, ou seja, 0 se
as matrizes forem iguais, caso contr√°rio, o valor ser√° maior que 0.
<h3>Observa√ß√£o</h3>
Os operadores de compara√ß√£o == ou != produzem uma compara√ß√£o exata elemento por elemento. √â
conhecido que a compara√ß√£o exata de n√∫meros reais tem sua aplica√ß√£o limitada, por isso foi
adicionado o m√©todo de compara√ß√£o com epsilon. Existem casos em que dentro da mesma matriz
existem elementos no intervalo, por exemplo, de 1e-20 a 1e+20. Para isso, √© fornecida uma
compara√ß√£o elemento a elemento, levando em considera√ß√£o d√≠gitos significativos.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   int    size_m=128;
   int    size_k=256;
   matrix matrix_a(size_m,size_k);
//--- preenchemos a matriz
   double  value=0.0;
   for(int i=0; i&lt;size_m; i++)
     {</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1373
</p>
<pre><code class="language-mql5">
      for(int j=0; j&lt;size_k; j++)
        {
         if(i==j)
            matrix_a[i][j]=1.0+i;
         else
           {
            value+=1.0;
            matrix_a[i][j]=value/1e+20;
           }
        }
     }
//--- obtemos outra matriz
   matrix matrix_c = matrix_a * -1;
   ulong errors_epsilon=matrix_a.Compare(matrix_c,1e-15);
   ulong errors_digits=matrix_a.CompareByDigits(matrix_c,15);
   printf(&quot;Compare matrix %d x %d  errors_epsilon=%I64u  errors_digits=%I64u&quot;,size_m,s
  /*
</code></pre>
<p>
  Compare matrix 128 x 256  errors_epsilon=128  errors_digits=32768
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1374
<h3>CompareEqual</h3>
Executa uma compara√ß√£o absoluta de duas matrizes, transformando suas linhas sequenciais em
vetores unidimensionais.
ulong vector::Compare(
¬† const vector&amp; vec    //¬†vetor para compara√ß√£o
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
ulong matrix::CompareEqual(
¬† const matrix&amp; mat     //¬†matriz para compara√ß√£o
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vec
[in]  Vetor para compara√ß√£o.
mat
[in]  Matriz para compara√ß√£o.
<h3>Descri√ß√£o do m√©todo</h3>
Suponha que temos duas matrizes: a matriz A ‚Äî matriz que chama o m√©todo ‚Äî e a matriz B,
passada como par√¢metro. A compara√ß√£o segue os seguintes passos:
1. As matrizes s√£o transformadas em vetores unidimensionais, concatenando suas linhas
sequencialmente.
2. Os vetores resultantes s√£o comparados elemento por elemento, at√© o primeiro elemento
divergente.
3. O m√©todo retorna um dos valores descritos abaixo, conforme o resultado da compara√ß√£o.
<h3>Valor retornado</h3>
-1 ‚Äî se um elemento da matriz A for menor que o elemento correspondente na matriz B.
0 ‚Äî se todos os elementos das matrizes A e B forem id√™nticos.
1 ‚Äî se um elemento da matriz A for maior que o elemento correspondente na matriz B.
<h3>Observa√ß√£o</h3>
Ao comparar, os elementos com valor NaN s√£o levados em considera√ß√£o.
Elementos NaN s√£o tratados como iguais se estiverem na mesma posi√ß√£o em ambas as matrizes.
O sinal de NaN n√£o √© considerado na compara√ß√£o.
Um elemento NaN √© considerado menor que qualquer outro valor num√©rico.
<h3>Example</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1375
</p>
<pre><code class="language-mql5">
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   matrix matrix_a= {{10, 3, 2}, {1, 8, 12}, {6, 5, 4}};
   matrix matrix_i=matrix::Identity(3, 3);
   matrix matrix_c=matrix_a.Inv();
   matrix matrix_check=matrix_a.MatMul(matrix_c);
   Print(&quot;matrix_check\n&quot;, matrix_check);
   ulong errors=matrix_check.Compare(matrix::Identity(3, 3), 1e-15);
   Print(&quot;errors=&quot;, errors);
   /*
   matrix_check
   [[1,0,0]
   [4.440892098500626e-16,1,8.881784197001252e-16]
   [4.440892098500626e-16,2.220446049250313e-16,0.9999999999999996]]
   errors=0
   */
//--- compara√ß√£o absoluta de matrizes
   matrix&lt;double&gt; A = matrix_a;  // Inicializa√ß√£o da matriz A
   matrix&lt;double&gt; B = matrix_c;  // Inicializa√ß√£o da matriz B
   int result = A.CompareEqual(B);
   switch(result)
     {
      case -1:
         Print(&quot;A matriz A √© menor que a matriz B&quot;);
         break;
      case 0:
         Print(&quot;As matrizes A e B s√£o id√™nticas&quot;);
         break;
      case 1:
         Print(&quot;A matriz A √© maior que a matriz B&quot;);
         break;
      case -2:
         Print(&quot;Error! A matriz A n√£o foi inicializada&quot;);
         break;
      case 2:
         Print(&quot;Error! Matriz B n√£o inicializada&quot;);
         break;
      case -3:
         Print(&quot;Error! O tamanho da matriz A √© menor que o tamanho da matriz B&quot;);
         break;
      case 3:
         Print(&quot;Error! O tamanho da matriz A √© maior do que o tamanho da matriz B&quot;);
         break;
      default:</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1376
</p>
<pre><code class="language-mql5">
         Print(&quot;Error! Erro desconhecido&quot;);
         break;
     }
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1377
<h3>Flat</h3>
Permite endere√ßar um elemento da matriz por meio de um √≠ndice, e n√£o por meio de dois.
</p>
<pre><code class="language-mql5">
bool matrix::Flat(
</code></pre>
<p>
  const ulong¬†  index,¬†    //¬†
  const double¬†  value¬†    //¬†valor a ser definido
</p>
<pre><code class="language-mql5">
   );
double matrix::Flat(
</code></pre>
<p>
  const ulong¬†  index,¬†    //¬†
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
index
[in]  √≠ndice Flat
value
[in]  O valor a ser definido pelo √≠ndice definido.
<h3>Valor retornado</h3>
Valor com base no √≠ndice fornecido.
<h3>Observa√ß√£o</h3>
Para a matriz matrix mat(3,3) os acessos podem ser escritos da seguinte forma:  
¬∑ para leitura ‚Äî x=mat.Flat(4), o que equivale a escrever x=mat[1][1]  
¬∑ para escrita ‚Äî mat.Flat(5, 42), o que equivale a escrever mat[1][2]=42
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   ulong arg_max=matrix_a.ArgMax();
   Print(&quot;max_value=&quot;,matrix_a.Flat(arg_max));
   matrix_a.Flat(arg_max,0);
   arg_max=matrix_a.ArgMax();
   Print(&quot;max_value=&quot;,matrix_a.Flat(arg_max));
  /*
</code></pre>
<p>
  matrix_a
  [[10,3,2]
</p>
<pre><code class="language-mql5">
   [1,8,12]
   [6,5,4]
   [7,11,9]]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1378
  max_value=12.0
  max_value=11.0
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1379
<h3>Clip</h3>
Limita os elementos de uma matriz/vetor a um intervalo especificado de valores v√°lidos.
</p>
<pre><code class="language-mql5">
bool matrix::Clip(
</code></pre>
<p>
¬† const double¬† min_value,¬†    //¬†valor m√≠nimo
¬† const double¬† max_value¬†     //¬†valor m√°ximo
</p>
<pre><code class="language-mql5">
   );
bool vector::Clip(
</code></pre>
<p>
¬† const double¬† min_value,¬†    //¬†valor m√≠nimo
¬† const double¬† max_value¬†     //¬†valor m√°ximo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
min_value
[in]  Valor m√≠nimo.
max_value
[in]  Valor m√°ximo.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
A matriz (ou vetor) √© processada localmente. Nenhuma c√≥pia √© criada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   bool res=matrix_a.Clip(4,8);
   Print(&quot;matrix_a\n&quot;,matrix_a);
  /*
</code></pre>
<p>
  matrix_a
  [[4,4,4]
</p>
<pre><code class="language-mql5">
   [4,5,6]
   [7,8,8]
   [8,8,8]]
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1380
<h3>Reshape</h3>
Altera a forma de uma matriz sem mudar seus dados.
</p>
<pre><code class="language-mql5">
void¬† Reshape(
</code></pre>
<p>
¬† const ulong¬† rows,¬†    //¬†novo n√∫mero de linhas
¬† const ulong¬† cols¬†     //¬†novo n√∫mero de colunas
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  Novo n√∫mero de linhas.
cols
[in]  Novo n√∫mero de colunas.
<h3>Observa√ß√£o</h3>
A matriz √© processada localmente. Nenhuma c√≥pia √© criada. Qualquer dimens√£o pode ser definida,
ou seja rows_new*cols_new!=rows_old*cols_old. Quando o buffer da matriz √© aumentado, os
valores &quot;extras&quot; ficam indefinidos ou n√£o inicializados.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   matrix_a.Reshape(2,6);
   Print(&quot;Reshape(2,6)\n&quot;,matrix_a);
   matrix_a.Reshape(3,5);
   Print(&quot;Reshape(3,5)\n&quot;,matrix_a);
   matrix_a.Reshape(2,4);
   Print(&quot;Reshape(2,4)\n&quot;,matrix_a);
  /*
</code></pre>
<p>
  matrix_a
  [[1,2,3]
</p>
<pre><code class="language-mql5">
   [4,5,6]
   [7,8,9]
   [10,11,12]]
</code></pre>
<p>
<h3>Reshape(2,6)</h3>
  [[1,2,3,4,5,6]
</p>
<pre><code class="language-mql5">
   [7,8,9,10,11,12]]
</code></pre>
<p>
<h3>Reshape(3,5)</h3>
  [[1,2,3,4,5]
</p>
<pre><code class="language-mql5">
   [6,7,8,9,10]
   [11,12,0,3,0]]
</code></pre>
<p>
<h3>Reshape(2,4)</h3>
  [[1,2,3,4]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1381
</p>
<pre><code class="language-mql5">
   [5,6,7,8]]
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1382
<h3>Resize</h3>
Retorna uma nova matriz da forma e tamanho especificados.
</p>
<pre><code class="language-mql5">
bool matrix::Resize(
</code></pre>
<p>
  const ulong¬† rows,¬†    //¬†
¬† const ulong¬† cols,     //¬†novo n√∫mero de colunas
¬† const ulong¬† reserve=0 //¬†n√∫mero reservado de elementos
</p>
<pre><code class="language-mql5">
   );
bool vector::Resize(
</code></pre>
<p>
¬† const ulong¬† size,     //¬†novo tamanho
¬† const ulong¬† reserve=0 //¬†n√∫mero reservado de elementos
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rows
[in]  Novo n√∫mero de linhas.
cols
[in]  Novo n√∫mero de colunas.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
A matriz (ou vetor) √© processada localmente. Nenhuma c√≥pia √© criada. Qualquer dimens√£o pode
ser definida, ou seja rows_new*cols_new!=rows_old*cols_old. Ao contr√°rio do Reshape, a matriz √©
processada linha por linha. Se o n√∫mero de colunas aumenta, os valores das colunas &quot;extras&quot; s√£o
indefinidos. Quando o n√∫mero de filas √© aumentado, os valores dos elementos das novas filas
ficam indefinidos. Quando o n√∫mero de colunas √© reduzido, cada linha da matriz √© truncada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   matrix_a.Resize(2,6);
   Print(&quot;Ressize(2,6)\n&quot;,matrix_a);
   matrix_a.Resize(3,5);
   Print(&quot;Resize(3,5)\n&quot;,matrix_a);
   matrix_a.Resize(2,4);
   Print(&quot;Resize(2,4)\n&quot;,matrix_a);
   /*
   matrix_a
   [[1,2,3]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1383
</p>
<pre><code class="language-mql5">
    [4,5,6]
    [7,8,9]
    [10,11,12]]
   Ressize(2,6)
   [[1,2,3,4,5,6]
    [4,5,6,10,11,12]]
   Resize(3,5)
   [[1,2,3,4,5]
    [4,5,6,10,11]
    [11,12,3,8,8]]
   Resize(2,4)
   [[1,2,3,4]
    [4,5,6,10]]
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1384
<h3>Set</h3>
Define o valor de um elemento vetorial pelo √≠ndice especificado.
</p>
<pre><code class="language-mql5">
bool vector::Set(
</code></pre>
<p>
¬† ulong¬†  index,     //¬†√≠ndice do elemento
¬† double¬† value      //¬†valor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
index
[in]  √çndice do elemento para o qual o valor deve ser definido.
value
[in]  Valor.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
O m√©todo Set faz a mesma coisa que a atribui√ß√£o de um valor por meio de colchetes, assim:
vector[index]=value. Adicionado para facilitar a portabilidade do c√≥digo proveniente de linguagens
que usam exatamente essa tipo de entrada. O exemplo abaixo mostra as duas variantes de
preenchimento do vetor com valores pelo √≠ndice especificado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   vector v1(10, VectorAssignValues);
   Print(&quot;v1 = &quot;, v1);
   vector v2(10, VectorSetValues);
   Print(&quot;v2 = &quot;, v2);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
¬†/* Resultado
</code></pre>
<p>
  v1 = [1,2,4,8,16,32,64,128,256,512]
  v2 = [1,2,4,8,16,32,64,128,256,512]
  */
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preenche o vetor com a pot√™ncia de um n√∫mero por meio da opera√ß√£o de atribui√ß√£o   
//+------------------------------------------------------------------+
void VectorAssignValues(vector&amp; v, double initial=1)
  {
   double value=initial;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1385
</p>
<pre><code class="language-mql5">
   for(ulong k=0; k&lt;v.Size(); k++)
     {
      v[k]=value;
      value*=2;
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preenche o vetor com pot√™ncias de um n√∫mero usando o m√©todo Set                   
//+------------------------------------------------------------------+
void VectorSetValues(vector&amp; v, double initial=1)
  {
   double value=initial;
   for(ulong k=0; k&lt;v.Size(); k++)
     {
      v.Set(k, value);
      value*=2;
     }
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1386
<h3>SwapRows</h3>
Troca as linhas na matriz.
</p>
<pre><code class="language-mql5">
bool matrix::SwapRows(
</code></pre>
<p>
¬† const ulong¬† row1,¬†    //¬†√≠ndice de primeira linha
¬† const ulong¬† row2¬†     //¬†√≠ndice da segunda linha
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
row1
[in]  √çndice de primeira linha.
row2
[in]  √çndice da segunda linha.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{1,2,3,4},
                    {5,6,7,8},
                    {9,10,11,12},
                    {13,14,15,16}};
   matrix matrix_i=matrix::Identity(4,4);
   matrix matrix_a1=matrix_a;
   matrix_a1.SwapRows(0,3);
   Print(&quot;matrix_a1\n&quot;,matrix_a1);
   matrix matrix_p=matrix_i;
   matrix_p.SwapRows(0,3);
   matrix matrix_c1=matrix_p.MatMul(matrix_a);
   Print(&quot;matrix_c1\n&quot;,matrix_c1);
  /*
</code></pre>
<p>
  matrix_a1
  [[13,14,15,16]
</p>
<pre><code class="language-mql5">
   [5,6,7,8]
   [9,10,11,12]
   [1,2,3,4]]
</code></pre>
<p>
  matrix_c1
  [[13,14,15,16]
</p>
<pre><code class="language-mql5">
   [5,6,7,8]
   [9,10,11,12]
   [1,2,3,4]]
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1387
<h3>SwapCols</h3>
Troca colunas em uma matriz.
</p>
<pre><code class="language-mql5">
bool matrix::SwapCols(
</code></pre>
<p>
¬† const ulong¬† col1,¬†    //¬†√≠ndice da primeira coluna
¬† const ulong¬† col2¬†     //¬†√≠ndice da segunda coluna
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
col1
[in]  √çndice da primeira coluna.
col2
[in]  √çndice da segunda coluna.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{1,2,3,4},
                    {5,6,7,8},
                    {9,10,11,12},
                    {13,14,15,16}};
   matrix matrix_i=matrix::Identity(4,4);
   matrix matrix_a1=matrix_a;
   matrix_a1.SwapCols(0,3);
   Print(&quot;matrix_a1\n&quot;,matrix_a1);
   matrix matrix_p=matrix_i;
   matrix_p.SwapCols(0,3);
   matrix matrix_c1=matrix_a.MatMul(matrix_p);
   Print(&quot;matrix_c1\n&quot;,matrix_c1);
  /*
</code></pre>
<p>
  matrix_a1
  [[4,2,3,1]
</p>
<pre><code class="language-mql5">
   [8,6,7,5]
   [12,10,11,9]
   [16,14,15,13]]
</code></pre>
<p>
  matrix_c1
  [[4,2,3,1]
</p>
<pre><code class="language-mql5">
   [8,6,7,5]
   [12,10,11,9]
   [16,14,15,13]]
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1388
<h3>Split</h3>
Divis√£o de uma matriz em v√°rias submatrices.
</p>
<pre><code class="language-mql5">
bool matrix::Split(
</code></pre>
<p>
  const ulong  parts,      //¬†n√∫mero de submatrizes
¬† const int¬†   axis,¬†      //¬†eixo
  matrix&amp;      splitted[]¬† //¬†matrizes das submatrizes obtidas
</p>
<pre><code class="language-mql5">
   );
void matrix::Split(
</code></pre>
<p>
  const ulong&amp; parts[],    //¬†tamanhos das submatrizes
¬† const int¬†   axis,¬†      //¬†eixo
  matrix&amp;      splitted[]¬† //¬†matrizes das submatrizes obtidas
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
parts
[in]  N√∫mero de submatrices para divis√£o da matriz.
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
splitted
[out]  Matriz de submatrices recebidas.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Se o n√∫mero de submatrizes for especificado, ser√£o obtidas submatrizes do mesmo tamanho. Em
outras palavras, o tamanho da matriz (0 - n√∫mero de linhas, 1 - n√∫mero de colunas) deve ser
divis√≠vel pelo n√∫mero parts sem resto. Submatrizes de diferentes tamanhos podem ser obtidas
usando uma matriz de tamanhos de submatrizes. Os elementos da matriz de tamanho s√£o usados
at√© que toda a matriz seja dividida. Se a matriz foi completamente dividida e o tamanho restante
n√£o for suficiente para formar uma submatriz completa, o restante n√£o dividido ser√° a √∫ltima
submatriz.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{ 1, 2, 3, 4, 5, 6},
                    { 7, 8, 9,10,11,12},
                    {13,14,15,16,17,18},
                    {19,20,21,22,23,24},
                    {25,26,27,28,29,30}};
   matrix splitted[];</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1389
</p>
<pre><code class="language-mql5">
   ulong  parts[]={2,2};
   bool res=matrix_a.Split(2,0,splitted);
   Print(res,&quot;  &quot;,GetLastError());
   ResetLastError();
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
   res=matrix_a.Split(2,1,splitted);
   Print(res,&quot;  &quot;,GetLastError());
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
   res=matrix_a.Split(parts,0,splitted);
   Print(res,&quot;  &quot;,GetLastError());
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
  /*
</code></pre>
<p>
  false  4003
  true  0
  splitted 0
  [[1,2,3]
</p>
<pre><code class="language-mql5">
   [7,8,9]
   [13,14,15]
   [19,20,21]
   [25,26,27]]
</code></pre>
<p>
  splitted 1
  [[4,5,6]
</p>
<pre><code class="language-mql5">
   [10,11,12]
   [16,17,18]
   [22,23,24]
   [28,29,30]]
</code></pre>
<p>
  true  0
  splitted 0
  [[1,2,3,4,5,6]
</p>
<pre><code class="language-mql5">
   [7,8,9,10,11,12]]
</code></pre>
<p>
  splitted 1
  [[13,14,15,16,17,18]
</p>
<pre><code class="language-mql5">
   [19,20,21,22,23,24]]
</code></pre>
<p>
  splitted 2
  [[25,26,27,28,29,30]]
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1390
<h3>Hsplit</h3>
Divis√£o horizontal de uma matriz em v√°rias submatrizes. O mesmo que Split com axis=0
</p>
<pre><code class="language-mql5">
bool matrix::Hsplit(
</code></pre>
<p>
  const ulong  parts,      //¬†n√∫mero de submatrizes
  matrix&amp;      splitted[]¬† //¬†matrizes das submatrizes obtidas
</p>
<pre><code class="language-mql5">
   );
void matrix::Hsplit(
</code></pre>
<p>
  const ulong&amp; parts[],    //¬†tamanhos das submatrizes
  matrix&amp;      splitted[]¬† //¬†matrizes das submatrizes obtidas
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
parts
[in]  N√∫mero de submatrices para divis√£o da matriz.
splitted
[out]  Matriz de submatrices recebidas.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Se o n√∫mero de submatrizes for especificado, ser√£o obtidas submatrizes do mesmo tamanho. Em
outras palavras, o n√∫mero de linhas deve ser divis√≠vel pelo n√∫mero de partes sem deixar resto.
Submatrizes de diferentes tamanhos podem ser obtidas usando uma matriz de tamanhos de
submatrizes. Os elementos da matriz de tamanho s√£o usados at√© que toda a matriz seja dividida.
Se a matriz foi completamente dividida e o tamanho restante n√£o for suficiente para formar uma
submatriz completa, o restante n√£o dividido ser√° a √∫ltima submatriz.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{ 1, 2, 3, 4, 5, 6},
                    { 7, 8, 9,10,11,12},
                    {13,14,15,16,17,18},
                    {19,20,21,22,23,24},
                    {25,26,27,28,29,30}};
   matrix splitted[];
   ulong  parts[]={2,4};
   bool res=matrix_a.Hsplit(2,splitted);
   Print(res,&quot;  &quot;,GetLastError());
   ResetLastError();
   for(uint i=0; i&lt;splitted.Size(); i++)</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1391
</p>
<pre><code class="language-mql5">
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
   res=matrix_a.Hsplit(5,splitted);
   Print(res,&quot;  &quot;,GetLastError());
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
   res=matrix_a.Hsplit(parts,splitted);
   Print(res,&quot;  &quot;,GetLastError());
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
  /*
</code></pre>
<p>
  false  4003
  true  0
  splitted 0
  [[1,2,3,4,5,6]]
  splitted 1
  [[7,8,9,10,11,12]]
  splitted 2
  [[13,14,15,16,17,18]]
  splitted 3
  [[19,20,21,22,23,24]]
  splitted 4
  [[25,26,27,28,29,30]]
  true  0
  splitted 0
  [[1,2,3,4,5,6]
  [7,8,9,10,11,12]]
  splitted 1
  [[13,14,15,16,17,18]
  [19,20,21,22,23,24]
  [25,26,27,28,29,30]]
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1392
<h3>Vsplit</h3>
Divis√£o vertical de uma matriz em v√°rias submatrizes. O mesmo que Split com axis=1
</p>
<pre><code class="language-mql5">
bool matrix::Vsplit(
</code></pre>
<p>
  const ulong  parts,      //¬†n√∫mero de submatrizes
  matrix&amp;      splitted[]¬† //¬†matrizes das submatrizes obtidas
</p>
<pre><code class="language-mql5">
   );
void matrix::Vsplit(
</code></pre>
<p>
  const ulong&amp; parts[],    //¬†tamanhos das submatrizes
  matrix&amp;      splitted[]¬† //¬†matrizes das submatrizes obtidas
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
parts
[in]  N√∫mero de submatrices para divis√£o da matriz.
splitted
[out]  Matriz de submatrices recebidas.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Se o n√∫mero de submatrizes for especificado, ser√£o obtidas submatrizes do mesmo tamanho. Em
outras palavras, o n√∫mero de colunas deve ser dividido pelo n√∫mero de parts sem um resto.
Submatrizes de diferentes tamanhos podem ser obtidas usando uma matriz de tamanhos de
submatrizes. Os elementos da matriz de tamanho s√£o usados at√© que toda a matriz seja dividida.
Se a matriz foi completamente dividida e o tamanho restante n√£o for suficiente para formar uma
submatriz completa, o restante n√£o dividido ser√° a √∫ltima submatriz.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{ 1, 2, 3, 4, 5, 6},
                    { 7, 8, 9,10,11,12},
                    {13,14,15,16,17,18}};
   matrix splitted[];
   ulong  parts[]={2,3};
   matrix_a.Vsplit(2,splitted);
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
   matrix_a.Vsplit(3,splitted);
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1393
</p>
<pre><code class="language-mql5">
   matrix_a.Vsplit(parts,splitted);
   for(uint i=0; i&lt;splitted.Size(); i++)
      Print(&quot;splitted &quot;,i,&quot;\n&quot;,splitted[i]);
  /*
     splitted 0
     [[1,2,3]
      [7,8,9]
      [13,14,15]]
     splitted 1
     [[4,5,6]
      [10,11,12]
      [16,17,18]]
     splitted 0
     [[1,2]
      [7,8]
      [13,14]]
     splitted 1
     [[3,4]
      [9,10]
      [15,16]]
     splitted 2
     [[5,6]
      [11,12]
      [17,18]]
     splitted 0
     [[1,2]
      [7,8]
      [13,14]]
     splitted 1
     [[3,4,5]
      [9,10,11]
      [15,16,17]]
     splitted 2
     [[6]
      [12]
      [18]]
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1394
<h3>ArgSort</h3>
Classifica√ß√£o indireta de uma matriz ou vetor.
vector vector::Sort(
  func_name  compare_func=NULL,  //¬†fun√ß√£o de compara√ß√£o
  T          context             //¬†par√¢metro para a fun√ß√£o de classifica√ß√£o personali
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix matrix::Sort(
  func_name  compare_func=NULL   //¬†fun√ß√£o de compara√ß√£o
  T          context             //¬†par√¢metro para a fun√ß√£o de classifica√ß√£o personali
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix matrix::Sort(
¬† const int¬† axis,¬†              //¬†eixo para classifica√ß√£o
  func_name  compare_func=NULL   //¬†fun√ß√£o de compara√ß√£o
  T          context             //¬†par√¢metro para a fun√ß√£o de classifica√ß√£o personali
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo para a realiza√ß√£o da classifica√ß√£o: 0 ‚Äî horizontal, 1 ‚Äî vertical.
func_name
[in]  Comparador. Voc√™ pode especificar um dos valores da enumera√ß√£o ENUM_SORT_MODE ou sua
pr√≥pria fun√ß√£o de compara√ß√£o. Se nenhuma fun√ß√£o for especificada, √© utilizada a classifica√ß√£o
ascendente.
A fun√ß√£o de compara√ß√£o personalizada pode ser de dois tipos:
¬∑ int comparator(T x1,T x2)
¬∑ int comparator(T x1,T x2,TContext context)
Neste caso T ‚Äî tipo de matriz ou vetor, j√° TContex ‚Äî tipo de vari√°vel context, passado como um
par√¢metro adicional ao m√©todo Sort.
context
[in]  Par√¢metro opcional adicional que pode ser passado para uma fun√ß√£o de classifica√ß√£o
personalizada.
<h3>Valor retornado</h3>
Vetor ou matriz com √≠ndices de elementos classificados. Por exemplo, o resultado [4, 2, 0, 1, 3]
indica que o elemento na posi√ß√£o zero do vetor ordenado deve ter o √≠ndice 4, o elemento na
primeira posi√ß√£o deve ter o √≠ndice 2 e assim por diante.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1395
<h3>Sort</h3>
Classifica√ß√£o de uma matriz ou vetor no lugar.
</p>
<pre><code class="language-mql5">
void vector::Sort(
</code></pre>
<p>
  func_name  compare_func=NULL,  //¬†fun√ß√£o de compara√ß√£o
  T          context             //¬†par√¢metro para a fun√ß√£o de classifica√ß√£o personali
</p>
<pre><code class="language-mql5">
   );
void matrix::Sort(
</code></pre>
<p>
  func_name  compare_func=NULL   //¬†fun√ß√£o de compara√ß√£o
  T          context             //¬†par√¢metro para a fun√ß√£o de classifica√ß√£o personali
</p>
<pre><code class="language-mql5">
   );
void matrix::Sort(
</code></pre>
<p>
¬† const int¬† axis,¬†              //¬†eixo para classifica√ß√£o
  func_name  compare_func=NULL   //¬†fun√ß√£o de compara√ß√£o
  T          context             //¬†par√¢metro para a fun√ß√£o de classifica√ß√£o personali
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo para a realiza√ß√£o da classifica√ß√£o: 0 ‚Äî horizontal, 1 ‚Äî vertical.
func_name
[in]  Comparador. Voc√™ pode especificar um dos valores da enumera√ß√£o ENUM_SORT_MODE ou sua
pr√≥pria fun√ß√£o de compara√ß√£o. Se nenhuma fun√ß√£o for especificada, √© utilizada a classifica√ß√£o
ascendente.
A fun√ß√£o de compara√ß√£o personalizada pode ser de dois tipos:
¬∑ int comparator(T x1,T x2)
¬∑ int comparator(T x1,T x2,TContext context)
Neste caso T ‚Äî tipo de matriz ou vetor, j√° TContex ‚Äî tipo de vari√°vel context, passado como um
par√¢metro adicional ao m√©todo Sort.
context
[in]  Par√¢metro opcional adicional que pode ser passado para uma fun√ß√£o de classifica√ß√£o
personalizada.
<h3>Valor retornado</h3>
N√£o. A classifica√ß√£o √© realizada no local, isto √©, aplicada aos dados da matriz/vetor para o qual o
m√©todo Sort √© chamado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de classifica√ß√£o                                          |
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1396
</p>
<pre><code class="language-mql5">
int MyDoubleComparator(double x1,double x2,int sort_mode=0)
  {
   int res=x1&lt;x2 ? -1 : (x1&gt;x2 ? 1 : 0);
   return(sort_mode==0 ? res : -res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o para executar o script                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   //--- preenchimento do vetor
   vector v(100);
   //--- classifica√ß√£o ascendente
   v.Sort(MyDoubleComparator);   // neste caso √© utilizado um par√¢metro adicional com 
   Print(v);
   // classifica√ß√£o decrescente
   v.Sort(MyDoubleComparator,1); // aqui o par√¢metro opcional &#x27;1&#x27; √© explicitamente esp
   Print(v);
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1397
<h3>Opera√ß√µes matem√°ticas sobre matrizes e vetores</h3>
As opera√ß√µes matem√°ticas de adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o podem ser realizadas em
matrizes e vetores, de forma elementar, isto √©, operando-se elemento por elemento.
As fun√ß√µes matem√°ticas foram originalmente projetadas para realizar opera√ß√µes matem√°ticas em
quantidades escalares. A maioria dessas fun√ß√µes agora tamb√©m pode ser usada com os novos tipos de
dados ‚Äî com matrizes e vetores ‚Äî MathAbs, MathArccos, MathArcsin, MathArctan, MathCeil,
MathCos, MathExp, MathFloor, MathLog, MathLog10, MathMod, MathPow, MathRound, MathSin,
MathSqrt, MathTan, MathExpm1, MathLog1p, MathArccosh, MathArcsinh, MathArctanh, MathCosh,
MathSinh, MathTanh. Neste caso, a matriz ou vetor √© processado elemento por elemento. Exemplo:
</p>
<pre><code class="language-mql5">
//---
</code></pre>
<p>
  matrix a= {{1, 4}, {9, 16}};
<h3>Print(&quot;matrix a=\n&quot;,a);</h3>
  a=MathSqrt(a);
<h3>Print(&quot;MatrSqrt(a)=\n&quot;,a);</h3>
</p>
<pre><code class="language-mql5">
  /*
   matrix a=
   [[1,4]
    [9,16]]
   MatrSqrt(a)=
   [[1,2]
    [3,4]]
</code></pre>
<p>
  */
No caso de MathMod e MathPow como segundo par√¢metro, pode ser usado um escalar, uma matriz ou
um vetor de tamanho apropriado.
Para ilustrar como calcular o desvio padr√£o usando fun√ß√µes matem√°ticas em um vetor, vamos utilizar
um exemplo.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
 {
//--- utilizamos uma fun√ß√£o de inicializa√ß√£o para preencher o vetor
</code></pre>
<p>
  vector r(10, ArrayRandom); // cs√©rie de n√∫meros aleat√≥rios de 0 a 1
</p>
<pre><code class="language-mql5">
//--- calculamos o valor m√©dio
</code></pre>
<p>
  double avr=r.Mean();       // m√©dia da matriz
  vector d=r-avr;            // calculamos a matriz de desvios em rela√ß√£o ao valor m√©d
<h3>Print(&quot;avr(r)=&quot;, avr);</h3>
<h3>Print(&quot;r=&quot;, r);</h3>
<h3>Print(&quot;d=&quot;, d);</h3>
  vector s2=MathPow(d, 2);   // matriz de quadrados de desvios
  double sum=s2.Sum();       // soma dos quadrados de desvios
</p>
<pre><code class="language-mql5">
//--- calculamos o desvio padr√£o de 2 maneiras
</code></pre>
<p>
  double std=MathSqrt(sum/r.Size());
<h3>Print(&quot; std(r)=&quot;, std);</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1398
<h3>Print(&quot;r.Std()=&quot;, r.Std());</h3>
 }
</p>
<pre><code class="language-mql5">
/*
</code></pre>
<p>
  avr(r)=0.5300302133243813
  r=[0.8346201971495713,0.8031556138798182,0.6696676534318063,0.05386516922513505,0.54
  d=[0.30458998382519,0.2731254005554369,0.1396374401074251,-0.4761650440992462,0.0190
</p>
<pre><code class="language-mql5">
   std(r)=0.2838269732183663
</code></pre>
<p>
  r.Std()=0.2838269732183663
*/
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preenche o vetor com valores aleat√≥rios                           |
//+------------------------------------------------------------------+
void ArrayRandom(vector&amp; v)
 {
</code></pre>
<p>
  for(ulong i=0; i&lt;v.Size(); i++)
</p>
<pre><code class="language-mql5">
    v[i]=double(MathRand())/32767.;
</code></pre>
<p>
 }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1399
<h3>Opera√ß√µes matem√°ticas</h3>
As opera√ß√µes matem√°ticas de adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o podem ser realizadas em
matrizes e vetores, de forma elementar, isto √©, operando-se elemento por elemento.
Ambas as matrizes ou ambos os vetores devem ser do mesmo tipo e ter as mesmas dimens√µes. Cada
membro da matriz opera com o membro correspondente da segunda matriz.
Como segunda soma (multiplicador, subtractor, divisor) tamb√©m pode ser usado um escalar do tipo
apropriado (double, float ou complex). Nesse caso, cada membro da matriz ou vetor operar√° com o
escalar especificado.
  matrix matrix_a={{0.1,0.2,0.3},{0.4,0.5,0.6}};
  matrix matrix_b={{1,2,3},{4,5,6}};
  matrix matrix_c1=matrix_a+matrix_b;
  matrix matrix_c2=matrix_b-matrix_a;
  matrix matrix_c3=matrix_a*matrix_b;   // produto Hadamard (Hadamard product) n√£o dev
  matrix matrix_c4=matrix_b/matrix_a;
  matrix_c1=matrix_a+1;
  matrix_c2=matrix_b-double_value;
  matrix_c3=matrix_a*M_PI;
  matrix_c4=matrix_b/0.1;
</p>
<pre><code class="language-mql5">
//--- opera√ß√µes s√£o localmente poss√≠veis
</code></pre>
<p>
  matrix_a+=matrix_b;
  matrix_a/=2;
As mesmas opera√ß√µes est√£o dispon√≠veis para vetores.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1400
<h3>Fun√ß√µes matem√°ticas</h3>
S√©rie de fun√ß√µes matem√°ticas: MathAbs, MathArccos, MathArcsin, MathArctan, MathCeil, MathCos,
MathExp, MathFloor, MathLog, MathLog10, MathMod, MathPow, MathRound, MathSin, MathSqrt,
MathTan, MathExpm1, MathLog1p, MathArccosh, MathArcsinh, MathArctanh, MathCosh, MathSinh,
MathTanh - –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ –º–∞—Ç—Ä–∏—Ü–∞–º –∏ –≤–µ–∫—Ç–æ—Ä–∞–º. Neste caso, a matriz ou vetor √©
processado elemento por elemento.
No caso de MathMod —É MathPow como segundo par√¢metro, pode ser usado um escalar, uma matriz ou
um vetor de tamanho apropriado.
</p>
<pre><code class="language-mql5">
   matrix&lt;T&gt; mat1(128,128);
   matrix&lt;T&gt; mat3(mat1.Rows(),mat1.Cols());
   ulong     n,size=mat1.Rows()*mat1.Cols();
</code></pre>
<p>
...
</p>
<pre><code class="language-mql5">
   mat2=MathPow(mat1,(T)1.9);
   for(n=0; n&lt;size; n++)
     {
      T res=MathPow(mat1.Flat(n),(T)1.9);
      if(res!=mat2.Flat(n))
         errors++;
     }
   mat2=MathPow(mat1,mat3);
   for(n=0; n&lt;size; n++)
     {
      T res=MathPow(mat1.Flat(n),mat3.Flat(n));
      if(res!=mat2.Flat(n))
         errors++;
     }
</code></pre>
<p>
...
</p>
<pre><code class="language-mql5">
   vector&lt;T&gt; vec1(16384);
   vector&lt;T&gt; vec3(vec1.Size());
   ulong     n,size=vec1.Size();
</code></pre>
<p>
...
</p>
<pre><code class="language-mql5">
   vec2=MathPow(vec1,(T)1.9);
   for(n=0; n&lt;size; n++)
     {
      T res=MathPow(vec1[n],(T)1.9);
      if(res!=vec2[n])
         errors++;
     }
   vec2=MathPow(vec1,vec3);
   for(n=0; n&lt;size; n++)
     {
      T res=MathPow(vec1[n],vec3[n]);
      if(res!=vec2[n])
         errors++;
     }</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1401
<h3>Produtos de matrizes e vetores</h3>
Os c√°lculos de matrizes e vetores incluem:
¬∑ multiplica√ß√£o matricial
¬∑ multiplica√ß√£o vetorial
¬∑ obten√ß√£o da matriz de covari√¢ncia
¬∑ c√°lculo da correla√ß√£o cruzada de dois vetores
¬∑ c√°lculo da convolu√ß√£o de dois vetores
¬∑ c√°lculo do coeficiente de correla√ß√£o  
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>MatMul</h3>
O m√©todo MatMul para deterninar o produto de matrizes e vetores
possui diversas sobrecargas
<h3>GeMM</h3>
Produto matricial geral de duas matrizes (General Matrix Multiply)
<h3>Power</h3>
Eleva uma matriz quadrada √† pot√™ncia inteira especificada
<h3>Dot</h3>
<h3>Produto escalar de dois vetores</h3>
<h3>Kron</h3>
Retorna o produto Kronecker de duas matrizes, uma matriz e um
vetor, um vetor e uma matriz ou dois vetores
<h3>Inner</h3>
<h3>Produto interno de duas matrizes</h3>
<h3>Outer</h3>
Calcula o produto externo de duas matrizes ou dois vetores
<h3>CorrCoef</h3>
Calcula o coeficiente de correla√ß√£o de Pearson (coeficiente de
correla√ß√£o linear)
<h3>Cov</h3>
<h3>Calcula a matriz de covari√¢ncia</h3>
<h3>Correlate</h3>
Calcula os valores da fun√ß√£o de correla√ß√£o cruzada (correla√ß√£o
cruzada) de dois vetores
<h3>Convolve</h3>
Retorna a convolu√ß√£o linear discreta de dois vetores de sequ√™ncia</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1402
<h3>MatMul</h3>
M√©todo MatMul para determinar o produto de matrizes e vetores possui diversas sobrecargas.
Multiplica√ß√£o de uma matriz por uma matriz:  matrix[M][K] * matrix[K][N] = matrix[M][N]
matrix¬† matrix::MatMul(
¬† const matrix&amp;¬† b¬†     //¬†segunda matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Multiplica√ß√£o de um vetor por uma matriz:  horizontal vector[K] * matrix[K][N] =
horizontal vector[N]
vector¬† vector::MatMul(
¬† const matrix&amp;¬† b¬†     //¬†matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Multiplica√ß√£o de uma matriz por um vetor:  matrix[M][K] * vertical vector[K] = vertical
vector[M]
vector¬† matrix::MatMul(
¬† const vector&amp;¬† b¬†     //¬†vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Multiplica√ß√£o escalar de vetores:  horizontal vector * vertical vector = dot value
scalar¬† vector::MatMul(
¬† const vector&amp;¬† b¬†     //¬†segundo vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
b
[in]  Matriz ou vetor.
<h3>Valor retornado</h3>
Matriz, vetor ou escalar, dependendo do m√©todo utilizado.
<h3>Observa√ß√£o</h3>
As matrizes multiplicadas devem ser compat√≠veis, o n√∫mero de colunas da primeira matriz deve ser
igual ao n√∫mero de linhas da segunda matriz. A multiplica√ß√£o de matrizes n√£o √© comutativa, a
multiplica√ß√£o da primeira matriz pela segunda n√£o √© igual √† multiplica√ß√£o da segunda matriz pela
primeira.
O produto matricial consiste em todas as combina√ß√µes poss√≠veis de produtos escalares dos vetores
linha da primeira matriz e dos vetores coluna da segunda matriz.
Com a multiplica√ß√£o escalar, os vetores devem ter o mesmo comprimento.
Ao multiplicar um vetor e uma matriz, o comprimento do vetor deve corresponder exatamente ao
n√∫mero de colunas da matriz.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1403
Algoritmo ing√™nuo de multiplica√ß√£o de matrizes em MQL5:
matrix MatrixProduct(const matrix&amp; matrix_a, const matrix&amp; matrix_b)
</p>
<pre><code class="language-mql5">
  {
   matrix matrix_c;
   if(matrix_a.Cols()!=matrix_b.Rows())
      return(matrix_c);
      
   ulong M=matrix_a.Rows();
   ulong K=matrix_a.Cols();
   ulong N=matrix_b.Cols();
   matrix_c=matrix::Zeros(M,N);
   for(ulong m=0; m&lt;M; m++)
      for(ulong k=0; k&lt;K; k++)
         for(ulong n=0; n&lt;N; n++)
            matrix_c[m][n]+=matrix_a[m][k]*matrix_b[k][n];
   return(matrix_c);
</code></pre>
<p>
  }
<h3>Exemplo de multiplica√ß√£o de matrizes</h3>
</p>
<pre><code class="language-mql5">
   matrix a={{1, 0, 0},
             {0, 1, 0}};
   matrix b={{4, 1},
             {2, 2},
             {1, 3}};
   matrix c1=a.MatMul(b);
   matrix c2=b.MatMul(a);
   Print(&quot;c1 = \n&quot;, c1);
   Print(&quot;c2 = \n&quot;, c2);
/*
   c1 = 
   [[4,1]
    [2,2]]
   c2 = 
   [[4,1,0]
    [2,2,0]
    [1,3,0]]
</code></pre>
<p>
*/
Exemplo de multiplica√ß√£o de um vetor horizontal por uma matriz</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1404
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- criamos uma matriz 3x5
   matrix m35;
   m35.Init(3, 5, Arange);
//---
   vector v3 = {1, 2, 3};
   Print(&quot;Produto do vetor horizontal v pela matriz m[3,5]&quot;);
   Print(&quot;Vetor √† esquerda v3 = &quot;, v3);
   Print(&quot;Matriz √† direita m35 = \n&quot;, m35);
   Print(&quot;v3.MatMul(m35) = vetor horizontal v[5] \n&quot;, v3.MatMul(m35));
¬† /* Resultado
    Produto do vetor horizontal v3 pela matriz m[3,5]
    Vetor √† esquerda v3 = [1,2,3]
    Matriz √† direita m35 =
    [[0,1,2,3,4]
     [5,6,7,8,9]
     [10,11,12,13,14]]
    v3.MatMul(m35) = vetor horizontal v[5]
    [40,46,52,58,64]
   */
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Preenchimento da matriz com valores incrementais                |
//+------------------------------------------------------------------+
void Arange(matrix &amp; m, double start = 0, double step = 1)
  {
//---
   ulong cols = m.Cols();
   ulong rows = m.Rows();
   double value = start;
   for(ulong r = 0; r &lt; rows; r++)
     {
      for(ulong c = 0; c &lt; cols; c++)
        {
         m[r][c] = value;
         value += step;
        }
     }
//---
</code></pre>
<p>
  }
Exemplo de multiplica√ß√£o de uma matriz por um vetor vertical</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1405
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- criamos uma matriz 3x5
   matrix m35;
   m35.Init(3, 5, Arange);
//---
   Print(&quot;Produto da matriz m[3,5] pelo vetor vertical v[5]&quot;);
   vector v5 = {1,2,3,4,5};
   Print(&quot;√Ä esquerda m35 = \n&quot;,m35);
   Print(&quot;√Ä direita v5 = &quot;,v5);
   Print(&quot;m35.MatMul(v5) = vetor vertical v[3] \n&quot;,m35.MatMul(v5));
¬† /* Resultado
   Produto da matriz m[3,5] pelo vetor vertical v[5]
   √Ä esquerda m35 = 
   [[0,1,2,3,4]
    [5,6,7,8,9]
    [10,11,12,13,14]]
   √Ä direita v5 = [1,2,3,4,5]
   m35.MatMul(v5) = vetor vertical v[3] 
   [40,115,190]
   */
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Preenchimento da matriz com valores incrementais                |
//+------------------------------------------------------------------+
void Arange(matrix &amp; m, double start = 0, double step = 1)
  {
//---
   ulong cols = m.Cols();
   ulong rows = m.Rows();
   double value = start;
   for(ulong r = 0; r &lt; rows; r++)
     {
      for(ulong c = 0; c &lt; cols; c++)
        {
         m[r][c] = value;
         value += step;
        }
     }
//---
</code></pre>
<p>
  }
<h3>Exemplo de multiplica√ß√£o escalar de vetores</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1406
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- multiplica√ß√£o escalar de vetores horizontais e verticais
   vector a= {1, 2, 3};  // vetor horizontal
   vector b= {4, 5, 6};  // vetor vertical
   Print(&quot;a = &quot;, a);
   Print(&quot;b = &quot;, b);
   Print(&quot;1) a.MatMul(b) = &quot;, a.MatMul(b));
   //--- mostramos que o m√©todo Dot d√° o mesmo resultado
   Print(&quot;2) a.Dot(b) = &quot;, a.Dot(b));
¬† /* Resultado
   a = [1,2,3]
   b = [4,5,6]
   1) a.MatMul(b) = 32.0
   2) a.Dot(b) = 32.0
    */
</code></pre>
<p>
  }
<h3>Ver tamb√©m</h3>
<h3>Dot, GeMM</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1407
<h3>GeMM</h3>
O m√©todo GeMM determina o produto matricial total de duas matrizes (General Matrix Multiply). Em
termos gerais, a express√£o √© escrita como C ‚Üê Œ± A B + Œ≤ C , onde as matrizes A e B podem ser
opcionalmente transpostas. Ao realizar a multiplica√ß√£o convencional de matrizes AB (MatMul), √©
assumido que o coeficiente alpha √© igual a um e o beta √© igual a zero.
A principal diferen√ßa entre GeMM e MatMul em termos de efici√™ncia √© que MatMul sempre cria um
novo objeto matriz/vetor, enquanto GeMM trabalha com um objeto matriz j√° existente que n√£o √©
recriado. Dessa forma, se a mem√≥ria para a matriz correspondente for alocada com anteced√™ncia ao
usar o m√©todo GeMM e as mesmas dimens√µes de matriz forem usadas posteriormente, n√£o haver√°
realoca√ß√£o de mem√≥ria. Isso pode ser uma vantagem muito importante para o m√©todo GeMM em
computa√ß√µes em massa, como na otimiza√ß√£o em um testador de estrat√©gia ou no treinamento de uma
rede neural.
GeMM tamb√©m possui 4 sobrecargas, assim como o m√©todo MatMul. Mas, nesse caso, a sem√¢ntica da
quarta sobrecarga foi alterada para permitir a multiplica√ß√£o de vetores verticais e horizontais.
Em um objeto de matriz/vetor existente, n√£o √© necess√°rio alocar mem√≥ria para dados com
anteced√™ncia. Na primeira vez que o GeMM for chamado, a mem√≥ria ser√° alocada e preenchida com
zeros.
Multiplica√ß√£o de uma matriz por uma matriz:    matrix C[M][N] = Œ± * ( matrix A[M][K] *
matrix B[K][N]) + Œ≤ *  matrix C[M][N]
</p>
<pre><code class="language-mql5">
bool¬† matrix::GeMM(
</code></pre>
<p>
¬† const matrix &amp;A,¬†   //¬†primeira matriz
¬† const matrix &amp;B,¬†   //¬†segunda matriz
  double¬†alpha,¬†      //¬†multiplicador alfa para o produto das matrizes AB
  double¬†beta,        //¬†multiplicador beta para a matriz C
  uint¬†  flags        //¬†combina√ß√£o de valores de enumera√ß√£o ENUM_GEMM (bits &quot;ou&quot;), qu
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Multiplica√ß√£o de um vetor por uma matriz:  vector C[N] = Œ± * ( vector A[K] * matrix B[K][N])
+ Œ≤ *  vector C[N]
</p>
<pre><code class="language-mql5">
bool¬† vector::GeMM(
</code></pre>
<p>
¬† const vector &amp;A,¬†   //¬†vetor horizontal 
¬† const matrix &amp;B,¬†   //¬†matriz
  double¬†alpha,¬†      //¬†multiplicador alfa para o produto AB
  double¬†beta,        //¬†multiplicador beta para o vetor C
  uint¬†  flags        //¬†valor da enumera√ß√£o ENUM_GEMM que determina a transposi√ß√£o da
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Multiplica√ß√£o de uma matriz por um vetor:  vector C[M] = Œ± * (  matrix A[M][K] * vector B[K]
* ) + Œ≤ *  vector C[M]
</p>
<pre><code class="language-mql5">
bool¬† vector::GeMM(
</code></pre>
<p>
¬† const matrix &amp;A,¬†   //¬†matriz
¬† const vector &amp;B,¬†   //¬†vetor vertical
  double¬†alpha,¬†      //¬†multiplicador alfa para o produto AB
  double¬†beta,        //¬†multiplicador beta para o vetor C</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1408
  uint¬†  flags        //¬†valor da enumera√ß√£o ENUM_GEMM que determina a transposi√ß√£o de
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Multiplica√ß√£o de um vetor por um vetor:  matrix C[M][N] = Œ± * (  vector A[M] * vector B[N]
* ) + Œ≤ *  matrix C[M][N]. Esta sobrecarga retorna uma matriz, ao contr√°rio do m√©todo MatMul,
que retorna um escalar.
</p>
<pre><code class="language-mql5">
bool¬† matrix::GeMM(
</code></pre>
<p>
¬† const vector &amp;A,¬†   //¬†primeiro vetor
¬† const vector &amp;B,¬†   //¬†segundo vetor
  double¬†alpha,¬†      //¬†multiplicador alfa para o produto AB
  double¬†beta,        //¬†multiplicador beta para a matriz C
  uint¬†  flags        //¬†valor da enumera√ß√£o ENUM_GEMM que determina a transposi√ß√£o da
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
<h3>A</h3>
[in]  Matriz ou vetor.
<h3>B</h3>
[in]  Matriz ou vetor.
alpha
[in]  Multiplicador alfa para o produto AB.
beta
[in]  Multiplicador Beta para a matriz resultante C.
flags
[in]  Valor da enumera√ß√£o ENUM_GEMM que determina a transposi√ß√£o das matrizes A, B e C.
<h3>Valor retornado</h3>
true se a opera√ß√£o for bem sucedida, caso contr√°rio false. 
<h3>ENUM_GEMM</h3>
Enumera√ß√£o de sinalizadores para o m√©todo GeMM.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>TRANSP_A</h3>
<h3>Uso da matriz transposta A</h3>
<h3>TRANSP_B</h3>
<h3>Uso da matriz transposta B</h3>
<h3>TRANSP_C</h3>
<h3>Uso da matriz transposta C</h3>
<h3>Observa√ß√£o</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1409
Matrizes e vetores do tipo float, double e complex podem ser usados como par√¢metros A e B. Assim,
as variantes de modelo do m√©todo GeMM t√™m este aspecto:
</p>
<pre><code class="language-mql5">
bool matrix&lt;T&gt;::GeMM(const matrix&lt;T&gt; &amp;A,const matrix&lt;T&gt; &amp;B,T alpha,T beta,ulong flags)
bool matrix&lt;T&gt;::GeMM(const vector&lt;T&gt; &amp;A,const vector&lt;T&gt; &amp;B,T alpha,T beta,ulong flags)
bool vector&lt;T&gt;::GeMM(const vector&lt;T&gt; &amp;A,const matrix&lt;T&gt; &amp;B,T alpha,T beta,ulong flags)
bool vector&lt;T&gt;::GeMM(const matrix&lt;T&gt; &amp;A,const vector&lt;T&gt; &amp;B,T alpha,T beta,ulong flags)
</code></pre>
<p>
Em geral, uma fun√ß√£o de multiplica√ß√£o geral da matriz √© descrita como:
<h3>C[m,n] = Œ± *Sum(A[m,k]*B[k,n]) + Œ≤*C[m,n]</h3>
onde a matriz A √© do tamanho M x K, a matriz B √© K x N, e a matriz C √© M x N.
Assim, as matrizes multiplicadas devem ser compat√≠veis, o n√∫mero de colunas da primeira matriz
deve ser igual ao n√∫mero de linhas da segunda matriz. A multiplica√ß√£o de matrizes n√£o √© comutativa,
a multiplica√ß√£o da primeira matriz pela segunda n√£o √© igual √† multiplica√ß√£o da segunda matriz pela
primeira.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   vector vector_a= {1, 2, 3, 4, 5};
   vector vector_b= {4, 3, 2, 1};
   matrix matrix_c;
//--- calculamos GeMM para dois vetores
   matrix_c.GeMM(vector_a, vector_b, 1, 0);
   Print(&quot;matrix_c:\n &quot;, matrix_c, &quot;\n&quot;);
   /*
   matrix_c:
    [[4,3,2,1]
    [8,6,4,2]
    [12,9,6,3]
    [16,12,8,4]
    [20,15,10,5]]
   */
//--- criamos matrizes sob a forma de vetores
   matrix matrix_a(5, 1);
   matrix matrix_b(1, 4);
   matrix_a.Col(vector_a, 0);
   matrix_b.Row(vector_b, 0);
   Print(&quot;matrix_a:\n &quot;, matrix_a);
   Print(&quot;matrix_b:\n &quot;, matrix_b);
   /*
   matrix_a:</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1410
</p>
<pre><code class="language-mql5">
   [[1]
   [2]
   [3]
   [4]
   [5]]
   matrix_b:
   [[4,3,2,1]]
   */
//-- calculamos GeMM para as duas matrizes e obtemos o mesmo resultado
   matrix_c.GeMM(matrix_a, matrix_b, 1, 0);
   Print(&quot;matrix_c:\n &quot;, matrix_c);
   /*
   matrix_c:
    [[4,3,2,1]
    [8,6,4,2]
    [12,9,6,3]
    [16,12,8,4]
    [20,15,10,5]]
   */
</code></pre>
<p>
  }
<h3>Ver tamb√©m</h3>
<h3>MatMul</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1411
<h3>Power</h3>
Eleva uma matriz quadrada √† pot√™ncia inteira especificada.
matrix¬†matrix::Power(
¬† const int¬† power¬†     //¬†pot√™ncia
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
power
[in]  O expoente pode ser qualquer n√∫mero inteiro: positivo, negativo ou zero.
<h3>Valor retornado</h3>
Matriz.
<h3>Observa√ß√£o</h3>
A matriz resultante tem o mesmo tamanho da matriz original. Ao elevar uma matriz a pot√™ncia 0, o
resultado √© a matriz identidade. Uma pot√™ncia positiva n de uma matriz pressup√µe que a matriz
original √© multiplicada por si mesma n vezes. Uma pot√™ncia negativa -n implica que a matriz original
√© primeiro invertida e, em seguida, a matriz invertida √© multiplicada por si mesma n vezes.
Algoritmo simples para elevar uma matriz a uma pot√™ncia em MQL5:
</p>
<pre><code class="language-mql5">
bool MatrixPower(matrix&amp; c, const matrix&amp; a, const int power)
  {
//--- a matriz deve ser quadr√°tica
   if(a.Rows()!=a.Cols())
      return(false);
//--- o tamanho da matriz resultante √© exatamente o mesmo
   ulong  rows=a.Rows();
   ulong  cols=a.Cols();
   matrix result(rows,cols);
//--- ao ser elevada a zero, retorna a matriz identidade
   if(power==0)
      result.Identity();
   else
     {
      //--- se elevada a uma pot√™ncia negativa, √© necess√°rio primeiro inverter a matri
      if(power&lt;0)
        {
         matrix inverted=a.Inv();
         result=inverted;
         for(int i=-1; i&gt;power; i--)
            result=result.MatMul(inverted);
        }</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1412
</p>
<pre><code class="language-mql5">
      else
        {
         result=a;
         for(int i=1; i&lt;power; i++)
            result=result.MatMul(a);
        }
     }
//---
   c=result;
   return(true);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
  matrix i= {{0, 1}, {-1, 0}};
<h3>Print(&quot;i:\n&quot;, i);</h3>
<h3>Print(&quot;i.Power(3):\n&quot;, i.Power(3));</h3>
<h3>Print(&quot;i.Power(0):\n&quot;, i.Power(0));</h3>
<h3>Print(&quot;i.Power(-3):\n&quot;, i.Power(-3));</h3>
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  i:
  [[0,1]
</p>
<pre><code class="language-mql5">
   [-1,0]]
</code></pre>
<p>
  i.Power(3):
  [[0,-1]
</p>
<pre><code class="language-mql5">
   [1,0]]
</code></pre>
<p>
  i.Power(0):
  [[1,0]
</p>
<pre><code class="language-mql5">
   [0,1]]
</code></pre>
<p>
  i.Power(-3):
  [[0, -1]
</p>
<pre><code class="language-mql5">
   [1,0]]
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
import numpy as np
from numpy.linalg import matrix_power
# matrix equiv. of the imaginary unit</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1413
i = np.array([[0, 1], [-1, 0]]) 
print(&quot;i:\n&quot;,i)
# should = -i
print(&quot;matrix_power(i, 3) :\n&quot;,matrix_power(i, 3) )
print(&quot;matrix_power(i, 0):\n&quot;,matrix_power(i, 0))
# should = 1/(-i) = i, but w/ f.p. elements
print(&quot;matrix_power(i, -3):\n&quot;,matrix_power(i, -3))
 
i:
 [[ 0  1]
 [-1  0]]
matrix_power(i, 3) :
 [[ 0 -1]
 [ 1  0]]
matrix_power(i, 0):
 [[1 0]
 [0 1]]
matrix_power(i, -3):
 [[ 0.  1.]
 [-1.  0.]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1414
<h3>Dot</h3>
Produto escalar de dois vetores.
</p>
<pre><code class="language-mql5">
double vector::Dot(
</code></pre>
<p>
¬† const vector&amp;¬† b¬†     //¬†segundo vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
b
[in]  Vetor.
<h3>Valor retornado</h3>
Escalar.
<h3>Observa√ß√£o</h3>
O produto Dot para duas matrizes nada mais √© do que o produto matricial matrix::MatMul().
Algoritmo simples para o produto escalar de vetores em MQL5:
</p>
<pre><code class="language-mql5">
double VectorDot(const vector&amp; vector_a, const vector&amp; vector_b)
  {
   double dot=0;
   if(vector_a.Size()==vector_b.Size())
     {
      for(ulong i=0; i&lt;vector_a.Size(); i++)
         dot+=vector_a[i]*vector_b[i];
     }
   return(dot);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   for(ulong i=0; i&lt;rows; i++)
     {
      vector v1=a.Row(i);
      for(ulong j=0; j&lt;cols; j++)
        {
         vector v2=b.Row(j);
         result[i][j]=v1.Dot(v2);
        }
     }</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1415
<h3>Exemplo em Python:</h3>
import numpy as np
a = [1, 0, 0, 1]
b = [4, 1, 2, 2]
print(np.dot(a, b))
&gt;&gt;&gt; 6</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1416
<h3>Kron</h3>
Retorna o produto Kronecker de duas matrizes, uma matriz e um vetor, um vetor e uma matriz ou dois
vetores.
matrix¬†matrix::Kron(
¬† const matrix&amp;¬† b¬†     //¬†segunda matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix¬†matrix::Kron(
¬† const vector&amp;¬† b¬†     //¬†vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix¬†vector::Kron(
¬† const matrix&amp;¬† b¬†     //¬†matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix¬†vector::Kron(
¬† const vector&amp;¬† b¬†     //¬†segundo vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
b
[in]  Segunda matriz.
<h3>Valor retornado</h3>
Matriz.
<h3>Observa√ß√£o</h3>
O produto Kronecker tamb√©m √© chamado de multiplica√ß√£o de tensor.
Algoritmo simples do produto Kronecker para duas matrizes em MQL5:
matrix MatrixKronecker(const matrix&amp; matrix_a,const matrix&amp; matrix_b)
</p>
<pre><code class="language-mql5">
  {
   ulong  M=matrix_a.Rows();
   ulong  N=matrix_a.Cols();
   ulong  P=matrix_b.Rows();
   ulong  Q=matrix_b.Cols();
   matrix matrix_c(M*P,N*Q);
   for(ulong m=0; m&lt;M; m++)
      for(ulong n=0; n&lt;N; n++)
         for(ulong p=0; p&lt;P; p++)</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1417
</p>
<pre><code class="language-mql5">
            for(ulong q=0; q&lt;Q; q++)
               matrix_c[m*P+p][n*Q+q]=matrix_a[m][n] * matrix_b[p][q];
   return(matrix_c);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   matrix a={{1,2,3},{4,5,6}};
   matrix b=matrix::Identity(2,2);
   vector v={1,2};
   Print(a.Kron(b));
   Print(a.Kron(v));
  /*
   [[1,0,2,0,3,0]
    [0,1,0,2,0,3]
    [4,0,5,0,6,0]
    [0,4,0,5,0,6]]
   [[1,2,2,4,3,6]
    [4,8,5,10,6,12]]
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
import numpy as np
<h3>A = np.arange(1,7).reshape(2,3)</h3>
<h3>B = np.identity(2)</h3>
<h3>V = [1,2]</h3>
print(np.kron(A, B))
print(&quot;&quot;)
print(np.kron(A, V))
[[1. 0. 2. 0. 3. 0.]
 [0. 1. 0. 2. 0. 3.]
 [4. 0. 5. 0. 6. 0.]
 [0. 4. 0. 5. 0. 6.]]
[[ 1  2  2  4  3  6]
 [ 4  8  5 10  6 12]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1418
<h3>Inner</h3>
Produto interno de duas matrizes.
matrix¬†matrix::Inner(
¬† const matrix&amp;¬† b¬†     //¬†segunda matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
b
[in]  Matriz.
<h3>Valor retornado</h3>
Matriz.
<h3>Observa√ß√£o</h3>
O produto interno de dois vetores nada mais √© do que o produto escalar dos dois vetores
vector::Dot().
Algoritmo simples do produto interno de duas matrizes em MQL5:
</p>
<pre><code class="language-mql5">
bool MatrixInner(matrix&amp; c, const matrix&amp; a, const matrix&amp; b)
  {
//--- o n√∫mero de colunas deve ser o mesmo
   if(a.Cols()!=b.Cols())
      return(false);
//--- o tamanho da matriz resultante depende do n√∫mero de vetores em cada uma das matr
   ulong  rows=a.Rows();
   ulong  cols=b.Rows();
   matrix result(rows,cols);
//---
   for(ulong i=0; i&lt;rows; i++)
     {
      vector v1=a.Row(i);
      for(ulong j=0; j&lt;cols; j++)
        {
         vector v2=b.Row(j);
         result[i][j]=v1.Dot(v2);
        }
     }
//---
   c=result;
   return(true);
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1419
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   matrix a={{0,1,2},{3,4,5}};
   matrix b={{0,1,2},{3,4,5},{6,7,8}};
   matrix c=a.Inner(b);
   Print(c);
   matrix a1={{0,1,2}};
   matrix c1=a1.Inner(b);
   Print(c1);
  /*
</code></pre>
<p>
  [[5,14,23]
  [14,50,86]]
  [[5,14,23]]
  */
<h3>Exemplo em Python:</h3>
import numpy as np
<h3>A = np.arange(6).reshape(2, 3)</h3>
<h3>B = np.arange(9).reshape(3, 3)</h3>
<h3>A1= np.arange(3)</h3>
print(np.inner(A, B))
print(&quot;&quot;);
print(np.inner(A1, B))
import numpy as np
<h3>A = np.arange(6).reshape(2, 3)</h3>
<h3>B = np.arange(9).reshape(3, 3)</h3>
<h3>A1= np.arange(3)</h3>
print(np.inner(A, B))
print(&quot;&quot;);
print(np.inner(A1, B))</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1420
<h3>Outer</h3>
Calcula o produto externo de duas matrizes ou dois vetores.
matrix¬†matrix::Outer(
¬† const matrix&amp;¬† b¬†     //¬†segunda matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix¬†vector::Outer(
¬† const vector&amp;¬† b¬†     //¬†segundo vetor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
b
[in]  Matriz.
<h3>Valor retornado</h3>
Matriz.
<h3>Observa√ß√£o</h3>
O produto externo, como o produto Kronecker, tamb√©m √© uma multiplica√ß√£o em bloco de matrizes (e
vetores).
Algoritmo simples para o produto externo de duas matrizes em MQL5:
matrix MatrixOuter(const matrix&amp; matrix_a, const matrix&amp; matrix_b)
</p>
<pre><code class="language-mql5">
  {
//--- tamanho da matriz de resultados depende do tamanho das matrizes
   ulong  rows=matrix_a.Rows()*matrix_a.Cols();
   ulong  cols=matrix_b.Rows()*matrix_b.Cols();
   matrix matrix_c(rows,cols);
   ulong  cols_a=matrix_a.Cols();
   ulong  cols_b=matrix_b.Cols();
//---
   for(ulong i=0; i&lt;rows; i++)
     {
      ulong row_a=i/cols_a;
      ulong col_a=i%cols_a;
      for(ulong j=0; j&lt;cols; j++)
        {
         ulong row_b=j/cols_b;
         ulong col_b=j%cols_b;
         matrix_c[i][j]=matrix_a[row_a][col_a] * matrix_b[row_b][col_b];
        }</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1421
</p>
<pre><code class="language-mql5">
     }
//---
   return(matrix_c);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   vector vector_a={0,1,2,3,4,5};
   vector vector_b={0,1,2,3,4,5,6};
   Print(&quot;vector_a.Outer\n&quot;,vector_a.Outer(vector_b));
   Print(&quot;vector_a.Kron\n&quot;,vector_a.Kron(vector_b));
   matrix matrix_a={{0,1,2},{3,4,5}};
   matrix matrix_b={{0,1,2},{3,4,5},{6,7,8}};
   Print(&quot;matrix_a.Outer\n&quot;,matrix_a.Outer(matrix_b));
   Print(&quot;matrix_a.Kron\n&quot;,matrix_a.Kron(matrix_b));
  /*
   vector_a.Outer
   [[0,0,0,0,0,0,0]
    [0,1,2,3,4,5,6]
    [0,2,4,6,8,10,12]
    [0,3,6,9,12,15,18]
    [0,4,8,12,16,20,24]
    [0,5,10,15,20,25,30]]
   vector_a.Kron
   [[0,0,0,0,0,0,0,0,1,2,3,4,5,6,0,2,4,6,8,10,12,0,3,6,9,12,15,18,0,4,8,12,16,20,24,0,
   matrix_a.Outer
   [[0,0,0,0,0,0,0,0,0]
    [0,1,2,3,4,5,6,7,8]
    [0,2,4,6,8,10,12,14,16]
    [0,3,6,9,12,15,18,21,24]
    [0,4,8,12,16,20,24,28,32]
    [0,5,10,15,20,25,30,35,40]]
   matrix_a.Kron
   [[0,0,0,0,1,2,0,2,4]
    [0,0,0,3,4,5,6,8,10]
    [0,0,0,6,7,8,12,14,16]
    [0,3,6,0,4,8,0,5,10]
    [9,12,15,12,16,20,15,20,25]
    [18,21,24,24,28,32,30,35,40]]
   */
</code></pre>
<p>
<h3>Exemplo em Python:</h3>
import numpy as np</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1422
<h3>A = np.arange(6)</h3>
<h3>B = np.arange(7)</h3>
print(&quot;np.outer&quot;)
print(np.outer(A, B))
print(&quot;np.kron&quot;)
print(np.kron(A, B))
<h3>A = np.arange(6).reshape(2, 3)</h3>
<h3>B = np.arange(9).reshape(3, 3)</h3>
print(&quot;np.outer&quot;)
print(np.outer(A, B))
print(&quot;np.kron&quot;)
np.outer
[[ 0  0  0  0  0  0  0]
 [ 0  1  2  3  4  5  6]
 [ 0  2  4  6  8 10 12]
 [ 0  3  6  9 12 15 18]
 [ 0  4  8 12 16 20 24]
 [ 0  5 10 15 20 25 30]]
np.kron
[ 0  0  0  0  0  0  0  0  1  2  3  4  5  6  0  2  4  6  8 10 12  0  3  6
  9 12 15 18  0  4  8 12 16 20 24  0  5 10 15 20 25 30]
np.outer
[[ 0  0  0  0  0  0  0  0  0]
 [ 0  1  2  3  4  5  6  7  8]
 [ 0  2  4  6  8 10 12 14 16]
 [ 0  3  6  9 12 15 18 21 24]
 [ 0  4  8 12 16 20 24 28 32]
 [ 0  5 10 15 20 25 30 35 40]]
np.kron
[[ 0  0  0  0  1  2  0  2  4]
 [ 0  0  0  3  4  5  6  8 10]
 [ 0  0  0  6  7  8 12 14 16]
 [ 0  3  6  0  4  8  0  5 10]
 [ 9 12 15 12 16 20 15 20 25]
 [18 21 24 24 28 32 30 35 40]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1423
<h3>CorrCoef</h3>
Calcula o coeficiente de correla√ß√£o de Pearson (coeficiente de correla√ß√£o linear).
matrix matrix::CorrCoef(
¬† const bool¬†   rowvar=true  //¬†os vetores de observa√ß√£o est√£o dispostos em filas, cas
);
scalar vector::CorrCoef(
¬† const vector&amp;¬† b¬†          //¬†segundo vetor
);
<h3>Par√¢metros</h3>
<h3>Par√¢metros</h3>
rowvar
[in]  Sinalizador que determina a posi√ß√£o dos vetores na matriz para o c√°lculo da correla√ß√£o dos
pares - horizontal ou verticalmente. Por padr√£o rowvar √© igual a true, significando que os vetores
est√£o nas filas da matriz. Se rowvar for igual a false, ent√£o as correla√ß√µes s√£o contadas entre as
colunas da matriz. 
b
[in]  Segundo vetor.
<h3>Valor retornado</h3>
Valor dos coeficientes de correla√ß√£o para o vetor.
Matriz quadrada de valores de coeficientes de correla√ß√£o entre os vetores da matriz para a matriz.
O tamanho da matriz corresponde ao n√∫mero de vetores na matriz, que podem ser dispostos ao
longo das linhas (rowvar=true) ou por colunas ((rowvar=false).
<h3>Observa√ß√£o</h3>
O coeficiente de correla√ß√£o est√° no intervalo [-1, 1].
Devido ao arredondamento de ponto flutuante, a matriz resultante pode n√£o ser hermitiana, os
elementos diagonais podem n√£o ser iguais a 1, e os elementos podem n√£o satisfazer a desigualdade
abs(a) &lt;= 1. As partes reais e imagin√°rias s√£o truncadas ao intervalo [-1, 1] para corrigir isto, mas
isto nem sempre ajuda em casos complexos.
Algoritmo simples para calcular o coeficiente de correla√ß√£o de dois vetores em MQL5:
</p>
<pre><code class="language-mql5">
double VectorCorrelation(const vector&amp; vector_x,const vector&amp; vector_y)
  {
   ulong n=vector_x.Size()&lt;vector_y.Size() ? vector_x.Size() : vector_y.Size();
   if(n&lt;=1)
      return(0);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1424
</p>
<pre><code class="language-mql5">
   ulong  i;
   double xmean=0;
   double ymean=0;
   for(i=0; i&lt;n; i++)
     {
      if(!MathIsValidNumber(vector_x[i]))
         return(0);
      if(!MathIsValidNumber(vector_y[i]))
         return(0);
      xmean+=vector_x[i];
      ymean+=vector_y[i];
     }
   xmean/=(double)n;
   ymean/=(double)n;
   double s=0;
   double xv=0;
   double yv=0;
   double t1=0;
   double t2=0;
//--- c√°lculo
   s=0;
   for(i=0; i&lt;n; i++)
     {
      t1=vector_x[i]-xmean;
      t2=vector_y[i]-ymean;
      xv+=t1*t1;
      yv+=t2*t2;
      s+=t1*t2;
     }
//--- verifica√ß√£o
   if(xv==0 || yv==0)
      return(0);
//--- retornamos o resultado
   return(s/(MathSqrt(xv)*MathSqrt(yv)));
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   vectorf vector_a={1,2,3,4,5};
   vectorf vector_b={0,1,0.5,2,2.5};
   Print(&quot;vectors correlation &quot;,vector_a.CorrCoef(vector_b));
//---
   matrixf matrix_a={{1,2,3,4,5},
                    {0,1,0.5,2,2.5}};
   Print(&quot;matrix rows correlation\n&quot;,matrix_a.CorrCoef());
   matrixf matrix_a2=matrix_a.Transpose();</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1425
</p>
<pre><code class="language-mql5">
   Print(&quot;transposed matrix cols correlation\n&quot;,matrix_a2.CorrCoef(false));
   matrixf matrix_a3={{1.0f, 2.0f, 3.0f, 4.0f, 5.0f},
                      {0.0f, 1.0f, 0.5f, 2.0f, 2.5f},
                      {0.1f, 1.0f, 2.0f, 1.0f, 0.3f}};
   Print(&quot;rows correlation\n&quot;,matrix_a3.CorrCoef());
   Print(&quot;cols correlation\n&quot;,matrix_a3.CorrCoef(false));
  /*
   vectors correlation 0.9149913787841797
   matrix rows correlation
   [[1,0.91499138]
    [0.91499138,1]]
   transposed matrix cols correlation
   [[1,0.91499138]
    [0.91499138,1]]
   rows correlation
   [[1,0.91499138,0.08474271]
    [0.91499138,1,-0.17123166]
    [0.08474271,-0.17123166,1]]
   cols correlation
   [[1,0.99587059,0.85375023,0.91129309,0.83773589]
    [0.99587059,1,0.80295509,0.94491106,0.88385159]
    [0.85375023,0.80295509,1,0.56362146,0.43088508]
    [0.91129309,0.94491106,0.56362146,1,0.98827404]
    [0.83773589,0.88385159,0.43088508,0.98827404,1]]
   */
</code></pre>
<p>
<h3>Exemplo em Python:</h3>
import numpy as np
va=[1,2,3,4,5]
vb=[0,1,0.5,2,2.5]
print(&quot;vectors correlation&quot;)
print(np.corrcoef(va,vb))
ma=np.zeros((2,5))
ma[0,:]=va
ma[1,:]=vb
print(&quot;matrix rows correlation&quot;)
print(np.corrcoef(ma))
print(&quot;transposed matrix cols correlation&quot;)
print(np.corrcoef(np.transpose(ma),rowvar=False))
print(&quot;&quot;)
ma1=[[1,2,3,4,5],[0,1,0.5,2,2.5],[0.1,1,0.2,1,0.3]]
print(&quot;rows correlation\n&quot;,np.corrcoef(ma1))
print(&quot;cols correlation\n&quot;,np.corrcoef(ma1,rowvar=False))</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1426
transposed matrix cols correlation
[[1.         0.91499142]
 [0.91499142 1.        ]]
rows correlation
 [[1.         0.91499142 0.1424941 ]
 [0.91499142 1.         0.39657517]
 [0.1424941  0.39657517 1.        ]]
cols correlation
 [[1.         0.99587059 0.98226063 0.91129318 0.83773586]
 [0.99587059 1.         0.99522839 0.94491118 0.88385151]
 [0.98226063 0.99522839 1.         0.97234063 0.92527551]
 [0.91129318 0.94491118 0.97234063 1.         0.98827406]
 [0.83773586 0.88385151 0.92527551 0.98827406 1.        ]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1427
<h3>Cov</h3>
Calcula a matriz de covari√¢ncia.
matrix matrix::Cov(
¬† const bool¬†   rowvar=true  // linhas ou colunas dos vetores de observa√ß√µes
);
matrix matrix::Cov(
¬† const bool¬†   rowvar,      // linhas ou colunas dos vetores de observa√ß√µes
  const int¬†    ddof         // ajuste do grau de liberdade
);
matrix vector::Cov(
¬† const vector&amp;¬† b¬†          // segundo vetor
);
matrix vector::Cov(
¬† const vector&amp;¬† b,¬†          // segundo vetor
  const int¬†     ddof         // ajuste do grau de liberdade
);
<h3>Par√¢metros</h3>
rowwar
[in] Se o valor rowwar for true (padr√£o), ent√£o cada linha representa uma vari√°vel e as
observa√ß√µes est√£o nas colunas. Caso contr√°rio (se for false), as linhas cont√™m as observa√ß√µes e as
colunas representam as vari√°veis (ou seja, a matriz √© transposta).
b
[in] Segundo vetor.
ddof
[in] ‚ÄúDelta Degrees of Freedom‚Äù: par√¢metro que define quanto o n√∫mero de graus de liberdade
ser√° reduzido. O divisor na f√≥rmula ser√° N - ddof, onde N √© o n√∫mero de observa√ß√µes. Por padr√£o,
ddof = 1.
<h3>Observa√ß√£o</h3>
Calcula a matriz de covari√¢ncia.
Algoritmo simples para calcular a matriz de covari√¢ncia de dois vetores em MQL5:
</p>
<pre><code class="language-mql5">
bool VectorCovariation(const vector&amp; vector_a,const vector&amp; vector_b,matrix&amp; matrix_c)
  {
   int i,j;
   int m=2;
   int n=(int)(vector_a.Size()&lt;vector_b.Size()?vector_a.Size():vector_b.Size());
//--- verifica√ß√µes
   if(n&lt;=1)</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1428
</p>
<pre><code class="language-mql5">
      return(false);
   for(i=0; i&lt;n; i++)
     {
      if(!MathIsValidNumber(vector_a[i]))
         return(false);
      if(!MathIsValidNumber(vector_b[i]))
         return(false);
     }
//---
   matrix matrix_x(2,n);
   matrix_x.Row(vector_a,0);
   matrix_x.Row(vector_b,1);
   vector t=vector::Zeros(m);
//--- c√°lculo
   for(i=0; i&lt;m; i++)
      for(j=0; j&lt;n; j++)
         t[i]+=matrix_x[i][j]/double(n);
   for(i=0; i&lt;m; i++)
      for(j=0; j&lt;n; j++)
         matrix_x[i][j]-=t[i];
//--- syrk C=alpha*A^H*A+beta*C (beta=0 and not considered)
   matrix_c=matrix::Zeros(m,m);
   for(i=0; i&lt;m; i++)
     {
      for(j=0; j&lt;n; j++)
        {
         double v=matrix_x[i][j]/(n-1);
         for(int i_=i; i_&lt;m; i_++)
            matrix_c[i][i_]+=v*matrix_x[i_][j];
        }
     }
//--- force symmetricity
   for(i=0; i&lt;m-1; i++)
      for(j=i+1; j&lt;m; j++)
         matrix_c[j][i]=matrix_c[i][j];
//---
   return(true);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{3,-2.1},{1.1,-1},{0.12,4.3}};
   Print(&quot;covariation cols\n&quot;,matrix_a.Cov(false));
   Print(&quot;covariation rows\n&quot;,matrix_a.Cov());
   
   vector vector_a=matrix_a.Col(0);
   vector vector_b=matrix_a.Col(1);
   Print(&quot;covariation vectors\n&quot;,vector_a.Cov(vector_b));</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1429
</p>
<pre><code class="language-mql5">
  /*
   covariation cols
   [[2.144133333333333,-4.286]
    [-4.286,11.71]]
   covariation rows
   [[13.005,5.355,-10.659]
    [5.355,2.205,-4.389]
    [-10.659,-4.389,8.736199999999998]]
   covariation vectors
   [[2.144133333333333,-4.286]
    [-4.286,11.71]]
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
import numpy as np
matrix_a=np.array([[3,-2.1],[1.1,-1],[0.12,4.3]])
matrix_c=np.cov(matrix_a,rowvar=False)
print(&quot;covariation cols\n&quot;,matrix_c)
matrix_c2=np.cov(matrix_a)
print(&quot;covariation rows\n&quot;,matrix_c2)
vector_a=matrix_a[:,0]
vector_b=matrix_a[:,1]
matrix_c3=np.cov(vector_a,vector_b)
print(&quot;covariation vectors\n&quot;,matrix_c3)
covariation cols
 [[ 2.14413333 -4.286     ]
 [-4.286      11.71      ]]
covariation rows
 [[ 13.005    5.355  -10.659 ]
 [  5.355    2.205   -4.389 ]
 [-10.659   -4.389    8.7362]]
covariation vectors
 [[ 2.14413333 -4.286     ]
 [-4.286      11.71      ]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1430
<h3>Correlate</h3>
Calcula os valores da fun√ß√£o de correla√ß√£o cruzada (correla√ß√£o cruzada) de dois vetores.
vector vector::Correlate(
¬† const vector&amp;¬†         v,¬†       //¬†vetor
<h3>ENUM_VECTOR_CONVOLVE¬†  mode¬†     //¬†modo</h3>
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
v
[in]  Segundo vetor.
mode
[in]  O par√¢metro mode define o modo de c√°lculo da convolu√ß√£o linear. Valor a partir da
enumera√ß√£o ENUM_VECTOR_CONVOLVE.
<h3>Valor retornado</h3>
Correla√ß√£o cruzada de dois vetores.
<h3>Observa√ß√£o</h3>
O par√¢metro mode define o modo de c√°lculo da convolu√ß√£o linear.
Algoritmo simples para calcular a correla√ß√£o cruzada de dois vetores em MQL5:
vector VectorCrossCorrelationFull(const vector&amp; a,const vector&amp; b)
</p>
<pre><code class="language-mql5">
  {
   int    m=(int)a.Size();
   int    n=(int)b.Size();
   int    size=m+n-1;
   vector c=vector::Zeros(size);
   for(int i=0; i&lt;n; i++)
      for(int i_=i; i_&lt;i+m; i_++)
         c[i_]+=b[n-i-1]*a[i_-i];
   return(c);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
</code></pre>
<p>
vector VectorCrossCorrelationSame(const vector&amp; a,const vector&amp; b)
</p>
<pre><code class="language-mql5">
  {
   int    m=(int)a.Size();
   int    n=(int)b.Size();
   int    size=MathMax(m,n);
   vector c=vector::Zeros(size);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1431
</p>
<pre><code class="language-mql5">
   for(int i=0; i&lt;n; i++)
     {
      for(int i_=i; i_&lt;i+m; i_++)
        {
         int k=i_-size/2+1;
         if(k&gt;=0 &amp;&amp; k&lt;size)
            c[k]+=b[n-i-1]*a[i_-i];
        }
     }
   return(c);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
</code></pre>
<p>
vector VectorCrossCorrelationValid(const vector&amp; a,const vector&amp; b)
</p>
<pre><code class="language-mql5">
  {
   int    m=(int)a.Size();
   int    n=(int)b.Size();
   int    size=MathMax(m,n)-MathMin(m,n)+1;
   vector c=vector::Zeros(size);
   for(int i=0; i&lt;n; i++)
     {
      for(int i_=i; i_&lt;i+m; i_++)
        {
         int k=i_-n+1;
         if(k&gt;=0 &amp;&amp; k&lt;size)
            c[k]+=b[n-i-1]*a[i_-i];
        }
     }
   return(c);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   vector a={1,2,3,4,5};
   vector b={0,1,0.5};
   Print(&quot;full\n&quot;,a.Correlate(b,VECTOR_CONVOLVE_FULL));
   Print(&quot;same\n&quot;,a.Correlate(b,VECTOR_CONVOLVE_SAME));
   Print(&quot;valid\n&quot;,a.Correlate(b,VECTOR_CONVOLVE_VALID));
   Print(&quot;full\n&quot;,b.Correlate(a,VECTOR_CONVOLVE_FULL));
  /*
   full</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1432
</p>
<pre><code class="language-mql5">
   [0.5,2,3.5,5,6.5,5,0]
   same
   [2,3.5,5,6.5,5]
   valid
   [3.5,5,6.5]
   full
   [0,5,6.5,5,3.5,2,0.5]
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
import numpy as np
a=[1,2,3,4,5]
b=[0,1,0.5]
print(&quot;full\n&quot;,np.correlate(a,b,&#x27;full&#x27;))
print(&quot;same\n&quot;,np.correlate(a,b,&#x27;same&#x27;));
print(&quot;valid\n&quot;,np.correlate(a,b,&#x27;valid&#x27;));
print(&quot;full\n&quot;,np.correlate(b,a,&#x27;full&#x27;))
full
 [0.5 2.  3.5 5.  6.5 5.  0. ]
same
 [2.  3.5 5.  6.5 5. ]
valid
 [3.5 5.  6.5]
full
 [0.  5.  6.5 5.  3.5 2.  0.5]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1433
<h3>Convolve</h3>
Retorna uma convolu√ß√£o linear discreta de dois vetores de sequ√™ncia.
vector vector::Convolve(
¬† const vector&amp;¬†          v,¬†       //¬†vetor
<h3>ENUM_VECTOR_CONVOLVE    mode¬†     //¬†modo</h3>
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
v
[out]  Segundo vetor.
mode
[in]  O par√¢metro mode define o modo de c√°lculo da convolu√ß√£o linear ENUM_VECTOR_CONVOLVE.
<h3>Valor retornado</h3>
Convolu√ß√£o linear discreta de dois vetores.
Algoritmo simples para calcular a convolu√ß√£o de dois vetores em MQL5:
vector VectorConvolutionFull(const vector&amp; a,const vector&amp; b)
</p>
<pre><code class="language-mql5">
  {
   if(a.Size()&lt;b.Size())
      return(VectorConvolutionFull(b,a));
   int    m=(int)a.Size();
   int    n=(int)b.Size();
   int    size=m+n-1;
   vector c=vector::Zeros(size);
   for(int i=0; i&lt;n; i++)
      for(int i_=i; i_&lt;i+m; i_++)
         c[i_]+=b[i]*a[i_-i];
   return(c);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
</code></pre>
<p>
vector VectorConvolutionSame(const vector&amp; a,const vector&amp; b)
</p>
<pre><code class="language-mql5">
  {
   if(a.Size()&lt;b.Size())
      return(VectorConvolutionSame(b,a));
   int    m=(int)a.Size();
   int    n=(int)b.Size();
   int    size=MathMax(m,n);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1434
</p>
<pre><code class="language-mql5">
   vector c=vector::Zeros(size);
   for(int i=0; i&lt;n; i++)
     {
      for(int i_=i; i_&lt;i+m; i_++)
        {
         int k=i_-size/2+1;
         if(k&gt;=0 &amp;&amp; k&lt;size)
            c[k]+=b[i]*a[i_-i];
        }
     }
   return(c);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
</code></pre>
<p>
vector VectorConvolutionValid(const vector&amp; a,const vector&amp; b)
</p>
<pre><code class="language-mql5">
  {
   if(a.Size()&lt;b.Size())
      return(VectorConvolutionValid(b,a));
   int    m=(int)a.Size();
   int    n=(int)b.Size();
   int    size=MathMax(m,n)-MathMin(m,n)+1;
   vector c=vector::Zeros(size);
   for(int i=0; i&lt;n; i++)
     {
      for(int i_=i; i_&lt;i+m; i_++)
        {
         int k=i_-n+1;
         if(k&gt;=0 &amp;&amp; k&lt;size)
            c[k]+=b[i]*a[i_-i];
        }
     }
   return(c);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
  vector a= {1, 2, 3, 4, 5};
  vector b= {0, 1, 0.5};
  Print(&quot;full\n&quot;, a.Convolve(b, VECTOR_CONVOLVE_FULL));
  Print(&quot;same\n&quot;, a.Convolve(b, VECTOR_CONVOLVE_SAME));
  Print(&quot;valid\n&quot;, a.Convolve(b, VECTOR_CONVOLVE_VALID));</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1435
</p>
<pre><code class="language-mql5">
  /*
   full
   [0,1,2.5,4,5.5,7,2.5]
   same
   [1,2.5,4,5.5,7]
   valid
   [2.5,4,5.5]
</code></pre>
<p>
  */
<h3>Exemplo em Python:</h3>
import numpy as np
a=[1,2,3,4,5]
b=[0,1,0.5]
print(&quot;full\n&quot;,np.convolve(a,b,&#x27;full&#x27;))
print(&quot;same\n&quot;,np.convolve(a,b,&#x27;same&#x27;));
print(&quot;valid\n&quot;,np.convolve(a,b,&#x27;valid&#x27;));
full
 [0.  1.  2.5 4.  5.5 7.  2.5]
same
 [1.  2.5 4.  5.5 7. ]
valid
 [2.5 4.  5.5]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1436
<h3>Convers√£o de matrizes</h3>
A decomposi√ß√£o de matrizes √© uma tarefa que pode surgir nos seguintes casos:
¬∑ como uma etapa intermedi√°ria no processo de resolu√ß√£o de sistemas de equa√ß√µes lineares
¬∑ para consulta de matrizes
¬∑ para calcular determinantes
¬∑ ao encontrar autovalores e autovetores de uma matriz
¬∑ para calcular fun√ß√µes anal√≠ticas de matrizes
¬∑ ao usar o m√©todo dos m√≠nimos quadrados
¬∑ na solu√ß√£o num√©rica de equa√ß√µes diferenciais
Nesse caso, dependendo do problema a ser resolvido, s√£o utilizados v√°rios tipos de decomposi√ß√£o de
matrizes.
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Cholesky</h3>
Calcula a decomposi√ß√£o de Cholecky.
<h3>Eig</h3>
Calcula os valores pr√≥prios e os vetores pr√≥prios direitos de uma
matriz quadrada
<h3>EigVals</h3>
Calcula os valores pr√≥prios de uma matriz comum
<h3>LU</h3>
Executa a decomposi√ß√£o LU de uma matriz como o produto de uma
matriz triangular inferior e uma matriz triangular superior
<h3>LUP</h3>
Executa uma decomposi√ß√£o LUP com rota√ß√£o parcial, que √© uma
fatora√ß√£o LU com apenas permuta√ß√µes de linha: PA=LU
<h3>QR</h3>
Calcula a fatora√ß√£o qr de uma matriz
<h3>SVD</h3>
<h3>Calcula a decomposi√ß√£o de valor singular</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1437
<h3>Cholesky</h3>
Calcula a decomposi√ß√£o de Cholesky.
</p>
<pre><code class="language-mql5">
bool matrix::Cholesky(
   matrix&amp;¬† L¬†     //¬†matrix
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
<h3>L</h3>
[out]  Matriz triangular inferior.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Retorna a decomposi√ß√£o de Cholesky, L * L.H, de uma matriz quadrada a, onde L √© uma matriz
triangular inferior e .H √© a matriz conjugada transposta (que √© a transposi√ß√£o usual quando a √©
real).a deve ser hermitiana (sim√©trica, se for real) e positiva definida. A fun√ß√£o n√£o verifica se a √©
hermitiana ou n√£o. Al√©m disso, apenas elementos triangulares e diagonais inferiores a s√£o usados.
Na verdade, apenas L √© retornado.
<h3>Exemplo:</h3>
  matrix matrix_a= {{5.7998084, -2.1825367}, {-2.1825367, 9.85910595}};
  matrix matrix_l;
<h3>Print(&quot;matrix_a\n&quot;, matrix_a);</h3>
  matrix_a.Cholesky(matrix_l);
<h3>Print(&quot;matrix_l\n&quot;, matrix_l);</h3>
  Print(&quot;check\n&quot;, matrix_l.MatMul(matrix_l.Transpose()));
  
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  matrix_a
  [[5.7998084,-2.1825367]
</p>
<pre><code class="language-mql5">
   [-2.1825367,9.85910595]]
</code></pre>
<p>
  matrix_l
  [[2.408279136645086,0]
</p>
<pre><code class="language-mql5">
   [-0.9062640068544704,3.006291985133859]]
</code></pre>
<p>
  check
  [[5.7998084,-2.1825367]
</p>
<pre><code class="language-mql5">
   [-2.1825367,9.85910595]]
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1438
<h3>Eig</h3>
Calcula os autovalores √† direita e os autovetores de uma matriz quadrada.
</p>
<pre><code class="language-mql5">
bool matrix::Eig(
</code></pre>
<p>
¬† matrix&amp;¬† eigen_vectors,¬†        //¬†matriz vetores pr√≥prios
¬† vector&amp;¬† eigen_values¬†          //¬†vetor de autovalor
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
Solu√ß√£o complexa de valores pr√≥prios e vetores pr√≥prios
</p>
<pre><code class="language-mql5">
bool matrix::Eig(
</code></pre>
<p>
¬† matrix&lt;complex&gt;&amp;¬†eigen_vectors,¬†//¬†matriz de vetores pr√≥prios
¬† vector&lt;complex&gt;&amp;¬†eigen_values¬†  //¬†vetor de autovalores
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
eigen_vectors
[out]  Matriz de autovetores verticais.
eigen_values
[out]  Vetor de autovalores.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Se, ao calcular os autovalores, for encontrada uma solu√ß√£o complexa, o c√°lculo ser√° interrompido e
o c√≥digo de erro ser√° definido como 4019 (ERR_MATH_OVERFLOW). Para obter uma solu√ß√£o
completa no espa√ßo complexo, precisamos usar o m√©todo de sobrecarga complexa Eig
Se um autovalor complexo tiver parte imagin√°ria igual a zero, ele j√° √© um autovalor real. E isso
pode ser visto no exemplo abaixo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   matrix matrix_a =
     {
        {-3.474589, 1.106384, -9.091977,-3.925227 },
        {-5.522139, 2.366887,-15.162351,-6.357512 },
        { 8.394926,-2.960067, 22.292115, 9.524129 },
        { 7.803242,-2.080287, 19.217706, 8.186645 }
     };
   matrix eigen_vectors;
   vector eigen_values;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1439
</p>
<pre><code class="language-mql5">
   bool res=matrix_a.Eig(eigen_vectors, eigen_values);
   Print(&quot;res=&quot;,res,&quot;  error=&quot;,GetLastError());
   Print(&quot;Eigen vectors:\n&quot;,eigen_vectors, &quot;\nEigen Values:\n&quot;,eigen_values);
//--- check correctness A * v = lambda * v
   int vectors=0;
   for(ulong n=0; n&lt;eigen_values.Size(); n++)
     {
      vector eigen_vector=eigen_vectors.Col(n);
      vector vector_d1   =eigen_vector*eigen_values[n];
      vector vector_d2   =matrix_a.MatMul(eigen_vector);
      ulong errors=vector_d1.Compare(vector_d2,1e-13);
      if(errors==0)
         vectors++;
     }
   Print(&quot;vectors=&quot;,vectors);
//--- complex solution
   matrix&lt;complex&gt; eigen_vectors_c;
   vector&lt;complex&gt; eigen_values_c;
   ResetLastError();
   res=matrix_a.Eig(eigen_vectors_c,eigen_values_c);
   Print(&quot;res=&quot;,res,&quot;  error=&quot;,GetLastError());
   Print(&quot;Eigen vectors:\n&quot;,eigen_vectors_c, &quot;\nEigen Values:\n&quot;,eigen_values_c);
//--- check correctness A * v = lambda * v
   matrixc matrix_c;
   matrix_c.Assign(matrix_a);
   vectors=0;
   for(ulong n=0; n&lt;eigen_values_c.Size(); n++)
     {
      vectorc eigen_vector_c=eigen_vectors_c.Col(n);
      vectorc vector_c1     =eigen_vector_c*eigen_values_c[n];
      vectorc vector_c2     =matrix_c.MatMul(eigen_vector_c);
      ulong errors=vector_c1.Compare(vector_c2,1e-13);
      if(errors==0)
         vectors++;
     }
   Print(&quot;vectors=&quot;,vectors);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
/* –†–µ–∑—É–ª—å—Ç–∞—Ç
   res=true  error=4019
   Eigen vectors:
   [[0.2649667608713664]
    [0.4488818803991876]
    [-0.6527335897527492]
    [-0.5497604331807768]]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1440
</p>
<pre><code class="language-mql5">
   Eigen Values:
   [28.94158645962942]
   vectors=1
   res=true  error=0
   Eigen vectors:
   [[(0.2649667608713664,0),(0.2227392219204762,0.3745470492013296),(0.403285439089771
    [(0.4488818803991876,0),(-0.2613452530342438,-0.3685707727819327),(-0.396850612637
    [(-0.6527335897527492,0),(-0.3418479634708521,-0.3299830378162041),(-0.35530210311
    [(-0.5497604331807768,0),(0.523227993452828,0.3262508584080381),(0.351283559614366
   Eigen Values:
   [(28.94158645962942,0),(0.01022501104810897,0.02954980822331488),(0.010225011048108
   vectors=3
</code></pre>
<p>
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1441
<h3>EigVals</h3>
Calcula os valores pr√≥prios de uma matriz comum.
</p>
<pre><code class="language-mql5">
bool matrix::EigVals(
</code></pre>
<p>
¬† vector&amp;¬† eigen_values¬†     //¬†vetor de autovalores 
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
eigen_values
[out]  Vetor de autovalores corretos.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
A √∫nica diferen√ßa entre EigVals e EigVals √© que EigVals n√£o calcula autovetores, apenas autovalores.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1442
<h3>LU</h3>
Executa a decomposi√ß√£o LU de uma matriz como o produto de uma matriz triangular inferior e uma
matriz triangular superior.
</p>
<pre><code class="language-mql5">
bool matrix::LU(
</code></pre>
<p>
¬† matrix&amp;¬† L,¬†    //¬†matriz triangular inferior
¬† matrix&amp;¬† U¬†     //¬†matriz triangular superior
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
<h3>L</h3>
[out]  Matriz triangular inferior.
<h3>U</h3>
[out]  Matriz triangular superior.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{1,2,3,4},
                    {5,2,6,7},
                    {8,9,3,10},
                    {11,12,14,4}};
   matrix matrix_l,matrix_u;
//--- decomposi√ß√£o de LU
   matrix_a.LU(matrix_l,matrix_u);
   Print(&quot;matrix_l\n&quot;,matrix_l);
   Print(&quot;matrix_u\n&quot;,matrix_u);
//--- verificamos se est√° correto A = L * U
   Print(&quot;check\n&quot;,matrix_l.MatMul(matrix_u));
   /*
   matrix_l
   [[1,0,0,0]
    [5,1,0,0]
    [8,0.875,1,0]
    [11,1.25,0.5904761904761905,1]]
   matrix_u
   [[1,2,3,4]
    [0,-8,-9,-13]
    [0,0,-13.125,-10.625]
    [0,0,0,-17.47619047619047]]
   check
   [[1,2,3,4]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1443
</p>
<pre><code class="language-mql5">
    [5,2,6,7]
    [8,9,3,10]
    [11,12,14,4]]
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1444
<h3>LUP</h3>
Executa uma decomposi√ß√£o LUP com rota√ß√£o parcial, que √© uma fatora√ß√£o LU com apenas
permuta√ß√µes de linha: PA=LU.
</p>
<pre><code class="language-mql5">
bool¬† LUP(
</code></pre>
<p>
¬† matrix&amp;¬† L,¬†    //¬†matriz triangular inferior
¬† matrix&amp;¬† U,¬†    //¬†matriz triangular superior
¬† matrix&amp;¬† P¬†     //¬†matriz de permuta√ß√µes
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
<h3>L</h3>
[out]  Matriz triangular inferior.
<h3>U</h3>
[out]  Matriz triangular superior.
<h3>P</h3>
[out]  Matriz de permuta√ß√µes.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{1,2,3,4},
                    {5,2,6,7},
                    {8,9,3,10},
                    {11,12,14,4}};
   matrix matrix_l,matrix_u,matrix_p;
//--- decomposi√ß√£o de LUP
   matrix_a.LUP(matrix_l,matrix_u,matrix_p);
   Print(&quot;matrix_l\n&quot;,matrix_l);
   Print(&quot;matrix_u\n&quot;,matrix_u);
   Print(&quot;matrix_p\n&quot;,matrix_p);
//--- verificamos se est√° correto P * A = L * U
   Print(&quot;P * A\n&quot;,matrix_p.MatMul(matrix_a));
   Print(&quot;L * U\n&quot;,matrix_l.MatMul(matrix_u));
   /*
   matrix_l
   [[1,0,0,0]
    [0.4545454545454545,1,0,0]
    [0.7272727272727273,-0.07894736842105282,1,0]
    [0.09090909090909091,-0.2631578947368421,-0.2262773722627738,1]]
   matrix_u
   [[11,12,14,4]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1445
</p>
<pre><code class="language-mql5">
    [0,-3.454545454545454,-0.3636363636363633,5.181818181818182]
    [0,0,-7.210526315789473,7.500000000000001]
    [0,0,0,6.697080291970803]]
   matrix_p
   [[0,0,0,1]
    [0,1,0,0]
    [0,0,1,0]
    [1,0,0,0]]
   P * A
   [[11,12,14,4]
    [5,2,6,7]
    [8,9,3,10]
    [1,2,3,4]]
   L * U
   [[11,12,14,4]
    [5,2,6,7]
    [8,9,3.000000000000001,10]
    [1,2,3,4]]
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1446
<h3>QR</h3>
Calcula a fatora√ß√£o qr de uma matriz.
</p>
<pre><code class="language-mql5">
bool¬† QR(
</code></pre>
<p>
¬† matrix&amp;¬† Q,¬†    //¬†matriz com colunas ortonormal
¬† matrix&amp;¬† R¬†     //¬†matriz triangular superior
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
<h3>Q</h3>
[out]  Matriz com colunas ortonormais. Quando o modo complete estiver habilitado, o resultado
ser√° uma matriz ortogonal/unit√°ria, dependendo se a √© real/complexa. Nesse caso, o
determinante pode ser +/- 1. Caso a matriz de entrada possua mais de duas dimens√µes, ser√°
retornado uma pilha de matrizes com as propriedades mencionadas.
<h3>R</h3>
[out]  Matriz triangular superior.
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//---  A*x = b
</code></pre>
<p>
  matrix A = {{0, 1}, {1, 1}, {1, 1}, {2, 1}};
<h3>Print(&quot;A \n&quot;, A);</h3>
  vector b = {1, 2, 2, 3};
<h3>Print(&quot;b \n&quot;, b);</h3>
</p>
<pre><code class="language-mql5">
//--- A = Q*R
</code></pre>
<p>
  matrix q, r;
<h3>A.QR(q, r);</h3>
<h3>Print(&quot;q \n&quot;, q);</h3>
<h3>Print(&quot;r \n&quot;, r);</h3>
  matrix qr=q.MatMul(r);
<h3>Print(&quot;qr \n&quot;, qr);</h3>
</p>
<pre><code class="language-mql5">
  /* 
</code></pre>
<p>
<h3>A</h3>
  [[0,1]
  [1,1]
  [1,1]
  [2,1]]
  b
  [1,2,2,3]
  q
  [[0.4082482904638631,-0.8164965809277259,-1.110223024625157e-16,-0.4082482904638631]
  [0.4625425214347352,-0.03745747856526496,0.7041241452319315,0.5374574785652647]
  [-0.5374574785652648,-0.03745747856526496,0.7041241452319316,-0.4625425214347352]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1447
  [-0.5749149571305296,-0.5749149571305299,-0.09175170953613698,0.5749149571305296]]
  r
  [[-1.224744871391589,-0.2415816237971962]
  [-1.22474487139159,-1.466326495188786]
  [1.224744871391589,1.316496580927726]
  [1.224744871391589,0.2415816237971961]]
  qr
  [[-1.110223024625157e-16,1]
  [1,0.9999999999999999]
  [1,1]
  [2,1]]
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1448
<h3>SVD</h3>
Calcula a decomposi√ß√£o de valor singular.
</p>
<pre><code class="language-mql5">
bool matrix::SVD(
</code></pre>
<p>
¬† matrix&amp;¬† U,¬†                  //¬†matriz unit√°ria
¬† matrix&amp;¬† V,¬†                  //¬†matriz unit√°ria
¬† vector&amp;¬† singular_values¬†     //¬†vetor de valores singulares
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
<h3>U</h3>
[out]  Matriz unit√°ria de ordem m, composta por vetores singulares √† esquerda.
<h3>V</h3>
[out]  Matriz unit√°ria de ordem n, composta por vetores singulares √† direita.
singular_values
[out]  Valores singulares
<h3>Valor retornado</h3>
Retorna true se bem-sucedido, caso contr√°rio, false.
<h3>Exemplo:</h3>
  matrix a= {{0, 1, 2, 3, 4, 5, 6, 7, 8}};
  a=a-4;
<h3>Print(&quot;matrix a \n&quot;, a);</h3>
  a.Reshape(3, 3);
  matrix b=a;
<h3>Print(&quot;matrix b \n&quot;, b);</h3>
</p>
<pre><code class="language-mql5">
//--- fazemos uma decomposi√ß√£o SVD
</code></pre>
<p>
  matrix U, V;
  vector singular_values;
  b.SVD(U, V, singular_values);
<h3>Print(&quot;U \n&quot;, U);</h3>
<h3>Print(&quot;V \n&quot;, V);</h3>
<h3>Print(&quot;singular_values = &quot;, singular_values);</h3>
</p>
<pre><code class="language-mql5">
// bloco de verifica√ß√£o
//--- U * singular diagonal * V = A
</code></pre>
<p>
  matrix matrix_s;
  matrix_s.Diag(singular_values);
<h3>Print(&quot;matrix_s \n&quot;, matrix_s);</h3>
  matrix matrix_vt=V.Transpose();
<h3>Print(&quot;matrix_vt \n&quot;, matrix_vt);</h3>
  matrix matrix_usvt=(U.MatMul(matrix_s)).MatMul(matrix_vt);
<h3>Print(&quot;matrix_usvt \n&quot;, matrix_usvt);</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1449
  ulong errors=(int)b.Compare(matrix_usvt, 1e-9);
  double res=(errors==0);
<h3>Print(&quot;errors=&quot;, errors);</h3>
</p>
<pre><code class="language-mql5">
//---- mais verifica√ß√µes
</code></pre>
<p>
  matrix U_Ut=U.MatMul(U.Transpose());
<h3>Print(&quot;U_Ut \n&quot;, U_Ut);</h3>
<h3>Print(&quot;Ut_U \n&quot;, (U.Transpose()).MatMul(U));</h3>
  matrix vt_V=matrix_vt.MatMul(V);
<h3>Print(&quot;vt_V \n&quot;, vt_V);</h3>
<h3>Print(&quot;V_vt \n&quot;, V.MatMul(matrix_vt));</h3>
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  matrix a
  [[-4,-3,-2,-1,0,1,2,3,4]]
  matrix b
  [[-4,-3,-2]
</p>
<pre><code class="language-mql5">
   [-1,0,1]
   [2,3,4]]
</code></pre>
<p>
<h3>U</h3>
  [[-0.7071067811865474,0.5773502691896254,0.408248290463863]
</p>
<pre><code class="language-mql5">
   [-6.827109697437648e-17,0.5773502691896253,-0.8164965809277256]
   [0.7071067811865472,0.5773502691896255,0.4082482904638627]]
</code></pre>
<p>
<h3>V</h3>
  [[0.5773502691896258,-0.7071067811865474,-0.408248290463863]
</p>
<pre><code class="language-mql5">
   [0.5773502691896258,1.779939029415334e-16,0.8164965809277258]
   [0.5773502691896256,0.7071067811865474,-0.408248290463863]]
</code></pre>
<p>
  singular_values = [7.348469228349533,2.449489742783175,3.277709923350408e-17]
  matrix_s
  [[7.348469228349533,0,0]
</p>
<pre><code class="language-mql5">
   [0,2.449489742783175,0]
   [0,0,3.277709923350408e-17]]
</code></pre>
<p>
  matrix_vt
  [[0.5773502691896258,0.5773502691896258,0.5773502691896256]
</p>
<pre><code class="language-mql5">
   [-0.7071067811865474,1.779939029415334e-16,0.7071067811865474]
   [-0.408248290463863,0.8164965809277258,-0.408248290463863]]
</code></pre>
<p>
  matrix_usvt
  [[-3.999999999999997,-2.999999999999999,-2]
</p>
<pre><code class="language-mql5">
   [-0.9999999999999981,-5.977974170712231e-17,0.9999999999999974]
   [2,2.999999999999999,3.999999999999996]]
</code></pre>
<p>
  errors=0
<h3>U_Ut</h3>
  [[0.9999999999999993,-1.665334536937735e-16,-1.665334536937735e-16]
</p>
<pre><code class="language-mql5">
   [-1.665334536937735e-16,0.9999999999999987,-5.551115123125783e-17]
   [-1.665334536937735e-16,-5.551115123125783e-17,0.999999999999999]]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1450
<h3>Ut_U</h3>
  [[0.9999999999999993,-5.551115123125783e-17,-1.110223024625157e-16]
</p>
<pre><code class="language-mql5">
   [-5.551115123125783e-17,0.9999999999999987,2.498001805406602e-16]
   [-1.110223024625157e-16,2.498001805406602e-16,0.999999999999999]]
</code></pre>
<p>
  vt_V
  [[1,-5.551115123125783e-17,0]
</p>
<pre><code class="language-mql5">
   [-5.551115123125783e-17,0.9999999999999996,1.110223024625157e-16]
   [0,1.110223024625157e-16,0.9999999999999996]]
</code></pre>
<p>
<h3>V_vt</h3>
  [[0.9999999999999999,1.110223024625157e-16,1.942890293094024e-16]
</p>
<pre><code class="language-mql5">
   [1.110223024625157e-16,0.9999999999999998,1.665334536937735e-16]
   [1.942890293094024e-16,1.665334536937735e-16,0.9999999999999996]
</code></pre>
<p>
  */
 }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1451
<h3>M√©todos estat√≠sticos</h3>
M√©todos de obten√ß√£o de estat√≠sticas descritivas de matrizes e vetores.
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>ArgMax</h3>
<h3>Retorna o √≠ndice do valor m√°ximo</h3>
<h3>ArgMin</h3>
<h3>Retorna o √≠ndice do valor m√≠nimo</h3>
<h3>Max</h3>
Retorna o valor m√°ximo em uma matriz/vetor
<h3>Min</h3>
Retorna o valor m√≠nimo em uma matriz/vetor
<h3>Ptp</h3>
Retorna o intervalo de valores de uma matriz/vetor ou um eixo
especificado de uma matriz
<h3>Sum</h3>
Executa uma soma de elementos de matriz/vetor, que tamb√©m pode
ser realizada ao longo do(s) eixo(s) especificado(s)
<h3>Prod</h3>
Calcula o produto de elementos de matriz/vetor, que tamb√©m podem
ser executados ao longo do eixo especificado
<h3>CumSum</h3>
Retorna a soma cumulativa (cumulativa) de elementos 
de
matriz/vetor, incluindo aqueles ao longo do eixo fornecido
<h3>CumProd</h3>
Retorna o produto cumulativo (cumulativo) dos elementos da
matriz/vetor, incluindo aqueles ao longo do eixo fornecido
<h3>Percentile</h3>
Calcula o percentil especificado dos valores dos elementos de
matriz/vetor ou elementos ao longo do eixo especificado
<h3>Quantile</h3>
Calcula o quantil especificado dos valores dos elementos da
matriz/vetor ou dos elementos ao longo do eixo especificado
<h3>Median</h3>
Calcula a mediana dos elementos de uma matriz/vetor
<h3>Mean</h3>
Calcula a m√©dia aritm√©tica dos valores dos elementos
<h3>Average</h3>
Calcula a m√©dia ponderada dos valores da matriz/vetor
<h3>Std</h3>
Calcula o desvio quadr√°tico m√©dio (padr√£o) dos valores dos
elementos de uma matriz/vetor ou um eixo especificado
<h3>Var</h3>
Calcula a vari√¢ncia dos valores dos elementos de uma matriz/vetor
<h3>LinearRegression</h3>
Calcula o vetor/matriz com os valores de regress√£o linear calculados</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1452
<h3>ArgMax</h3>
Retorna o √≠ndice do valor m√°ximo.
ulong vector::ArgMax();
ulong matrix::ArgMax();
vector matrix::ArgMax(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
O √≠ndice do valor m√°ximo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vector cols_max=matrix_a.ArgMax(0);
   vector rows_max=matrix_a.ArgMax(1);
   ulong  matrix_max=matrix_a.ArgMax();
   Print(&quot;cols_max=&quot;,cols_max);
   Print(&quot;rows_max=&quot;,rows_max);
   Print(&quot;max index &quot;,matrix_max,&quot;  max value &quot;,matrix_a.Flat(matrix_max));
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_max=[0,3,1]
   rows_max=[0,2,0,1]
   max index 5  max value 12.0
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1453
<h3>ArgMin</h3>
Retorna o √≠ndice do valor m√≠nimo.
ulong vector::ArgMin();
ulong matrix::ArgMin();
vector matrix::ArgMin(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
√çndice de valor m√≠nimo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vector cols_min=matrix_a.ArgMin(0);
   vector rows_min=matrix_a.ArgMin(1);
   ulong  matrix_min=matrix_a.ArgMin();
   Print(&quot;cols_min=&quot;,cols_min);
   Print(&quot;rows_min=&quot;,rows_min);
   Print(&quot;min index &quot;,matrix_min,&quot;  min value &quot;,matrix_a.Flat(matrix_min));
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_min=[1,0,0]
   rows_min=[2,0,2,0]
   min index 3  min value 1.0
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1454
<h3>Max</h3>
Retorna o valor m√°ximo em uma matriz/vetor.
</p>
<pre><code class="language-mql5">
double vector::Max();
double matrix::Max();
</code></pre>
<p>
vector matrix::Max(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
O valor m√°ximo na matriz/vetor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vector cols_max=matrix_a.Max(0);
   vector rows_max=matrix_a.Max(1);
   double matrix_max=matrix_a.Max();
   Print(&quot;cols_max=&quot;,cols_max);
   Print(&quot;rows_max=&quot;,rows_max);
   Print(&quot;max value &quot;,matrix_max);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_max=[10,11,12]
   rows_max=[10,12,6,11]
   max value 12.0
   */  </p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1455
<h3>Min</h3>
Retorna o valor m√≠nimo em uma matriz/vetor.
</p>
<pre><code class="language-mql5">
double vector::Min();
double matrix::Min();
</code></pre>
<p>
vector matrix::Min(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
O valor m√≠nimo na matriz/vetor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vector cols_min=matrix_a.Min(0);
   vector rows_min=matrix_a.Min(1);
   double matrix_min=matrix_a.Min();
   Print(&quot;cols_min=&quot;,cols_min);
   Print(&quot;rows_min=&quot;,rows_min);
   Print(&quot;min value &quot;,matrix_min);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_min=[1,3,2]
   rows_min=[2,1,4,7]
   min value 1.0
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1456
<h3>Ptp</h3>
Retorna a faixa de valores de matriz/vetor ou o eixo de matriz especificado e equivalente ao
resultado Max() - Min(). Ptp - Peak to peak, de pico a pico.
</p>
<pre><code class="language-mql5">
double vector::Ptp();
double matrix::Ptp();
</code></pre>
<p>
vector matrix::Ptp(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
Vetor com faixas de valores (m√°ximo - m√≠nimo).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vector cols_ptp=matrix_a.Ptp(0);
   vector rows_ptp=matrix_a.Ptp(1);
   double matrix_ptp=matrix_a.Ptp();
   Print(&quot;cols_ptp  &quot;,cols_ptp);
   Print(&quot;rows_ptp  &quot;,rows_ptp);
   Print(&quot;ptp value  &quot;,matrix_ptp);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_ptp [9,8,10]
   rows_ptp [8,11,2,4]
   ptp value  11.0
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1457
<h3>Sum</h3>
Executa uma soma de elementos de matriz/vetor, que tamb√©m pode ser realizada ao longo do(s)
eixo(s) especificado(s).
</p>
<pre><code class="language-mql5">
double vector::Sum();
double matrix::Sum();
</code></pre>
<p>
vector matrix::Sum(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
Soma de elementos de matriz/vetor, que tamb√©m pode ser realizada ao longo do(s) eixo(s)
especificado(s).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vector cols_sum=matrix_a.Sum(0);
   vector rows_sum=matrix_a.Sum(1);
   double matrix_sum=matrix_a.Sum();
   Print(&quot;cols_sum=&quot;,cols_sum);
   Print(&quot;rows_sum=&quot;,rows_sum);
   Print(&quot;sum value &quot;,matrix_sum);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_sum=[24,27,27]
   rows_sum=[15,21,15,27]
   sum value 78.0
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1458
<h3>Prod</h3>
Calcula o produto de elementos de matriz/vetor, que tamb√©m podem ser executados ao longo do eixo
especificado.
</p>
<pre><code class="language-mql5">
double vector::Prod(
</code></pre>
<p>
  const double¬† initial=1¬†     //¬†multiplicador inicial
</p>
<pre><code class="language-mql5">
   );
double matrix::Prod(
</code></pre>
<p>
  const double¬† initial=1¬†     //¬†multiplicador inicial
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
vector matrix::Prod(
¬† const int¬†    axis,¬†         //¬†eixo
  const double¬† initial=1¬†     //¬†multiplicador inicial
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
initial=1
[in]  Multiplicador inicial.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vector cols_prod=matrix_a.Prod(0);
   vector rows_prod=matrix_a.Prod(1);
   double matrix_prod=matrix_a.Prod();
   Print(&quot;cols_prod=&quot;,cols_prod);
   cols_prod=matrix_a.Prod(0,0.1);
   Print(&quot;cols_prod=&quot;,cols_prod);
   Print(&quot;rows_prod=&quot;,rows_prod);
   Print(&quot;prod value &quot;,matrix_prod);
  /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_prod=[420,1320,864]
   cols_prod=[42,132,86.40000000000001]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1459
</p>
<pre><code class="language-mql5">
   rows_prod=[60,96,120,693]
   prod value 479001600.0
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1460
<h3>CumSum</h3>
Retorna a soma cumulativa (cumulativa) de elementos de matriz/vetor, incluindo aqueles ao longo do
eixo fornecido.
vector vector::CumSum();
vector matrix::CumSum();
matrix matrix::CumSum(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
Soma acumulada de elementos ao longo do eixo dado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   matrix cols_cumsum=matrix_a.CumSum(0);
   matrix rows_cumsum=matrix_a.CumSum(1);
   vector cumsum_values=matrix_a.CumSum();
   Print(&quot;cols_cumsum\n&quot;,cols_cumsum);
   Print(&quot;rows_cumsum\n&quot;,rows_cumsum);
   Print(&quot;cumsum values  &quot;,cumsum_values);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_cumsum
   [[10,3,2]
    [11,11,14]
    [17,16,18]
    [24,27,27]]
   rows_cumsum
   [[10,13,15]
    [1,9,21]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1461
</p>
<pre><code class="language-mql5">
    [6,11,15]
    [7,18,27]]
   cumsum values  [10,13,15,16,24,36,42,47,51,58,69,78]
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1462
<h3>CumProd</h3>
Retorna o produto cumulativo (cumulativo) dos elementos da matriz/vetor, incluindo aqueles ao longo
do eixo fornecido.
vector vector::CumProd();
vector matrix::CumProd();
matrix matrix::CumProd(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal para cada coluna (ou seja, por linhas), 1 ‚Äî eixo vertical para cada
linha (ou seja, por colunas).
<h3>Valor retornado</h3>
Produto cumulativo de elementos ao longo de um determinado eixo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   matrix cols_cumprod=matrix_a.CumProd(0);
   matrix rows_cumprod=matrix_a.CumProd(1);
   vector cumprod_values=matrix_a.CumProd();
   Print(&quot;cols_cumprod\n&quot;,cols_cumprod);
   Print(&quot;rows_cumprod\n&quot;,rows_cumprod);
   Print(&quot;cumprod values  &quot;,cumprod_values);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_cumprod
   [[10,3,2]
    [10,24,24]
    [60,120,96]
    [420,1320,864]]
   rows_cumprod
   [[10,30,60]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1463
</p>
<pre><code class="language-mql5">
    [1,8,96]
    [6,30,120]
    [7,77,693]]
   cumprod values  [10,30,60,60,480,5760,34560,172800,691200,4838400,53222400,47900160
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1464
<h3>Percentile</h3>
Calcula o percentil especificado dos valores dos elementos de matriz/vetor ou elementos ao longo do
eixo especificado.
</p>
<pre><code class="language-mql5">
double vector::Percentile(
</code></pre>
<p>
  const int¬† percent ¬†    //¬†
</p>
<pre><code class="language-mql5">
   );
double matrix::Percentile(
</code></pre>
<p>
  const int¬† percent ¬†    //¬†
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
vector matrix::Percentile(
  const int¬† percent,¬†    //¬†
¬† const int¬† axis¬†        //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
percent
[in]  O percentil a ser calculado deve estar entre 0 e 100, inclusive.
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
Percentil: escalar ou vetorial.
<h3>Observa√ß√£o</h3>
Os valores v√°lidos para o par√¢metro percent est√£o no intervalo [0, 100]. Um algoritmo linear √©
usado para calcular percentis. Para calcular corretamente os percentis, a sequ√™ncia deve ser
classificada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrixf matrix_a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vectorf cols_percentile=matrix_a.Percentile(50,0);
   vectorf rows_percentile=matrix_a.Percentile(50,1);
   float matrix_percentile=matrix_a.Percentile(50);
   Print(&quot;cols_percentile &quot;,cols_percentile);
   Print(&quot;rows_percentile &quot;,rows_percentile);
   Print(&quot;percentile value  &quot;,matrix_percentile);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1465
</p>
<pre><code class="language-mql5">
   /*
   matrix_a
   [[1,2,3]
    [4,5,6]
    [7,8,9]
    [10,11,12]]
   cols_percentile [5.5,6.5,7.5]
   rows_percentile [2,5,8,11]
   percentile value  6.5
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1466
<h3>Quantile</h3>
Calcula o quantil especificado dos valores dos elementos da matriz/vetor ou dos elementos ao longo do
eixo especificado.
</p>
<pre><code class="language-mql5">
double vector::Quantile(
</code></pre>
<p>
¬† const double¬†quantile ¬†    //¬†quantil
</p>
<pre><code class="language-mql5">
   );
double matrix::Quantile(
</code></pre>
<p>
¬† const double quantile ¬†    //¬†quantil
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
vector matrix::Quantile(
¬† const double¬†quantile,¬†    //¬†quantil
¬† const int¬†   axis¬†         //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
quantile
[in]  O quantil a ser calculado deve estar entre 0 e 100, inclusive.
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical
<h3>Valor retornado</h3>
Quantil: escalar ou vetorial.
<h3>Observa√ß√£o</h3>
A faixa de valores do par√¢metro quantil toma valores no intervalo [0,1]. Um algoritmo linear √©
usado para calcular os quantis. Para calcular corretamente os quantis, a sequ√™ncia deve ser
classificada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrixf matrix_a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vectorf cols_quantile=matrix_a.Quantile(0.5,0);
   vectorf rows_quantile=matrix_a.Quantile(0.5,1);
   float matrix_quantile=matrix_a.Quantile(0.5);
   Print(&quot;cols_quantile &quot;,cols_quantile);
   Print(&quot;rows_quantile &quot;,rows_quantile);
   Print(&quot;quantile value  &quot;,matrix_quantile);
   /*</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1467
</p>
<pre><code class="language-mql5">
   matrix_a
   [[1,2,3]
    [4,5,6]
    [7,8,9]
    [10,11,12]]
   cols_quantile [5.5,6.5,7.5]
   rows_quantile [2,5,8,11]
   quantile value  6.5
   */
   </p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1468
<h3>Median</h3>
Calcula a mediana dos elementos de uma matriz/vetor.
</p>
<pre><code class="language-mql5">
double vector::Median();
double matrix::Median();
</code></pre>
<p>
vector matrix::Median(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
Mediana: escalar ou vetorial.
<h3>Observa√ß√£o</h3>
A mediana √© um valor tal que exatamente metade dos elementos da matriz/vetor ser√° menor que
ela, e a outra ser√° maior. O mesmo que Quantile(0,5) e Percentile(50). Para calcular corretamente
os percentis, a sequ√™ncia deve ser classificada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrixf matrix_a={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vectorf cols_median=matrix_a.Median(0);
   vectorf rows_median=matrix_a.Median(1);
   float matrix_median=matrix_a.Median();
   Print(&quot;cols_median &quot;,cols_median);
   Print(&quot;rows_median &quot;,rows_median);
   Print(&quot;median value  &quot;,matrix_median);
   /*
   matrix_a
   [[1,2,3]
    [4,5,6]
    [7,8,9]
    [10,11,12]]
   cols_median [5.5,6.5,7.5]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1469
</p>
<pre><code class="language-mql5">
   rows_median [2,5,8,11]
   median value  6.5
   */
      </p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1470
<h3>Mean</h3>
Calcula a m√©dia aritm√©tica dos valores dos elementos.
</p>
<pre><code class="language-mql5">
double vector::Mean();
double matrix::Mean();
</code></pre>
<p>
vector matrix::Mean(
¬† const int¬† axis¬†     //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
M√©dia aritm√©tica dos valores dos elementos.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrixf matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vectorf cols_mean=matrix_a.Mean(0);
   vectorf rows_mean=matrix_a.Mean(1);
   float matrix_mean=matrix_a.Mean();
   Print(&quot;cols_mean &quot;,cols_mean);
   Print(&quot;rows_mean &quot;,rows_mean);
   Print(&quot;mean value  &quot;,matrix_mean);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_mean [6,6.75,6.75]
   rows_mean [5,7,5,9]
   mean value  6.5
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1471
<h3>Average</h3>
Calcula a m√©dia ponderada dos valores da matriz/vetor.
</p>
<pre><code class="language-mql5">
double vector::Average(
</code></pre>
<p>
¬† const vector&amp; weigts¬†     //¬†vetor de pesos
</p>
<pre><code class="language-mql5">
   );
double matrix::Average(
</code></pre>
<p>
¬† const matrix&amp; weigts¬†     //¬†matriz de pesos
);
vector matrix::Average(
¬† const matrix&amp; weigts,     //¬†matriz de pesos
¬† const int¬†    axis¬†       //¬†eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
M√©dia aritm√©tica: escalar ou vetorial.
<h3>Observa√ß√£o</h3>
A matriz/vetor de pondera√ß√£o est√° associada √† matriz/vetor principal.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrixf matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   matrixf matrix_w=matrixf::Ones(4,3);
   Print(&quot;matrix_a\n&quot;,matrix_a);
   vectorf cols_average=matrix_a.Average(matrix_w,0);
   vectorf rows_average=matrix_a.Average(matrix_w,1);
   float matrix_average=matrix_a.Average(matrix_w);
   Print(&quot;cols_average &quot;,cols_average);
   Print(&quot;rows_average &quot;,rows_average);
   Print(&quot;average value  &quot;,matrix_average);
   /*
   matrix_a
   [[10,3,2]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1472
</p>
<pre><code class="language-mql5">
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_average [6,6.75,6.75]
   rows_average [5,7,5,9]
   average value  6.5
   */ value  6.5</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1473
<h3>Std</h3>
Calcula o desvio padr√£o dos valores dos elementos da matriz/vetor ou do eixo especificado.
</p>
<pre><code class="language-mql5">
double vector::Std();
double vector::Std(
</code></pre>
<p>
  const int¬† ddof      // ajuste do grau de liberdade
);
</p>
<pre><code class="language-mql5">
double matrix::Std();
</code></pre>
<p>
vector matrix::Std(
¬† const int¬† axis¬†     // eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
vector matrix::Std(
¬† const int¬† axis,     // eixo
  const int¬† ddof      // ajuste do grau de liberdade
);
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
ddof
[in] ‚ÄúDelta Degrees of Freedom‚Äù: par√¢metro que define quanto o n√∫mero de graus de liberdade
ser√° reduzido. O divisor na f√≥rmula ser√° N - ddof, onde N √© o n√∫mero de observa√ß√µes. Por padr√£o,
ddof = 0.
<h3>Valor retornado</h3>
Desvio padr√£o: escalar ou vetorial.
<h3>Observa√ß√£o</h3>
O desvio padr√£o √© a raiz quadrada da m√©dia dos quadrados dos desvios em rela√ß√£o √† m√©dia, ou
seja, std = sqrt(mean(x)), onde x = abs(a - a.mean())**2.
O desvio padr√£o normalmente √© calculado como x.sum() / N, onde N = len(x).
A express√£o com ddof=0 √© √†s vezes chamada de &quot;vari√¢ncia da popula√ß√£o&quot;. Se ddof &gt; 0 (valor mais
comum √© 1), o valor resultante √© chamado de &quot;vari√¢ncia amostral&quot;.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrixf matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1474
</p>
<pre><code class="language-mql5">
   vectorf cols_std=matrix_a.Std(0);
   vectorf rows_std=matrix_a.Std(1);
   float matrix_std=matrix_a.Std();
   Print(&quot;cols_std &quot;,cols_std);
   Print(&quot;rows_std &quot;,rows_std);
   Print(&quot;std value  &quot;,matrix_std);
 
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_std [3.2403703,3.0310888,3.9607449]
   rows_std [3.5590262,4.5460606,0.81649661,1.6329932]
   std value  3.452052593231201
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1475
<h3>Var</h3>
Calcula a vari√¢ncia dos valores dos elementos da matriz/vetor.
</p>
<pre><code class="language-mql5">
double vector::Var();
double vector::Std(
</code></pre>
<p>
  const int¬† ddof      // ajuste do grau de liberdade
);
</p>
<pre><code class="language-mql5">
double matrix::Var();
</code></pre>
<p>
vector matrix::Var(
¬† const int¬† axis¬†     // eixo
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
vector matrix::Std(
¬† const int¬† axis,     // eixo
  const int¬† ddof      // ajuste do grau de liberdade
);
<h3>Par√¢metros</h3>
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
ddof
[in] ‚ÄúDelta Degrees of Freedom‚Äù: par√¢metro que define quanto o n√∫mero de graus de liberdade
ser√° reduzido. O divisor na f√≥rmula ser√° N - ddof, onde N √© o n√∫mero de observa√ß√µes. Por padr√£o,
ddof = 0.
<h3>Valor retornado</h3>
Vari√¢ncia: escalar ou vetorial.
<h3>Observa√ß√£o</h3>
A vari√¢ncia representa o desvio quadr√°tico m√©dio em rela√ß√£o √† m√©dia, ou seja, var = mean(x), onde
x = abs(a - a.mean())**2.
O valor m√©dio geralmente √© calculado como x.sum() / N, onde N = len(x).
A express√£o com ddof=0 √© √†s vezes chamada de &quot;vari√¢ncia da popula√ß√£o&quot;. Se ddof &gt; 0 (valor mais
comum √© 1), o valor resultante √© chamado de &quot;vari√¢ncia amostral&quot;.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrixf matrix_a={{10,3,2},{1,8,12},{6,5,4},{7,11,9}};
   Print(&quot;matrix_a\n&quot;,matrix_a);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1476
</p>
<pre><code class="language-mql5">
   vectorf cols_var=matrix_a.Var(0);
   vectorf rows_var=matrix_a.Var(1);
   float matrix_var=matrix_a.Var();
   Print(&quot;cols_var &quot;,cols_var);
   Print(&quot;rows_var &quot;,rows_var);
   Print(&quot;var value  &quot;,matrix_var);
   /*
   matrix_a
   [[10,3,2]
    [1,8,12]
    [6,5,4]
    [7,11,9]]
   cols_var [10.5,9.1875,15.6875]
   rows_var [12.666667,20.666666,0.66666669,2.6666667]
   var value  11.916666984558105
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1477
<h3>LinearRegression</h3>
Calcula o vetor/matriz com os valores de regress√£o linear calculados.
vector vector::LinearRegression();
matrix matrix::LinearRegression(
¬† ENUM_MATRIX_AXIS  axis=AXIS_NONE¬†     //¬†eixo ao longo do qual a regress√£o √© calcula
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
axis
[in]  Especifica o eixo ao longo do qual a regress√£o √© contada. Valor a partir da enumera√ß√£o
ENUM_MATRIX_AXIS (AXIS_HORZ ‚Äî eixo horizontal, AXIS_VERT ‚Äî eixo vertical).
<h3>Valor retornado</h3>
Um vetor ou matriz com valores de regress√£o linear calculados.
<h3>Observa√ß√£o</h3>
Para calcular uma regress√£o linear, √© usada a equa√ß√£o de regress√£o padr√£o: y (x) =  a * x + b, onde a
√© a inclina√ß√£o da linha e b √© seu deslocamento ao longo do eixo Y.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#include &lt;Graphics\Graphic.mqh&gt;
#define GRAPH_WIDTH  750
#define GRAPH_HEIGHT 350
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1478
</p>
<pre><code class="language-mql5">
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   vector vector_a;
   vector_a.CopyRates(_Symbol,_Period,COPY_RATES_CLOSE,1,100);
   vector vector_r=vector_a.LinearRegression();
//--- switch off chart show
   ChartSetInteger(0,CHART_SHOW,false);
//--- arrays for drawing a graph
   double x[];
   double y1[];
   double y2[];
   ArrayResize(x,uint(vector_a.Size()));
   ArrayResize(y1,uint(vector_a.Size()));
   ArrayResize(y2,uint(vector_a.Size()));
   for(ulong i=0; i&lt;vector_a.Size(); i++)
     {
      x[i]=(double)i;
      y1[i]=vector_a[i];
      y2[i]=vector_r[i];
     }
//--- graph title
   string title=&quot;Linear regression &quot;+_Symbol+&quot;,&quot;+EnumToString(_Period);
   long   chart=0;
   string name=&quot;LinearRegression&quot;;
//--- create graph
   CGraphic graphic;
   graphic.Create(chart,name,0,0,0,GRAPH_WIDTH,GRAPH_HEIGHT);
   graphic.BackgroundMain(title);
   graphic.BackgroundMainSize(12);
   
//--- activation function graph
   CCurve *curvef=graphic.CurveAdd(x,y1,CURVE_POINTS_AND_LINES);
   curvef.Name(&quot;vector_a&quot;);
   curvef.LinesWidth(2);
   curvef.LinesSmooth(true);
   curvef.LinesSmoothTension(1);
   curvef.LinesSmoothStep(10);
//--- derivatives of activation function
   CCurve *curved=graphic.CurveAdd(x,y2,CURVE_LINES);
   curved.Name(&quot;vector_r&quot;);
   curved.LinesWidth(2);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1479
</p>
<pre><code class="language-mql5">
   curved.LinesSmooth(true);
   curved.LinesSmoothTension(1);
   curved.LinesSmoothStep(10);
   graphic.CurvePlotAll();
   graphic.Update();
//--- endless loop to recognize pressed keyboard buttons
   while(!IsStopped())
     {
      //--- press escape button to quit program
      if(TerminalInfoInteger(TERMINAL_KEYSTATE_ESCAPE)!=0)
         break;
      //--- press PdDn to save graph picture
      if(TerminalInfoInteger(TERMINAL_KEYSTATE_PAGEDOWN)!=0)
        {
         string file_names[];
         if(FileSelectDialog(&quot;Save Picture&quot;,NULL,&quot;All files (*.*)|*.*&quot;,FSD_WRITE_FILE,
            continue;
         ChartScreenShot(0,file_names[0],GRAPH_WIDTH,GRAPH_HEIGHT);
        }
      Sleep(10);
     }
//--- clean up
   graphic.Destroy();
   ObjectDelete(chart,name);
   ChartSetInteger(0,CHART_SHOW,true);
</code></pre>
<p>
  }
<h3>ENUM_MATRIX_AXIS</h3>
Enumera√ß√£o para indicar o eixo em todas as fun√ß√µes estat√≠sticas para matrizes.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>AXIS_NONE</h3>
O eixo n√£o √© definido, o c√°lculo √© realizado em todos os
elementos da matriz, como se fosse um vetor (consulte o
m√©todo Flat).
<h3>AXIS_HORZ</h3>
<h3>Eixo horizontal</h3>
<h3>AXIS_VERT</h3>
<h3>Eixo vertical</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1480
<h3>M√©todos de Caracteriza√ß√£o</h3>
M√©todos para obter as seguintes caracter√≠sticas da matriz:
¬∑ n√∫mero de linhas
¬∑ numero de colunas
¬∑ norma
¬∑ n√∫mero de condicionamento
¬∑ determinante
¬∑ posto da matriz
¬∑ tra√ßo
¬∑ espectro
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Rows</h3>
Retorna o n√∫mero de linhas em uma matriz
<h3>Cols</h3>
Retorna o n√∫mero de colunas em uma matriz
<h3>Size</h3>
<h3>Retorna o tamanho do vetor</h3>
<h3>Norm</h3>
Retorna a norma de uma matriz ou vetor
<h3>Cond</h3>
Calcula o n√∫mero de condicionamento de uma matriz
<h3>Det</h3>
Calcula o determinante de uma matriz quadrada n√£o singular
<h3>SLogDet</h3>
Calcula o sinal e o logaritmo do determinante de uma matriz
<h3>Rank</h3>
Retorna a posto de uma matriz usando o m√©todo de Gauss
<h3>Trace</h3>
Retorna a soma dos elementos ao longo das diagonais da matriz
<h3>Spectrum</h3>
Retorna o espectro de uma matriz como o conjunto de seus
autovalores do produto AT*A</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1481
<h3>Rows</h3>
Retorna o n√∫mero de linhas em uma matriz.
ulong matrix::Rows()
<h3>Valor retornado</h3>
Valor do tipo integer.
<h3>Exemplo:</h3>
  matrix m= {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}};
  m.Reshape(3, 4);
<h3>Print(&quot;matrix m \n&quot; , m);</h3>
<h3>Print(&quot;m.Rows()=&quot;, m.Rows());</h3>
<h3>Print(&quot;m.Cols()=&quot;, m.Cols());</h3>
</p>
<pre><code class="language-mql5">
  /*
   matrix m 
   [[1,2,3,4]
    [5,6,7,8]
    [9,10,11,12]]
   m.Rows()=3
   m.Cols()=4
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1482
<h3>Cols</h3>
Retorna o n√∫mero de colunas em uma matriz.
ulong matrix::Cols()
<h3>Valor retornado</h3>
Valor do tipo integer.
<h3>Exemplo:</h3>
  matrix m= {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}};
  m.Reshape(3, 4);
<h3>Print(&quot;matrix m \n&quot; , m);</h3>
<h3>Print(&quot;m.Cols()=&quot;, m.Cols());</h3>
<h3>Print(&quot;m.Rows()=&quot;, m.Rows());</h3>
</p>
<pre><code class="language-mql5">
  /*
   matrix m 
   [[1,2,3,4]
    [5,6,7,8]
    [9,10,11,12]]
   m.Cols()=4
   m.Rows()=3
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1483
<h3>Size</h3>
Retorna o tamanho do vetor.
ulong vector::Size()
<h3>Valor retornado</h3>
Valor do tipo integer.
<h3>Exemplo:</h3>
  matrix m={{1,2,3,4,5,6,7,8,9,10,11,12}};
  m.Reshape(3,4);
<h3>Print(&quot;matrix m\n&quot;,m);</h3>
  vector v=m.Row(1);
<h3>Print(&quot;v.Size()=&quot;,v.Size());</h3>
<h3>Print(&quot;v=&quot;,v);</h3>
</p>
<pre><code class="language-mql5">
  /*
   matrix m
   [[1,2,3,4]
    [5,6,7,8]
    [9,10,11,12]]
   v.Size()=4
   v=[5,6,7,8]  
</code></pre>
<p>
  */</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1484
<h3>Norm</h3>
Retorna a norma de uma matriz ou vetor.
</p>
<pre><code class="language-mql5">
double vector::Norm(
</code></pre>
<p>
¬† const ENUM_VECTOR_NORM¬† norm,     //¬†norma do vetor
¬† const int                        norm_p=2  //¬†n√∫mero p-norm caso VECTOR_NORM_P
</p>
<pre><code class="language-mql5">
   );
double matrix::Norm(
</code></pre>
<p>
¬† const ENUM_MATRIX_NORM¬† norm      //¬†norma da matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
norm
[in] Ordem da norma
<h3>Valor retornado</h3>
Norma de uma matriz ou vetor.
<h3>Observa√ß√£o</h3>
¬∑ VECTOR_NORM_INF ‚Äî valor absoluto m√°ximo entre os elementos do vetor.
¬∑ VECTOR_NORM_MINUS_INF ‚Äî valor m√≠nimo absoluto do vetor.
¬∑ VECTOR_NORM_P ‚Äî norma-p do vetor. Se norm_p=0, √© o n√∫mero de elementos n√£o nulos do
vetor; norm_p=1 √© a soma dos valores absolutos dos elementos vetoriais; norm_p=2 √© a raiz
quadrada da soma dos quadrados dos valores dos elementos vetoriais. A norma-p pode ser
negativa.
¬∑ MATRIX_NORM_FROBENIUS ‚Äî raiz quadrada da soma dos quadrados dos valores dos elementos da
matriz. A norma de Frobenius e a norma do vetor P2 s√£o consistentes.
¬∑ MATRIX_NORM_SPECTRAL ‚Äî valor m√°ximo do espectro da matriz.
¬∑ MATRIX_NORM_NUCLEAR ‚Äî soma dos valores singulares da matriz.
¬∑ MATRIX_NORM_INF ‚Äî norma-p1 vetorial m√°xima entre os vetores verticais da matriz. A norma inf
da matriz e a norma inf do vetor s√£o consistentes.
¬∑ MATRIX_NORM_MINUS_INF ‚Äî norma-p1 vetorial m√≠nima entre os vetores verticais da matriz.
¬∑ MATRIX_NORM_P1 ‚Äî norma-p1 vetorial m√°xima entre os vetores horizontais da matriz.
¬∑ MATRIX_NORM_MINUS_P1 ‚Äî norma-p1 vetorial m√≠nima entre os vetores horizontais da matriz.
¬∑ MATRIX_NORM_P2 ‚Äî maior valor singular da matriz.
¬∑ MATRIX_NORM_MINUS_P2 ‚Äî menor valor singular da matriz.
Algoritmo simples para calcular a norma-p de um vetor em MQL5:
</p>
<pre><code class="language-mql5">
double VectorNormP(const vector&amp; v,int norm_value)
  {
   ulong  i;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1485
</p>
<pre><code class="language-mql5">
   double norm=0.0;
//---
   switch(norm_value)
     {
      case 0 :
         for(i=0; i&lt;v.Size(); i++)
            if(v[i]!=0)
               norm+=1.0;
         break;
      case 1 :
         for(i=0; i&lt;v.Size(); i++)
            norm+=MathAbs(v[i]);
         break;
      case 2 :
         for(i=0; i&lt;v.Size(); i++)
            norm+=v[i]*v[i];
         norm=MathSqrt(norm);
         break;
      default :
         for(i=0; i&lt;v.Size(); i++)
            norm+=MathPow(MathAbs(v[i]),norm_value);
         norm=MathPow(norm,1.0/norm_value);
     }
//---
   return(norm);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
  matrix a= {{0, 1, 2, 3, 4, 5, 6, 7, 8}};
  a=a-4;
<h3>Print(&quot;matrix a \n&quot;, a);</h3>
  a.Reshape(3, 3);
  matrix b=a;
<h3>Print(&quot;matrix b \n&quot;, b);</h3>
  Print(&quot;b.Norm(MATRIX_NORM_P2)=&quot;, b.Norm(MATRIX_NORM_FROBENIUS));
  Print(&quot;b.Norm(MATRIX_NORM_FROBENIUS)=&quot;, b.Norm(MATRIX_NORM_FROBENIUS));
  Print(&quot;b.Norm(MATRIX_NORM_INF)&quot;, b.Norm(MATRIX_NORM_INF));
  Print(&quot;b.Norm(MATRIX_NORM_MINUS_INF)&quot;, b.Norm(MATRIX_NORM_MINUS_INF));
  Print(&quot;b.Norm(MATRIX_NORM_P1)=)&quot;, b.Norm(MATRIX_NORM_P1));
  Print(&quot;b.Norm(MATRIX_NORM_MINUS_P1)=&quot;, b.Norm(MATRIX_NORM_MINUS_P1));
  Print(&quot;b.Norm(MATRIX_NORM_P2)=&quot;, b.Norm(MATRIX_NORM_P2));
  Print(&quot;b.Norm(MATRIX_NORM_MINUS_P2)=&quot;, b.Norm(MATRIX_NORM_MINUS_P2));
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  matrix a
  [[-4,-3,-2,-1,0,1,2,3,4]]
  matrix b
  [[-4,-3,-2]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1486
  [-1,0,1]
  [2,3,4]]
  b.Norm(MATRIX_NORM_P2)=7.745966692414834
  b.Norm(MATRIX_NORM_FROBENIUS)=7.745966692414834
  b.Norm(MATRIX_NORM_INF)9.0
  b.Norm(MATRIX_NORM_MINUS_INF)2.0
  b.Norm(MATRIX_NORM_P1)=)7.0
  b.Norm(MATRIX_NORM_MINUS_P1)=6.0
  b.Norm(MATRIX_NORM_P2)=7.348469228349533
  b.Norm(MATRIX_NORM_MINUS_P2)=1.857033188519056e-16
  */
<h3>Exemplo em Python:</h3>
import numpy as np
from numpy import linalg as LA
a = np.arange(9) - 4
print(&quot;a \n&quot;,a)
b = a.reshape((3, 3))
print(&quot;b \n&quot;,b)
print(&quot;LA.norm(b)=&quot;,LA.norm(b))
print(&quot;LA.norm(b, &#x27;fro&#x27;)=&quot;,LA.norm(b, &#x27;fro&#x27;))
print(&quot;LA.norm(b, np.inf)=&quot;,LA.norm(b, np.inf))
print(&quot;LA.norm(b, -np.inf)=&quot;,LA.norm(b, -np.inf))
print(&quot;LA.norm(b, 1)=&quot;,LA.norm(b, 1))
print(&quot;LA.norm(b, -1)=&quot;,LA.norm(b, -1))
print(&quot;LA.norm(b, 2)=&quot;,LA.norm(b, 2))
print(&quot;LA.norm(b, -2)=&quot;,LA.norm(b, -2))
a 
 [-4 -3 -2 -1  0  1  2  3  4]
b 
 [[-4 -3 -2]
 [-1  0  1]
 [ 2  3  4]]
<h3>LA.norm(b)= 7.745966692414834</h3>
<h3>LA.norm(b, &#x27;fro&#x27;)= 7.745966692414834</h3>
<h3>LA.norm(b, np.inf)= 9.0</h3>
<h3>LA.norm(b, -np.inf)= 2.0</h3>
<h3>LA.norm(b, 1)= 7.0</h3>
<h3>LA.norm(b, -1)= 6.0</h3>
<h3>LA.norm(b, 2)= 7.3484692283495345</h3>
<h3>LA.norm(b, -2)= 1.857033188519056e-16</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1487
<h3>Cond</h3>
Calcula o n√∫mero de condicionamento da matriz.
</p>
<pre><code class="language-mql5">
double matrix::Cond(
</code></pre>
<p>
¬† const ENUM_MATRIX_NORM¬† norm      //¬†norma da matriz
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
norm
[in]  Ordem da norma a partir da enumera√ß√£o ENUM_MATRIX_NORM.
<h3>Valor retornado</h3>
N√∫mero de condicionamento da matriz. Pode ser infinito.
<h3>Observa√ß√£o</h3>
O n√∫mero de condicionamento x √© definido como o produto da norma x e seu inverso x [1]. Nesse
caso, a norma pode ser a norma L2 usual (raiz da soma dos quadrados) ou uma norma matricial
diferente.
O n√∫mero de condicionamento (ou medida) de uma matriz √© o valor K, que √© igual ao produto das
normas da matriz A e seu inverso. Matrizes com um grande n√∫mero de condicionamento s√£o
chamadas mal condicionadas e vice-versa, matrizes com um pequeno n√∫mero s√£o chamadas bem
condicionadas. A matriz inversa √© obtida usando a pseudo-invers√£o, para n√£o se limitar √† condi√ß√£o
de que a matriz seja quadrada e n√£o-singular.
Uma exce√ß√£o √© o n√∫mero de condicionamento espectral.
Algoritmo simples para calcular o n√∫mero de condicionamento espectral em MQL5:
</p>
<pre><code class="language-mql5">
double MatrixCondSpectral(matrix&amp; a)
  {
   double norm=0.0;
   vector v=a.Spectrum();
   if(v.Size()&gt;0)
     {
      double max_norm=v[0];
      double min_norm=v[0];
      for(ulong i=1; i&lt;v.Size(); i++)
        {
         double real=MathAbs(v[i]);
         if(max_norm&lt;real)
            max_norm=real;
         if(min_norm&gt;real)
            min_norm=real;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1488
</p>
<pre><code class="language-mql5">
        }
      max_norm=MathSqrt(max_norm);
      min_norm=MathSqrt(min_norm);
      if(min_norm&gt;0.0)
         norm=max_norm/min_norm;
     }
   return(norm);
</code></pre>
<p>
  }
<h3>Exemplo em MQL5:</h3>
  matrix a= {{1, 0, -1}, {0, 1, 0}, { 1, 0, 1}};
  Print(&quot;a.Cond(MATRIX_NORM_P2)=&quot;, a.Cond(MATRIX_NORM_P2));
  Print(&quot;a.Cond(MATRIX_NORM_FROBENIUS)=&quot;, a.Cond(MATRIX_NORM_FROBENIUS));
  Print(&quot;a.Cond(MATRIX_NORM_INF)=&quot;, a.Cond(MATRIX_NORM_INF));
  Print(&quot;a.Cond(MATRIX_NORM_MINUS_INF)=&quot;, a.Cond(MATRIX_NORM_MINUS_INF));
  Print(&quot;a.Cond(MATRIX_NORM_P1)=)&quot;, a.Cond(MATRIX_NORM_P1));
  Print(&quot;a.Cond(MATRIX_NORM_MINUS_P1)=&quot;, a.Cond(MATRIX_NORM_MINUS_P1));
  Print(&quot;a.Cond(MATRIX_NORM_P2)=&quot;, a.Cond(MATRIX_NORM_P2));
  Print(&quot;a.Cond(MATRIX_NORM_MINUS_P2)=&quot;, a.Cond(MATRIX_NORM_MINUS_P2));
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  matrix a
  [[1,0,-1]
  [0,1,0]
  [1,0,1]]
  a.Cond(MATRIX_NORM_P2)=1.414213562373095
  a.Cond(MATRIX_NORM_FROBENIUS)=3.162277660168379
  a.Cond(MATRIX_NORM_INF)=2.0
  a.Cond(MATRIX_NORM_MINUS_INF)=0.9999999999999997
  a.Cond(MATRIX_NORM_P1)=)2.0
  a.Cond(MATRIX_NORM_MINUS_P1)=0.9999999999999998
  a.Cond(MATRIX_NORM_P2)=1.414213562373095
  a.Cond(MATRIX_NORM_MINUS_P2)=0.7071067811865472
  */
<h3>Exemplo em Python:</h3>
import numpy as np
from numpy import linalg as LA
a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
print(&quot;a \n&quot;,a)
print(&quot;LA.cond(a)=&quot;,LA.cond(a))
print(&quot;LA.cond(a, &#x27;fro&#x27;)=&quot;,LA.cond(a, &#x27;fro&#x27;))
print(&quot;LA.cond(a, np.inf)=&quot;,LA.cond(a, np.inf))
print(&quot;LA.cond(a, -np.inf)=&quot;,LA.cond(a, -np.inf))</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1489
print(&quot;LA.cond(a, 1)=&quot;,LA.cond(a, 1))
print(&quot;LA.cond(a, -1)=&quot;,LA.cond(a, -1))
print(&quot;LA.cond(a, 2)=&quot;,LA.cond(a, 2))
print(&quot;LA.cond(a, -2)=&quot;,LA.cond(a, -2))
a 
 [[ 1  0 -1]
 [ 0  1  0]
 [ 1  0  1]]
<h3>LA.cond(a)= 1.4142135623730951</h3>
<h3>LA.cond(a, &#x27;fro&#x27;)= 3.1622776601683795</h3>
<h3>LA.cond(a, np.inf)= 2.0</h3>
<h3>LA.cond(a, -np.inf)= 1.0</h3>
<h3>LA.cond(a, 1)= 2.0</h3>
<h3>LA.cond(a, -1)= 1.0</h3>
<h3>LA.cond(a, 2)= 1.4142135623730951</h3>
<h3>LA.cond(a, -2)= 0.7071067811865475</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1490
<h3>Det</h3>
Calcula o determinante de uma matriz quadrada n√£o degenerada
</p>
<pre><code class="language-mql5">
double matrix::Det()
</code></pre>
<p>
<h3>Valor retornado</h3>
Calcula o determinante de uma matriz.
<h3>Observa√ß√£o</h3>
Determinantes de matrizes de 2¬™ e 3¬™ ordens s√£o calculados de acordo com a regra de Sarrus.
d2=a11*a22-a12*a21; 
d3=a11*a22*a33+a12*a23*a31+a13*a21*a32-a13*a22*a31-a11*a23*a32-
a12*a21*a33
O determinante √© calculado pelo m√©todo de elimina√ß√£o de Gauss-Jordan, reduzindo a matriz a uma
forma triangular superior. O determinante de uma matriz triangular superior √© igual ao produto dos
termos da diagonal principal.
Se pelo menos uma linha (coluna) da matriz for zero, o determinante ser√° zero.
Se duas (ou mais) linhas (colunas) de uma matriz s√£o linearmente dependentes, seu determinante
ser√° zero.
O determinante da matriz √© igual ao produto de seus autovalores.
<h3>Exemplo em MQL5:</h3>
</p>
<pre><code class="language-mql5">
   matrix m={{1,2},{3,4}};
   double det=m.Det();
   Print(&quot;matrix m\n&quot;,m);
   Print(&quot;det(m)=&quot;,det);
   /*
   matrix m
   [[1,2]
    [3,4]]
   det(m)=-2.0      
   */
</code></pre>
<p>
<h3>Exemplo em Python:</h3>
import numpy as np
a = np.array([[1, 2], [3, 4]])
print(&#x27;a \n&#x27;,a)
print(&#x27;nnp.linalg.det(a) \n&#x27;,np.linalg.det(a))
a </p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1491
 [[1 2]
 [3 4]]
np.linalg.det(a) 
 -2.0000000000000004</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1492
<h3>SLogDet</h3>
Calcula o sinal e o logaritmo do determinante de uma matriz.
</p>
<pre><code class="language-mql5">
double matrix::SLogDet(
</code></pre>
<p>
¬† int&amp;¬† sign¬†     //¬†sinal
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
sign
[out]  O sinal do determinante. Se o valor sign for par, o determinante ser√° positivo.
<h3>Valor retornado</h3>
N√∫mero que representa o sinal do determinante.
<h3>Observa√ß√£o</h3>
O determinante √© calculado pelo m√©todo de elimina√ß√£o de Gauss-Jordan, reduzindo a matriz a uma
forma triangular superior. O determinante de uma matriz triangular superior √© igual ao produto dos
termos da diagonal principal. O logaritmo de um produto √© igual √† soma dos logaritmos. Por isso, no
caso de um estouro ao calcular o determinante, o m√©todo SLogDet pode ser usado.
Se o valor sign for par, o determinante ser√° positivo.
<h3>Exemplo:</h3>
a = np.array([[1, 2], [3, 4]])  (sign, logdet) = np.linalg.slogdet(a)  (sign, logdet) </p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1493
<h3>Rank</h3>
Retorna o posto de uma matriz usando o m√©todo de Gauss.
</p>
<pre><code class="language-mql5">
int¬† Rank()
</code></pre>
<p>
<h3>Valor retornado</h3>
Posto da matriz.
<h3>Observa√ß√£o</h3>
O posto de um sistema de linhas (colunas) de uma matriz A com m linhas e n colunas √© o n√∫mero
m√°ximo de linhas (colunas) linearmente independentes. V√°rias linhas (colunas) s√£o chamadas
linearmente independentes se nenhuma delas puder ser expressa linearmente em termos de outras.
O posto do sistema de linhas √© sempre igual ao posto do sistema de colunas, e esse n√∫mero √©
chamado de posto da matriz.
<h3>Exemplo em MQL5:</h3>
  matrix a=matrix::Eye(4, 4);;
<h3>Print(&quot;matrix a \n&quot;, a);</h3>
<h3>Print(&quot;a.Rank()=&quot;, a.Rank());</h3>
  matrix I=matrix::Eye(4, 4);
  I[3, 3] = 0.;    // d√©ficit da matriz
<h3>Print(&quot;I \n&quot;, I);</h3>
<h3>Print(&quot;I.Rank()=&quot;, I.Rank());</h3>
  matrix b=matrix::Ones(1, 4);
<h3>Print(&quot;b \n&quot;, b);</h3>
  Print(&quot;b.Rank()=&quot;, b.Rank());;// 1 dimens√£o - posto 1, a menos que todos sejam &quot;0&quot;.
  matrix  zeros=matrix::Zeros(4, 1);
<h3>Print(&quot;zeros \n&quot;, zeros);</h3>
<h3>Print(&quot;zeros.Rank()=&quot;, zeros.Rank());</h3>
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  matrix a
  [[1,0,0,0]
  [0,1,0,0]
  [0,0,1,0]
  [0,0,0,1]]
  a.Rank()=4
<h3>I</h3>
  [[1,0,0,0]
  [0,1,0,0]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1494
  [0,0,1,0]
  [0,0,0,0]]
<h3>I.Rank()=3</h3>
  b
  [[1,1,1,1]]
  b.Rank()=1
  zeros
  [[0]
  [0]
  [0]
  [0]]
  zeros.Rank()=0
  */
<h3>Exemplo em Python:</h3>
import numpy as np
from numpy.linalg import matrix_rank
a=(np.eye(4)) # Full rank matrix
print(&quot;a \n&quot;, a)
print(&quot;matrix_rank(a)=&quot;,matrix_rank(a))
<h3>I=np.eye(4)</h3>
I[-1,-1] = 0. # rank deficient matrix
print(&quot;I \n&quot;,I)
print(&quot;matrix_rank(I)=&quot;,matrix_rank(I))
b=np.ones((4,))
print(&quot;b \n&quot;,b)
print(&quot;matrix_rank(b)=&quot;,matrix_rank(b)) # 1 dimension - rank 1 unless all 0
zeros=np.zeros((4,))
print(&quot;zeroes \n&quot;,zeros)
print(&quot;matrix_rank(zeros)=&quot;,matrix_rank(zeros))
a 
 [[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 1.]]
matrix_rank(a)= 4
<h3>I</h3>
 [[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 0.]]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1495
matrix_rank(I)= 3
b 
 [1. 1. 1. 1.]
matrix_rank(b)= 1
zeroes 
 [0. 0. 0. 0.]
matrix_rank(zeros)= 0</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1496
<h3>Trace</h3>
Retorna a soma dos elementos ao longo das diagonais da matriz.
</p>
<pre><code class="language-mql5">
double matrix::Trace()
</code></pre>
<p>
<h3>Valor retornado</h3>
Soma dos elementos ao longo da diagonal.
<h3>Observa√ß√£o</h3>
O de uma matriz √© igual √† soma de seus autovalores.
<h3>Exemplo em MQL5:</h3>
  matrix a= {{0, 1, 2, 3, 4, 5, 6, 7, 8}};
  a.Reshape(3, 3);
<h3>Print(&quot;matrix a \n&quot;, a);</h3>
<h3>Print(&quot;a.Trace() \n&quot;, a.Trace());</h3>
</p>
<pre><code class="language-mql5">
  /*
</code></pre>
<p>
  matrix a
  [[0,1,2]
  [3,4,5]
  [6,7,8]]
  a.Trace()
  12.0
  */
<h3>Exemplo em Python:</h3>
a = np.arange(9).reshape((3,3))
print(&#x27;a \n&#x27;,a)
print(&#x27;np.trace(a) \n&#x27;,np.trace(a))
a 
 [[0 1 2]
 [3 4 5]
 [6 7 8]]
np.trace(a) 
 12</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1497
<h3>Spectrum</h3>
Retorna o espectro de uma matriz como um conjunto de seus autovalores do produto AT*A.
vector matrix::Spectrum()
<h3>Valor retornado</h3>
Espectro de uma matriz como um vetor de autovalores da matriz.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
double MatrixCondSpectral(matrix&amp; a)
  {
   double norm=0.0;
   vector v=a.Spectrum();
   if(v.Size()&gt;0)
     {
      double max_norm=v[0];
      double min_norm=v[0];
      for(ulong i=1; i&lt;v.Size(); i++)
        {
         double real=MathAbs(v[i]);
         if(max_norm&lt;real)
            max_norm=real;
         if(min_norm&gt;real)
            min_norm=real;
        }
      max_norm=MathSqrt(max_norm);
      min_norm=MathSqrt(min_norm);
      if(min_norm&gt;0.0)
         norm=max_norm/min_norm;
     }
   return(norm);
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1498
M√©todos matriciais para resolver sistemas de equa√ß√µes
lineares
M√©todos de resolu√ß√£o de sistemas de equa√ß√µes lineares e c√°lculo da matriz inversa.
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Solve</h3>
Resolve uma equa√ß√£o de matriz linear ou um sistema de equa√ß√µes
alg√©bricas lineares
<h3>LstSq</h3>
<h3>Resolve</h3>
um 
sistema 
de 
equa√ß√µes 
alg√©bricas 
lineares
aproximadamente (para matrizes n√£o quadradas ou degeneradas)
<h3>Inv</h3>
Calcula uma matriz inversa multiplicativa em rela√ß√£o a uma matriz
quadrada n√£o degenerada usando o m√©todo Gauss-Jordan
<h3>PInv</h3>
<h3>Calcula o pseudoinverso pelo m√©todo Moore-Penrose</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1499
<h3>Solve</h3>
Resolve uma equa√ß√£o de matriz linear ou um sistema de equa√ß√µes alg√©bricas lineares.
vector matrix::Solve(
¬† const vector¬† b¬†     //¬†valores do ordenado ou &quot;vari√°vel dependente&quot;.
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
b
[in]  Valores do ordenado ou &quot;vari√°vel dependente&quot;. (Vetor de membros livres).
<h3>Valor retornado</h3>
Vetor com solu√ß√£o de sistema a * x = b.
<h3>Observa√ß√£o</h3>
Se pelo menos uma linha (coluna) da matriz for zero, o sistema n√£o tem solu√ß√£o.
Se duas (ou v√°rias) linhas (colunas) da matriz forem linearmente dependentes, o sistema n√£o tem
solu√ß√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- solu√ß√£o
   vector_x=matrix_a.Solve(vector_b);
//--- verificamos se est√° correto a * x = b
   result_vector=matrix_a.MatMul(vector_x);
   errors=vector_b.Compare(result_vector,1e-12);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1500
<h3>LstSq</h3>
Resolve um sistema de equa√ß√µes alg√©bricas lineares aproximadamente (para matrizes n√£o quadradas
ou degeneradas).
vector matrix::LstSq(
¬† const vector¬† b¬†     //¬†valores do ordenado ou &quot;vari√°vel dependente&quot;.
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
b
[in]  Valores do ordenado ou &quot;vari√°vel dependente&quot;. (Vetor de membros livres)
<h3>Valor retornado</h3>
Vetor com solu√ß√£o de sistema a * x = b. Isso √© verdade apenas para sistemas que t√™m uma solu√ß√£o
exata.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   matrix a={{3, 2},
             {4,-5},
             {3, 3}};
   vector b={7,40,3};
//---
   vector x=a.LstSq(b);
//--- verifica√ß√£o, deve ser [5, -4]
   Print(&quot;x=&quot;, x);
//--- verifica√ß√£o, deve ser [7, 40, 3]
   vector b1=a.MatMul(x);
   Print(&quot;b1=&quot;,b1);
/*
</code></pre>
<p>
  x=[5.000000000000002,-4]
  b1=[7.000000000000005,40.00000000000001,3.000000000000005]
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1501
<h3>Inv</h3>
Calcula uma matriz inversa multiplicativa em rela√ß√£o a uma matriz quadrada n√£o degenerada usando o
m√©todo Gauss-Jordan.
matrix matrix::Inv()
<h3>Valor retornado</h3>
Matriz inversa multiplicativa.
<h3>Observa√ß√£o</h3>
O produto da matriz inicial e da matriz inversa √© a matriz identidade.
Se pelo menos uma linha (coluna) da matriz for zero, a matriz inversa n√£o pode ser obtida.
Se duas (ou mais) linhas (colunas) de uma matriz s√£o linearmente dependentes, ent√£o a matriz
inversa n√£o pode ser obtida.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int TestInverse(const int size_m)
  {
   int    i,j,errors=0;
   matrix matrix_a(size_m,size_m);
//--- preenchemos a matriz quadrada
   MatrixTestFirst(matrix_a);
//--- medimos microssegundos
   ulong t1=GetMicrosecondCount();
//--- obtemos uma matriz inversa
   matrix inverse=matrix_a.Inv();
//--- medimos
   ulong t2=GetMicrosecondCount();
//--- verificamos se est√° correto
   matrix identity=matrix_a.MatMul(inverse);
//---
   for(i=0; i&lt;size_m; i++)
     {
      for(j=0; j&lt;size_m; j++)
        {
         double value;
         //--- diagonal principal deve conter o valor um
         if(i==j)
            value=1.0;
         else
            value=0.0;
         if(MathClassify(identity[i][j])&gt;FP_ZERO)
            errors++;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1502
</p>
<pre><code class="language-mql5">
         else
           {
            if(identity[i][j]!=value)
              {
               double diff=MathAbs(identity[i][j]-value);
               //--- muitas multiplica√ß√µes e divis√µes, por isso reduzimos a precis√£o d
               if(diff&gt;1e-9)
                  errors++;
              }
           }
        }
     }
//---
   double elapsed_time=double(t2-t1)/1000.0;
   printf(&quot;Inversion of matrix %d x %d  %s  errors=%d  time=%.3f ms&quot;,size_m,size_m,err
   return(errors);
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1503
<h3>PInv</h3>
Calcula o pseudoinverso pelo m√©todo Moore-Penrose.
matrix matrix::PInv()
<h3>Valor retornado</h3>
Matriz pseudo-inversa.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int TestPseudoInverse(const int size_m, const int size_k)
  {
   matrix matrix_a(size_m,size_k);
   matrix matrix_inverted(size_k,size_m);
   matrix matrix_temp;
   matrix matrix_a2;
//--- preenchemos a matriz
   MatrixTestFirst(matrix_a);
//--- invertemos
   matrix_inverted=matrix_a.PInv();
//--- verificamos se est√° correto
   int errors=0;
//--- A * A+ * A = A   (A+ - matriz pseudo inversa de A)
   matrix_temp=matrix_a.MatMul(matrix_inverted);
   matrix_a2=matrix_temp.MatMul(matrix_a);
   errors=(int)matrix_a.CompareByDigits(matrix_a2,10);
   printf(&quot;PseudoInversion %s matrix_size  %d x %d  errors=%d&quot;,errors==0?&quot;passed&quot;:&quot;fai
//---
   return(errors);
</code></pre>
<p>
  }</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1504
<h3>Aprendizado de m√°quina</h3>
M√©todos para aprendizado de m√°quina.
A fun√ß√£o de ativa√ß√£o de uma rede neural determina o valor de sa√≠da de um neur√¥nio dependendo do
resultado da soma ponderada das entradas. A escolha da fun√ß√£o de ativa√ß√£o tem um grande impacto
nas capacidades e no desempenho da rede neural. Diferentes partes do modelo (camadas) podem usar
diferentes fun√ß√µes de ativa√ß√£o.
MQL5 implementa n√£o apenas todas as fun√ß√µes de ativa√ß√£o conhecidas, mas tamb√©m suas derivadas.
As fun√ß√µes derivadas permitem que os par√¢metros do modelo sejam atualizados eficientemente com
base no processo de treinamento.
A tarefa por tr√°s do treinamento de uma rede neural √© encontrar um algoritmo que minimize o erro na
amostra de treinamento, utilizando a fun√ß√£o de perda (loss function). O valor da fun√ß√£o perda
caracteriza a magnitude do desvio do valor previsto pelo modelo em rela√ß√£o ao real. Dependendo do
tipo de problema que est√° sendo resolvido, diferentes fun√ß√µes de perda s√£o usadas. Por exemplo: para
um problema de regress√£o mean squared error (MSE), para a classifica√ß√£o bin√°ria binary cross-entropy
(BCE).
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>Activation</h3>
Calcula os valores da fun√ß√£o de ativa√ß√£o e registra no
vetor/matriz passado
<h3>Derivative</h3>
Calcula os valores da derivada da fun√ß√£o de ativa√ß√£o e
escreve no vetor/matriz passado
<h3>Loss</h3>
Calcula os valores da fun√ß√£o de perda e grava no
vetor/matriz passado
<h3>LossGradient</h3>
Calcula o vetor ou a matriz de gradiente da fun√ß√£o de perda
<h3>RegressionMetric</h3>
Calcula a m√©trica de regress√£o como o erro de desvio da
linha de regress√£o criada na matriz de dados especificada
<h3>ConfusionMatrix</h3>
Calcula a matriz de erros. O m√©todo √© aplicado a um vetor de
valores previstos
<h3>ConfusionMatrixMultilabel</h3>
Calcula a matriz de erros para cada r√≥tulo. O m√©todo √©
aplicado a um vetor de valores previstos
<h3>ClassificationMetric</h3>
Calcula uma m√©trica de classifica√ß√£o para avaliar a qualidade
dos dados previstos em rela√ß√£o aos dados reais. O m√©todo √©
aplicado a um vetor de valores previstos
<h3>ClassificationScore</h3>
Diferentemente de outros m√©todos na se√ß√£o Aprendizado de
m√°quina, esse m√©todo √© aplicado a um vetor de valores reais
em vez de um vetor de valores previstos
<h3>PrecisionRecall</h3>
Calcula os valores para tra√ßar a curva precision-recall. Esse
m√©todo, assim como o m√©todo ClassificationScore, √©
aplicado a um vetor de valores verdadeiros</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1505
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>ReceiverOperatingCharacteristic</h3>
Calcula os valores para tra√ßar a curva Receiver Operating
Characteristic (ROC). Esse m√©todo, assim como o m√©todo
ClassificationScore, √© aplicado a um vetor de valores
verdadeiros
<h3>Exemplo:</h3>
Este exemplo mostra o treinamento de um modelo usando opera√ß√µes de matriz. O modelo aprende
com a fun√ß√£o (a + b + c)^2 / (a^2 + b^2 + c^2). A entrada √© uma matriz de dados iniciais, na qual a, b
e c est√£o contidos em colunas separadas. A sa√≠da do modelo retorna o resultado da fun√ß√£o.
matrix weights1, weights2, weights3;               // matrizes de pesos
matrix output1, output2, result;                   // matrizes de sa√≠da das camadas ne
</p>
<pre><code class="language-mql5">
input int layer1 = 200;                            // tamanho da 1¬™ camada oculta
input int layer2 = 200;                            // tamanho da 2¬™ camada oculta
input int Epochs = 20000;                          // n√∫mero de √©pocas de aprendizado
input double lr = 3e-6;                            // taxa de aprendizado
input ENUM_ACTIVATION_FUNCTION ac_func = AF_SWISH; // fun√ß√£o de ativa√ß√£o
//+------------------------------------------------------------------+
//| Fun√ß√£o para executar o script                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   int train = 1000;    // tamanho da amostra de treinamento
   int test = 10;       // tamanho da amostra de teste
   matrix m_data, m_target;
//--- geramos uma amostra de treinamento
   if(!CreateData(m_data, m_target, train))  
      return;
//--- treinamos o modelo
   if(!Train(m_data, m_target, Epochs))      
      return;
//--- geramos uma amostra de teste
   if(!CreateData(m_data, m_target, test))   
      return;
//--- teste do modelo
   Test(m_data, m_target);                   
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| M√©todo de gera√ß√£o de amostras                                    |
//+------------------------------------------------------------------+
bool CreateData(matrix &amp;data, matrix &amp;target, const int count)
  {
//--- inicializamos as matrizes de entrada e sa√≠da
   if(!data.Init(count, 3) || !target.Init(count, 1))
      return false;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1506
</p>
<pre><code class="language-mql5">
//--- preenchemos a matriz de dados inicial com valores aleat√≥rios
   data.Random(-10, 10);                     
//--- calculamos os valores-alvo para a amostra de treinamento
   vector X1 = MathPow(data.Col(0) + data.Col(1) + data.Col(1), 2);
   vector X2 = MathPow(data.Col(0), 2) + MathPow(data.Col(1), 2) + MathPow(data.Col(2)
   if(!target.Col(X1 / X2, 0))
      return false;
//--- retornamos o resultado
   return true;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| M√©todo de treinamento modelo                                     |
//+------------------------------------------------------------------+
bool Train(matrix &amp;data, matrix &amp;target, const int epochs = 10000)
  {
//--- criamos o modelo
   if(!CreateNet())
      return false;
//--- treinamos o modelo
   for(int ep = 0; ep &lt; epochs; ep++)
     {
      //--- propaga√ß√£o
      if(!FeedForward(data))
         return false;
      PrintFormat(&quot;Epoch %d, loss %.5f&quot;, ep, result.Loss(target, LOSS_MSE));
      //--- retropropaga√ß√£o e atualiza√ß√£o das matrizes de pesos
      if(!Backprop(data, target))
         return false;
     }
//--- retornamos o resultado
   return true;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| M√©todo de cria√ß√£o do modelo                                      |
//+------------------------------------------------------------------+
bool CreateNet()
  {
//--- inicializamos as matrizes de peso
   if(!weights1.Init(4, layer1) || !weights2.Init(layer1 + 1, layer2) || !weights3.Ini
      return false;
//--- preenchemos as matrizes de peso com valores aleat√≥rios
   weights1.Random(-0.1, 0.1);
   weights2.Random(-0.1, 0.1);
   weights3.Random(-0.1, 0.1);
//--- retornamos o resultado
   return true;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| M√©todo de propaga√ß√£o                                             |</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1507
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
bool FeedForward(matrix &amp;data)
  {
//--- verificamos o tamanho dos dados de entrada
   if(data.Cols() != weights1.Rows() - 1)
      return false;
//--- calculamos a primeira camada neural
   matrix temp = data;
   if(!temp.Resize(temp.Rows(), weights1.Rows()) ||
      !temp.Col(vector::Ones(temp.Rows()), weights1.Rows() - 1))
      return false;
   output1 = temp.MatMul(weights1);
//--- calculamos a fun√ß√£o de ativa√ß√£o
   if(!output1.Activation(temp, ac_func))
      return false;
//--- calculamos a segunda camada neural
   if(!temp.Resize(temp.Rows(), weights2.Rows()) ||
      !temp.Col(vector::Ones(temp.Rows()), weights2.Rows() - 1))
      return false;
   output2 = temp.MatMul(weights2);
//--- calculamos a fun√ß√£o de ativa√ß√£o
   if(!output2.Activation(temp, ac_func))
      return false;
//--- calculamos a terceira camada neural
   if(!temp.Resize(temp.Rows(), weights3.Rows()) ||
      !temp.Col(vector::Ones(temp.Rows()), weights3.Rows() - 1))
      return false;
   result = temp.MatMul(weights3);
//--- retornamos o resultado
   return true;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| M√©todo de retropropaga√ß√£o                                        |
//+------------------------------------------------------------------+
bool Backprop(matrix &amp;data, matrix &amp;target)
  {
//--- verificamos a dimensionalidade da matriz de valores-alvo
   if(target.Rows() != result.Rows() ||
      target.Cols() != result.Cols())
      return false;
//--- determinamos o desvio dos valores calculados em rela√ß√£o aos valores alvo
   matrix loss = (target - result) * 2;
//--- tra√ßamos um gradiente para a camada anterior
   matrix gradient = loss.MatMul(weights3.Transpose());
//--- atualizamos a matriz de peso da √∫ltima camada
   matrix temp;
   if(!output2.Activation(temp, ac_func))
      return false;
   if(!temp.Resize(temp.Rows(), weights3.Rows()) ||</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1508
</p>
<pre><code class="language-mql5">
      !temp.Col(vector::Ones(temp.Rows()), weights3.Rows() - 1))
      return false;
   weights3 = weights3 + temp.Transpose().MatMul(loss) * lr;
//--- ajustamos o gradiente de erro pela derivada da fun√ß√£o de ativa√ß√£o
   if(!output2.Derivative(temp, ac_func))
      return false;
   if(!gradient.Resize(gradient.Rows(), gradient.Cols() - 1))
      return false;
   loss = gradient * temp;
//--- diminu√≠mos o gradiente para uma camada abaixo
   gradient = loss.MatMul(weights2.Transpose());
//--- atualizamos a matriz de peso da 2¬™ camada oculta
   if(!output1.Activation(temp, ac_func))
      return false;
   if(!temp.Resize(temp.Rows(), weights2.Rows()) ||
      !temp.Col(vector::Ones(temp.Rows()), weights2.Rows() - 1))
      return false;
   weights2 = weights2 + temp.Transpose().MatMul(loss) * lr;
//--- ajustamos o gradiente de erro pela derivada da fun√ß√£o de ativa√ß√£o
   if(!output1.Derivative(temp, ac_func))
      return false;
   if(!gradient.Resize(gradient.Rows(), gradient.Cols() - 1))
      return false;
   loss = gradient * temp;
//--- atualizamos a matriz de peso da 1¬™ camada oculta
   temp = data;
   if(!temp.Resize(temp.Rows(), weights1.Rows()) ||
      !temp.Col(vector::Ones(temp.Rows()), weights1.Rows() - 1))
      return false;
   weights1 = weights1 + temp.Transpose().MatMul(loss) * lr;
//--- retornamos o resultado
   return true;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| M√©todo de teste do modelo                                        |
//+------------------------------------------------------------------+
bool Test(matrix &amp;data, matrix &amp;target)
  {
//--- propaga√ß√£o nos dados de teste
   if(!FeedForward(data))
      return false;
//--- registramos no log os resultados do c√°lculo do modelo e os valores verdadeiros
   PrintFormat(&quot;Test loss %.5f&quot;, result.Loss(target, LOSS_MSE));
   ulong total = data.Rows();
   for(ulong i = 0; i &lt; total; i++)
      PrintFormat(&quot;(%.2f + %.2f + %.2f)^2 / (%.2f^2 + %.2f^2 + %.2f^2) =  Net %.2f, Ta
                  data[i, 0], data[i, 1], data[i, 2], result[i, 0], target[i, 0]);
//--- retornamos o resultado
   return true;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1509
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1510
<h3>Activation</h3>
Calcula os valores da fun√ß√£o de ativa√ß√£o e os grava no vetor/matriz transmitido.
</p>
<pre><code class="language-mql5">
bool vector::Activation(
</code></pre>
<p>
  vector&amp;¬†                  vect_out,¬†     //¬†vetor para obter valores
  ENUM_ACTIVATION_FUNCTION¬† activation,    //¬†fun√ß√£o de ativa√ß√£o
</p>
<pre><code class="language-mql5">
   ...¬†                                    // par√¢metros adicionais
   );
bool matrix::Activation(
</code></pre>
<p>
  matrix&amp;¬†                  matrix_out,¬†   //¬†matriz para obter valores
  ENUM_ACTIVATION_FUNCTION¬† activation     //¬†fun√ß√£o de ativa√ß√£o
</p>
<pre><code class="language-mql5">
   );
bool matrix::Activation(
</code></pre>
<p>
  matrix&amp;¬†                  matrix_out,¬†   //¬†matriz para obter valores
  ENUM_ACTIVATION_FUNCTION¬† activation,    //¬†fun√ß√£o de ativa√ß√£o
<h3>ENUM_MATRIX_AXIS     ¬†    axis,          //¬†eixo</h3>
</p>
<pre><code class="language-mql5">
   ...¬†                                    // par√¢metros adicionais
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vect_out/matrix_out
[out]  Vetor ou matriz para obter os valores calculados da fun√ß√£o de ativa√ß√£o.
activation
[in]  Fun√ß√£o de ativa√ß√£o a partir da enumera√ß√£o ENUM_ACTIVATION_FUNCTION.
axis
[in]  Valor a partir da enumera√ß√£o ENUM_MATRIX_AXIS (AXIS_HORZ ‚Äî eixo horizontal, AXIS_VERT
‚Äî eixo vertical).
...
[in]  Par√¢metros adicionais necess√°rios para algumas fun√ß√µes de ativa√ß√£o. Se nenhum par√¢metro
</p>
<pre><code class="language-mql5">
for especificado, ser√£o usados os valores padr√£o.
</code></pre>
<p>
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false.
<h3>Par√¢metros adicionais</h3>
Algumas fun√ß√µes de ativa√ß√£o aceitam par√¢metros adicionais. Se nenhum par√¢metro for
especificado, ser√£o usados os valores padr√£o</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1511
</p>
<pre><code class="language-mql5">
   AF_ELU  (Exponential Linear Unit)  
     double alpha=1.0
   
   Fun√ß√£o de ativa√ß√£o: if(x&gt;=0) f(x) = x
                      else f(x) = alpha * (exp(x)-1)
   
   
   AF_LINEAR   
     double alpha=1.0
     double beta=0.0
   
   Fun√ß√£o de ativa√ß√£o: f(x) = alpha*x + beta
   
   
   AF_LRELU   (Leaky REctified Linear Unit)   
     double alpha=0.3
   
   Fun√ß√£o de ativa√ß√£o: if(x&gt;=0) f(x)=x
                      else f(x) = alpha*x
   
                        
   AF_RELU  (REctified Linear Unit)   
     double alpha=0.0
     double max_value=0.0
     double treshold=0.0
   
   Fun√ß√£o de ativa√ß√£o: if(alpha==0) f(x) = max(x,0)
                      else if(x&gt;max_value) f(x) = x
                      else f(x) = alpha*(x - treshold)
   
   
   AF_SWISH   
     double beta=1.0
   
   Fun√ß√£o de ativa√ß√£o: f(x) = x / (1+exp(-x*beta))
   
   
   AF_TRELU   (Thresholded REctified Linear Unit)   
     double theta=1.0
   
   Fun√ß√£o de ativa√ß√£o: if(x&gt;theta) f(x) = x
                      else f(x) = 0
   
   
   AF_PRELU   (Parametric REctified Linear Unit)   
     double alpha[] - learned array of coeefficients
   </p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1512
</p>
<pre><code class="language-mql5">
   Fun√ß√£o de ativa√ß√£o: if(x[i]&gt;=0) f(x)[i] = x[i]
                      else f(x)[i] = alpha[i] * x[i]
</code></pre>
<p>
<h3>Observa√ß√£o</h3>
Nas redes neurais artificiais, a fun√ß√£o de ativa√ß√£o do neur√¥nio determina o sinal de sa√≠da, que √©
determinado pelo sinal de entrada ou pelo conjunto de sinais de entrada. A escolha da fun√ß√£o de
ativa√ß√£o tem um grande impacto sobre os recursos e o desempenho da rede neural. Diferentes
partes do modelo (camadas) podem usar diferentes fun√ß√µes de ativa√ß√£o.
<h3>Exemplos do uso de par√¢metros adicionais:</h3>
</p>
<pre><code class="language-mql5">
   vector x={0.1, 0.4, 0.9, 2.0, -5.0, 0.0, -0.1};
   vector y;
   x.Activation(y,AF_ELU);
   Print(y);
   x.Activation(y,AF_ELU,2.0);
   Print(y);
   Print(&quot;&quot;);
   x.Activation(y,AF_LINEAR);
   Print(y);
   x.Activation(y,AF_LINEAR,2.0);
   Print(y);
   x.Activation(y,AF_LINEAR,2.0,5.0);
   Print(y);
   Print(&quot;&quot;);
   x.Activation(y,AF_LRELU);
   Print(y);
   x.Activation(y,AF_LRELU,1.0);
   Print(y);
   x.Activation(y,AF_LRELU,0.1);
   Print(y);
  
   Print(&quot;&quot;);
   x.Activation(y,AF_RELU);
   Print(y);
   x.Activation(y,AF_RELU,2.0,0.5);
   Print(y);
   x.Activation(y,AF_RELU,2.0,0.5,1.0);
   Print(y);
   Print(&quot;&quot;);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1513
</p>
<pre><code class="language-mql5">
   x.Activation(y,AF_SWISH);
   Print(y);
   x.Activation(y,AF_SWISH,2.0);
   Print(y);
   Print(&quot;&quot;);
   x.Activation(y,AF_TRELU);
   Print(y);
   x.Activation(y,AF_TRELU,0.3);
   Print(y);
   Print(&quot;&quot;);
   vector a=vector::Full(x.Size(),2.0);
   x.Activation(y,AF_PRELU,a);
   Print(y);
/*  Resultados
   [0.1,0.4,0.9,2,-0.993262053000915,0,-0.095162581964040]
   [0.1,0.4,0.9,2,-1.986524106001829,0,-0.190325163928081]
   
   [0.1,0.4,0.9,2,-5,0,-0.1]
   [0.2,0.8,1.8,4,-10,0,-0.2]
   [5.2,5.8,6.8,9,-5,5,4.8]
   
   [0.1,0.4,0.9,2,-1.5,0,-0.03]
   [0.1,0.4,0.9,2,-5,0,-0.1]
   [0.1,0.4,0.9,2,-0.5,0,-0.01]
   
   [0.1,0.4,0.9,2,0,0,0]
   [0.2,0.8,0.9,2,-10,0,-0.2]
   [-1.8,-1.2,0.9,2,-12,-2,-2.2]
   
   [0.052497918747894,0.239475064044981,0.6398545523625035,1.761594155955765,-0.033464
   [0.054983399731247,0.275989792451045,0.7723340415895611,1.964027580075817,-0.000226
   
   [0,0,0,2,0,0,0]
   [0,0.4,0.9,2,0,0,0]
   
   [0.1,0.4,0.9,2,-10,0,-0.2]
</code></pre>
<p>
*/  </p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1514
<h3>Derivative</h3>
Calcula os valores da derivada da fun√ß√£o de ativa√ß√£o e os grava no vetor/matriz transmitido.
</p>
<pre><code class="language-mql5">
bool vector::Derivative(
</code></pre>
<p>
  vector&amp;¬†                  vect_out,¬†     //¬†vetor para obter valores
  ENUM_ACTIVATION_FUNCTION¬† activation,    //¬†fun√ß√£o de ativa√ß√£o
</p>
<pre><code class="language-mql5">
   ...¬†                                    // par√¢metros adicionais
   );
bool matrix::Derivative(
</code></pre>
<p>
  matrix&amp;¬†                  matrix_out,¬†   //¬†matriz para obter valores
  ENUM_ACTIVATION_FUNCTION¬† activation,    //¬†fun√ß√£o de ativa√ß√£o
</p>
<pre><code class="language-mql5">
   );
bool matrix::Derivative(
</code></pre>
<p>
  matrix&amp;¬†                  matrix_out,¬†   //¬†matriz para obter valores
  ENUM_ACTIVATION_FUNCTION¬† activation,    //¬†fun√ß√£o de ativa√ß√£o
<h3>ENUM_MATRIX_AXIS     ¬†    axis,          //¬†eixo</h3>
</p>
<pre><code class="language-mql5">
   ...¬†                                    // par√¢metros adicionais
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vect_out/matrix_out
¬†[out]  Vetor ou matriz para obter os valores calculados da derivada da fun√ß√£o de ativa√ß√£o.
activation
[in]  Fun√ß√£o de ativa√ß√£o a partir da enumera√ß√£o ENUM_ACTIVATION_FUNCTION.
axis
[in]  Valor a partir da enumera√ß√£o ENUM_MATRIX_AXIS (AXIS_HORZ ‚Äî eixo horizontal, AXIS_VERT
‚Äî eixo vertical).
...
[in]  Par√¢metros adicionais, que s√£o os mesmos das fun√ß√µes de ativa√ß√£o. Somente algumas
fun√ß√µes de ativa√ß√£o aceitam par√¢metros adicionais. Se nenhum par√¢metro for especificado, ser√£o
usados os valores padr√£o.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
As derivadas das fun√ß√µes permitem que os par√¢metros do modelo sejam atualizados com efici√™ncia
com base no erro obtido no processo de aprendizado quando o erro se propaga para tr√°s.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1515</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1516
<h3>Loss</h3>
Calcula o valor da fun√ß√£o de perda.
</p>
<pre><code class="language-mql5">
double vector::Loss(
</code></pre>
<p>
  const vector&amp;¬†      vect_true,     //¬†vetor de valores reais
<h3>ENUM_LOSS_FUNCTION¬† loss,          //¬†fun√ß√£o de perda</h3>
</p>
<pre><code class="language-mql5">
   ...¬†                              // par√¢metro adicional
   );
double matrix::Loss(
</code></pre>
<p>
  const matrix&amp;¬†      matrix_true,   //¬†matriz de valores reais
<h3>ENUM_LOSS_FUNCTION¬† loss,          //¬†fun√ß√£o de perda</h3>
</p>
<pre><code class="language-mql5">
   );
double matrix::Loss(
</code></pre>
<p>
  const matrix&amp;¬†      matrix_true,   //¬†matriz de valores reais
<h3>ENUM_LOSS_FUNCTION¬† loss,          //¬†fun√ß√£o de perda</h3>
<h3>ENUM_MATRIX_AXIS    axis,          //¬†eixo</h3>
</p>
<pre><code class="language-mql5">
   ...¬†                              // par√¢metro adicional
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vect_true/matrix_true
¬†[in] Vetor ou matriz de valores reais.
loss
[in]  Fun√ß√£o de perda a partir da enumera√ß√£o ENUM_LOSS_FUNCTION.
axis
[in]  Valor a partir da enumera√ß√£o ENUM_MATRIX_AXIS (AXIS_HORZ ‚Äî eixo horizontal, AXIS_VERT
‚Äî eixo vertical).
...
[in]  Somente a fun√ß√£o de perda Huber (LOSS_HUBER) pode ter o par√¢metro delta adicional
<h3>Valor retornado</h3>
Valor double.
Como o par√¢metro delta √© usado na fun√ß√£o de perda Huber (LOSS_HUBER)
</p>
<pre><code class="language-mql5">
   double delta = 1.0;
   double error = fabs(y - x);
   if(error&lt;delta)
      loss = 0.5 * error^2;
   else</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1517
</p>
<pre><code class="language-mql5">
      loss = 0.5 * delta^2 + delta * (error - delta);
</code></pre>
<p>
<h3>Observa√ß√£o</h3>
A tarefa de treinamento de rede neural √© encontrar coeficientes que minimizem o erro na amostra
de treinamento, usando a fun√ß√£o de perda.
O valor da fun√ß√£o de perda descreve a magnitude do desvio entre o valor previsto pelo modelo e o
valor real.
Diferentes fun√ß√µes de perda s√£o usadas, dependendo do tipo de problema a ser resolvido. Por
exemplo: para um problema de regress√£o, o erro quadr√°tico m√©dio (mean squared error , MSE),
para uma classifica√ß√£o bin√°ria, a entropia cruzada bin√°ria (binary cross-entropy, BCE).
Exemplo de uma chamada para a fun√ß√£o de perda Hubert:
</p>
<pre><code class="language-mql5">
   vector y_true = {0.0, 1.0, 0.0, 0.0};
   vector y_pred = {0.6, 0.4, 0.4, 0.6};
   double loss=y_pred.Loss(y_true,LOSS_HUBER);
   Print(loss);
   double loss2=y_pred.Loss(y_true,LOSS_HUBER,0.5);
   Print(loss2);
/* Resultado
   0.155
   0.15125
</code></pre>
<p>
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1518
<h3>LossGradient</h3>
Calcula o vetor ou a matriz de gradiente da fun√ß√£o de perda.
vector vector::LossGradient(
  const vector&amp;¬†      vect_true,     //¬†vetor de valores reais
  ENUM_LOSS_FUNCTION¬† loss,          //¬†tipo de fun√ß√£o de perda
</p>
<pre><code class="language-mql5">
   ...¬†                              // par√¢metro adicional
   );
</code></pre>
<p>
matrix matrix::LossGradient(
  const matrix&amp;¬†      matrix_true,   //¬†matriz de valores reais
<h3>ENUM_LOSS_FUNCTION¬† loss,          //¬†fun√ß√£o de perda</h3>
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix matrix::LossGradient(
  const matrix&amp;¬†      matrix_true,   //¬†matriz de valores reais
<h3>ENUM_LOSS_FUNCTION¬† loss,          //¬†fun√ß√£o de perda</h3>
<h3>ENUM_MATRIX_AXIS    axis,          //¬†eixo</h3>
</p>
<pre><code class="language-mql5">
   ...¬†                              // par√¢metro adicional
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vect_true/matrix_true
¬†[in] Vetor ou matriz de valores reais.
loss
[in]  Fun√ß√£o de perda a partir da enumera√ß√£o ENUM_LOSS_FUNCTION.
axis
[in]  Valor a partir da enumera√ß√£o ENUM_MATRIX_AXIS (AXIS_HORZ ‚Äî eixo horizontal, AXIS_VERT
‚Äî eixo vertical).
...
[in]  Somente a fun√ß√£o de perda Huber (LOSS_HUBER) pode ter o par√¢metro delta adicional
<h3>Valor retornado</h3>
Vetor ou matriz de valores de gradiente da fun√ß√£o de perda. O gradiente √© a derivada parcial sobre
dx (x √© o valor previsto) da fun√ß√£o de perda em um determinado ponto.
<h3>Observa√ß√£o</h3>
Os gradientes s√£o usados em redes neurais para ajustar os valores da matriz de peso quando o erro
se propaga de volta ao treinamento do modelo.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1519
A tarefa de treinamento de rede neural √© encontrar coeficientes que minimizem o erro na amostra
de treinamento, usando a fun√ß√£o de perda.
Diferentes fun√ß√µes de perda s√£o usadas, dependendo do tipo de problema a ser resolvido. Por
exemplo: para um problema de regress√£o, o erro quadr√°tico m√©dio (mean squared error , MSE),
para uma classifica√ß√£o bin√°ria, a entropia cruzada bin√°ria (binary cross-entropy, BCE).
Exemplo de c√°lculo dos gradientes de uma fun√ß√£o de perda
</p>
<pre><code class="language-mql5">
   matrixf y_true={{ 1, 2, 3, 4 },
                   { 5, 6, 7, 8 },
                   { 9,10,11,12 }};
   matrixf y_pred={{ 1, 2, 3, 4 },
                   {11,10, 9, 8 },
                   { 5, 6, 7,12 }};
   matrixf loss_gradient =y_pred.LossGradient(y_true,LOSS_MAE);
   matrixf loss_gradienth=y_pred.LossGradient(y_true,LOSS_MAE,AXIS_HORZ);
   matrixf loss_gradientv=y_pred.LossGradient(y_true,LOSS_MAE,AXIS_VERT);
   Print(&quot;loss gradients\n&quot;,loss_gradient);
   Print(&quot;loss gradients on horizontal axis\n&quot;,loss_gradienth);
   Print(&quot;loss gradients on vertical axis\n&quot;,loss_gradientv);
/* Resultado
   loss gradients
   [[0,0,0,0]
    [0.083333336,0.083333336,0.083333336,0]
    [-0.083333336,-0.083333336,-0.083333336,0]]
   loss gradients on horizontal axis
   [[0,0,0,0]
    [0.33333334,0.33333334,0.33333334,0]
    [-0.33333334,-0.33333334,-0.33333334,0]]
   loss gradients on vertical axis
   [[0,0,0,0]
    [0.25,0.25,0.25,0]
    [-0.25,-0.25,-0.25,0]]
</code></pre>
<p>
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1520
<h3>RegressionMetric</h3>
Calcula uma m√©trica de regress√£o para avaliar a qualidade dos dados previstos em rela√ß√£o aos dados
reais
</p>
<pre><code class="language-mql5">
double vector::RegressionMetric(
   const vector&amp;           vector_true,   // vetor de valores reais
   ENUM_REGRESSION_METRIC  metric         // tipo de m√©trica
   );
double matrix::RegressionMetric(
   const matrix&amp;           matrix_true,   // matriz de valores reais
   ENUM_REGRESSION_METRIC  metric         // tipo de m√©trica
</code></pre>
<p>
);
vector matrix::RegressionMetric(
</p>
<pre><code class="language-mql5">
   const matrix&amp;           matrix_true,   // matriz de valores reais
   ENUM_REGRESSION_METRIC  metric,        // tipo de m√©trica
¬†  int¬†                    axis¬†          //¬†eixo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vector_true/matrix_true
[in]  Vetor ou matriz de valores reais.
metric
[in]  Tipo de m√©trica a partir da enumera√ß√£o ENUM_REGRESSION_METRIC.
axis
[in]  Eixo. 0 ‚Äî eixo horizontal, 1 ‚Äî eixo vertical.
<h3>Valor retornado</h3>
M√©trica calculada ‚Äî avalia a qualidade dos dados previstos em rela√ß√£o aos dados reais.
<h3>Observa√ß√£o</h3>
¬∑ REGRESSION_MAE ‚Äî m√©dia das diferen√ßas absolutas entre os valores previstos e os valores reais
correspondentes–∏
¬∑ REGRESSION_MSE ‚Äî m√©dia dos quadrados das diferen√ßas entre os valores previstos e os valores
reais correspondentes
¬∑ REGRESSION_RMSE ‚Äî raiz quadrada do MSE
¬∑ REGRESSION_R2 - 1 ‚Äî MSE(regress√£o) / MSE(m√©dia)
¬∑ REGRESSION_MAPE ‚Äî erro absoluto m√©dio (MAE) em porcentagem
¬∑ REGRESSION_MSPE ‚Äî erro quadr√°tico m√©dio (MSE) como porcentagem
¬∑ REGRESSION_RMSLE ‚Äî RMSE calculado em escala logar√≠tmica
<h3>Exemplo:</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1521
</p>
<pre><code class="language-mql5">
   vector y_true = {3, -0.5, 2, 7};
   vector y_pred = {2.5, 0.0, 2, 8};
//---
   double mse=y_pred.RegressionMetric(y_true,REGRESSION_MSE);
   Print(&quot;mse=&quot;,mse);
//---
   double mae=y_pred.RegressionMetric(y_true,REGRESSION_MAE);
   Print(&quot;mae=&quot;,mae);
//---
   double r2=y_pred.RegressionMetric(y_true,REGRESSION_R2);
   Print(&quot;r2=&quot;,r2);
¬† /* Resultado
   mae=0.375
   mse=0.5
   r2=0.9486081370449679
   */</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1522
<h3>ConfusionMatrix</h3>
Calcula a matriz de erros. O m√©todo √© aplicado a um vetor de valores previstos.
matrix vector::ConfusionMatrix(
  const vector&amp;¬†      vect_true,     //¬†vetor de valores reais
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
matrix vector::ConfusionMatrix(
  const vector&amp;¬†      vect_true,     //¬†vetor de valores reais
</p>
<pre><code class="language-mql5">
   uint¬†               label¬†         // valor do r√≥tulo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vect_true
[in] Vetor de valores reais.
√©pocas
[in] Valor do r√≥tulo para o c√°lculo da matriz de erros.
<h3>Valor retornado</h3>
Matriz de erros. Se o valor da r√≥tulo n√£o for especificado, ser√° retornada uma matriz de erro
multiclasse, em que cada r√≥tulo √© comparado com cada outro r√≥tulo individualmente. Se um valor de
r√≥tulo for especificado, ser√° retornada uma matriz 2 x 2, em que o r√≥tulo especificado √©
considerado positivo, e todos os outros r√≥tulos s√£o negativos (ovr, one vs rest).
<h3>Observa√ß√£o</h3>
A matriz de erro C √© tal que Cij √© igual ao n√∫mero de observa√ß√µes que est√£o no grupo i e que
tamb√©m se prev√™ que estejam no grupo j. Assim, na classifica√ß√£o bin√°ria, o n√∫mero de verdadeiros
negativos (TN) √© C00, o de falsos negativos (FN) √© C10, o de verdadeiros positivos (TP) √© C11 e o de
falsos positivos (FP) √© C01.
Ou seja, essa matriz pode ser representada graficamente dessa forma:
<h3>TN</h3>
<h3>FP</h3>
<h3>FN</h3>
<h3>TP</h3>
Os tamanhos do vetor de valores reais e do vetor de valores previstos devem ser os mesmos.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector y_true={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,8,4,2,7,6,8,4,2,3,6};
   vector y_pred={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,2,9,4,9,5,9,2,7,7,0};</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1523
</p>
<pre><code class="language-mql5">
   matrix confusion=y_pred.ConfusionMatrix(y_true);
   Print(confusion);
   confusion=y_pred.ConfusionMatrix(y_true,0);
   Print(confusion);
   confusion=y_pred.ConfusionMatrix(y_true,1);
   Print(confusion);
   confusion=y_pred.ConfusionMatrix(y_true,2);
   Print(confusion);
/*
</code></pre>
<p>
  [[3,0,0,0,0,0,0,0,0,0]
</p>
<pre><code class="language-mql5">
   [0,3,0,0,0,0,0,0,0,0]
   [0,0,1,0,1,0,0,1,0,0]
   [0,0,0,1,0,0,0,1,0,0]
   [0,0,1,0,3,0,0,0,0,1]
   [0,0,0,0,0,2,0,0,0,0]
   [1,0,0,0,0,1,1,0,0,0]
   [0,0,0,0,0,0,0,2,0,1]
   [0,0,1,0,0,0,0,0,0,1]
   [0,0,0,0,0,0,0,0,0,4]]
</code></pre>
<p>
  [[26,1]
</p>
<pre><code class="language-mql5">
   [0,3]]
</code></pre>
<p>
  [[27,0]
</p>
<pre><code class="language-mql5">
   [0,3]]
</code></pre>
<p>
  [[25,2]
</p>
<pre><code class="language-mql5">
   [2,1]]
</code></pre>
<p>
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1524
<h3>ConfusionMatrixMultilabel</h3>
Calcula a matriz de erros para cada r√≥tulo. O m√©todo √© aplicado a um vetor de valores previstos.
uint vector::ConfusionMatrixMultiLabel(
  const vector&amp;¬†      vect_true,     //¬†vetor de valores reais
</p>
<pre><code class="language-mql5">
   matrix&amp;¬†            confusions[]¬†  //¬†array de matrizes de erro calculadas
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vect_true
[in] Vetor de valores reais.
confusions
[out] Array de matrizes 2 x 2 com matrizes de erro calculadas para cada r√≥tulo.
<h3>Valor retornado</h3>
Tamanho do array de matrizes de erro calculadas. Em caso de falha, √© retornado 0
<h3>Observa√ß√£o</h3>
O array de resultados pode ser din√¢mico ou est√°tico. Se o array for est√°tico, ele dever√° ter um
tamanho pelo menos igual ao n√∫mero de classes.
Os tamanhos do vetor de valores reais e do vetor de valores previstos devem ser os mesmos.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector y_true={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,8,4,2,7,6,8,4,2,3,6};
   vector y_pred={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,2,9,4,9,5,9,2,7,7,0};
   matrix label_confusions[12];
   uint   res=y_pred.ConfusionMatrixMultiLabel(y_true,label_confusions);
   Print(&quot;res=&quot;,res,&quot;  size=&quot;,label_confusions.Size());
   for(uint i=0; i&lt;res; i++)
      Print(label_confusions[i]);
/*
</code></pre>
<p>
  res=10  size=12
  [[26,1]
</p>
<pre><code class="language-mql5">
   [0,3]]
</code></pre>
<p>
  [[27,0]
</p>
<pre><code class="language-mql5">
   [0,3]]
</code></pre>
<p>
  [[25,2]
</p>
<pre><code class="language-mql5">
   [2,1]]</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1525
  [[28,0]
</p>
<pre><code class="language-mql5">
   [1,1]]
</code></pre>
<p>
  [[24,1]
</p>
<pre><code class="language-mql5">
   [2,3]]
</code></pre>
<p>
  [[27,1]
</p>
<pre><code class="language-mql5">
   [0,2]]
</code></pre>
<p>
  [[27,0]
</p>
<pre><code class="language-mql5">
   [2,1]]
</code></pre>
<p>
  [[25,2]
</p>
<pre><code class="language-mql5">
   [1,2]]
</code></pre>
<p>
  [[28,0]
</p>
<pre><code class="language-mql5">
   [2,0]]
</code></pre>
<p>
  [[23,3]
</p>
<pre><code class="language-mql5">
   [0,4]]
</code></pre>
<p>
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1526
<h3>ClassificationMetric</h3>
Calcula uma m√©trica de classifica√ß√£o para avaliar a qualidade dos dados previstos em rela√ß√£o aos
dados reais. O m√©todo √© aplicado a um vetor de valores previstos.
vector vector::ClassificationMetric(
  const vector&amp;¬†      vect_true,     //¬†vetor de valores reais
</p>
<pre><code class="language-mql5">
   ENUM_CLASSIFICATION_METRIC¬†metric¬†        //¬†tipo de m√©trica
   );
</code></pre>
<p>
vector vector::ClassificationMetric(
  const vector&amp;¬†      vect_true,     //¬†vetor de valores reais
</p>
<pre><code class="language-mql5">
   ENUM_CLASSIFICATION_METRIC¬†metric¬†        //¬†tipo de m√©trica
   ENUM_AVERAGE_MODE¬†         mode¬†          //¬†modo de m√©dia
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
vect_true
[in] Vetor de valores reais.
metric
[in] Tipo de m√©trica a partir da enumera√ß√£o ENUM_CLASSIFICATION_METRIC. S√£o usados valores
diferentes de CLASSIFICATION_TOP_K_ACCURACY, 
<h3>CLASSIFICATION_AVERAGE_PRECISION</h3>
e
CLASSIFICATION_ROC_AUC (que s√£o usados no m√©todo ClassificationScore).
mode
[in]  Modo de c√°lculo da m√©dia a partir da enumera√ß√£o ENUM_AVERAGE_MODE. Para m√©tricas s√£o
usados 
<h3>CLASSIFICATION_F1,</h3>
<h3>CLASSIFICATION_JACCARD,</h3>
<h3>CLASSIFICATION_PRECISION</h3>
e
CLASSIFICATION_RECALL.
<h3>Valor retornado</h3>
Vetor que cont√©m a m√©trica calculada. No caso do modo de c√°lculo de m√©dia AVERAGE_NONE, o
vetor cont√©m valores m√©tricos para cada classe sem c√°lculo de m√©dia. (Por exemplo, para
classifica√ß√£o bin√°ria, seriam 2 m√©tricas para false e true, respectivamente).
Observa√ß√£o sobre os modos de c√°lculo da m√©dia
AVERAGE_BINARY s√≥ faz sentido para classifica√ß√£o bin√°ria.
AVERAGE_MICRO ‚Äî calcular m√©tricas globalmente contando o n√∫mero total de verdadeiros, falsos
negativos e falsos positivos.
AVERAGE_MACRO ‚Äî calcular m√©tricas para cada r√≥tulo e encontrar seu valor m√©dio n√£o ponderado.
Isso n√£o leva em conta o desequil√≠brio dos r√≥tulos.
AVERAGE_WEIGHTED ‚Äî calcular as m√©tricas para cada r√≥tulo e encontrar sua m√©dia ponderada
sobre o suporte (n√∫mero de inst√¢ncias verdadeiras para cada r√≥tulo). Esse c√°lculo altera a macro
para levar em conta o desequil√≠brio de r√≥tulo, o que pode levar a uma medida F que n√£o est√° entre a
precis√£o e a abrang√™ncia.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1527
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector y_true={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,8,4,2,7,6,8,4,2,3,6};
   vector y_pred={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,2,9,4,9,5,9,2,7,7,0};
   vector accuracy=y_pred.ClassificationMetric(y_true,CLASSIFICATION_ACCURACY);
   Print(&quot;accuracy=&quot;,accuracy);
   vector balanced=y_pred.ClassificationMetric(y_true,CLASSIFICATION_BALANCED_ACCURACY
   Print(&quot;balanced=&quot;,balanced);
   Print(&quot;&quot;);
   vector f1_micro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_F1,AVERAGE_MICRO)
   Print(&quot;f1_micro=&quot;,f1_micro);
   vector f1_macro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_F1,AVERAGE_MACRO)
   Print(&quot;f1_macro=&quot;,f1_macro);
   vector f1_weighted=y_pred.ClassificationMetric(y_true,CLASSIFICATION_F1,AVERAGE_WEI
   Print(&quot;f1_weighted=&quot;,f1_weighted);
   vector f1_none=y_pred.ClassificationMetric(y_true,CLASSIFICATION_F1,AVERAGE_NONE);
   Print(&quot;f1_none=&quot;,f1_none);
   Print(&quot;&quot;);
   vector jaccard_micro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_JACCARD,AVER
   Print(&quot;jaccard_micro=&quot;,jaccard_micro);
   vector jaccard_macro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_JACCARD,AVER
   Print(&quot;jaccard_macro=&quot;,jaccard_macro);
   vector jaccard_weighted=y_pred.ClassificationMetric(y_true,CLASSIFICATION_JACCARD,A
   Print(&quot;jaccard_weighted=&quot;,jaccard_weighted);
   vector jaccard_none=y_pred.ClassificationMetric(y_true,CLASSIFICATION_JACCARD,AVERA
   Print(&quot;jaccard_none=&quot;,jaccard_none);
   Print(&quot;&quot;);
   vector precision_micro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_PRECISION,
   Print(&quot;precision_micro=&quot;,precision_micro);
   vector precision_macro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_PRECISION,
   Print(&quot;precision_macro=&quot;,precision_macro);
   vector precision_weighted=y_pred.ClassificationMetric(y_true,CLASSIFICATION_PRECISI
   Print(&quot;precision_weighted=&quot;,precision_weighted);
   vector precision_none=y_pred.ClassificationMetric(y_true,CLASSIFICATION_PRECISION,A
   Print(&quot;precision_none=&quot;,precision_none);
   Print(&quot;&quot;);
   vector recall_micro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_RECALL,AVERAG
   Print(&quot;recall_micro=&quot;,recall_micro);
   vector recall_macro=y_pred.ClassificationMetric(y_true,CLASSIFICATION_RECALL,AVERAG
   Print(&quot;recall_macro=&quot;,recall_macro);
   vector recall_weighted=y_pred.ClassificationMetric(y_true,CLASSIFICATION_RECALL,AVE
   Print(&quot;recall_weighted=&quot;,recall_weighted);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1528
</p>
<pre><code class="language-mql5">
   vector recall_none=y_pred.ClassificationMetric(y_true,CLASSIFICATION_RECALL,AVERAGE
   Print(&quot;recall_none=&quot;,recall_none);
   Print(&quot;&quot;);
//--- binary classification
   vector y_pred_bin={0,1,0,1,1,0,0,0,1};
   vector y_true_bin={1,0,0,0,1,0,1,1,1};
   vector f1_bin=y_pred_bin.ClassificationMetric(y_true_bin,CLASSIFICATION_F1,AVERAGE_
   Print(&quot;f1_bin=&quot;,f1_bin);
   vector jaccard_bin=y_pred_bin.ClassificationMetric(y_true_bin,CLASSIFICATION_JACCAR
   Print(&quot;jaccard_bin=&quot;,jaccard_bin);
   vector precision_bin=y_pred_bin.ClassificationMetric(y_true_bin,CLASSIFICATION_PREC
   Print(&quot;precision_bin=&quot;,precision_bin);
   vector recall_bin=y_pred_bin.ClassificationMetric(y_true_bin,CLASSIFICATION_RECALL,
   Print(&quot;recall_bin=&quot;,recall_bin);
/*
</code></pre>
<p>
  accuracy=[0.6666666666666666]
  balanced=[0.6433333333333333]
  
  f1_micro=[0.6666666666666666]
  f1_macro=[0.6122510822510823]
  f1_weighted=[0.632049062049062]
  f1_none=[0.8571428571428571,1,0.3333333333333333,0.6666666666666666,0.66666666666666
  
  jaccard_micro=[0.5]
  jaccard_macro=[0.4921428571428572]
  jaccard_weighted=[0.5056349206349205]
  jaccard_none=[0.75,1,0.2,0.5,0.5,0.6666666666666666,0.3333333333333333,0.4,0,0.57142
  
  precision_micro=[0.6666666666666666]
  precision_macro=[0.6571428571428571]
  precision_weighted=[0.6706349206349207]
  precision_none=[0.75,1,0.3333333333333333,1,0.75,0.6666666666666666,1,0.5,0,0.571428
  
  recall_micro=[0.6666666666666666]
  recall_macro=[0.6433333333333333]
  recall_weighted=[0.6666666666666666]
  recall_none=[1,1,0.3333333333333333,0.5,0.6,1,0.3333333333333333,0.6666666666666666,
  
  f1_bin=[0.4444444444444445]
  jaccard_bin=[0.2857142857142857]
  precision_bin=[0.5]
  recall_bin=[0.4]
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1529
<h3>ClassificationScore</h3>
Calcula uma m√©trica de classifica√ß√£o para avaliar a qualidade dos dados previstos em rela√ß√£o aos
dados reais.
Diferentemente de outros m√©todos na se√ß√£o Aprendizado de m√°quina, esse m√©todo √© aplicado a um
vetor de valores reais em vez de um vetor de valores previstos.
vector vector::ClassificationScore(
</p>
<pre><code class="language-mql5">
   const matrix&amp;¬†             pred_scores,   //¬†matriz que cont√©m a distribui√ß√£o de pr
   ENUM_CLASSIFICATION_METRIC¬†metric¬†        //¬†tipo de m√©trica
   ENUM_AVERAGE_MODE¬†         mode¬†          //¬†modo de m√©dia
   );
</code></pre>
<p>
vector vector::ClassificationScore(
</p>
<pre><code class="language-mql5">
   const matrix&amp;¬†             pred_scores,   //¬†matriz que cont√©m a distribui√ß√£o de pr
   ENUM_CLASSIFICATION_METRIC¬†metric¬†        //¬†tipo de m√©trica
   int              ¬†         param¬†         //¬†par√¢metro adicional
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
pred_scores
[in] Matriz que cont√©m um conjunto de vetores horizontais com probabilidades para cada classe. O
n√∫mero de linhas da matriz deve corresponder ao tamanho do vetor de valores reais.
metric
[in] Tipo de m√©trica a partir da enumera√ß√£o ENUM_CLASSIFICATION_METRIC. S√£o usados os
valores 
<h3>CLASSIFICATION_TOP_K_ACCURACY,</h3>
<h3>CLASSIFICATION_AVERAGE_PRECISION</h3>
e
CLASSIFICATION_ROC_AUC.
mode
[in]  Modo de c√°lculo da m√©dia a partir da enumera√ß√£o ENUM_AVERAGE_MODE. Para a m√©trica s√£o
usados CLASSIFICATION_AVERAGE_PRECISION e CLASSIFICATION_ROC_AUC.
param
[in]  Para a m√©trica CLASSIFICATION_TOP_TOP_K_ACCURACY, √© necess√°rio especificar um valor K
inteiro em vez do modo de c√°lculo da m√©dia.
<h3>Valor retornado</h3>
Vetor que cont√©m a m√©trica calculada. No caso do modo de c√°lculo de m√©dia AVERAGE_NONE, o
vetor cont√©m valores m√©tricos para cada classe sem c√°lculo de m√©dia. (Por exemplo, para
classifica√ß√£o bin√°ria, seriam 2 m√©tricas para false e true, respectivamente).
Observa√ß√£o sobre os modos de c√°lculo da m√©dia
AVERAGE_BINARY s√≥ faz sentido para classifica√ß√£o bin√°ria.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1530
AVERAGE_MICRO ‚Äî  calcula as m√©tricas globalmente, considerando cada elemento da matriz de
indicadores de etiquetas como uma etiqueta. A matriz de indicadores de etiquetas √© uma matriz
com um conjunto de probabilidades para cada etiqueta.
AVERAGE_MACRO ‚Äî calcular m√©tricas para cada r√≥tulo e encontrar seu valor m√©dio n√£o ponderado.
Isso n√£o leva em conta o desequil√≠brio dos r√≥tulos.
AVERAGE_WEIGHTED ‚Äî calcular as m√©tricas para cada r√≥tulo e encontrar sua m√©dia ponderada
sobre o suporte (n√∫mero de inst√¢ncias verdadeiras para cada r√≥tulo).
<h3>Observa√ß√£o</h3>
Para a classifica√ß√£o bin√°ria, n√£o apenas uma matriz n x 2, em que a primeira coluna cont√©m as
probabilidades do r√≥tulo negativo e a segunda coluna cont√©m as probabilidades do r√≥tulo positivo,
mas tamb√©m uma matriz que consiste em uma √∫nica coluna com probabilidades positivas pode ser
alimentada como entrada. Isso ocorre porque os modelos de classifica√ß√£o bin√°ria podem retornar
duas probabilidades ou uma probabilidade para um r√≥tulo positivo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   vector y_true={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,8,4,2,7,6,8,4,2,3,6};
   //vector y_pred={7,2,1,0,4,1,4,9,5,9,0,6,9,0,1,5,9,7,3,4,2,9,4,9,5,9,2,7,7,0};
//--- label scores          0         1         2         3         4         5       
   matrix y_scores={{0.000109, 0.000186, 0.000449, 0.000052, 0.000002, 0.000022, 0.000
                    {0.000091, 0.081956, 0.916816, 0.001106, 0.000006, 0.000002, 0.000
                    {0.000108, 0.972863, 0.003600, 0.000021, 0.010479, 0.000015, 0.000
                    {0.925425, 0.000080, 0.002913, 0.000057, 0.000274, 0.000638, 0.063
                    {0.000060, 0.000126, 0.000006, 0.000000, 0.993513, 0.000000, 0.000
                    {0.000016, 0.982124, 0.000045, 0.000002, 0.008445, 0.000001, 0.000
                    {0.000000, 0.000040, 0.000001, 0.000000, 0.989395, 0.000167, 0.000
                    {0.000795, 0.002938, 0.023447, 0.007418, 0.021838, 0.002476, 0.000
                    {0.000091, 0.000226, 0.000038, 0.000007, 0.000048, 0.854910, 0.068
                    {0.000000, 0.000000, 0.000000, 0.000000, 0.003004, 0.000000, 0.000
                    {0.998856, 0.000009, 0.000976, 0.000002, 0.000000, 0.000013, 0.000
                    {0.000178, 0.000446, 0.000326, 0.000033, 0.000193, 0.000071, 0.998
                    {0.000005, 0.000016, 0.000153, 0.000045, 0.004110, 0.000012, 0.000
                    {0.994188, 0.000003, 0.002584, 0.000005, 0.000005, 0.000100, 0.000
                    {0.000173, 0.990569, 0.000792, 0.000040, 0.001798, 0.000035, 0.000
                    {0.000000, 0.000537, 0.000008, 0.005080, 0.000046, 0.992910, 0.000
                    {0.000127, 0.000003, 0.000003, 0.000000, 0.001583, 0.000000, 0.000
                    {0.000001, 0.000012, 0.000072, 0.000020, 0.000000, 0.000000, 0.000
                    {0.000020, 0.000105, 0.001139, 0.901343, 0.002132, 0.083873, 0.000
                    {0.000002, 0.000048, 0.000019, 0.000000, 0.999347, 0.000002, 0.000
                    {0.000059, 0.001344, 0.612502, 0.002749, 0.000229, 0.000678, 0.000
                    {0.000586, 0.000740, 0.001625, 0.000007, 0.269341, 0.000076, 0.016
                    {0.009547, 0.018055, 0.283795, 0.071079, 0.426074, 0.082335, 0.036
                    {0.002506, 0.002545, 0.001148, 0.005659, 0.020416, 0.000112, 0.006
                    {0.001263, 0.001769, 0.000293, 0.000011, 0.000302, 0.881768, 0.112
                    {0.002904, 0.002909, 0.013421, 0.001461, 0.007519, 0.001251, 0.000</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1531
</p>
<pre><code class="language-mql5">
                    {0.000055, 0.001080, 0.893158, 0.000000, 0.104492, 0.000159, 0.001
                    {0.000344, 0.002693, 0.071184, 0.000262, 0.000001, 0.000003, 0.000
                    {0.001404, 0.009375, 0.002638, 0.229189, 0.000064, 0.000896, 0.007
                    {0.491140, 0.000125, 0.000024, 0.000302, 0.000038, 0.034947, 0.473
   vector top_k=y_true.ClassificationScore(y_scores,CLASSIFICATION_TOP_K_ACCURACY,1);
   Print(&quot;top 1 accuracy score = &quot;,top_k);
   top_k=y_true.ClassificationScore(y_scores,CLASSIFICATION_TOP_K_ACCURACY,2);
   Print(&quot;top 2 accuracy score = &quot;,top_k);
   vector y_true2={0, 1, 2, 2};
   matrix y_score2={{0.5, 0.2, 0.2},  // 0 is in top 2
                    {0.3, 0.4, 0.2},  // 1 is in top 2
                    {0.2, 0.4, 0.3},  // 2 is in top 2
                    {0.7, 0.2, 0.1}}; // 2 isn&#x27;t in top 2
   top_k=y_true2.ClassificationScore(y_score2,CLASSIFICATION_TOP_K_ACCURACY,2);
   Print(&quot;top k = &quot;,top_k);
   Print(&quot;&quot;);
   vector ap_micro=y_true.ClassificationScore(y_scores,CLASSIFICATION_AVERAGE_PRECISIO
   Print(&quot;average precision score micro = &quot;,ap_micro);
   vector ap_macro=y_true.ClassificationScore(y_scores,CLASSIFICATION_AVERAGE_PRECISIO
   Print(&quot;average precision score macro = &quot;,ap_macro);
   vector ap_weighted=y_true.ClassificationScore(y_scores,CLASSIFICATION_AVERAGE_PRECI
   Print(&quot;average precision score weighted = &quot;,ap_weighted);
   vector ap_none=y_true.ClassificationScore(y_scores,CLASSIFICATION_AVERAGE_PRECISION
   Print(&quot;average precision score none = &quot;,ap_none);
   Print(&quot;&quot;);
   vector area_micro=y_true.ClassificationScore(y_scores,CLASSIFICATION_ROC_AUC,AVERAG
   Print(&quot;roc auc score micro = &quot;,area_micro);
   vector area_macro=y_true.ClassificationScore(y_scores,CLASSIFICATION_ROC_AUC,AVERAG
   Print(&quot;roc auc score macro = &quot;,area_macro);
   vector area_weighted=y_true.ClassificationScore(y_scores,CLASSIFICATION_ROC_AUC,AVE
   Print(&quot;roc auc score weighted = &quot;,area_weighted);
   vector area_none=y_true.ClassificationScore(y_scores,CLASSIFICATION_ROC_AUC,AVERAGE
   Print(&quot;roc auc score none = &quot;,area_none);
   Print(&quot;&quot;);
//--- binary classification
   vector y_pred_bin={0,1,0,1,1,0,0,0,1};
   vector y_true_bin={1,0,0,0,1,0,1,1,1};
   vector y_score_true={0.3,0.7,0.1,0.6,0.9,0.0,0.4,0.2,0.8};
   matrix y_score1_bin(y_score_true.Size(),1);
   y_score1_bin.Col(y_score_true,0);
   matrix y_scores_bin={{0.7, 0.3},
                        {0.3, 0.7},
                        {0.9, 0.1},
                        {0.4, 0.6},
                        {0.1, 0.9},</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1532
</p>
<pre><code class="language-mql5">
                        {1.0, 0.0},
                        {0.6, 0.4},
                        {0.8, 0.2},
                        {0.2, 0.8}};
   vector ap=y_true_bin.ClassificationScore(y_scores_bin,CLASSIFICATION_AVERAGE_PRECIS
   Print(&quot;average precision score binary = &quot;,ap);
   vector ap2=y_true_bin.ClassificationScore(y_score1_bin,CLASSIFICATION_AVERAGE_PRECI
   Print(&quot;average precision score binary = &quot;,ap2);
   vector ap3=y_true_bin.ClassificationScore(y_scores_bin,CLASSIFICATION_AVERAGE_PRECI
   Print(&quot;average precision score none = &quot;,ap3);
   Print(&quot;&quot;);
   vector area=y_true_bin.ClassificationScore(y_scores_bin,CLASSIFICATION_ROC_AUC,AVER
   Print(&quot;roc auc score binary = &quot;,area);
   vector area2=y_true_bin.ClassificationScore(y_score1_bin,CLASSIFICATION_ROC_AUC,AVE
   Print(&quot;roc auc score binary = &quot;,area2);
   vector area3=y_true_bin.ClassificationScore(y_scores_bin,CLASSIFICATION_ROC_AUC,AVE
   Print(&quot;roc auc score none = &quot;,area3);
/*
</code></pre>
<p>
  top 1 accuracy score = [0.6666666666666666]
  top 2 accuracy score = [1]
  top k = [0.75]
  
  average precision score micro = [0.8513333333333333]
  average precision score macro = [0.9326666666666666]
  average precision score weighted = [0.9333333333333333]
  average precision score none = [1,1,0.7,1,0.9266666666666666,0.8333333333333333,1,0.
  
  roc auc score micro = [0.9839506172839506]
  roc auc score macro = [0.9892068783068803]
  roc auc score weighted = [0.9887354497354497]
  roc auc score none = [1,1,0.9506172839506173,1,0.984,0.9821428571428571,1,0.97530864
  
  average precision score binary = [0.7961904761904761]
  average precision score binary = [0.7961904761904761]
  average precision score none = [0.7678571428571428,0.7961904761904761]
  
  roc auc score binary = [0.7]
  roc auc score binary = [0.7]
  roc auc score none = [0.7,0.7]
*/</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1533
<h3>PrecisionRecall</h3>
Calcula os valores para tra√ßar a curva precision-recall. Esse m√©todo, assim como o m√©todo
ClassificationScore, √© aplicado a um vetor de valores verdadeiros.
</p>
<pre><code class="language-mql5">
bool vector::PrecisionRecall(
   const matrix&amp;¬†             pred_scores,   //¬†matriz que cont√©m a distribui√ß√£o de pr
   const ENUM_ENUM_AVERAGE_MODE  mode¬†          //¬†modo de c√°lculo da m√©dia
   matrix&amp;¬†                      precision,     //¬†valores de precision calculados par
   matrix&amp;¬†                      recall,        //¬†valores de recall calculados para c
   matrix&amp;¬†                      thresholds,    //¬†limiares classificados em ordem dec
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
pred_scores
[in] Matriz que cont√©m um conjunto de vetores horizontais com probabilidades para cada classe. O
n√∫mero de linhas da matriz deve corresponder ao tamanho do vetor de valores reais.
mode
[in]  Modo de c√°lculo da m√©dia a partir da enumera√ß√£o ENUM_AVERAGE_MODE. S√£o usados apenas
AVERAGE_NONE, AVERAGE_BINARY e AVERAGE_MICRO.
precision
[out]  Matriz com valores calculados da curva precision. Se n√£o houver c√°lculo de m√©dia
(AVERAGE_NONE), o n√∫mero de linhas na matriz corresponder√° ao n√∫mero de classes de modelo. O
n√∫mero de colunas corresponde ao tamanho do vetor de valores verdadeiros (ou o n√∫mero de
linhas na matriz de distribui√ß√£o de probabilidade pred_score). No caso da micro-m√©dia, o n√∫mero
de linhas na matriz corresponde ao n√∫mero total de limites, excluindo as duplas.
recall
[out]  Matriz com valores calculados da curva recall.
threshold
[out]  Matriz de limiar obtida pela classifica√ß√£o da matriz de probabilidade
<h3>Observa√ß√£o</h3>
Consulte as notas sobre o m√©todo ClassificationScore.
<h3>Exemplo:</h3>
Exemplo de coleta de estat√≠sticas do modelo mnist.onnx (99% de precis√£o).
</p>
<pre><code class="language-mql5">
//--- data for classification metrics
   vectorf y_true(images);
   vectorf y_pred(images);
   matrixf y_scores(images,10);
//--- input-output
   matrixf image(28,28);</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1534
</p>
<pre><code class="language-mql5">
   vectorf result(10);
//--- testing
   for(int test=0; test&lt;images; test++)
     {
      image=test_data[test].image;
      if(!OnnxRun(model,ONNX_DEFAULT,image,result))
        {
         Print(&quot;OnnxRun error &quot;,GetLastError());
         break;
        }
      result.Activation(result,AF_SOFTMAX);
      //--- collect data
      y_true[test]=(float)test_data[test].label;
      y_pred[test]=(float)result.ArgMax();
      y_scores.Row(result,test);
     }    }
</code></pre>
<p>
<h3>C√°lculo da precis√£o</h3>
</p>
<pre><code class="language-mql5">
   vectorf accuracy=y_pred.ClassificationMetric(y_true,CLASSIFICATION_ACCURACY);
   PrintFormat(&quot;accuracy=%f&quot;,accuracy[0]);
</code></pre>
<p>
accuracy=0.989000
Exemplo de gera√ß√£o de gr√°ficos precision-recall, em que os valores de precision s√£o plotados no eixo y
e os valores de recall s√£o plotados no eixo x. Assim como a gera√ß√£o de gr√°ficos separados de precision
e recall, em que os valores de limite s√£o plotados no eixo x  
</p>
<pre><code class="language-mql5">
   if(y_true.PrecisionRecall(y_scores,AVERAGE_MICRO,mat_precision,mat_recall,mat_thres
     {
      double precision[],recall[],thres[];
      ArrayResize(precision,mat_thres.Cols());
      ArrayResize(recall,mat_thres.Cols());
      ArrayResize(thres,mat_thres.Cols());
      for(uint i=0; i&lt;thres.Size(); i++)
        {
         precision[i]=mat_precision[0][i];
         recall[i]=mat_recall[0][i];
         thres[i]=mat_thres[0][i];
        }
      thres[0]=thres[1]+0.001;
      PlotCurve(&quot;Precision-Recall curve (micro average)&quot;,&quot;p-r&quot;,&quot;&quot;,recall,precision);
      Plot2Curves(&quot;Precision-Recall (micro average)&quot;,&quot;precision&quot;,&quot;recall&quot;,thres,precis
     }</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1535
<h3>Resultado:</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1536
</p>
<pre><code class="language-mql5">
   </p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1537
<h3>ReceiverOperatingCharacteristic</h3>
Calcula os valores para tra√ßar a curva Receiver Operating Characteristic (ROC). Esse m√©todo, assim
como o m√©todo ClassificationScore, √© aplicado a um vetor de valores verdadeiros.
</p>
<pre><code class="language-mql5">
bool vector::ReceiverOperatingCharacteristic(
   const matrix&amp;¬†             pred_scores,   //¬†matriz que cont√©m a distribui√ß√£o de pr
   const ENUM_ENUM_AVERAGE_MODE  mode¬†          //¬†modo de c√°lculo da m√©dia
   matrix&amp;¬†                      fpr,           //¬†valores false positive rate calcula
   matrix&amp;¬†                      tpr,           //¬†valores true positive rate calculad
   matrix&amp;¬†                      thresholds,    //¬†limiares classificados em ordem dec
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
pred_scores
[in] Matriz que cont√©m um conjunto de vetores horizontais com probabilidades para cada classe. O
n√∫mero de linhas da matriz deve corresponder ao tamanho do vetor de valores reais.
mode
[in]  Modo de c√°lculo da m√©dia a partir da enumera√ß√£o ENUM_AVERAGE_MODE. S√£o usados apenas
AVERAGE_NONE, AVERAGE_BINARY e AVERAGE_MICRO.
fpr
[out]  Matriz com valores calculados da curva false positive rate. Se n√£o houver c√°lculo de m√©dia
(AVERAGE_NONE), o n√∫mero de linhas na matriz corresponder√° ao n√∫mero de classes de modelo. O
n√∫mero de colunas corresponde ao tamanho do vetor de valores verdadeiros (ou o n√∫mero de
linhas na matriz de distribui√ß√£o de probabilidade pred_score). No caso da micro-m√©dia, o n√∫mero
de linhas na matriz corresponde ao n√∫mero total de limites, excluindo as duplas.
tpr
[out]  Matriz com valores calculados da curva true positive rate.
threshold
[out]  Matriz de limiar obtida pela classifica√ß√£o da matriz de probabilidade
<h3>Observa√ß√£o</h3>
Consulte as notas sobre o m√©todo ClassificationScore.
<h3>Exemplo:</h3>
Exemplo de exibi√ß√£o de gr√°fico ROC, em que os valores de tpr s√£o plotados no eixo y e os valores de
fpr s√£o plotados no eixo x. Al√©m de gerar gr√°ficos separados de fpr e tpr, em que os valores de limite
s√£o plotados no eixo x.
</p>
<pre><code class="language-mql5">
   matrixf mat_thres;
   matrixf mat_fpr;
   matrixf mat_tpr;</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1538
</p>
<pre><code class="language-mql5">
   if(y_true.ReceiverOperatingCharacteristic(y_scores,AVERAGE_MICRO,mat_fpr,mat_tpr,ma
     {
      double fpr[],tpr[],thres[];
      ArrayResize(fpr,mat_thres.Cols());
      ArrayResize(tpr,mat_thres.Cols());
      ArrayResize(thres,mat_thres.Cols());
      for(uint i=0; i&lt;fpr.Size(); i++)
        {
         fpr[i]=mat_fpr[0][i];
         tpr[i]=mat_tpr[0][i];
         thres[i]=mat_thres[0][i];
        }
      thres[0]=thres[1]+0.001;
      PlotCurve(&quot;ROC curve (micro average)&quot;,&quot;roc&quot;,&quot;0.5&quot;,fpr,tpr);
      Plot2Curves(&quot;fpr-tpr (micro average)&quot;,&quot;fpr&quot;,&quot;tpr&quot;,thres,fpr,tpr);
     }
    
</code></pre>
<p>
<h3>Resultado:</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1539</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1540
<h3>O</h3>
c√≥digo 
de 
gera√ß√£o 
de 
gr√°ficos 
√© 
elementar 
e 
se 
baseia 
na 
biblioteca 
padr√£o
&lt;Graphics/Graphic.mqh&gt;.
S√£o usados dados de teste do modelo mnist.onnx, e o c√≥digo √© apresentado na descri√ß√£o do m√©todo
PrecisionRecall.
O ROC AUC est√° pr√≥ximo do ideal.
roc auc score micro = [0.99991]</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1541
<h3>OpenBLAS Methods</h3>
OpenBLAS is a high-performance open-source linear algebra library that implements BLAS (Basic Linear
Algebra Subprograms) and some LAPACK functions. OpenBLAS is designed to improve computational
performance, particularly in matrix and vector operations, which are often used in scientific and
engineering tasks such as machine learning, numerical methods, and simulations.
<h3>Key features of OpenBLAS:</h3>
¬∑ Multithreading support: OpenBLAS can efficiently use multiple processor cores for parallel
computations, significantly accelerating operations on multiprocessor systems.
¬∑ Optimization for processor architectures: OpenBLAS includes optimized builds for various processors
such as Intel, AMD, ARM and others. The library automatically detects processor characteristics and
selects the most suitable function implementations.
¬∑ Extensive BLAS operation support: OpenBLAS implements core BLAS functions, including vector
operations (e.g., vector addition and dot product), matrix operations (multiplication), and vector-
matrix operations.
¬∑ LAPACK compatibility: The library supports LAPACK (Linear Algebra PACKage) functions for more
complex linear algebra operations, such as solving systems of linear equations, calculating matrix
eigenvalues, and others.
¬∑ High performance: Compared to other BLAS libraries, OpenBLAS often shows better results due to
hand-optimization for specific processor architectures.
<h3>Applications</h3>
OpenBLAS is widely used in applications involving numerical computations:
¬∑ Training neural networks and other machine learning tasks.
¬∑ Scientific computing (e.g. modeling of physical processes).
¬∑ Processing and analyzing large amounts of data.
The library is integrated into many popular scientific software packages such as NumPy, SciPy, and
TensorFlow, which rely on high-performance linear algebra operations.
OpenBLAS is an excellent choice for those seeking an open-source solution for high-performance
computing, particularly when working with large matrices and vectors.
<h3>Function</h3>
<h3>Action</h3>
<h3>SingularValueDecompositionDC</h3>
<h3>Singular Value Decomposition, &quot;divide-and-</h3>
conquer&quot; algorithm. This algorithm is
considered the fastest among other SVD
algorithms (lapack function GESDD).
<h3>SingularValueDecompositionQR</h3>
<h3>Singular</h3>
<h3>Value</h3>
<h3>Decomposition,</h3>
<h3>QR</h3>
algorithm. This algorithm is considered a
classical SVD algorithm (lapack function
GESVD).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1542
<h3>Function</h3>
<h3>Action</h3>
<h3>SingularValueDecompositionQRPivot</h3>
<h3>Singular Value Decomposition, QR with</h3>
pivoting 
algorithm 
(lapack 
function
GESVDQ).
<h3>SingularValueDecompositionBisect</h3>
<h3>Singular Value Decomposition, bisection</h3>
algorithm (lapack function GESVDX).
<h3>SingularValueDecompositionJacobiHigh</h3>
<h3>Singular Value Decomposition, Jacobi high</h3>
level algorithm (lapack function GEJSV).
<h3>SingularValueDecompositionJacobiLow</h3>
<h3>Singular Value Decomposition, Jacobi low</h3>
level algorithm (lapack function GESVJ).
<h3>The method computes small singular</h3>
values and their singular vectors with
much greater accuracy than other SVD
routines in certain cases.
<h3>SingularValueDecompositionBidiagDC</h3>
<h3>Singular Value Decomposition, divide-and-</h3>
conquer algorithm for bidiagonal matrices
(lapack function BDSVDX).
<h3>SingularValueDecompositionBidiagBisect</h3>
<h3>Singular Value Decomposition, bisection</h3>
algorithm for bidiagonal matrices (lapack
function BDSVDX).
<h3>EigenSolver</h3>
<h3>Compute eigenvalues and eigenvectors of</h3>
a regular square matrix using the classical
algorithm (lapack function GEEV).
<h3>EigenSolver2</h3>
<h3>Compute generalized</h3>
eigenvalues 
and
eigenvectors for a pair of ordinary square
matrices (lapack function GGEV).
<h3>EigenSolverX</h3>
<h3>Compute eigenvalues and eigenvectors of</h3>
a regular square matrix in Expert mode,
i.e. with the ability to influence the
computation algorithm and the ability to
obtain accompanying computation data
(lapack function GEEVX).
<h3>EigenSolverShur</h3>
<h3>Compute eigenvalues, upper triangular</h3>
matrix in Schur form, and matrix of Schur
vectors (lapack function GEES). See also
Schur decomposition.
<h3>EigenSymmetricDC</h3>
<h3>Compute eigenvalues and eigenvectors of</h3>
a 
symmetric 
or 
<h3>Hermitian</h3>
(complex
conjugate) matrix using the divide-and-
conquer 
algorithm 
(lapack 
functions
SYEVD, HEEVD).
<h3>EigenSymmetricQR</h3>
<h3>Compute eigenvalues and eigenvectors of</h3>
a 
symmetric 
or 
<h3>Hermitian</h3>
(complex</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1543
<h3>Function</h3>
<h3>Action</h3>
conjugate) matrix using the QR algorithm
(lapack functions SYEV, HEEV).
<h3>EigenSymmetricRobust</h3>
<h3>Compute eigenvalues and eigenvectors of</h3>
a 
symmetric 
or 
<h3>Hermitian</h3>
(complex
conjugate) matrix using the Multiple
<h3>Relatively Robust Representations, MRRR</h3>
algorithm 
(lapack 
functions 
<h3>SYEVR,</h3>
HEEVR).
<h3>EigenSymmetricBisect</h3>
<h3>Compute eigenvalues and eigenvectors of</h3>
a 
symmetric 
or 
<h3>Hermitian</h3>
(complex
conjugate) matrix using the bisection
algorithm 
(lapack 
functions 
<h3>SYEVX,</h3>
HEEVX).
<h3>SingularSpectrumAnalysisSpectrum</h3>
<h3>A method function for calculating the</h3>
relative 
contributions 
of 
spectral
components based on their eigenvalues.
<h3>SingularSpectrumAnalysisForecast</h3>
<h3>A</h3>
method 
function 
</p>
<pre><code class="language-mql5">
for 
</code></pre>
<p>
calculating
reconstructed and predicted data using
spectral components of the input time
series.
<h3>SingularSpectrumAnalysisReconstructComponents</h3>
<h3>A</h3>
method 
function 
</p>
<pre><code class="language-mql5">
for 
</code></pre>
<p>
calculating
reconstructed components of the input
time series and their contributions.
<h3>SingularSpectrumAnalysisReconstructSeries</h3>
<h3>A method function for calculating the</h3>
reconstructed time series using the first
component_count components.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1544
<h3>Singular value decomposition</h3>
This section features functions for decomposing a matrix into three components: orthogonal matrices
and a diagonal matrix of singular values. SVD is applied to solve various linear algebra problems such
as data dimensionality reduction, image compression, solving systems of equations, and data analysis
and optimization. The main functions allow you to compute singular values and vectors, reconstruct
matrices, and approximate matrices with reduced rank accuracy.
<h3>Function</h3>
<h3>Action</h3>
<h3>SingularValueDecompositionDC</h3>
Singular Value Decomposition, &quot;divide-and-conquer&quot;
algorithm. This algorithm is considered the fastest
among other SVD algorithms (lapack function
GESDD).
<h3>SingularValueDecompositionQR</h3>
<h3>Singular Value Decomposition, QR algorithm. This</h3>
algorithm is considered a classical SVD algorithm
(lapack function GESVD).
<h3>SingularValueDecompositionQRPivot</h3>
<h3>Singular Value Decomposition, QR with pivoting</h3>
algorithm (lapack function GESVDQ).
<h3>SingularValueDecompositionBisect</h3>
<h3>Singular Value Decomposition, bisection algorithm</h3>
(lapack function GESVDX).
<h3>SingularValueDecompositionJacobiHigh</h3>
<h3>Singular Value Decomposition, Jacobi high level</h3>
algorithm (lapack function GEJSV).
<h3>SingularValueDecompositionJacobiLow</h3>
<h3>Singular Value Decomposition, Jacobi low level</h3>
algorithm (lapack function GESVJ). The method
computes small singular values and their singular
vectors with much greater accuracy than other SVD
routines in certain cases.
<h3>SingularValueDecompositionBidiagDC</h3>
<h3>Singular Value Decomposition, divide-and-conquer</h3>
algorithm for bidiagonal matrices (lapack function
BDSVDX).
<h3>SingularValueDecompositionBidiagBisect</h3>
<h3>Singular Value Decomposition, bisection algorithm</h3>
</p>
<pre><code class="language-mql5">
for bidiagonal matrices (lapack function BDSVDX).
</code></pre>
<p>
<h3>SingularValueDecompositionBidiagQR</h3>
Computes the singular value decomposition of a
general matrix that has been reduced to bidiagonal
form by the method ReduceToBidiagonal. Lapack
function BDSQR.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1545
<h3>SingularValueDecompositionDC</h3>
Singular Value Decomposition, &quot;divide-and-conquer&quot; algorithm. This algorithm is considered the
fastest among other SVD algorithms (lapack function GESDD).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionDC(
   ENUM_SVD_Z      jobz,¬†    // how to computed
   vector&amp;         S,¬†       // vector of computed singular values
   matrix&amp;         U,¬†       // matrix of computed left vectors U
   matrix&amp;         VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionDC(
   ENUM_SVD_Z      jobz,¬†    // how to computed
   vectorf&amp;        S,¬†       // vector of computed singular values
   matrixf&amp;        U,¬†       // matrix of computed left vectors U
   matrixf&amp;        VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionDC(
   ENUM_SVD_Z      jobz,¬†    // how to computed
   vector&amp;         S,¬†       // vector of computed singular values
   matrixc&amp;        U,¬†       // matrix of computed left vectors U
   matrixc&amp;        VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionDC(
   ENUM_SVD_Z      jobz,¬†                  // how to computed
   vectorf&amp;        singular_values,¬†       // vector of computed singular values
   matrixcf&amp;       U,¬†                     // matrix of computed left vectors U
   matrixcf&amp;       VT¬†                     // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobz
[in]  ENUM_SVD_Z enumeration value which determines the method for computing left and singular
eigenvectors.
<h3>S</h3>
[out] Vector of singular values.
<h3>U</h3>
[out] Matrix of left singular vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1546
<h3>VT</h3>
[out] Matrix of right singular vectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the jobz parameter.
When jobv is set to SVDZ_N, the left and right vectors are not computed. Only singular values are
computed.
When jobv is set to SVDZ_A, the full matrices of the U and VT vectors are computed.
When the value is SVDZ_S, truncated matrices of vectors U and VT are computed.
<h3>ENUM_SVD_Z</h3>
An enumeration defining the way to compute left and right singular vectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDZ_N</h3>
Columns U or rows VT are not computed
<h3>SVDZ_A</h3>
All M columns of U or all N columns of VT are returned in arrays
<h3>U and VT</h3>
<h3>SVDZ_S</h3>
The first min(M,N) columns of U or the first min(M,N) columns
of VT are returned in arrays U and VT
<h3>See also</h3>
SingularValueDecompositionQR, SingularValueDecompositionQRPivot</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1547
<h3>SingularValueDecompositionQR</h3>
Singular Value Decomposition, QR algorithm. Considered a classical SVD algorithm (lapack function
GESVD).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQR(
   ENUM_SVD_Z      jobu,¬†    // how to compute left vectors
   ENUM_SVD_Z      jobv,¬†    // how to compute right vectors
   vector&amp;         S,¬†       // vector of computed singular values
   matrix&amp;         U,¬†       // matrix of computed left vectors U
   matrix&amp;         VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQR(
   ENUM_SVD_Z      jobu,¬†    // how to compute left vectors
   ENUM_SVD_Z      jobv,¬†    // how to compute right vectors
   vectorf&amp;        S,¬†       // vector of computed singular values
   matrixf&amp;        U,¬†       // matrix of computed left vectors U
   matrixf&amp;        VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQR(
   ENUM_SVD_Z      jobu,¬†    // how to compute left vectors
   ENUM_SVD_Z      jobv,¬†    // how to compute right vectors
   vector          S,¬†       // vector of computed singular values
   matrixc         U,¬†       // matrix of computed left vectors U
   matrixc         VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQR(
   ENUM_SVD_Z      jobu,¬†                  // how to compute left vectors
   ENUM_SVD_Z      jobv,¬†                  // how to compute right vectors
   vectorf&amp;        singular_values,¬†       // vector of computed singular values
   matrixcf&amp;       u,¬†                     // matrix of computed left vectors U
   matrixcf&amp;       vt¬†                     // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobu
[in]  ENUM_SVD_Z enumeration value defining how the left singular vectors should be computed.
jobv</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1548
[in]  ENUM_SVD_Z enumeration value defining how the right singular vectors should be computed.
<h3>S</h3>
[out] Vector of singular values.
<h3>U</h3>
[out] Matrix of left singular vectors.
<h3>VT</h3>
[out] Matrix of right singular vectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the jobu and jobv parameters.
When set to SVDZ_N, the left (jobu) and right (jobv) vectors are not computed. Singular values are
always computed.
When set to SVDZ_A, the full matrices of vectors U (jobu) or VT (jobv) are computed.
With the value SVDZ_S, truncated matrices of vectors U (jobu) or VT (jobv) are computed.
<h3>ENUM_SVD_Z</h3>
An enumeration defining the way to compute left and right singular vectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDZ_N</h3>
Columns U or rows VT are not computed
<h3>SVDZ_A</h3>
All M columns of U or all N columns of VT are returned in arrays
<h3>U and VT</h3>
<h3>SVDZ_S</h3>
The first min(M,N) columns of U or the first min(M,N) columns
of VT are returned in arrays U and VT
<h3>See also</h3>
SingularValueDecompositionDC, SingularValueDecompositionQRPivot</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1549
<h3>SingularValueDecompositionQRPivot</h3>
Singular Value Decomposition, QR with pivoting algorithm (lapack function GESVDQ).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQRPivot(
   ENUM_SVDQRP_A   joba,¬†    // computation accuracy level
   ENUM_SVDQRP_P   jobp,¬†    // use row reversal to compute
   ENUM_SVDQRP_R   jobr,¬†    // use triangular matrix R to compute
   ENUM_SVDQRP_U   jobu,¬†    // how to compute left vectors
   ENUM_SVDQRP_V   jobv,¬†    // how to compute right vectors
   vector&amp;         S,¬†       // vector of computed singular values
   matrix&amp;         U,¬†       // matrix of computed left vectors U
   matrix&amp;         VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQRPivot(
   ENUM_SVDQRP_A   joba,¬†    // computation accuracy level
   ENUM_SVDQRP_P   jobp,¬†    // use row reversal to compute
   ENUM_SVDQRP_R   jobr,¬†    // use triangular matrix R to compute
   ENUM_SVDQRP_U   jobu,¬†    // how to compute left vectors
   ENUM_SVDQRP_V   jobv,¬†    // how to compute right vectors
   vectorf&amp;        S,¬†       // vector of computed singular values
   matrixf&amp;        U,¬†       // matrix of computed left vectors U
   matrixf&amp;        VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQRPivot(
   ENUM_SVDQRP_A   joba,¬†    // computation accuracy level
   ENUM_SVDQRP_P   jobp,¬†    // use row reversal to compute
   ENUM_SVDQRP_R   jobr,¬†    // use triangular matrix R to compute
   ENUM_SVDQRP_U   jobu,¬†    // how to compute left vectors
   ENUM_SVDQRP_V   jobv,¬†    // how to compute right vectors
   vector&amp;         S,¬†       // vector of computed singular values
   matrixc&amp;        U,¬†       // matrix of computed left vectors U
   matrixc&amp;        VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionQRPivot(
   ENUM_SVDQRP_A   joba,¬†                  // computation accuracy level
   ENUM_SVDQRP_P   jobp,¬†                  // use row reversal to compute
   ENUM_SVDQRP_R   jobr,¬†                  // use triangular matrix R to compute
   ENUM_SVDQRP_U   jobu,¬†                  // how to compute left vectors</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1550
</p>
<pre><code class="language-mql5">
   ENUM_SVDQRP_V   jobv,¬†                  // how to compute right vectors
   vectorf&amp;        singular_values,¬†       // vector of computed singular values
   matrixcf&amp;       u,                      // matrix of computed left vectors U
   matrixcf&amp;       vt¬†                     // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Parameters</h3>
joba
[in]  ENUM_SVDQRP_A enumeration value defining the accuracy level of the SVD computation.
jobp
[in]  ENUM_SVDQRP_P enumeration value defining the use of row reversal during the computation
process.
jobr
[in]  ENUM_SVDQRP_R enumeration value defining whether to transpose the triangular matrix R
obtained as a result of the initial QR factorization.
jobu
[in]  ENUM_SVDQRP_U enumeration value that determines how the left singular vectors should be
computed.
jobv
[in]  ENUM_SVDQRP_V enumeration value defining how the right singular vectors should be
computed.
<h3>S</h3>
[out] Vector of singular values.
<h3>U</h3>
[out] Matrix of left singular vectors.
<h3>VT</h3>
[out] Matrix of right singular vectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The number of matrix rows must not be less than the number of columns.
If both left and right singular vectors are computed, jobv must be set to SVDQRPV_R when
jobu=SVDQRPU_R.
<h3>ENUM_SVDQRP_A</h3>
An enumeration that specifies the level of accuracy of the SVD computation.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1551
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDQRP_A</h3>
The requested accuracy corresponds to the inverse error
limited by epsilon. This is an aggressive level of truncation.
<h3>SVDQRPA_M</h3>
Similar to SVDQRP_A, but the truncation is softer. This is the
average level of truncation.
<h3>SVDQRPA_H</h3>
High accuracy is required.
<h3>ENUM_SVDQRP_P</h3>
An enumeration that specifies whether to use row reversal during calculation.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDQRPP_P</h3>
The rows of A are ordered in descending order. Recommended
</p>
<pre><code class="language-mql5">
for numerical reliability.
</code></pre>
<p>
<h3>SVDQRPP_N</h3>
No row reversal.
<h3>ENUM_SVDQRP_R</h3>
An enumeration that specifies whether to transpose the triangular matrix R obtained as a result of the
initial QR factorization.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDQRPR_T</h3>
After the initial rotated QR factorization, GESVD is applied to
the transpose R**T of the calculated triangular factor R.
<h3>SVDQRPR_N</h3>
The triangular factor R is given as input to GESVD.
<h3>ENUM_SVDQRP_U</h3>
An enumeration defining how left singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDQRPU_A</h3>
All M left singular vectors are computed.
<h3>SVDQRPU_S</h3>
The min(M,N) left singular vectors are computed.
<h3>SVDQRPU_R</h3>
The numerical rank NUMRANK is determined and only the
NUMRANK of the left singular vectors is computed.
<h3>SVDQRPU_F</h3>
N left singular vectors are returned.
<h3>SVDQRPU_N</h3>
Left singular vectors are not computed.
<h3>ENUM_SVDQRP_V</h3>
An enumeration defining how right singular vectors should be computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1552
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDQRPV_A</h3>
All N right singular vectors are computed.
<h3>SVDQRPV_R</h3>
The numerical rank NUMRANK is defined and only the NUMRANK
of right singular vectors are computed.
<h3>SVDQRPV_N</h3>
Right singular vectors are not computed.
<h3>See also</h3>
<h3>SingularValueDecompositionDC, SingularValueDecompositionQR</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1553
<h3>SingularValueDecompositionBisect</h3>
Singular Value Decomposition, bisection algorithm (lapack function GESVDX).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBisect(
   ENUM_SVD_VECTORS    jobv,¬†    // computation accuracy level
   ENUM_BLAS_RANGE     range,¬†   // subset of computable singular values
   double              lower,¬†   // lower limit of the subset
   double              upper,¬†   // upper limit of the subset
   vector&amp;             S,¬†       // vector of computed singular values
   matrix&amp;             U,¬†       // matrix of computed left vectors U
   matrix&amp;             VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBisect(
   ENUM_SVD_VECTORS    jobv,¬†    // computation accuracy level
   ENUM_BLAS_RANGE     range,¬†   // subset of computable singular values
   double              lower,¬†   // lower limit of the subset
   double              upper,¬†   // upper limit of the subset
   vectorf&amp;            S,¬†       // vector of computed singular values
   matrixf&amp;            U,¬†       // matrix of computed left vectors U
   matrixf&amp;            VT¬†       // ransposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBisect(
   ENUM_SVD_VECTORS    jobv,¬†    // computation accuracy level
   ENUM_BLAS_RANGE     range,¬†   // subset of computable singular values
   double              lower,¬†   // lower limit of the subset
   double              upper,¬†   // upper limit of the subset
   vector              S,¬†       // vector of computed singular values
   matrixc             U,¬†       // matrix of computed left vectors U
   matrixc             VT¬†       // transposed matrix of right vectors VT
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBisect(
   ENUM_SVD_VECTORS    jobv,¬†              // computation accuracy level
   ENUM_BLAS_RANGE     range,¬†             // subset of computable singular values
   double              lower,¬†             // lower limit of the subset
   double              upper,¬†             // upper limit of the subset
   vectorf&amp;            singular_values,¬†   // vector of computed singular values
   matrixcf&amp;           u,¬†                 // matrix of computed left vectors U
   matrixcf&amp;           vt¬†                 // transposed matrix of right vectors VT</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1554
</p>
<pre><code class="language-mql5">
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_SVD_VECTORS enumeration value which determines the method for computing left and
singular eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable singular values
and vectors.
lower
[in]  The lower limit of singular values subset; specified depending on the value of the range
parameter.
upper
[in]  The upper limit of singular values subset; specified depending on the value of the range
parameter.
<h3>S</h3>
[out] Vector of singular values.
<h3>U</h3>
[out] Matrix of left singular vectors.
<h3>VT</h3>
[out] Matrix of right singular vectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobuv and range parameters.
When BLASRANGE_A is set, all singular values are computed, and the lower and upper parameters
are ignored.
With the BLASRANGE_V value, only those singular values (and their vectors) that fall within the
range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters are computed.
With the BLASRANGE_I value, only those singular values (and their vectors) that fall within the range
of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters are computed. For example, with
lower=0 and upper=2, only the first three singular values are computed.
<h3>ENUM_SVD_VECTORS</h3>
An enumeration defining the way to compute left and right singular vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1555
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDVECTORS_N</h3>
Only singular values are computed, without vectors.
<h3>SVDVECTORS_U</h3>
Left singular vectors are computed.
<h3>SVDVECTORS_V</h3>
Right singular vectors are computed.
<h3>SVDVECTORS_UV</h3>
Left and right singular vectors are computed.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining a subset of computable singular values and vectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
Singular or eigenvalues from IL to IU will be found
<h3>See also</h3>
SingularValueDecompositionDC, SingularValueDecompositionQR, SingularValueDecompositionQRPivot</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1556
<h3>SingularValueDecompositionJacobiHigh</h3>
Singular Value Decomposition, Jacobi high level algorithm (lapack function GEJSV).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiHigh(
   ENUM_SVDJH_A   joba,¬†           // computation accuracy level
   ENUM_SVDJH_U   jobu,¬†           // how to compute left vectors
   ENUM_SVDJH_V   jobv,¬†           // how to compute right vectors
   ENUM_SVDJH_R   jobr,¬†           // define range of computable singular values
   ENUM_SVDJH_T   jobt,¬†           // define whether to transpose when computing a squ
   ENUM_SVDJH_P   jobp,¬†           // the possibility of structured perturbations to r
   vector&amp;        S,¬†              // vector of computed singular values
   matrix&amp;        U,¬†              // matrix of computed left vectors U
   matrix&amp;        V,¬†              // matrix of computed left vectors V
   vector&amp;        work_results     // additional computation results
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiHigh(
   ENUM_SVDJH_A   joba,¬†           // computation accuracy level
   ENUM_SVDJH_U   jobu,¬†           // how to compute left vectors
   ENUM_SVDJH_V   jobv,¬†           // how to compute right vectors
   ENUM_SVDJH_R   jobr,¬†           // define range of computable singular values
   ENUM_SVDJH_T   jobt,¬†           // define whether to transpose when computing a squ
   ENUM_SVDJH_P   jobp,¬†           // the possibility of structured perturbations to r
   vectorf&amp;       S,¬†              // vector of computed singular values
   matrixf&amp;       U,¬†              // U matrix of computed left vectors
   matrixf&amp;       V,¬†              // V matrix of computed left vectors
   vector&amp;        work_results     // additional computation results
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiHigh(
   ENUM_SVDJH_A   joba,¬†           // computation accuracy level
   ENUM_SVDJH_U   jobu,¬†           // how to compute left vectors
   ENUM_SVDJH_V   jobv,¬†           // how to compute right vectors
   ENUM_SVDJH_R   jobr,¬†           // define range of computable singular values
   ENUM_SVDJH_T   jobt,¬†           // define whether to transpose when computing a squ
   ENUM_SVDJH_P   jobp,¬†           // the possibility of structured perturbations to r
   vectorc&amp;       S,¬†              // vector of computed singular values
   matrixc&amp;       U,¬†              // U matrix of computed left vectors
   matrixc&amp;       V,¬†              // V matrix of computed left vectors
   vector&amp;        work_results     // additional computation results
   );</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1557
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiHigh(
   ENUM_SVDJH_A    joba,¬†                  // computation accuracy level
   ENUM_SVDJH_U    jobu,¬†                  // how to compute left vectors
   ENUM_SVDJH_V    jobv,¬†                  // how to compute right vectors
   ENUM_SVDJH_R    jobr,¬†                  // define range of computable singular valu
   ENUM_SVDJH_T    jobt,¬†                  // define whether to transpose when computi
   ENUM_SVDJH_P    jobp,¬†                  // the possibility of structured perturbati
   vectorf&amp;        singular_values,¬†       // vector of computed singular values S
   matrixcf&amp;       u,¬†                     // matrix of computed left vectors U
   matrixcf&amp;       v,¬†                     // matrix of computed left vectors V
   vectorf&amp;        work_results            // additional computation results
   );
</code></pre>
<p>
<h3>Parameters</h3>
joba
[in]  ENUM_SVDJH_A enumeration value determining the accuracy level of the SVD computation.
jobu
[in]  ENUM_SVDJH_U enumeration value that determines how the left singular vectors should be
computed.
jobv
[in]  ENUM_SVDJH_V enumeration value that determines how the right singular vectors should be
computed.
jobr
[in]  ENUM_SVDJH_R enumeration value defining the range of computable values
jobt
[in]  ENUM_SVDJH_T enumeration value defining whether to transpose the matrix of it is square.
If the matrix is non-square, this parameter is ignored.
jobp
[in]  ENUM_SVDJH_P enumeration value defining the possibility of structured perturbations to
remove denormalized values.
<h3>S</h3>
[out] Vector of singular values.
For work(1)/work(2) = one: the singular values of A. During the computation S contains
Euclidean column norms of the iterated matrices in the array a.
For work(1)‚â†work(2): the singular values of A are (work(1)/work(2)) * S(1:n). This factored form
is used if sigma_max(A) overflows or if small singular values have been saved from underflow by
scaling the input matrix A.
jobr = &#x27;R&#x27;, some of the singular values may be returned as exact zeros obtained by &#x27;setting to
zero&#x27; because they are below the numerical rank threshold or are denormalized numbers.
<h3>U</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1558
[out] Matrix of left singular vectors.
<h3>V</h3>
[out] Matrix of right singular vectors.
work_results
[out] Vector consisting of 7 statistics obtained as a result of the computation.
work(1) = scale = work(2)/work(1) is the scaling factor such that scale*sva(1:n) are the
computed singular values of A. See the description of S.
work(2) = see the description of work(1).
work(3) = sconda is an estimate for the condition number of column equilibrated A. If joba = &#x27;E&#x27;
or &#x27;G&#x27;, sconda is an estimate of sqrt(||(R**t * R)**(-1)||_1). It is computed using ?pocon. It holds
n**(-1/4) * sconda ‚â§ ||R**(-1)||_2 ‚â§ n**(1/4) * sconda, where R is the triangular factor from the
QRF of A. However, if R is truncated and the numerical rank is determined to be strictly smaller
than n, sconda is returned as -1, indicating that the smallest singular values might be lost.
If full SVD is needed, the following two condition numbers are useful for the analysis of the
algorithm. They are provied for a user who is familiar with the details of the method.
work(4) = an estimate of the scaled condition number of the triangular factor in the first QR
factorization.
work(5) = an estimate of the scaled condition number of the triangular factor in the second QR
factorization.
The following two parameters are computed if jobt = &#x27;T&#x27;. They are provided for a user who is
familiar with the details of the method.
work(6) = the entropy of A**t*A :: this is the Shannon entropy of diag(A**t*A) / Trace(A**t*A)
taken as point in the probability simplex.
work(7) = the entropy of A*A**t.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The number of matrix rows must not be less than the number of columns.
<h3>ENUM_SVDJH_A</h3>
An enumeration that specifies the level of accuracy of the SVD computation.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJHA_C</h3>
Computation as with &#x27;C&#x27; with an additional estimate of the
condition number. It provides a realistic error bound.
<h3>SVDJHA_E</h3>
Computation as with SVDJHA_C&#x27; with an additional estimate of
the condition number. It provides a realistic error bound.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1559
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJHA_F</h3>
Higher accuracy than the SVDJHA_C option.
<h3>SVDJHA_G</h3>
Computation as with SVDJHA_F with an additional estimate of
the condition number.
<h3>SVDJHA_A</h3>
Small singular values are the noise and the matrix is treated as
numerically rank deficient.
<h3>SVDJHA_R</h3>
Similar as in SVDJHA_A, but more accuracy.
<h3>ENUM_SVDJH_U</h3>
An enumeration defining how left singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJHU_U</h3>
N columns of U are returned in the array U.
<h3>SVDJHU_F</h3>
Full set of M left singular vectors is returned in the array U.
<h3>SVDJHU_N</h3>
U is not computed.
<h3>ENUM_SVDJH_V</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJHV_V</h3>
N columns of V are returned in the array V
<h3>SVDJHV_J</h3>
N columns of V are returned in the array V, but they are
computed as the product of Jacobi rotations
<h3>SVDJHV_N</h3>
<h3>V is not computed</h3>
<h3>ENUM_SVDJH_R</h3>
An enumeration that defines the range of values to be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJHR_N</h3>
Do not kill small columns of c*A.
<h3>SVDJHR_R</h3>
<h3>RESTRICTED</h3>
range 
</p>
<pre><code class="language-mql5">
for 
</code></pre>
<p>
sigma(c*A). 
<h3>This</h3>
option 
is
recommended.
<h3>ENUM_SVDJH_T</h3>
An enumeration that specifies whether a matrix should be transposed if it is square.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1560
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJHT_T</h3>
Transpose if entropy test indicates possibly faster convergence
of Jacobi process.
<h3>SVDJHT_N</h3>
Do not use transposition. Do not speculate.
<h3>ENUM_SVDJH_P</h3>
An enumeration that specifies the possibility of structured perturbations to remove denormalized
values.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJHP_P</h3>
Introduce perturbation.
<h3>SVDJHP_N</h3>
 Do not perturb.
<h3>See also</h3>
<h3>SingularValueDecompositionDC, SingularValueDecompositionQR</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1561
<h3>SingularValueDecompositionJacobiLow</h3>
Singular Value Decomposition, Jacobi low level algorithm (lapack function GESVJ). The method
computes small singular values and their singular vectors with much greater accuracy than other SVD
routines in certain cases.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiLow(
   ENUM_SVDJH_U   jobu,¬†           // how to compute left vectors
   ENUM_SVDJH_V   jobv,¬†           // how to compute right vectors
   double         ctol,¬†           // threshold for convergence if jobu=&#x27;C&#x27;
   ulong          mv,¬†             // number of first rows of matrix V if jobv=&#x27;A&#x27;
   vector&amp;        S,¬†              // vector of computed singular values
   matrix&amp;        U,¬†              // matrix of computed left vectors U
   matrix&amp;        V,¬†              // matrix of computed left vectors V
   vector&amp;        work_results     // additional computation results
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiLow(
   ENUM_SVDJH_U   jobu,¬†           // how to compute left vectors
   ENUM_SVDJH_V   jobv,¬†           // how to compute right vectors
   double         ctol,¬†           // threshold for convergence if jobu=&#x27;C&#x27;
   ulong          mv,¬†             // number of first rows of matrix V if jobv=&#x27;A&#x27;
   vectorf&amp;       S,¬†              // vector of computed singular values
   matrixf&amp;       U,¬†              // U matrix of computed left vectors
   matrixf&amp;       V,¬†              // V matrix of computed left vectors
   vector&amp;        work_results     // additional computation results
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiLow(
   ENUM_SVDJH_U   jobu,¬†           // how to compute left vectors
   ENUM_SVDJH_V   jobv,¬†           // how to compute right vectors
   double         ctol,¬†           // threshold for convergence if jobu=&#x27;C&#x27;
   ulong          mv,¬†             // number of first rows of matrix V if jobv=&#x27;A&#x27;
   vector&amp;        S,¬†              // vector of computed singular values
   matrixc&amp;       U,¬†              // U matrix of computed left vectors
   matrixc&amp;       V,¬†              // V matrix of computed left vectors
   vector&amp;        work_results     // additional computation results
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionJacobiLow(
   ENUM_SVDJH_U    jobu,¬†                  // how to compute left vectors
   ENUM_SVDJH_V    jobv,¬†                  // how to compute right vectors</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1562
</p>
<pre><code class="language-mql5">
   double          ctol,¬†                  // threshold for convergence if jobu=&#x27;C&#x27;
   ulong           mv,¬†                    // number of first rows of matrix V if jobv
   vectorf&amp;        singular_values,¬†       // vector of computed singular values S
   matrixcf&amp;       u,¬†                     // matrix of computed left vectors U
   matrixcf&amp;       v,¬†                     // matrix of computed left vectors V
   vectorf&amp;        work_results            // additional computation results
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobu
[in]  ENUM_SVDJL_U enumeration value that determines how the left singular vectors should be
computed.
jobv
[in]  ENUM_SVDJL_V enumeration value defining how the right singular vectors should be
computed.
ctol
[in] Convergence threshold if jobu=SVDJLU_C. For other values of &#x27;jobu&#x27; the parameter is ignored.
mv
[in] Number of rows of matrix V to be computed if jobv=SVDJLV_A. For other values of &#x27;jobv&#x27; the
parameter is ignored.
<h3>S</h3>
[out] Vector of singular values.
Depending on the value scale = work(1), where scale is the scaling factor:
</p>
<pre><code class="language-mql5">
    if scale = 1, S(1:n) contains the computed singular values of a. During the computation, sva
</code></pre>
<p>
contains the Euclidean column norms of the iterated matrices in the array a.
</p>
<pre><code class="language-mql5">
    if scale ‚â† 1, the singular values of a are scale*S(1:n), and this factored representation is due
</code></pre>
<p>
to the fact that some of the singular values of a might underflow or overflow.
<h3>U</h3>
[out] Matrix of left singular vectors.
<h3>V</h3>
[out] Matrix of right singular vectors (non-transposed).
work_results
[out] Vector consisting of 7 statistics obtained as a result of the computation.
work(1) = scale is the scaling factor such that scale*S(1:n) are the computed singular values of
A. See the description of S).
work(2) is the number of the computed nonzero singular value.
work(3) is the number of the computed singular values that are larger than the underflow
threshold.
work(4) is the number of sweeps of Jacobi rotations needed for numerical convergence.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1563
work(5) = max_{i.NE.j} |COS(A(:,i),A(:,j))| in the last sweep. This is useful information in
cases when ?gesvj did not converge, as it can be used to estimate whether the output is still
useful and for post festum analysis.
work(6) is the largest absolute value over all sines of the Jacobi rotation angles in the last
sweep. It can be useful in a post festum analysis.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The number of matrix rows must not be less than the number of columns.
<h3>ENUM_SVDJL_U</h3>
An enumeration defining how left singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJLU_U</h3>
The left singular vectors corresponding to the nonzero singular
values are computed and returned in the leading columns of A
<h3>SVDJLU_C</h3>
Analogous to SVDJLU_U, except that user can control the level
of numerical orthogonality of the computed left singular
vectors.
<h3>SVDJLU_N</h3>
The matrix U is not computed.
<h3>ENUM_SVDJL_V</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJLV_V</h3>
<h3>The matrix V is computed</h3>
<h3>SVDJLV_A</h3>
The Jacobi rotations are applied to the MV-by-N matrix V.
<h3>SVDJLV_N</h3>
The matrix V is not computed.
<h3>See also</h3>
<h3>SingularValueDecompositionDC, SingularValueDecompositionQR</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1564
<h3>SingularValueDecompositionBidiagDC</h3>
Singular Value Decomposition, divide-and-conquer algorithm for bidiagonal matrices (lapack function
BDSDC).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagDC(
   ENUM_SVDBIDIAG_Z    jobz,¬†      // how to compute left vectors
   ENUM_BLAS_RANGE     range,¬†     // subset of computed singular values
   double              lower,¬†     // lower limit of the subset
   double              upper,      // upper limit of the subset
   vector&amp;             S,¬†         // vector of computed singular values
   matrix&amp;             U,¬†         // U matrix of computed left vectors
   matrix&amp;             VT ¬†        // VT transposed matrix of right vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagDC(
   ENUM_SVDBIDIAG_Z    jobz,¬†      // how to compute left vectors
   ENUM_BLAS_RANGE     range,¬†     // subset of computed singular values
   double              lower,¬†     // lower limit of the subset
   double              upper,      // upper limit of the subset
   vectorf&amp;            S,¬†         // vector of computed singular values
   matrixf&amp;            U,¬†         // U matrix of computed left vectors
   matrixf&amp;            VT ¬†        // VT transposed matrix of right vectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobz
[in]  ENUM_SVDBIDIAG_Z enumeration value that determines how the left singular vectors should
be computed.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable singular values
and vectors.
lower
[in]  The lower limit of singular values subset; specified depending on the value of the range
parameter.
upper
[in]  The upper limit of singular values subset; specified depending on the value of the range
parameter.
<h3>S</h3>
[out] Vector of singular values.
<h3>U</h3>
[out] Matrix of left singular vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1565
<h3>V</h3>
[out] Transposed matrix of right singular vectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobz and range parameters.
When BLASRANGE_A is set, all singular values are computed, and the lower and upper parameters
are ignored.
With the BLASRANGE_V value, only those singular values (and their vectors) that fall within the
range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters are computed.
With the BLASRANGE_I value, only those singular values (and their vectors) that fall within the range
of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters are computed. For example, with
lower=0 and upper=2, only the first three singular values are computed.
A bidiagonal matrix is a square matrix with non-zero main diagonal and one of the sub-diagonals.
<h3>Upper bidiagonal matrix</h3>
[[x, x, 0, 0, 0],
 [0, x, x, 0, 0],
 [0, 0, x, x, 0],
 [0, 0, 0, x, x],
 [0, 0, 0, 0, x]]
<h3>Lower bidiagonal matrix</h3>
[[x, 0, 0, 0, 0],
 [x, x, 0, 0, 0],
 [0, x, x, 0, 0],
 [0, 0, x, x, 0],
 [0, 0, 0, x, x]]
<h3>ENUM_SVDBIDIAG_Z</h3>
An enumeration defining how left singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJOBZ_V</h3>
Compute singular values and singular vectors.
<h3>SVDJOBZ_N</h3>
Compute singular values only.
<h3>ENUM_BLAS_RANGE</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1566
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.
<h3>See also</h3>
<h3>SingularValueDecompositionDC, SingularValueDecompositionQR</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1567
<h3>SingularValueDecompositionBidiagBisect</h3>
Singular Value Decomposition, bisection algorithm for bidiagonal matrices (lapack function BDSVDX).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagBisect(
   ENUM_SVDBIDIAG_Z    jobz,¬†      // how to compute left vectors
   ENUM_BLAS_RANGE     range,¬†     // subset of computed singular values
   double              lower,¬†     // lower limit of the subset
   double              upper,      // upper limit of the subset
   vector&amp;             S,¬†         // vector of computed singular values
   matrix&amp;             U,¬†         // U matrix of computed left vectors
   matrix&amp;             VT ¬†        // VT transposed matrix of right vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagBisect(
   ENUM_SVDBIDIAG_Z    jobz,¬†      // how to compute left vectors
   ENUM_BLAS_RANGE     range,¬†     // subset of computed singular values
   double              lower,¬†     // lower limit of the subset
   double              upper,      // upper limit of the subset
   vectorf&amp;            S,¬†         // vector of computed singular values
   matrixf&amp;            U,¬†         // U matrix of computed left vectors
   matrixf&amp;            VT ¬†        // VT transposed matrix of right vectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobz
[in]  ENUM_SVDBIDIAG_Z enumeration value that determines how the left singular vectors should
be computed.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable singular values
and vectors.
lower
[in]  The lower limit of singular values subset; specified depending on the value of the range
parameter.
upper
[in]  The upper limit of singular values subset; specified depending on the value of the range
parameter.
<h3>S</h3>
[out] Vector of singular values.
<h3>U</h3>
[out] Matrix of left singular vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1568
<h3>V</h3>
[out] Transposed matrix of right singular vectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
When BLASRANGE_A is set, all singular values are computed, and the lower and upper parameters
are ignored.
With the BLASRANGE_V value, only those singular values (and their vectors) that fall within the
range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters are computed.
With the BLASRANGE_I value, only those singular values (and their vectors) that fall within the range
of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters are computed. For example, with
lower=0 and upper=2, only the first three singular values are computed.
A bidiagonal matrix is a square matrix with non-zero main diagonal and one of the sub-diagonals.
<h3>Upper bidiagonal matrix</h3>
[[x, x, 0, 0, 0],
 [0, x, x, 0, 0],
 [0, 0, x, x, 0],
 [0, 0, 0, x, x],
 [0, 0, 0, 0, x]]
<h3>Lower bidiagonal matrix</h3>
[[x, 0, 0, 0, 0],
 [x, x, 0, 0, 0],
 [0, x, x, 0, 0],
 [0, 0, x, x, 0],
 [0, 0, 0, x, x]]
<h3>ENUM_SVDBIDIAG_Z</h3>
An enumeration defining how left singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDJOBZ_V</h3>
Compute singular values and singular vectors.
<h3>SVDJOBZ_N</h3>
Compute singular values only.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1569
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.
<h3>See also</h3>
<h3>SingularValueDecompositionDC, SingularValueDecompositionQR</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1570
<h3>SingularValueDecompositionBidiagQR</h3>
Computes the singular value decomposition of a general matrix that has been reduced to bidiagonal
form by the method ReduceToBidiagonal. Lapack function BDSQR.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagQR(
   matrix&amp;         Q,¬†       // orthogonal matrix Q
   matrix&amp;         PT,¬†      // transposed matrix P
   vector&amp;         S,¬†       // vector of computed singular values
   matrix&amp;         U,¬†       // matrix U of computed left vectors
   matrix&amp;         VT¬†       // transposed matrix V of right vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagQR(
   matrix&amp;         Q,¬†       // orthogonal matrix Q
   matrix&amp;         PT,¬†      // transposed matrix P
   vectorf&amp;        S,¬†       // vector of computed singular values
   matrixf&amp;        U,¬†       // matrix U of computed left vectors
   matrixf&amp;        VT¬†       // transposed matrix V of right vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagQR(
   matrix&amp;         Q,¬†       // orthogonal matrix Q
   matrix&amp;         PH,¬†      // Hermitian conjugated matrix P
   vector          S,¬†       // vector of computed singular values
   matrixc         U,¬†       // matrix U of computed left vectors
   matrixc         VH¬†       // Hermitian conjugated matrix V of right vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::SingularValueDecompositionBidiagQR(
   matrixf&amp;        Q,¬†       // orthogonal matrix Q
   matrixf&amp;        PH,¬†      // Hermitian conjugated matrix P
   vectorf&amp;        S,¬†       // vector of computed singular values
   matrixcf&amp;       U,¬†       // matrix U of computed left vectors
   matrixcf&amp;       VH¬†       // Hermitian conjugated matrix V of right vectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>Q</h3>
[in]  Orthogonal matrix Q produced by method ReflectBidiagonalToQP. If matrix Q has zero size,
then left vectors U are not calculated.
<h3>PT</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1571
[in]  Transposed (or hermitian conjugated) matrix P produced by method ReflectBidiagonalToQP. If
matrix PT has zero size, then right vectors VT are not calculated.
<h3>S</h3>
[out] Vector of singular values.
<h3>U</h3>
[out] Matrix of left singular vectors.
<h3>VT</h3>
[out] Matrix of right singular vectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
BDSQR computes the singular values and, optionally, the right and/or left singular vectors from the
singular value decomposition (SVD) of a N-by-N (upper or lower) bidiagonal matrix B using the
implicit zero-shift QR algorithm.  The SVD of B has the form
</p>
<pre><code class="language-mql5">
    B = Q * S * P**T
</code></pre>
<p>
where S is the diagonal matrix of singular values, Q is an orthogonal matrix of left singular vectors,
and P is an orthogonal matrix of right singular vectors.  If left singular vectors are requested, this
subroutine actually returns U*Q instead of Q, and, if right singular vectors are requested, this
subroutine returns P**T*VT instead of P**T, for given real input matrices U and VT.  When U and VT
are the orthogonal matrices that reduce a general matrix A to bidiagonal form:  A = U*B*VT, as
computed by GEBRD, then
</p>
<pre><code class="language-mql5">
    A = (U*Q) * S * (P**T*VT)
</code></pre>
<p>
is the SVD of A.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1572
<h3>Eigen Values</h3>
The section features functions for computing eigenvalues and eigenvectors. It describes methods for
solving standard linear algebra problems using the LAPACK library algorithms. These functions are
efficient for matrix analysis, diagonalization, system stabilization, and other tasks.
¬∑ EigenSolver: The function is designed to compute the eigenvalues and eigenvectors of an arbitrary
square matrix using the classical algorithm represented by the GEEV lapack function. This method is
applied to a wide range of matrices, allowing the decomposition of matrices into their eigenvalues
and eigenvectors.
¬∑ EigenSymmetricDC: The function for computing eigenvalues and eigenvectors of symmetric or
Hermitian matrices using the divide-and-conquer algorithm. The lapack functions SYEVD and HEEVD
enable the efficient handling of symmetric or Hermitian matrices, providing faster and more
accurate processing of such matrices.
<h3>Function</h3>
<h3>Action</h3>
<h3>EigenSolver</h3>
Compute eigenvalues and eigenvectors of a regular
square matrix using the classical algorithm (lapack
function GEEV).
<h3>EigenSolverX</h3>
Compute eigenvalues and eigenvectors of a regular
square matrix in Expert mode, i.e. with the ability to
influence the computation algorithm and the ability
to obtain accompanying computation data (lapack
function GEEVX).
<h3>EigenSolverShur</h3>
<h3>Compute eigenvalues, upper triangular matrix in</h3>
Schur form, and matrix of Schur vectors (lapack
function GEES). See also Schur decomposition.
<h3>EigenSolver2</h3>
<h3>Compute generalized eigenvalues and eigenvectors</h3>
</p>
<pre><code class="language-mql5">
for a pair of ordinary square matrices (lapack
</code></pre>
<p>
function GGEV).
<h3>EigenSolver2X</h3>
<h3>Compute generalized eigenvalues and eigenvectors</h3>
</p>
<pre><code class="language-mql5">
for a pair of regular square matrices in Expert mode,
</code></pre>
<p>
i.e. with the ability to influence the computation
algorithm and the ability to obtain accompanying
computation data (lapack function GGEVX). Both
matrices must be the same size.
<h3>EigenSolver2Shur</h3>
Compute a pair of ordinary square matrices of
generalized eigenvalues,  generalized eigenvectors,
generalized Schur forms, as well as left and right
Schur vectors (lapack function GGES).
<h3>EigenSolver2Blocked</h3>
<h3>Compute generalized eigenvalues and eigenvectors</h3>
</p>
<pre><code class="language-mql5">
for a pair of regular square matrices using a block
</code></pre>
<p>
algorithm (lapack function GGEV3). Both matrices
must be the same size. The method parameters are
exactly the same as EigenSolver2.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1573
<h3>Function</h3>
<h3>Action</h3>
<h3>EigenSolver2ShurBlocked</h3>
Compute a pair of regular square matrices of
generalized eigenvalues,  generalized eigenvectors,
generalized Schur forms, as well as left and right
Schur vectors (lapack function GGES3).
<h3>EigenSymmetricDC</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the divide-and-conquer algorithm (lapack
functions SYEVD, HEEVD).
<h3>EigenSymmetricQR</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the QR algorithm (lapack functions SYEV,
HEEV).
<h3>EigenSymmetricRobust</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the Multiple Relatively Robust Representations,
MRRR algorithm (lapack functions SYEVR, HEEVR).
<h3>EigenSymmetricBisect</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the bisection algorithm (lapack functions
SYEVX, HEEVX).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1574
<h3>General Matrices</h3>
Functions for calculating eigenvalues and eigenvectors of a square matrix using classical algorithms. It
provides various methods for working with both real and complex matrices, allowing you to solve linear
algebra problems with a choice of methods for calculating eigenvectors.
<h3>Function</h3>
<h3>Action</h3>
<h3>EigenSolver</h3>
Compute eigenvalues and eigenvectors of a regular
square matrix using the classical algorithm (lapack
function GEEV).
<h3>EigenSolverX</h3>
Compute eigenvalues and eigenvectors of a regular
square matrix in Expert mode, i.e. with the ability to
influence the computation algorithm and the ability
to obtain accompanying computation data (lapack
function GEEVX).
<h3>EigenSolverShur</h3>
<h3>Compute eigenvalues, upper triangular matrix in</h3>
Schur form, and matrix of Schur vectors (lapack
function GEES). See also Schur decomposition.
<h3>EigenSolver2</h3>
<h3>Compute generalized eigenvalues and eigenvectors</h3>
</p>
<pre><code class="language-mql5">
for a pair of ordinary square matrices (lapack
</code></pre>
<p>
function GGEV).
<h3>EigenSolver2X</h3>
<h3>Compute generalized eigenvalues and eigenvectors</h3>
</p>
<pre><code class="language-mql5">
for a pair of regular square matrices in Expert mode,
</code></pre>
<p>
i.e. with the ability to influence the computation
algorithm and the ability to obtain accompanying
computation data (lapack function GGEVX). Both
matrices must be the same size.
<h3>EigenSolver2Shur</h3>
Compute a pair of ordinary square matrices of
generalized eigenvalues,  generalized eigenvectors,
generalized Schur forms, as well as left and right
Schur vectors (lapack function GGES).
<h3>EigenSolver2Blocked</h3>
<h3>Compute generalized eigenvalues and eigenvectors</h3>
</p>
<pre><code class="language-mql5">
for a pair of regular square matrices using a block
</code></pre>
<p>
algorithm (lapack function GGEV3). Both matrices
must be the same size. The method parameters are
exactly the same as EigenSolver2.
<h3>EigenSolver2ShurBlocked</h3>
Compute a pair of regular square matrices of
generalized eigenvalues,  generalized eigenvectors,
generalized Schur forms, as well as left and right
Schur vectors (lapack function GGES3).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1575
<h3>EigenSolver</h3>
Compute eigenvalues and eigenvectors of a regular square matrix using the classical algorithm (lapack
function GEEV).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver(
   ENUM_EIG_VECTORS      jobv,¬†                   // compute left and right eigenvecto
   vectorc&amp;              eigen_values,¬†           // vector of computed eigenvalues
   matrix&amp;               left_eigenvectors,¬†      // matrix of computed left vectors
   matrix&amp;               right_eigenvectors¬†      // matrix of computed right vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSolver(
   ENUM_EIG_VECTORS      jobv,¬†                   // compute left and right eigenvecto
   vectorcf&amp;             eigen_values,¬†           // vector of computed eigenvalues
   matrixf&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixf&amp;              right_eigenvectors¬†      // matrix of computed right vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSolver(
   ENUM_EIG_VECTORS      jobv,¬†                   // compute left and right vectors
   vectorc&amp;              eigen_values,¬†           // vector of computed eigenvalues
   matrixc&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixc&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSolver(
   ENUM_EIG_VECTORS      jobv,¬†                   // compute left and right vectors
   vectorcf&amp;             eigen_values,¬†           // vector of computed eigenvalues
   matrixcf&amp;             left_eigenvectors,¬†      // matrix of computed left vectors
   matrixcf&amp;             right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VECTORS enumeration value which determines the method for computing left and
right eigenvectors.
<h3>EV</h3>
[out] Vector of eigenvalues.
left_eigenvectors
[out] Matrix of left eigenvectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1576
right_eigenvectors
[out] Matrix of right eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
If EIGVECTORS_N is set, the left and right vectors are not computed. Only eigenvalues are
computed.
With EIGVECTORS_L, only left eigenvectors are computed, right eigenvectors are not computed.
When EIGVECTORS_R is set, only the right eigenvectors are computed, the left vectors are not
computed.
With EIGVECTORS_LR, the left and right eigenvectors are computed, Eigenvalues are always
computed.
Real (non-complex) matrices can have a complex solution. Therefore, the vector of eigenvalues
must be complex. In case of a complex solution, the error code is set to 4019
(ERR_MATH_OVERFLOW). Otherwise, only the real parts of the complex values of the eigenvalue
vector should be used.
<h3>ENUM_EIG_VECTORS</h3>
An enumeration that specifies whether to calculate eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_N</h3>
Only eigenvalues are calculated, without vectors.
<h3>EIGVECTORS_L</h3>
Only left eigenvectors are computed.
<h3>EIGVECTORS_R</h3>
Only right eigenvectors are computed.
<h3>EIGVECTORS_LR</h3>
Left and right eigenvectors are computed, eigenvalues are
always computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1577
<h3>EigenSolverX</h3>
Compute eigenvalues and eigenvectors of a regular square matrix in Expert mode, i.e. with the ability
to influence the computation algorithm and the ability to obtain accompanying computation data
(lapack function GEEVX).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolverX(
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorc&amp;              eigen_values,¬†           // vector of computed eigenvalues
   matrix&amp;               left_eigenvectors,¬†      // matrix of computed left vectors
   matrix&amp;               right_eigenvectors¬†      // matrix of computed right vectors
   matrix&amp;               shur_matrix,             // balanced matrix in Schur form
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vector&amp;               scale,¬†                  // details of permutations and scali
   double&amp;               ab_norm,                 // 1-norm of balanced matrix
   vector&amp;               rconde,¬†                 // vector of reciprocal condition nu
   vector&amp;               rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSolverX(
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorcf&amp;             eigen_values,¬†           // vector of computed eigenvalues
   matrixf&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixf&amp;              right_eigenvectors¬†      // matrix of computed right vectors
   matrixf&amp;              shur_matrix,             // balanced matrix in Schur form
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vectorf&amp;              scale,¬†                  // details of permutations and scali
   float&amp;                ab_norm,                 // 1-norm of balanced matrix
   vectorf&amp;              rconde,¬†                 // vector of reciprocal condition nu
   vectorf&amp;              rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSolverX(
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorc&amp;              eigen_values,¬†           // vector of computed eigenvalues</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1578
</p>
<pre><code class="language-mql5">
   matrixc&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixc&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   matrixc&amp;              shur_matrix,             // balanced matrix in Schur form
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vector&amp;               scale,¬†                  // details of permutations and scali
   double&amp;               ab_norm,                 // 1-norm of balanced matrix
   vector&amp;               rconde,¬†                 // vector of reciprocal condition nu
   vector&amp;               rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSolverX(
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorcf&amp;             eigen_values,¬†           // vector of computed eigenvalues
   matrixcf&amp;             left_eigenvectors,¬†      // matrix of computed left vectors
   matrixcf&amp;             right_eigenvectors¬†      // matrix of computed right vectors 
   matrixcf&amp;             shur_matrix,             // balanced matrix in Schur form
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vectorf&amp;              scale,¬†                  // details of permutations and scali
   float&amp;                ab_norm,                 // 1-norm of balanced matrix
   vectorf&amp;              rconde,¬†                 // vector of reciprocal condition nu
   vectorf&amp;              rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Parameters</h3>
balance
[in]  Value from the ENUM_EIG_BALANCE enumeration which determines the need and method for
balancing the input matrix; it is used to improve the conditioning of the eigenvalues and
eigenvectors.
jobv
[in]  ENUM_EIG_VECTORS enumeration value which determines the method for computing left and
right eigenvectors.
sense
[in]  Value from the ENUM_EIG_SENSE enumeration determining the need to compute reciprocal
condition numbers.
eigen_values
[out] Vector of eigenvalues.
left_eigenvectors
[out] Matrix of left eigenvectors.
right_eigenvectors</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1579
[out] Matrix of right eigenvectors.
shur_matrix
[out]  Balanced matrix in Schur form; the matrix is not filled if neither left nor right eigenvectors
are computed.
ilo
[out]  Subscript of the balanced matrix; the matrix is not filled if no balancing is applied.
ihi
[out]  Superscript of the balanced matrix; the matrix is not filled if no balancing is applied.
scale
[out]  Vector of details of permutations and scaling when balancing the input matrix.
Details of the permutations and scaling factors applied when balancing A.
If P(j) is the index of the row and column interchanged with row and column j, and D(j) is
the scaling factor applied to row and column j, then
scale(j) = P(j), for j = 1,...,ilo-1
= D(j), for j = ilo,...,ihi
= P(j) for j = ihi+1,..., n.
The order in which the interchanges are made is n to ihi+1, then 1 to ilo-1.
ab_norm
[out]  1-norm of the balanced matrix (the maximum of the sum of absolute values of elements in
any of the matrix columns).
rconde
[out]  Vector of reciprocal condition numbers for each eigenvalue; it is computed if the &#x27;sense&#x27;
parameter is set to &#x27;E&#x27; or &#x27;B&#x27;.
rcondv
[out]  Vector of reciprocal condition numbers for each eigenvector; it is computed if the &#x27;sense&#x27;
parameter is set to &#x27;V&#x27; or &#x27;B.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Input matrix balancing depends on the value of the &#x27;balance&#x27; parameter.
<h3>ENUM_EIG_BALANCE</h3>
An enumeration defining the need to compute eigenvectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1580
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGBALANCE_N</h3>
<h3>Do not diagonally scale or permute</h3>
<h3>EIGBALANCE_P</h3>
Perform permutations to make the matrix more nearly upper
triangular. Do not diagonally scale
<h3>EIGBALANCE_S</h3>
Diagonally scale the matrix. Do not permute
<h3>EIGBALANCE_B</h3>
<h3>Both diagonally scale and permute</h3>
<h3>ENUM_EIG_VECTORS</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_N</h3>
Only eigenvalues are computed, without vectors.
<h3>EIGVECTORS_L</h3>
Only left eigenvectors are computed.
<h3>EIGVECTORS_R</h3>
Only right eigenvectors are computed.
<h3>EIGVECTORS_LR</h3>
Left and right eigenvectors are computed, eigenvalues are
always computed.
<h3>ENUM_EIG_SENSE</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGSENSE_N</h3>
None of reciprocal condition numbers are computed
<h3>EIGSENSE_E</h3>
<h3>Computed for eigenvalues only</h3>
<h3>EIGSENSE_V</h3>
<h3>Computed for right eigenvectors only</h3>
<h3>EIGSENSE_B</h3>
<h3>Computed for eigenvalues and right eigenvectors</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1581
<h3>EigenSolverShur</h3>
Compute eigenvalues, upper triangular matrix in Schur form, and matrix of Schur vectors (lapack
function GEES). See also Schur decomposition.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolverShur(
   ENUM_EIG_VECTORS      jobvs,                   // method to compute Shur vectors
   vectorc&amp;              eigen_values,¬†           // vector of computed eigenvalues
   matrix&amp;               shur_matrix,¬†            // matrix in Schur form
   matrix&amp;               shur_vectors¬†            // matrix of Schur vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSolverShur(
   ENUM_EIG_VECTORS      jobvs,                   // method to compute Shur vectors
   vectorcf&amp;             eigen_values,¬†           // vector of computed eigenvalues
   matrixf&amp;              shur_matrix,¬†            // matrix in Schur form
   matrixf&amp;              shur_vectors¬†            // matrix of Schur vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSolverShur(
   ENUM_EIG_VECTORS      jobvs,                   // method to compute Shur vectors
   vectorc&amp;              eigen_values,¬†           // vector of computed eigenvalues
   matrixc&amp;              shur_matrix,¬†            // matrix in Schur form
   matrixc&amp;              shur_vectors¬†            // matrix of Schur vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSolverShur(
   ENUM_EIG_VECTORS      jobvs,                   // method to compute Shur vectors
   vectorcf&amp;             eigen_values,¬†           // vector of computed eigenvalues
   matrixcf&amp;             shur_matrix,¬†            // matrix in Schur form
   matrixcf&amp;             shur_vectors¬†            // matrix of Schur vectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobvs
[in]  Value from the ENUM_EIG_SHUR enumeration, which defines the method for computing Shur
vectors.
eigen_values
[out] Vector of eigenvalues.
shur_matrix
[out]  Upper triangular Schur matrix (Schur form for the input matrix).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1582
shur_vectors
[out]  Matrix of Schur vectors; it is not computed if the jobvs parameter is set to N.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the jobvs parameter values.
Real (non-complex) matrices can have a complex solution. Therefore, the input vector of
eigenvalues must be complex. In case of a complex solution, the error code is set to 4019
(ERR_MATH_OVERFLOW). Otherwise, only the real parts of the complex values of the eigenvalue
vector should be used.
<h3>EigenSolverShur</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGSHUR_N</h3>
<h3>Schur vectors are not computed</h3>
<h3>EIGSHUR_V</h3>
<h3>Schur vectors are computed</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1583
<h3>EigenSolver2</h3>
Compute generalized eigenvalues and eigenvectors for a pair of ordinary square matrices (lapack
function GGEV). Both matrices must be the same size.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2(
   matrix&amp;               B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorc&amp;              alpha,¬†                  // vector of computed eigenvalues
   vector&amp;               beta,¬†                   // vector of eigenvalue divisors
   matrix&amp;               left_eigenvectors,¬†      // matrix of computed left vectors
   matrix&amp;               right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSolver2(
   matrix&amp;               B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorcf&amp;             alpha,¬†                  // vector of computed eigenvalues
   vectorf&amp;              beta,¬†                   // vector of eigenvalue divisors
   matrixf&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixf&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSolver2(
   matrixc&amp;              B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorc&amp;              alpha,¬†                  // vector of computed eigenvalues
   vectorc&amp;              beta,¬†                   // vector of eigenvalue divisors
   matrixc&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixc&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSolver2(
   matrixcf&amp;             B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorcf&amp;             alpha,¬†                  // vector of computed eigenvalues
   vectorcf&amp;             beta,¬†                   // vector of eigenvalue divisors
   matrixcf&amp;             left_eigenvectors,¬†      // matrix of computed left vectors
   matrixcf&amp;             right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Parameters</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1584
<h3>B</h3>
[in]  The second matrix in the pair.
jobv
[in]  ENUM_EIG_VECTORS enumeration value which determines the method for computing left and
right eigenvectors.
alpha
[out] Vector of eigenvalues.
beta
[out]  Vector of eigen value divisors.
left_eigenvectors
[out] Matrix of left eigenvectors.
right_eigenvectors
[out] Matrix of right eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
<h3>ENUM_EIG_VECTORS</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_N</h3>
Only eigenvalues are computed, without vectors.
<h3>EIGVECTORS_L</h3>
Only left eigenvectors are computed.
<h3>EIGVECTORS_R</h3>
Only right eigenvectors are computed.
<h3>EIGVECTORS_LR</h3>
Left and right eigenvectors are computed, eigenvalues are
always computed.
A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta =
lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there
is a reasonable interpretation for beta=0, and even for both being zero.
The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies
</p>
<pre><code class="language-mql5">
                  A * v(j) = lambda(j) * B * v(j).
</code></pre>
<p>
The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies
</p>
<pre><code class="language-mql5">
                  u(j)**H * A  = lambda(j) * u(j)**H * B .</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1585
where u(j)**H is the conjugate-transpose of u(j).
Real (non-complex) matrices can have a complex solution. Therefore, the input vector of eigenvalues
must be complex. In case of a complex solution, the error code is set 
to 
4019
(ERR_MATH_OVERFLOW). Otherwise, only the real parts of the complex values of the eigenvalue
vector should be used.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1586
<h3>EigenSolver2X</h3>
Compute generalized eigenvalues and eigenvectors for a pair of regular square matrices in Expert
mode, i.e. with the ability to influence the computation algorithm and the ability to obtain
accompanying computation data (lapack function GGEVX). Both matrices must be the same size.
Optionally, it also computes a balancing transformation to improve the conditioning of the eigenvalues
and eigenvectors (ILO, IHI, LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
the eigenvalues (RCONDE), and reciprocal condition numbers for the right eigenvectors (RCONDV).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2X(
   matrix&amp;               B,¬†                      // second matrix in the pair
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorc&amp;              alpha,¬†                  // vector of computed eigenvalues
   vector&amp;               beta,¬†                   // vector of eigenvalue divisors
   matrix&amp;               left_eigenvectors,¬†      // matrix of computed left vectors
   matrix&amp;               right_eigenvectors¬†      // matrix of computed right vectors 
   matrix&amp;               shur_matrix1,            // the first part of the real Schur 
   matrix&amp;               shur_matrix2,            // the second part of the real Schur
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vector&amp;               lscale,¬†                 // details of the permutations and s
   vector&amp;               rscale,¬†                 // details of the permutations and s
   double&amp;               ab_norm,                 // one-norm of balanced input matrix
   double&amp;               bb_norm,                 // one-norm of balanced second matri
   vector&amp;               rconde,¬†                 // vector of reciprocal condition nu
   vector&amp;               rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSolver2X(
   matrixf&amp;              B,¬†                      // second matrix in the pair
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorcf&amp;             alpha,¬†                  // vector of computed eigenvalues
   vectorf&amp;              beta,¬†                   // vector of eigenvalue divisors
   matrixf&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixf&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   matrixf&amp;              shur_matrix1,            // the first part of the real Schur 
   matrixf&amp;              shur_matrix2,            // the second part of the real Schur
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vectorf&amp;              lscale,¬†                 // details of the permutations and s</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1587
</p>
<pre><code class="language-mql5">
   vectorf&amp;              rscale,¬†                 // details of the permutations and s
   float&amp;                ab_norm,                 // one-norm of balanced input matrix
   float&amp;                bb_norm,                 // one-norm of balanced second matri
   vectorf&amp;              rconde,¬†                 // vector of reciprocal condition nu
   vectorf&amp;              rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSolver2X(
   matrixc&amp;              B,¬†                      // second matrix in the pair
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorc&amp;              alpha,¬†                  // vector of computed eigenvalues
   vectorc&amp;              beta,¬†                   // vector of eigenvalue divisors
   matrixc&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixc&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   matrixc&amp;              shur_matrix1,            // the first part of the real Schur 
   matrixc&amp;              shur_matrix2,            // the second part of the real Schur
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vector&amp;               lscale,¬†                 // details of the permutations and s
   vector&amp;               rscale,¬†                 // details of the permutations and s
   double&amp;               ab_norm,                 // one-norm of balanced input matrix
   double&amp;               bb_norm,                 // one-norm of balanced second matri
   vector&amp;               rconde,¬†                 // vector of reciprocal condition nu
   vector&amp;               rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSolver2X(
   matrixcf&amp;             B,¬†                      // second matrix in the pair
   ENUM_EIG_BALANCE      balance,¬†                // input matrix balancing method
   ENUM_EIG_VECTORS      jobv,¬†                   // determines computation of right a
   ENUM_EIG_SENSE        sense,¬†                  // determines computation of recipro
   vectorcf&amp;             alpha,¬†                  // vector of computed eigenvalues
   vectorf&amp;              beta,¬†                   // vector of eigenvalue divisors
   matrixcf&amp;             left_eigenvectors,¬†      // matrix of computed left vectors
   matrixcf&amp;             right_eigenvectors¬†      // matrix of computed right vectors 
   matrixcf&amp;             shur_matrix1,            // the first part of the real Schur 
   matrixcf&amp;             shur_matrix2,            // the second part of the real Schur
   long&amp;                 ilo,¬†                    // subscript of balanced matrix
   long&amp;                 ihi,¬†                    // superscript of balanced matrix
   vectorf&amp;              lscale,¬†                 // details of the permutations and s
   vectorf&amp;              rscale,¬†                 // details of the permutations and s
   float&amp;                ab_norm,                 // one-norm of balanced input matrix</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1588
</p>
<pre><code class="language-mql5">
   float&amp;                bb_norm,                 // one-norm of balanced second matri
   vectorf&amp;              rconde,¬†                 // vector of reciprocal condition nu
   vectorf&amp;              rcondv¬†                  // vector of reciprocal condition nu
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  The second matrix in the pair.
balance
[in]  Value from the ENUM_EIG_BALANCE enumeration which determines the need and method for
balancing the input matrix; it is used to improve the conditioning of the eigenvalues and
eigenvectors.
jobv
[in]   Value from the ENUM_EIG_VECTORS enumeration which determines the method for
computing left and right eigenvectors.
sense
[in]   Value from the ENUM_EIG_SENSE enumeration which determines the need to compute
reciprocal condition numbers.
eigen_values
[out] Vector of eigenvalues.
left_eigenvectors
[out] Matrix of left eigenvectors.
right_eigenvectors
[out] Matrix of right eigenvectors.
shur_matrix1, shur_matrix2
[out]  2 parts of balanced matrix in Schur form; the matrix is not filled if neither left nor right
eigenvectors are computed.
ilo
[out]  Subscript of the balanced matrix; the matrix is not filled if no balancing is applied.
ihi
[out]  Superscript of the balanced matrix; the matrix is not filled if no balancing is applied.
lscale
[out]  Vector contains details of the permutations and scaling factors applied to the left side of A
and B.
If PL(j) is the index of the row interchanged with row j, and DL(j) is the scaling factor applied to
row j, then
lscale(j) = PL(j), for j = 1,..., ilo-1
= DL(j), for j = ilo,...,ihi
= PL(j) for j = ihi+1,..., n.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1589
The order in which the interchanges are made is n to ihi+1, then 1 to ilo-1.
rscale
[out]  Vector contains details of the permutations and scaling factors applied to the right side of A
and B.
If PR(j) is the index of the column interchanged with column j, and DR(j) is the scaling factor
applied to column j, then
rscale(j) = PR(j), for j = 1,..., ilo-1
= DR(j), for j = ilo,...,ihi
= PR(j) for j = ihi+1,..., n.
The order in which the interchanges are made is n to ihi+1, then 1 to ilo-1.
ab_norm
[out]  One-norm of the balanced input matrix (the maximum of the sum of absolute values of
elements in any of the matrix columns).
bb_norm
[out]  One-norm of balanced second matrix B.
rconde
[out]  Vector of reciprocal condition numbers for each eigenvalue; it is computed if the &#x27;sense&#x27;
parameter is set to &#x27;E&#x27; or &#x27;B&#x27;.
rcondv
[out]  Vector of reciprocal condition numbers for each eigenvector; it is computed if the &#x27;sense&#x27;
parameter is set to &#x27;V&#x27; or &#x27;B&#x27;.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
Input matrices balancing depends on the value of the balance parameter.
<h3>ENUM_EIG_BALANCE</h3>
An enumeration that specifies whether the matrices should be balanced.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGBALANCE_N</h3>
Do not diagonally scale or permute.
<h3>EIGBALANCE_P</h3>
Perform permutations to make the matrix more nearly upper
triangular. Do not diagonally scale.
<h3>EIGBALANCE_S</h3>
Diagonally scale the matrix. Do not permute.
<h3>EIGBALANCE_B</h3>
Both diagonally scale and permute.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1590
<h3>ENUM_EIG_VECTORS</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_N</h3>
Only eigenvalues are computed, without vectors.
<h3>EIGVECTORS_L</h3>
Only left eigenvectors are computed.
<h3>EIGVECTORS_R</h3>
Only right eigenvectors are computed.
<h3>EIGVECTORS_LR</h3>
Left and right eigenvectors are computed, eigenvalues are
always computed.
<h3>ENUM_EIG_SENSE</h3>
An enumeration determining the need to compute reciprocal condition numbers.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGSENSE_N</h3>
None of reciprocal condition numbers are computed.
<h3>EIGSENSE_E</h3>
Computed for eigenvalues only.
<h3>EIGSENSE_V</h3>
Computed for right eigenvectors only.
<h3>EIGSENSE_B</h3>
Computed for eigenvalues and right eigenvectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1591
<h3>EigenSolver2Shur</h3>
Compute a pair of ordinary square matrices of generalized eigenvalues,  generalized eigenvectors,
generalized Schur forms, as well as left and right Schur vectors (lapack function GGES).
–°omputes the generalized eigenvalues, the generalized real/complex Schur form (S,T), optionally, the
left and/or right matrices of Schur vectors (vsl and vsr) for a pair of n-by-n real/complex
nonsymmetric matrices (A,B). This gives the generalized Schur factorization:
(A,B) = ( vsl*S *vsrH, vsl*T*vsrH )
Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the
leading diagonal blocks of the upper quasi-triangular matrix S and the upper triangular matrix T. The
leading columns of vsl and vsr then form an orthonormal/unitary basis for the corresponding left and
right eigenspaces (deflating subspaces).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2Shur(
   matrix&amp;                B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vector&amp;                alpha,    // vector of computed eigenvalues
   vector&amp;                beta,¬†    // vector of eigenvalue divisors
   matrix&amp;                shur_s,¬†  // matrix S in Schur form
   matrix&amp;                shur_t,¬†  // matrix T in Schur form
   matrix&amp;                vsl,¬†     // matrix of left Schur vectors vsl
   matrix&amp;                vsr¬†      // matrix of right Schur vectors vsr
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSolver2Shur(
   matrixf&amp;               B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vectorcf&amp;              alpha,    // vector of computed eigenvalues
   vectorf&amp;               beta,¬†    // vector of eigenvalue divisors
   matrixf&amp;               shur_s,¬†  // matrix S in Schur form
   matrixf&amp;               shur_t,¬†  // matrix T in Schur form
   matrixf&amp;               vsl,¬†     // matrix of left Schur vectors vsl
   matrixf&amp;               vsr¬†      // matrix of right Schur vectors vsr
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2Shur(
   matrixc&amp;               B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vectorc&amp;               alpha,    // vector of computed eigenvalues
   vectorc&amp;               beta,¬†    // vector of eigenvalue divisors
   matrixc&amp;               shur_s,¬†  // matrix S in Schur form
   matrixc&amp;               shur_t,¬†  // matrix T in Schur form</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1592
</p>
<pre><code class="language-mql5">
   matrixc&amp;               vsl,¬†     // matrix of left Schur vectors vsl
   matrixc&amp;               vsr¬†      // matrix of right Schur vectors vsr
   );
</code></pre>
<p>
<h3>–í—ã—á–∏—Å–ª–µ–Ω–∏—è –¥–ª—è —Ç–∏–ø–∞ matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSolver2Shur(
   matrixcf&amp;              B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vectorcf&amp;              alpha,    // vector of computed eigenvalues
   vectorcf&amp;              beta,¬†    // vector of eigenvalue divisors
   matrixcf&amp;              shur_s,¬†  // matrix S in Schur form
   matrixcf&amp;              shur_t,¬†  // matrix T in Schur form
   matrixcf&amp;              vsl,¬†     // matrix of left Schur vectors vsl
   matrixcf&amp;              vsr¬†      // matrix of right Schur vectors vsr
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[out]  The second matrix in the pair.
jobvs
[in]  ENUM_EIG_VECTORS enumeration value which determines the method for computing left and
right eigenvectors.
alpha
[out]  Vector of eigenvalues.
beta
[out]  Vector of eigenvalue divisors.
shur_s
[out]  Matrix S, block upper triangular Schur matrix (Schur form for the input matrix).
shur_t
[out]  Matrix T, block upper triangular Schur matrix (Schur form for the second matrix in the pair).
vsl
[out]  Matrix of left Schur vectors.
vsr
[out]  Matrix of right Schur vectors.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
Computation depends on the jobvs parameter values.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1593
The second matrix in the pair must be the same size as the first (input) one.
Real (non-complex) matrices can have a complex solution. Therefore, the vector of eigenvalues
must be complex. In case of a complex solution, the error code is set to 4019
(ERR_MATH_OVERFLOW). Otherwise, only the real parts of the complex values of the eigenvalue
vector should be used.
<h3>EigenSolverShur</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_N</h3>
Only eigenvalues are computed, without vectors.
<h3>EIGVECTORS_L</h3>
Only left eigenvectors are computed.
<h3>EIGVECTORS_R</h3>
Only right eigenvectors are computed.
<h3>EIGVECTORS_LR</h3>
Left and right eigenvectors are computed, eigenvalues are
always computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1594
<h3>EigenSolver2Blocked</h3>
Compute generalized eigenvalues and eigenvectors for a pair of regular square matrices using a block
algorithm (lapack function GGEV3). Both matrices must be the same size. The method parameters are
exactly the same as EigenSolver2.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2Blocked(
   matrix&amp;               B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorc&amp;              alpha,¬†                  // vector of computed eigenvalues
   vector&amp;               beta,¬†                   // vector of eigenvalue divisors
   matrix&amp;               left_eigenvectors,¬†      // matrix of computed left vectors
   matrix&amp;               right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSolver2Blocked(
   matrix&amp;               B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorcf&amp;             alpha,¬†                  // vector of computed eigenvalues
   vectorf&amp;              beta,¬†                   // vector of eigenvalue divisors
   matrixf&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixf&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2Blocked(
   matrixc&amp;              B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorc&amp;              alpha,¬†                  // vector of computed eigenvalues
   vectorc&amp;              beta,¬†                   // vector of eigenvalue divisors
   matrixc&amp;              left_eigenvectors,¬†      // matrix of computed left vectors
   matrixc&amp;              right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSolver2(
   matrixcf&amp;             B,¬†                      // second matrix in the pair
   ENUM_EIG_VECTORS      jobv,¬†                   // method to compute right and left 
   vectorcf&amp;             alpha,¬†                  // vector of computed eigenvalues
   vectorcf&amp;             beta,¬†                   // vector of eigenvalue divisors
   matrixcf&amp;             left_eigenvectors,¬†      // matrix of computed left vectors
   matrixcf&amp;             right_eigenvectors¬†      // matrix of computed right vectors 
   );
</code></pre>
<p>
<h3>Parameters</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1595
<h3>B</h3>
[out]  The second matrix in the pair.
jobv
[in]  ENUM_EIG_VECTORS enumeration value which determines the method for computing left and
right eigenvectors.
alpha
[out]  Vector of eigenvalues.
beta
[out]  Vector of eigenvalue divisors.
left_eigenvectors
[out]  Matrix of left eigenvectors.
righeft_eigenvectors
[out]  Matrix of right eigenvectors.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta =
lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as
there is a reasonable interpretation for beta=0, and even for both being zero.
The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies:
A * v(j) = lambda(j) * B * v(j).
The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies:
u(j)**H * A  = lambda(j) * u(j)**H * B .
where u(j)**H is the conjugate-transpose of u(j).
Real (non-complex) matrices can have a complex solution. Therefore, the input vector of
eigenvalues must be complex. In case of a complex solution, the error code is set to 4019
(ERR_MATH_OVERFLOW). Otherwise, only the real parts of the complex values of the eigenvalue
vector should be used.
<h3>ENUM_EIG_VECTORS</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_N</h3>
Only eigenvalues are computed, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1596
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_L</h3>
Only left eigenvectors are computed.
<h3>EIGVECTORS_R</h3>
Only right eigenvectors are computed.
<h3>EIGVECTORS_LR</h3>
Left and right eigenvectors are computed, eigenvalues are
always computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1597
<h3>EigenSolver2ShurBlocked</h3>
Compute a pair of regular square matrices of generalized eigenvalues,  generalized eigenvectors,
generalized Schur forms, as well as left and right Schur vectors (lapack function GGES3).
–°omputes the generalized eigenvalues, the generalized real/complex Schur form (S,T), optionally, the
left and/or right matrices of Schur vectors (VSL and VSR) for a pair of n-by-n real/complex
nonsymmetric matrices (A,B). This gives the generalized Schur factorization:
(A,B) = ( vsl*S *vsrH, vsl*T*vsrH )
Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the
leading diagonal blocks of the upper quasi-triangular matrix S and the upper triangular matrix T. The
leading columns of vsl and vsr then form an orthonormal/unitary basis for the corresponding left and
right eigenspaces (deflating subspaces).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2ShurBlocked(
   matrix&amp;                B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vectorc&amp;               alpha,    // vector of computed eigenvalues
   vector&amp;                beta,¬†    // vector of eigenvalue divisors
   matrix&amp;                shur_s,¬†  // matrix S in Schur form
   matrix&amp;                shur_t,¬†  // matrix T in Schur form
   matrix&amp;                vsl,¬†     // matrix of left Schur vectors VSL
   matrix&amp;                vsr¬†      // matrix of right Schur vectors VSR
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2ShurBlocked(
   matrixf&amp;               B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vectorcf&amp;              alpha,    // vector of computed eigenvalues
   vectorf&amp;               beta,¬†    // vector of eigenvalue divisors
   matrixf&amp;               shur_s,¬†  // matrix S in Schur form
   matrixf&amp;               shur_t,¬†  // matrix T in Schur form
   matrixf&amp;               vsl,¬†     // matrix of left Schur vectors VSL
   matrixf&amp;               vsr¬†      // matrix of right Schur vectors VSR
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2ShurBlocked(
   matrixc&amp;               B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vectorc&amp;               alpha,    // vector of computed eigenvalues
   vectorc&amp;               beta,¬†    // vector of eigenvalue divisors
   matrixc&amp;               shur_s,¬†  // matrix S in Schur form
   matrixc&amp;               shur_t,¬†  // matrix T in Schur form</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1598
</p>
<pre><code class="language-mql5">
   matrixc&amp;               vsl,¬†     // matrix of left Schur vectors VSL
   matrixc&amp;               vsr¬†      // matrix of right Schur vectors VSR
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSolver2ShurBlocked(
   matrixcf&amp;              B,¬†       // second matrix in the pair
   ENUM_EIG_VECTORS       jobvs,    // method to compute left and right vectors
   vectorcf&amp;              alpha,    // vector of computed eigenvalues
   vectorcf&amp;              beta,¬†    // vector of eigenvalue divisors
   matrixcf&amp;              shur_s,¬†  // matrix S in Schur form
   matrixcf&amp;              shur_t,¬†  // matrix T in Schur form
   matrixcf&amp;              vsl,¬†     // matrix of left Schur vectors VSL
   matrixcf&amp;              vsr¬†      // matrix of right Schur vectors VSR
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  The second matrix in the pair.
jobvs
[in]  ENUM_EIG_VECTORS enumeration value which determines the method for computing left and
right eigenvectors.
alpha
[out]  Vector of eigenvalues.
beta
[out]  Vector of eigenvalue divisors.
shur_s
[out]  Matrix S, block upper triangular Schur matrix (Schur form for the input matrix).
shur_t
[out]  Matrix T, block upper triangular Schur matrix (Schur form for the second matrix in the pair).
vsl
[out]  Matrix of left Schur vectors VSL.
vsr
[out]  Matrix of right Schur vectors VSR.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
Computation depends on the jobvs parameter values.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1599
The second matrix in the pair must be the same size as the first (input) one.
Real (non-complex) matrices can have a complex solution. Therefore, the vector of eigenvalues
must be complex. In case of a complex solution, the error code is set to 4019
(ERR_MATH_OVERFLOW). Otherwise, only the real parts of the complex values of the eigenvalue
vector should be used.
<h3>EigenSolverShur</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVECTORS_N</h3>
Only eigenvalues are computed, without vectors.
<h3>EIGVECTORS_L</h3>
Only left eigenvectors are computed.
<h3>EIGVECTORS_R</h3>
Only right eigenvectors are computed.
<h3>EIGVECTORS_LR</h3>
Left and right eigenvectors are computed, eigenvalues are
always computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1600
<h3>Symmetric Matrices</h3>
Functions for computing eigenvalues and eigenvectors of symmetric or Hermitian matrices using the
divide and conquer algorithm, making the process efficient and fast. These methods can be applied to
matrices of different data types, including real and complex numbers.
<h3>Function</h3>
<h3>Action</h3>
<h3>EigenSymmetricDC</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the divide-and-conquer algorithm (lapack
functions SYEVD, HEEVD).
<h3>EigenSymmetricQR</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the QR algorithm (lapack functions SYEV,
HEEV).
<h3>EigenSymmetricRobust</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the Multiple Relatively Robust Representations,
MRRR algorithm (lapack functions SYEVR, HEEVR).
<h3>EigenSymmetricBisect</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian (complex conjugate) matrix
using the bisection algorithm (lapack functions
SYEVX, HEEVX).
<h3>EigenSymmetricDC2s</h3>
<h3>Compute</h3>
all 
eigenvalues 
and, 
optionally,
eigenvectors of a real symmetric or Hermitian
(complex conjugated) matrix using the 2stage
technique for the reduction to tridiagonal. If
eigenvectors are desired, it uses a divide and
conquer algorithm (lapack functions SYEVD_2STAGE,
HEEVD_2STAGE).
<h3>EigenSymmetricQR2s</h3>
<h3>Compute</h3>
all 
eigenvalues 
and, 
optionally,
eigenvectors of a real symmetric or Hermitian
(complex conjugated) matrix using the 2stage
technique for the reduction to tridiagonal (lapack
functions SYEV_2STAGE, HEEV_2STAGE).
<h3>EigenSymmetricRobust2s</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian 
(complex 
conjugated)
matrix using the 2stage technique for the reduction
to tridiagonal then using the Multiple Relatively
<h3>Robust Representations, MRRR algorithm (lapack</h3>
functions SYEVR_2STAGE, HEEVR_2STAGE).
<h3>EigenSymmetricBisect2s</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric or Hermitian 
(complex 
conjugated)
matrix using the 2stage technique for the reduction</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1601
<h3>Function</h3>
<h3>Action</h3>
to tridiagonal then using the bisection algorithm
(lapack functions SYEVX_2STAGE, HEEVX_2STAGE).
<h3>EigenSymmetric2DC</h3>
Compute all the eigenvalues, and optionally, the
eigenvectors of a generalized symmetric-definite
eigenproblem, of the form  A*x=(lambda)*B*x, 
A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
<h3>EigenSymmetric2QR</h3>
Compute all the eigenvalues, and optionally, the
eigenvectors of a generalized symmetric-definite
eigenproblem, of the form A*x=(lambda)*B*x, 
A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
<h3>EigenSymmetric2Bisect</h3>
Compute all the eigenvalues, and optionally, the
eigenvectors of a generalized symmetric-definite
eigenproblem, of the form A*x=(lambda)*B*x, 
A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1602
<h3>EigenSymmetricDC</h3>
Compute eigenvalues and eigenvectors of a symmetric or Hermitian (complex conjugated) matrix
using the divide-and-conquer algorithm (lapack functions SYEVD, HEEVD).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricDC(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricDC(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricDC(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricDC(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1603
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated.
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration that specifies whether to calculate eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are calculated, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1604
<h3>EigenSymmetricQR</h3>
Compute eigenvalues and eigenvectors of a symmetric or Hermitian (complex conjugated) matrix
using the QR algorithm (lapack functions SYEV, HEEV).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricQR(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricQR(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricQR(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricQR(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1605
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated.
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1606
<h3>EigenSymmetricRobust</h3>
Compute eigenvalues and eigenvectors of a symmetric or Hermitian (complex conjugated) matrix
using the Multiple Relatively Robust Representations, MRRR algorithm (lapack functions SYEVR,
HEEVR).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricRobust(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrix&amp;               eigen_vectors  ¬†    // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricRobust(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricRobust(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricRobust(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // Upper bound of the subset
   float                 abstol,             // absolute error tolerance</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1607
</p>
<pre><code class="language-mql5">
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable eigenvalues and
vectors.
lower
[in]  The lower bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
upper
[in]  The upper bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
abstol
[in]  Absolute error tolerance.
The absolute error tolerance to which each eigenvalue/eigenvector is required.
If jobv = &#x27;V&#x27;, the eigenvalues and eigenvectors output have residual norms bounded by abstol,
and the dot products between different eigenvectors are bounded by abstol.
If abstol &lt; n *eps*|T|, then n *eps*|T| is used instead, where eps is the machine precision,
and |T| is the 1-norm of the matrix T. The eigenvalues are computed to an accuracy of eps*|
T| irrespective of abstol.
If high relative precision is important, &#x27;abstol&#x27; should be set to a safe minimum value X such
that 1.0/X does not overflow.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobv and range parameters.
When BLASRANGE_A is set, all eigenvalues are computed, and the lower and upper parameters are
ignored.
With the BLASRANGE_V value, only those eigenvalues (and their vectors) are computed, which fall
within the range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1608
With the BLASRANGE_I value, only those eigenvalues (and their vectors) are computed, which fall
within the range of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters. For example, with
lower=0 and upper=2, only the first three eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1609
<h3>EigenSymmetricBisect</h3>
Compute eigenvalues and eigenvectors of a symmetric or Hermitian (complex conjugated) matrix
using the bisection algorithm (lapack functions SYEVX, HEEVX).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricBisect(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricBisect(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricBisect(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricBisect(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // Upper bound of the subset
   float                 abstol,             // absolute error tolerance
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1610
</p>
<pre><code class="language-mql5">
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable eigenvalues and
vectors.
lower
[in]  The lower bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
upper
[in]  The upper bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
abstol
[in]  Absolute error tolerance.
The absolute error tolerance to which each eigenvalue/eigenvector is required.
If jobv = &#x27;V&#x27;, the eigenvalues and eigenvectors output have residual norms bounded by abstol,
and the dot products between different eigenvectors are bounded by abstol.
If abstol &lt; n *eps*|T|, then n *eps*|T| is used instead, where eps is the machine precision,
and |T| is the 1-norm of the matrix T. The eigenvalues are computed to an accuracy of eps*|
T| irrespective of abstol.
If high relative precision is important, &#x27;abstol&#x27; should be set to a safe minimum value X such
that 1.0/X does not overflow.
eigen_values
[out] Vector of eigenvalues.
<h3>V</h3>
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobv and range parameters.
When BLASRANGE_A is set, all eigenvalues are computed, and the lower and upper parameters are
ignored.
With the BLASRANGE_V value, only those eigenvalues (and their vectors) are computed, which fall
within the range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1611
With the BLASRANGE_I value, only those eigenvalues (and their vectors) are computed, which fall
within the range of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters. For example, with
lower=0 and upper=2, only the first three eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1612
<h3>EigenSymmetricDC2s</h3>
Compute all eigenvalues and, optionally, eigenvectors of a real symmetric or Hermitian (complex
conjugated) matrix using the 2stage technique for the reduction to tridiagonal. If eigenvectors are
desired, it uses a divide and conquer algorithm (lapack functions SYEVD_2STAGE, HEEVD_2STAGE).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricDC2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricDC2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricDC2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricDC2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1613
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated. In the current OpenBLAS
implementation, this value is not supported. Attempting to use it will result in error 4003
(ERR_INVALID_PARAMETER).
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration that specifies whether to calculate eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated. Not available in
this release.
<h3>EIGVALUES_N</h3>
Only eigenvalues are calculated, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1614
<h3>EigenSymmetricQR2s</h3>
Compute all eigenvalues and, optionally, eigenvectors of a real symmetric or Hermitian (complex
conjugated) matrix using the 2stage technique for the reduction to tridiagonal (lapack functions
SYEV_2STAGE, HEEV_2STAGE).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricQR2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricQR2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricQR2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricQR2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1615
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated. In the current OpenBLAS
implementation, this value is not supported. Attempting to use it will result in error 4003
(ERR_INVALID_PARAMETER).
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated. Not available in
this release.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1616
<h3>EigenSymmetricRobust2s</h3>
Compute eigenvalues and eigenvectors of a symmetric or Hermitian (complex conjugated) matrix
using the 2stage technique for the reduction to tridiagonal then using the Multiple Relatively Robust
Representations, MRRR algorithm (lapack functions SYEVR_2STAGE, HEEVR_2STAGE).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricRobust2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrix&amp;               eigen_vectors  ¬†    // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricRobust2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricRobust2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricRobust2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1617
</p>
<pre><code class="language-mql5">
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable eigenvalues and
vectors.
lower
[in]  The lower bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
upper
[in]  The upper bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
abstol
[in]  Absolute error tolerance.
The absolute error tolerance to which each eigenvalue/eigenvector is required.
If jobv = &#x27;V&#x27;, the eigenvalues and eigenvectors output have residual norms bounded by abstol,
and the dot products between different eigenvectors are bounded by abstol.
If abstol &lt; n *eps*|T|, then n *eps*|T| is used instead, where eps is the machine precision,
and |T| is the 1-norm of the matrix T. The eigenvalues are computed to an accuracy of eps*|
T| irrespective of abstol.
If high relative precision is important, &#x27;abstol&#x27; should be set to a safe minimum value X such
that 1.0/X does not overflow.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobv and range parameters.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated. In the current OpenBLAS
implementation, this value is not supported. Attempting to use it will result in error 4003
(ERR_INVALID_PARAMETER).
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1618
When BLASRANGE_A is set, all eigenvalues are computed, and the lower and upper parameters are
ignored.
With the BLASRANGE_V value, only those eigenvalues (and their vectors) are computed, which fall
within the range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters.
With the BLASRANGE_I value, only those eigenvalues (and their vectors) are computed, which fall
within the range of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters. For example, with
lower=0 and upper=2, only the first three eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated. Not available in
this release.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1619
<h3>EigenSymmetricBisect2s</h3>
Compute eigenvalues and eigenvectors of a symmetric or Hermitian (complex conjugated) matrix
using the 2stage technique for the reduction to tridiagonal then using the bisection algorithm (lapack
functions SYEVX_2STAGE, HEEVX_2STAGE).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetricBisect2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetricBisect2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetricBisect2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetricBisect2s(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1620
</p>
<pre><code class="language-mql5">
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable eigenvalues and
vectors.
lower
[in]  The lower bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
upper
[in]  The upper bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
abstol
[in]  Absolute error tolerance.
The absolute error tolerance to which each eigenvalue/eigenvector is required.
If jobv = &#x27;V&#x27;, the eigenvalues and eigenvectors output have residual norms bounded by abstol,
and the dot products between different eigenvectors are bounded by abstol.
If abstol &lt; n *eps*|T|, then n *eps*|T| is used instead, where eps is the machine precision,
and |T| is the 1-norm of the matrix T. The eigenvalues are computed to an accuracy of eps*|
T| irrespective of abstol.
If high relative precision is important, &#x27;abstol&#x27; should be set to a safe minimum value X such
that 1.0/X does not overflow.
eigen_values
[out] Vector of eigenvalues.
<h3>V</h3>
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobv and range parameters.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated. In the current OpenBLAS
implementation, this value is not supported. Attempting to use it will result in error 4003
(ERR_INVALID_PARAMETER).
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1621
When BLASRANGE_A is set, all eigenvalues are computed, and the lower and upper parameters are
ignored.
With the BLASRANGE_V value, only those eigenvalues (and their vectors) are computed, which fall
within the range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters.
With the BLASRANGE_I value, only those eigenvalues (and their vectors) are computed, which fall
within the range of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters. For example, with
lower=0 and upper=2, only the first three eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated. Not available in
this release.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1622
<h3>EigenSymmetric2DC</h3>
Compute all the eigenvalues, and optionally, the eigenvectors of a generalized symmetric-definite
eigenproblem, of the form 
A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
Here A and B are assumed to be symmetric (Hermitian) and B is also positive definite. If eigenvectors
are desired, it uses a divide-and-conquer algorithm (lapack functions SYGVD, HEGVD).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetric2DC(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrix&amp;               B,                  // second matrix
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors,      // matrix of computed eigenvectors
   matrix&amp;               triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetric2DC(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrixf&amp;              B,                  // second matrix
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors,      // matrix of computed eigenvectors
   matrixf&amp;              triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetric2DC(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrixc&amp;              B,                  // second matrix
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors,¬†     // matrix of computed eigenvectors
   matrixc&amp;              triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetric2DC(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrixcf&amp;             B,                  // second matrix
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors,      // matrix of computed eigenvectors</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1623
</p>
<pre><code class="language-mql5">
   matrixcf&amp;             triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Parameters</h3>
itype
[in]  ENUM_EIGS2_TYPE enumeration value which specified the problem type to be solved :
A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
<h3>B</h3>
[in]  Second matrix B. Must be positive definite symmetric (or Hermitian conjugated) matrix.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
triangular_factor
[out] The triangular factor U or L from the Cholesky factorization B = U**T*U or B = L*L**T.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated). Second matrix B must be positive
definite symmetric. If the input matrix and second matrix B are triangular, then both must be the
same triangular, upper or lower.
<h3>ENUM_EIGS2_TYPE</h3>
An enumeration that specifies  the problem type to be solved.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGS2TYPE_1</h3>
1:  A*x = (lambda)*B*x
<h3>EIGS2TYPE_2</h3>
2:  A*B*x = (lambda)*x
<h3>EIGS2TYPE_3</h3>
3:  B*A*x = (lambda)*x
<h3>ENUM_EIG_VALUES</h3>
An enumeration that specifies whether to calculate eigenvectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1624
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are calculated, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1625
<h3>EigenSymmetric2QR</h3>
Compute all the eigenvalues, and optionally, the eigenvectors of a generalized symmetric-definite
eigenproblem, of the form 
A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
Here A and B are assumed to be symmetric (Hermitian) and B is also positive definite. This method
uses QR algorithm (lapack functions SYGV, HEGV).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetric2QR(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrix&amp;               B,                  // second matrix
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors,      // matrix of computed eigenvectors
   matrix&amp;               triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetric2QR(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrixf&amp;              B,                  // second matrix
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors,      // matrix of computed eigenvectors
   matrixf&amp;              triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetric2QR(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrixc&amp;              B,                  // second matrix
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors,¬†     // matrix of computed eigenvectors
   matrixc&amp;              triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetric2QR(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   matrixcf&amp;             B,                  // second matrix
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors,      // matrix of computed eigenvectors</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1626
</p>
<pre><code class="language-mql5">
   matrixcf&amp;             triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Parameters</h3>
itype
[in]  ENUM_EIGS2_TYPE enumeration value which specified the problem type to be solved :
A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
<h3>B</h3>
[in]  Second matrix B. Must be positive definite symmetric (or Hermitian conjugated) matrix.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
triangular_factor
[out] The triangular factor U or L from the Cholesky factorization B = U**T*U or B = L*L**T.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated). Second matrix B must be positive
definite symmetric. If the input matrix and second matrix B are triangular, then both must be the
same triangular, upper or lower.
<h3>ENUM_EIGS2_TYPE</h3>
An enumeration that specifies  the problem type to be solved.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGS2TYPE_1</h3>
1:  A*x = (lambda)*B*x
<h3>EIGS2TYPE_2</h3>
2:  A*B*x = (lambda)*x
<h3>EIGS2TYPE_3</h3>
3:  B*A*x = (lambda)*x
<h3>ENUM_EIG_VALUES</h3>
An enumeration that specifies whether to calculate eigenvectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1627
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are calculated, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1628
<h3>EigenSymmetric2Bisect</h3>
Compute all the eigenvalues, and optionally, the eigenvectors of a generalized symmetric-definite
eigenproblem, of the form 
A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
Here A and B are assumed to be symmetric (Hermitian) and B is also positive definite. Eigenvalues
and eigenvectors can be selected by specifying either a range of values or a range of indices for the
desired eigenvalues. This method uses bisection algorithm (lapack functions SYGVX, HEGVX).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenSymmetric2Bisect(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   matrix&amp;               B,                  // second matrix
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors,      // matrix of computed eigenvectors
   matrix&amp;               triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenSymmetric2Bisect(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance
   matrixf&amp;              B,                  // second matrix
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors,      // matrix of computed eigenvectors
   matrixf&amp;              triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenSymmetric2Bisect(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1629
</p>
<pre><code class="language-mql5">
   matrixc&amp;              B,                  // second matrix
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors,¬†     // matrix of computed eigenvectors
   matrixc&amp;              triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenSymmetric2Bisect(
   ENUM_EIGS2_TYPE       itype,¬†             // the problem type to be solved
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // Upper bound of the subset
   float                 abstol,             // absolute error tolerance
   matrixcf&amp;             B,                  // second matrix
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors,      // matrix of computed eigenvectors
   matrixcf&amp;             triangular_factor¬†  // triangular factor from the Cholesky fa
   );
</code></pre>
<p>
<h3>Parameters</h3>
itype
[in]  ENUM_EIGS2_TYPE enumeration value which specified the problem type to be solved :
A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable eigenvalues and
vectors.
lower
[in]  The lower bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
upper
[in]  The upper bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
abstol
[in]  Absolute error tolerance.
The absolute error tolerance to which each eigenvalue/eigenvector is required.
If jobv = &#x27;V&#x27;, the eigenvalues and eigenvectors output have residual norms bounded by abstol,
and the dot products between different eigenvectors are bounded by abstol.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1630
If abstol &lt; n *eps*|T|, then n *eps*|T| is used instead, where eps is the machine precision,
and |T| is the 1-norm of the matrix T. The eigenvalues are computed to an accuracy of eps*|
T| irrespective of abstol.
If high relative precision is important, &#x27;abstol&#x27; should be set to a safe minimum value X such
that 1.0/X does not overflow.
<h3>B</h3>
[in]  Second matrix B. Must be positive definite symmetric (or Hermitian conjugated) matrix.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
triangular_factor
[out] The triangular factor U or L from the Cholesky factorization B = U**T*U or B = L*L**T.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobv and range parameters.
When BLASRANGE_A is set, all eigenvalues are computed, and the lower and upper parameters are
ignored.
With the BLASRANGE_V value, only those eigenvalues (and their vectors) are computed, which fall
within the range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters.
With the BLASRANGE_I value, only those eigenvalues (and their vectors) are computed, which fall
within the range of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters. For example, with
lower=0 and upper=2, only the first three eigenvalues are computed.
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated). Second matrix B must be positive
definite symmetric. If the input matrix and second matrix B are triangular, then both must be the
same triangular, upper or lower.
<h3>ENUM_EIGS2_TYPE</h3>
An enumeration that specifies  the problem type to be solved.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGS2TYPE_1</h3>
1:  A*x = (lambda)*B*x
<h3>EIGS2TYPE_2</h3>
2:  A*B*x = (lambda)*x
<h3>EIGS2TYPE_3</h3>
3:  B*A*x = (lambda)*x</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1631
<h3>ENUM_EIG_VALUES</h3>
An enumeration that specifies whether to calculate eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are calculated, without vectors.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1632
<h3>Tridiagonal Matrices</h3>
Functions for computing eigenvalues and eigenvectors of symmetric tridiagonal matrices using various
algorithms. Each function implements a specific solution method and supports matrix types double and
float.
<h3>Common Parameters:</h3>
¬∑ jobv ‚Äî Determines whether to compute eigenvectors (EIGVALUES_V) or only eigenvalues
(EIGVALUES_N).
¬∑ range ‚Äî Specifies the range of computed eigenvalues (BLASRANGE_A, BLASRANGE_V,
BLASRANGE_I).
¬∑ lower and upper ‚Äî Lower and upper bounds for computing a subset of the spectrum.
¬∑ abstol ‚Äî Absolute error tolerance.
All functions operate on symmetric tridiagonal matrices and allow selecting the most suitable algorithm
depending on performance and accuracy requirements.
<h3>Function</h3>
<h3>Action</h3>
<h3>EigenTridiagonalDC</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric tridiagonal matrix using the divide-and-
conquer algorithm (lapack function STEVD).
<h3>EigenTridiagonalQR</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric tridiagonal matrix using the QR algorithm
(lapack function STEV).
<h3>EigenTridiagonalRobust</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric tridiagonal matrix using the Multiple
<h3>Relatively Robust Representations, MRRR algorithm</h3>
(lapack function STEVR).
<h3>EigenTridiagonalBisect</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric tridiagonal matrix using the bisection
algorithm (lapack function STEVX).
<h3>EigenTridiagonalQL</h3>
Compute all eigenvalues of a symmetric tridiagonal
matrix using the Pal-Walker-Kahan variant of the QL
or QR algorithm (lapack function STERF).
<h3>EigenTridiagonalDCQ</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric tridiagonal matrix using the divide-and-
conquer algorithm (lapack function STEDC).
<h3>EigenTridiagonalQRQ</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric tridiagonal matrix using the QR algorithm
(lapack function STEQR).
<h3>EigenTridiagonalPosDefQ</h3>
<h3>Compute</h3>
eigenvalues 
and 
eigenvectors 
of 
a
symmetric 
positive 
definite 
(–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1633
<h3>Function</h3>
<h3>Action</h3>
–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–∞—è) tridiagonal matrix using the QR
algorithm (lapack function PTEQR).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1634
<h3>EigenTridiagonalDC</h3>
Compute eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide-and-conquer
algorithm (lapack function STEVD).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalDC(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalDC(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated.
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.
The input must be a symmetric matrix in the tridiagonal form.
<h3>ENUM_EIG_VALUES</h3>
An enumeration that specifies whether to calculate eigenvectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1635
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are calculated, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1636
<h3>EigenTridiagonalQR</h3>
Compute eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the QR algorithm
(lapack function STEV).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalQR(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalQR(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the jobv parameter.
When jobv = EIGVALUES_V, eigenvectors and eigenvalues are calculated.
If EIGVALUES_N is set, eigenvectors are not calculated. Only eigenvalues are computed.
The input must be a symmetric matrix in the tridiagonal form.
<h3>ENUM_EIG_VALUES</h3>
An enumeration that specifies whether to calculate eigenvectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1637
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are calculated, without vectors.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1638
<h3>EigenTridiagonalRobust</h3>
Compute eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the Multiple Relatively
Robust Representations, MRRR algorithm (lapack function STEVR).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalRobust(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrix&amp;               eigen_vectors  ¬†    // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalRobust(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable eigenvalues and
vectors.
lower
[in]  The lower bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
upper
[in]  The upper bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
abstol
[in]  Absolute error tolerance.
The absolute error tolerance to which each eigenvalue/eigenvector is required.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1639
If jobv = &#x27;V&#x27;, the eigenvalues and eigenvectors output have residual norms bounded by abstol,
and the dot products between different eigenvectors are bounded by abstol.
If abstol &lt; n *eps*|T|, then n *eps*|T| is used instead, where eps is the machine precision,
and |T| is the 1-norm of the matrix T. The eigenvalues are computed to an accuracy of eps*|
T| irrespective of abstol.
If high relative precision is important, &#x27;abstol&#x27; should be set to a safe minimum value X such
that 1.0/X does not overflow.
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobv and range parameters.
When BLASRANGE_A is set, all eigenvalues are computed, and the lower and upper parameters are
ignored.
With the BLASRANGE_V value, only those eigenvalues (and their vectors) are computed, which fall
within the range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters.
With the BLASRANGE_I value, only those eigenvalues (and their vectors) are computed, which fall
within the range of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters. For example, with
lower=0 and upper=2, only the first three eigenvalues are computed.
The input must be a symmetric matrix in the tridiagonal form.
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1640
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1641
<h3>EigenTridiagonalBisect</h3>
Compute eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the bisection algorithm
(lapack function STEVX).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalBisect(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   double                lower,¬†             // lower bound of the subset
   double                upper,              // Upper bound of the subset
   double                abstol,             // absolute error tolerance
   vector&amp;               eigen_values,¬†      // vector of computed eigenvectors
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalBisect(
   ENUM_EIG_VALUES       jobv,¬†              // compute eigenvectors or not
   ENUM_BLAS_RANGE       range,¬†             // subset of eigenvalues to compute
   float                 lower,¬†             // lower bound of the subset
   float                 upper,              // upper bound of the subset
   float                 abstol,             // absolute error tolerance
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvectors
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobv
[in]  ENUM_EIG_VALUES enumeration value which determines the method for computing
eigenvectors.
range
[in]  ENUM_BLAS_RANGE enumeration value that defines a subset of computable eigenvalues and
vectors.
lower
[in]  The lower bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
upper
[in]  The upper bound of eigenvalues subset; it is specified depending on the value of the &#x27;range&#x27;
parameter.
abstol
[in]  Absolute error tolerance.
The absolute error tolerance to which each eigenvalue/eigenvector is required.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1642
If jobv = &#x27;V&#x27;, the eigenvalues and eigenvectors output have residual norms bounded by abstol,
and the dot products between different eigenvectors are bounded by abstol.
If abstol &lt; n *eps*|T|, then n *eps*|T| is used instead, where eps is the machine precision,
and |T| is the 1-norm of the matrix T. The eigenvalues are computed to an accuracy of eps*|
T| irrespective of abstol.
If high relative precision is important, &#x27;abstol&#x27; should be set to a safe minimum value X such
that 1.0/X does not overflow.
eigen_values
[out] Vector of eigenvalues.
<h3>V</h3>
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the values of the jobv and range parameters.
When BLASRANGE_A is set, all eigenvalues are computed, and the lower and upper parameters are
ignored.
With the BLASRANGE_V value, only those eigenvalues (and their vectors) are computed, which fall
within the range of real values specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters.
With the BLASRANGE_I value, only those eigenvalues (and their vectors) are computed, which fall
within the range of integer indices specified by the &#x27;lower&#x27; and &#x27;upper&#x27; parameters. For example, with
lower=0 and upper=2, only the first three eigenvalues are computed.
The input must be a symmetric matrix in the tridiagonal form.
<h3>ENUM_EIG_VALUES</h3>
An enumeration defining the need to compute eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGVALUES_V</h3>
Eigenvectors and eigenvalues are calculated.
<h3>EIGVALUES_N</h3>
Only eigenvalues are computed, without vectors.
<h3>ENUM_BLAS_RANGE</h3>
An enumeration defining how right singular vectors should be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_A</h3>
All singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1643
<h3>ID</h3>
<h3>Description</h3>
<h3>BLASRANGE_V</h3>
All singular or eigenvalues in the half-open interval (VL,VU] will
be found.
<h3>BLASRANGE_I</h3>
The IL-th through IU-th singular or eigenvalues will be found.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1644
<h3>EigenTridiagonalQL</h3>
Compute all eigenvalues of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of the
QL or QR algorithm (lapack function STERF).
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalQL(
   vector&amp;               eigen_values ¬†      // vector of computed eigenvalues
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalQL(
   vectorf&amp;              eigen_values ¬†      // vector of computed eigenvalues
   );
</code></pre>
<p>
<h3>Parameters</h3>
eigen_values
[out] Vector of eigenvalues.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The input must be a symmetric matrix in the tridiagonal form.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1645
<h3>EigenTridiagonalDCQ</h3>
Compute eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide-and-conquer
algorithm (lapack function STEDC). Unlike EigenTridiagonalDC, this method can be used to compute
the eigenvectors of the original symmetric matrix. A symmetric matrix can be reduced to tridiagonal
form using the ReduceSymmetricToTridiagonal method. The orthogonal matrix Q obtained from this
transformation is then used to compute the eigenvectors of the original symmetric matrix.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalDCQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrix&amp;               Q,                  // orthogonal matrix used in the reductio
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalDCQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixf&amp;              Q,                  // orthogonal matrix used in the reductio
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenTridiagonalDCQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixc&amp;              Q,                  // orthogonal matrix used in the reductio
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenTridiagonalDCQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixcf&amp;             Q,                  // orthogonal matrix used in the reductio
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
compv
[in]  ENUM_EIGTRIDIAG_Z enumeration value which determines the method for computing
eigenvectors.
<h3>Q</h3>
[in]  Orthogonal matrix Q produced by method ReflectTridiagonalToQ.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1646
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the compv parameter.
When compv = EIGCOMPZ_N, compute eigenvalues only, eigenvectors are not calculated.
If EIGCOMPZ_V is set, eigenvalues are computed and eigenvectors of original symmetric matrix are
calculated also.
If EIGCOMPZ_I is set, eigenvalues are computed and eigenvectors of tridiagonal matrix are
calculated also.
The input must be a symmetric matrix in the tridiagonal form.
<h3>ENUM_EIGTRIDIAG_Z</h3>
An enumeration that specifies whether to calculate eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGCOMPZ_N</h3>
&#x27;N&#x27;: Compute eigenvalues only
<h3>EIGCOMPZ_V</h3>
&#x27;V&#x27;: Compute eigenvectors of original symmetric matrix also
<h3>EIGCOMPZ_I</h3>
&#x27;I&#x27;: Compute eigenvectors of tridiagonal matrix also</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1647
<h3>EigenTridiagonalQRQ</h3>
Compute eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the QR algorithm
(lapack function STEQR). Unlike EigenTridiagonalQR, this method can be used to compute the
eigenvectors of the original symmetric matrix. A symmetric matrix can be reduced to tridiagonal form
using the ReduceSymmetricToTridiagonal method. The orthogonal matrix Q obtained from this
transformation is then used to compute the eigenvectors of the original symmetric matrix.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalQRQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrix&amp;               Q,                  // orthogonal matrix used in the reductio
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalQRQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixf&amp;              Q,                  // orthogonal matrix used in the reductio
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenTridiagonalQRQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixc&amp;              Q,                  // orthogonal matrix used in the reductio
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenTridiagonalQRQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixcf&amp;             Q,                  // orthogonal matrix used in the reductio
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
compv
[in]  ENUM_EIGTRIDIAG_Z enumeration value which determines the method for computing
eigenvectors.
<h3>Q</h3>
[in]  Orthogonal matrix Q produced by method ReflectTridiagonalToQ.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1648
eigen_values
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the compv parameter.
When compv = EIGCOMPZ_N, compute eigenvalues only, eigenvectors are not calculated.
If EIGCOMPZ_V is set, eigenvalues are computed and eigenvectors of original symmetric matrix are
calculated also.
If EIGCOMPZ_I is set, eigenvalues are computed and eigenvectors of tridiagonal matrix are
calculated also.
The input must be a symmetric matrix in the tridiagonal form.
<h3>ENUM_EIGTRIDIAG_Z</h3>
An enumeration that specifies whether to calculate eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGCOMPZ_N</h3>
&#x27;N&#x27;: Compute eigenvalues only
<h3>EIGCOMPZ_V</h3>
&#x27;V&#x27;: Compute eigenvectors of original symmetric matrix also
<h3>EIGCOMPZ_I</h3>
&#x27;I&#x27;: Compute eigenvectors of tridiagonal matrix also</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1649
<h3>EigenTridiagonalPosDefQ</h3>
Compute eigenvalues and eigenvectors of a symmetric positive definite tridiagonal matrix using the
QR algorithm (lapack function PTEQR). This method can be used to compute the eigenvectors of both
the input tridiagonal matrix and the original positive definite symmetric matrix. This is achieved
using the orthogonal matrix Q obtained during the reduction to tridiagonal form.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::EigenTridiagonalPosDefQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrix&amp;               Q,                  // orthogonal matrix used in the reductio
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrix&amp;               eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::EigenTridiagonalPosDefQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixf&amp;              Q,                  // orthogonal matrix used in the reductio
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixf&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::EigenTridiagonalPosDefQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixc&amp;              Q,                  // orthogonal matrix used in the reductio
   vector&amp;               eigen_values,¬†      // vector of computed eigenvalues
   matrixc&amp;              eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::EigenTridiagonalPosDefQ(
   ENUM_EIGTRIDIAG_Z     compv,¬†             // compute eigenvectors or not
   matrixcf&amp;             Q,                  // orthogonal matrix used in the reductio
   vectorf&amp;              eigen_values,¬†      // vector of computed eigenvalues
   matrixcf&amp;             eigen_vectors¬†      // matrix of computed eigenvectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
compv
[in]  ENUM_EIGTRIDIAG_Z enumeration value which determines the method for computing
eigenvectors.
<h3>Q</h3>
[in]  Orthogonal matrix Q produced by method ReflectTridiagonalToQ.
eigen_values</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1650
[out] Vector of eigenvalues.
eigen_vectors
[out] Matrix of eigenvectors.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Computation depends on the value of the compv parameter.
When compv = EIGCOMPZ_N, compute eigenvalues only, eigenvectors are not calculated.
If EIGCOMPZ_V is set, eigenvalues are computed and eigenvectors of original symmetric matrix are
calculated also.
If EIGCOMPZ_I is set, eigenvalues are computed and eigenvectors of tridiagonal matrix are
calculated also.
The input must be a symmetric positive definite tridiagonal matrix.
<h3>ENUM_EIGTRIDIAG_Z</h3>
An enumeration that specifies whether to calculate eigenvectors.
<h3>ID</h3>
<h3>Description</h3>
<h3>EIGCOMPZ_N</h3>
&#x27;N&#x27;: Compute eigenvalues only
<h3>EIGCOMPZ_V</h3>
&#x27;V&#x27;: Compute eigenvectors of original symmetric matrix also
<h3>EIGCOMPZ_I</h3>
&#x27;I&#x27;: Compute eigenvectors of tridiagonal matrix also</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1651
<h3>Orthogonal Factorizations</h3>
OpenBLAS –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ä—è–¥ –ø—Ä–æ—Ü–µ–¥—É—Ä –¥–ª—è —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –æ–±—â–µ–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã A —Ä–∞–∑–º–µ—Ä–∞
m –Ω–∞ n –≤ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ–π (–≤ –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–º —Å–ª—É—á–∞–µ ‚Äî —É–Ω–∏—Ç–∞—Ä–Ω–æ–π) –∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π (–∏–ª–∏,
–≤–æ–∑–º–æ–∂–Ω–æ, —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω–æ–π) –º–∞—Ç—Ä–∏—Ü.  
–†–µ–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ Q –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ–π, –µ—Å–ª–∏ QT Q = I ; –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ Q –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è
—É–Ω–∏—Ç–∞—Ä–Ω–æ–π, –µ—Å–ª–∏ QH Q = I . –û—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã–µ –∏ —É–Ω–∏—Ç–∞—Ä–Ω—ã–µ –º–∞—Ç—Ä–∏—Ü—ã –æ–±–ª–∞–¥–∞—é—Ç –≤–∞–∂–Ω—ã–º —Å–≤–æ–π—Å—Ç–≤–æ–º ‚Äî
–æ–Ω–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç –µ–≤–∫–ª–∏–¥–æ–≤—É –Ω–æ—Ä–º—É –≤–µ–∫—Ç–æ—Ä–∞:
||x||2 = ||Qx||2, –µ—Å–ª–∏ Q –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞ –∏–ª–∏ —É–Ω–∏—Ç–∞—Ä–Ω–∞
–ë–ª–∞–≥–æ–¥–∞—Ä—è —ç—Ç–æ–º—É —Ç–∞–∫–∏–µ –º–∞—Ç—Ä–∏—Ü—ã —Å–ø–æ—Å–æ–±—Å—Ç–≤—É—é—Ç —á–∏—Å–ª–µ–Ω–Ω–æ–π —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –Ω–µ —É—Å–∏–ª–∏–≤–∞—é—Ç
–æ—à–∏–±–∫–∏ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è.
–û—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è —à–∏—Ä–æ–∫–æ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ –∑–∞–¥–∞—á –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö –∫–≤–∞–¥—Ä–∞—Ç–æ–≤. –ò—Ö
—Ç–∞–∫–∂–µ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö —à–∞–≥–æ–≤ –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ –∑–∞–¥–∞—á –Ω–∞
—Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–ª–∏ —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
<h3>–§—É–Ω–∫—Ü–∏—è</h3>
<h3>–í—ã–ø–æ–ª–Ω—è–µ–º–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ</h3>
<h3>FactorizationQR</h3>
<h3>–í—ã—á–∏—Å–ª—è–µ—Ç QR-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –æ–±—â–µ–π –º–∞—Ç—Ä–∏—Ü—ã —Ä–∞–∑–º–µ—Ä–∞</h3>
m –Ω–∞ n: A = Q * R. LAPACK-—Ñ—É–Ω–∫—Ü–∏—è GEQRF.
<h3>FactorizationQRNonNeg</h3>
<h3>–í—ã—á–∏—Å–ª—è–µ—Ç QR-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –æ–±—â–µ–π –º–∞—Ç—Ä–∏—Ü—ã —Ä–∞–∑–º–µ—Ä–∞</h3>
m –Ω–∞ n: A = Q * R, –≥–¥–µ R ‚Äî –≤–µ—Ä—Ö–Ω–µ—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è
–º–∞—Ç—Ä–∏—Ü–∞ —Å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ 
–Ω–∞
–¥–∏–∞–≥–æ–Ω–∞–ª–∏. LATPACK-—Ñ—É–Ω–∫—Ü–∏—è GEQRFP.
<h3>FactorizationQRPivot</h3>
<h3>–í—ã—á–∏—Å–ª—è–µ—Ç QR-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –æ–±—â–µ–π –º–∞—Ç—Ä–∏—Ü—ã —Ä–∞–∑–º–µ—Ä–∞</h3>
m –Ω–∞ n —Å –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–æ–π —Å—Ç–æ–ª–±—Ü–æ–≤: A * P = Q * R.
LAPACK-—Ñ—É–Ω–∫—Ü–∏—è GEQP3.
<h3>FactorizationLQ</h3>
Computes the LQ factorization of a general m-by-n
matrix: A = L * Q. Lapack function GELQF.
<h3>FactorizationQL</h3>
Computes the QL factorization of a general m-by-n
matrix: A = Q * L. Lapack function GEQLF.
<h3>FactorizationRQ</h3>
Computes the RQ factorization of a general m-by-n
matrix: A = R * Q. Lapack function GERQF.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1652
<h3>FactorizationQR</h3>
Computes the QR factorization of a general m-by-n matrix: A = Q * R. Lapack function GEQRF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQR(
   bool            reduced,      // calculation mode reduced or complete
   matrix&amp;         Q,            // orthogonal matrix Q
   matrix&amp;         R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQR(
   bool            reduced,      // calculation mode reduced or complete
   matrixf&amp;        Q,            // orthogonal matrix Q
   matrixf&amp;        R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQR(
   bool            reduced,      // calculation mode reduced or complete
   matrixc&amp;        Q,            // unitary matrix Q
   matrixc&amp;        R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQR(
   bool            reduced,      // calculation mode reduced or complete
   matrixcf&amp;       Q,            // unitary matrix Q
   matrixcf&amp;       R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Parameters</h3>
reduced
[in]  Calculation mode. If reduced is true then matrices Q, R calculated with dimensions (M, K), (K,
N). If reduced is false it means complete calculation of matrices Q, R with dimensions (M,M),
(M,N).
<h3>Q</h3>
[out]  Orthogonal or unitary matrix Q.
<h3>R</h3>
[out]  Upper triangular matrix R.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1653
<h3>Note</h3>
<h3>If reduced is true</h3>
</p>
<pre><code class="language-mql5">
   If m &gt;= n, matrix Q is of m-by-n sizes, matrix R is of n-by-n sizes.
   If m &lt; n, matrix Q is of m-by-m sizes, matrix R is of m-by-n sizes.
</code></pre>
<p>
If reduced is false, matrix Q is of m-by-m sizes, matrix R is of m-by-n sizes.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1654
<h3>FactorizationQRNonNeg</h3>
Computes the QR factorization of a general m-by-n matrix: A = Q * R. R is an upper triangular matrix
with nonnegative diagonal entries. Lapack function GEQRFP.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRNonNeg(
   bool            reduced,      // calculation mode reduced or complete
   matrix&amp;         Q,            // orthogonal matrix Q
   matrix&amp;         R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRNonNeg(
   bool            reduced,      // calculation mode reduced or complete
   matrixf&amp;        Q,            // orthogonal matrix Q
   matrixf&amp;        R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRNonNeg(
   bool            reduced,      // calculation mode reduced or complete
   matrixc&amp;        Q,            // unitary matrix Q
   matrixc&amp;        R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRNonNeg(
   bool            reduced,      // calculation mode reduced or complete
   matrixcf&amp;       Q,            // unitary matrix Q
   matrixcf&amp;       R             // upper triangular matrix R
   );
</code></pre>
<p>
<h3>Parameters</h3>
reduced
[in]  Calculation mode. If reduced is true then matrices Q, R calculated with dimensions (M, K), (K,
N). If reduced is false it means complete calculation of matrices Q, R with dimensions (M,M),
(M,N).
<h3>Q</h3>
[out]  Orthogonal or unitary matrix Q.
<h3>R</h3>
[out]  Upper triangular matrix R.
<h3>Return Value</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1655
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
<h3>If reduced is true</h3>
</p>
<pre><code class="language-mql5">
   If m &gt;= n, matrix Q is of m-by-n sizes, matrix R is of n-by-n sizes.
   If m &lt; n, matrix Q is of m-by-m sizes, matrix R is of m-by-n sizes.
</code></pre>
<p>
If reduced is false, matrix Q is of m-by-m sizes, matrix R is of m-by-n sizes.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1656
<h3>FactorizationQRPivot</h3>
Computes the QR factorization of a general m-by-n matrix with column pivoting: A * P = Q * R. Lapack
function GEQP3.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRPivot(
   bool            reduced,      // calculation mode reduced or complete
   long[]&amp;         jpvt,         // array with predefined permutations
   matrix&amp;         Q,            // orthogonal matrix Q
   matrix&amp;         R,            // upper triangular matrix R
   matrix&amp;         P             // permutation matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRPivot(
   bool            reduced,      // calculation mode reduced or complete
   long[]&amp;         jpvt,         // array with predefined permutations
   matrixf&amp;        Q,            // orthogonal matrix Q
   matrixf&amp;        R,            // upper triangular matrix R
   matrixf&amp;        P             // permutation matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRPivot(
   bool            reduced,      // calculation mode reduced or complete
   long[]&amp;         jpvt,         // array with predefined permutations
   matrixc&amp;        Q,            // unitary matrix Q
   matrixc&amp;        R,            // upper triangular matrix R
   matrixc&amp;        P             // permutation matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQRPivot(
   bool            reduced,      // calculation mode reduced or complete
   long[]&amp;         jpvt,         // array with predefined permutations
   matrixcf&amp;       Q,            // unitary matrix Q
   matrixcf&amp;       R,            // upper triangular matrix R
   matrixcf&amp;       P             // permutation matrix
   );
</code></pre>
<p>
<h3>Parameters</h3>
reduced
[in]  Calculation mode. If reduced is true then matrices Q, R calculated with dimensions (M, K), (K,
N). If reduced is false it means complete calculation of matrices Q, R with dimensions (M,M),
(M,N).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1657
jpvt
[in]  Integer array of dimension n. if jpvt(i) ‚â† 0, the i-th column of A is moved to the beginning of
AP before the computation, and fixed in place during the computation. If jpvt(i) = 0, the i-th
column of A is a free column (that is, it may be interchanged during the computation with any
other free column). If array has zero size (or not initialized), then all the columns of A assumed to
be free.
<h3>Q</h3>
[out]  Orthogonal or unitary matrix Q.
<h3>R</h3>
[out]  Upper triangular matrix R.
<h3>P</h3>
[out]  Permutation matrix P of n-by-n sizes.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
<h3>If reduced is true</h3>
</p>
<pre><code class="language-mql5">
   If m &gt;= n, matrix Q is of m-by-n sizes, matrix R is of n-by-n sizes.
   If m &lt; n, matrix Q is of m-by-m sizes, matrix R is of m-by-n sizes.
</code></pre>
<p>
If reduced is false, matrix Q is of m-by-m sizes, matrix R is of m-by-n sizes.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1658
<h3>FactorizationLQ</h3>
Computes the LQ factorization of a general m-by-n matrix: A = L * Q. Lapack function GELQF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLQ(
   bool            reduced,      // calculation mode reduced or complete
   matrix&amp;         L,            // lower triangular matrix L
   matrix&amp;         Q             // orthogonal matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLQ(
   bool            reduced,      // calculation mode reduced or complete
   matrixf&amp;        L,            // lower triangular matrix L
   matrixf&amp;        Q             // orthogonal matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLQ(
   bool            reduced,      // calculation mode reduced or complete
   matrixc&amp;        L,            // lower triangular matrix L
   matrixc&amp;        Q             // unitary matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLQ(
   bool            reduced,      // calculation mode reduced or complete
   matrixcf&amp;       L,            // lower triangular matrix L
   matrixcf&amp;       Q             // unitary matrix Q
   );
</code></pre>
<p>
<h3>Parameters</h3>
reduced
[in]  Calculation mode. If reduced is true then matrices L, Q calculated with reduced dimensions
(M, K), (K, N). If reduced is false it means complete calculation of matrices L, Q with dimensions
(M,N), (N,N).
<h3>L</h3>
[out]  Lower triangular matrix L.
<h3>Q</h3>
[out]  Orthogonal or unitary matrix Q.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1659
<h3>Note</h3>
<h3>If reduced is true</h3>
</p>
<pre><code class="language-mql5">
   If m &lt;= n, matrix L is of m-by-m sizes, matrix Q is of m-by-n sizes.
   If m &gt; n, matrix L is of m-by-n sizes, matrix Q is of n-by-n sizes.
</code></pre>
<p>
If reduced is false, matrix L is of m-by-n sizes, matrix Q is of n-by-n sizes.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1660
<h3>FactorizationQL</h3>
Computes the QL factorization of a general m-by-n matrix: A = Q * L. Lapack function GEQLF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQL(
   bool            reduced,      // calculation mode reduced or complete
   matrix&amp;         Q,            // orthogonal matrix Q
   matrix&amp;         L             // lower triangular matrix L
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQL(
   bool            reduced,      // calculation mode reduced or complete
   matrixf&amp;        Q,            // orthogonal matrix Q
   matrixf&amp;        L             // lower triangular matrix L
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQL(
   bool            reduced,      // calculation mode reduced or complete
   matrixc&amp;        Q,            // unitary matrix Q
   matrixc&amp;        L             // lower triangular matrix L
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationQL(
   bool            reduced,      // calculation mode reduced or complete
   matrixcf&amp;       Q,            // unitary matrix Q
   matrixcf&amp;       L             // lower triangular matrix L
   );
</code></pre>
<p>
<h3>Parameters</h3>
reduced
[in]  Calculation mode. If reduced is true then matrices Q, L calculated with reduced dimensions
(M, K), (K, N). If reduced is false it means complete calculation of matrices Q, L with dimensions
(M,M), (M,N).
<h3>Q</h3>
[out]  Orthogonal or unitary matrix Q.
<h3>L</h3>
[out]  Lower triangular matrix L.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1661
<h3>Note</h3>
<h3>If reduced is true</h3>
</p>
<pre><code class="language-mql5">
   If m &gt;= n, matrix Q is of m-by-n sizes, matrix L is of n-by-n sizes.
   If m &lt; n, matrix Q is of m-by-m sizes, matrix L is of m-by-n sizes.
</code></pre>
<p>
If reduced is false, matrix Q is of m-by-m sizes, matrix L is of m-by-n sizes.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1662
<h3>FactorizationRQ</h3>
Computes the RQ factorization of a general m-by-n matrix: A = R * Q. Lapack function GERQF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationRQ(
   bool            reduced,      // calculation mode reduced or complete
   matrix&amp;         R,            // upper triangular matrix R
   matrix&amp;         Q             // orthogonal matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationRQ(
   bool            reduced,      // calculation mode reduced or complete
   matrixf&amp;        R,            // upper triangular matrix R
   matrixf&amp;        Q             // orthogonal matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationRQ(
   bool            reduced,      // calculation mode reduced or complete
   matrixc&amp;        R,            // upper triangular matrix R
   matrixc&amp;        Q             // unitary matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationRQ(
   bool            reduced,      // calculation mode reduced or complete
   matrixcf&amp;       R,            // upper triangular matrix R
   matrixcf&amp;       Q             // unitary matrix Q
   );
</code></pre>
<p>
<h3>Parameters</h3>
reduced
[in]  Calculation mode. If reduced is true then matrices R, Q calculated with reduced dimensions
(M, K), (K, N). If reduced is false it means complete calculation of matrices L, Q with dimensions
(M,N), (N,N).
<h3>R</h3>
[out]  Upper triangular matrix R.
<h3>Q</h3>
[out]  Orthogonal or unitary matrix Q.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1663
<h3>Note</h3>
<h3>If reduced is true</h3>
</p>
<pre><code class="language-mql5">
   If m &lt;= n, matrix R is of m-by-m sizes, matrix Q is of m-by-n sizes.
   If m &gt; n, matrix R is of m-by-n sizes, matrix Q is of n-by-n sizes.
</code></pre>
<p>
If reduced is false, matrix R is of m-by-n sizes, matrix Q is of n-by-n sizes.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1664
<h3>Linear Equations</h3>
This section provides functions for solving systems of linear equations of the form A¬∑X = B, where A is
a square coefficient matrix, B is the right-hand side, and X is the solution matrix or vector. The
methods support various data types (double, float, complex, complexf) and are based on LAPACK
functions to ensure high precision and performance.
The functions are categorized based on the type of the coefficient matrix A. Each function is
overloaded to support both matrix and vector forms for the right-hand side (B) and the solution (X).
<h3>Function</h3>
<h3>Action</h3>
<h3>LinearEquationsSolution</h3>
Computes the solution to the system of linear
equations with a square coefficient matrix A and
multiple right-hand sides. A*X = B, where A is an n-
by-n general matrix, the columns of matrix B are
individual right-hand sides, and the columns of X are
the corresponding solutions. Lapack function GESV.
<h3>LinearEquationsSolutionTriangular</h3>
Computes the solution to the system of linear
equations with a square triangular coefficient matrix
A and multiple right-hand sides. A*X = B, where A is
an n-by-n general matrix, the columns of matrix B
are individual right-hand sides, and the columns of X
are the corresponding solutions. Lapack function
TRTRS.
<h3>LinearEquationsSolutionSy</h3>
Computes the solution to the system of linear
equations with a symmetric or Hermitian conjugated
matrix A and multiple right-hand sides. A*X = B,
where A is an n-by-n symmetric or Hermitian
conjugated matrix, the columns of matrix B are
individual right-hand sides, and the columns of X are
the corresponding solutions. Lapack functions SYSV,
HESV.
<h3>LinearEquationsSolutionComplexSy</h3>
Computes the solution to the system of linear
equations with a complex symmetric (not Hermitian
conjugated!) matrix A and multiple right-hand sides.
A*X = B, where A is an n-by-n complex symmetric
matrix, the columns of matrix B are individual right-
hand sides, and the columns of X are the
corresponding solutions. Lapack function SYSV.
<h3>LinearEquationsSolutionSyPD</h3>
Computes the solution to the system of linear
equations with a symmetric or Hermitian conjugated
positive-definite matrix A and multiple right-hand
sides. A*X = B, where A is an n-by-n symmetric or
<h3>Hermitian conjugated positive-definite matrix, the</h3>
columns of matrix B are individual right-hand sides,</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1665
<h3>Function</h3>
<h3>Action</h3>
and the columns of X are the corresponding
solutions. Lapack function POSV.
<h3>LinearEquationsSolutionGeTrid</h3>
Computes the solution to the system of linear
equations with a general (nonsymmetric) tridiagonal
coefficient matrix A and multiple right-hand sides.
A*X = B, where A is an n-by-n general tridiagonal
matrix, the columns of matrix B are individual right-
hand sides, and the columns of X are the
corresponding solutions. Lapack function GTSV.
<h3>LinearEquationsSolutionSyTridPD</h3>
Computes the solution to the system of linear
equations with a symmetric tridiagonal positive-
definite coefficient matrix A and multiple right-hand
sides. A*X = B, where A is an n-by-n symmetric
tridiagonal matrix, the columns of matrix B are
individual right-hand sides, and the columns of X are
the corresponding solutions. Lapack function PTSV.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1666
<h3>LinearEquationsSolution</h3>
Computes the solution to the system of linear equations with a square coefficient matrix A and
multiple right-hand sides. A*X = B, where A is an n-by-n general matrix, the columns of matrix B are
individual right-hand sides, and the columns of X are the corresponding solutions. Lapack function
GESV.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolution(
   matrix&amp;         B,            // right hand side matrix B
   matrix&amp;         X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolution(
   vector&amp;         B,            // right hand side vector B
   vector&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolution(
   matrixf&amp;        B,            // right hand side matrix B
   matrixf&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolution(
   vectorf&amp;         B,            // right hand side vector B
   vectorf&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolution(
   matrixc&amp;        B,            // right hand side matrix B
   matrixc&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolution(
   vectorc&amp;        B,            // right hand side vector B
   vectorc&amp;        X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolution(
   matrixcf&amp;       B,            // right hand side matrix B
   matrixcf&amp;       X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolution(</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1667
</p>
<pre><code class="language-mql5">
   vectorcf&amp;       B,            // right hand side vector B
   vectorcf&amp;       X             // solution vector X
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  Matrix B whose columns are the right-hand sides for the systems of equations. Vector B
contains one column of right-hand side.
<h3>X</h3>
[out]  Matrix or vector X with solutions of linear equations system.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Output matrix X has the same sizes as input matrix B. Output vector X has the same size as input
vector B.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1668
<h3>LinearEquationsSolutionTriangular</h3>
Computes the solution to the system of linear equations with a square triangular coefficient matrix A
and multiple right-hand sides. A*X = B, where A is an n-by-n general matrix, the columns of matrix B
are individual right-hand sides, and the columns of X are the corresponding solutions. Lapack function
TRTRS.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   matrix&amp;             B,            // right hand side matrix B
   matrix&amp;             X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   vector&amp;             B,            // right hand side vector B
   vector&amp;             X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   matrixf&amp;            B,            // right hand side matrix B
   matrixf&amp;            X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   vectorf&amp;            B,            // right hand side vector B
   vectorf&amp;            X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   matrixc&amp;            B,            // right hand side matrix B
   matrixc&amp;            X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   vectorc&amp;            B,            // right hand side vector B
   vectorc&amp;            X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1669
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   matrixcf&amp;           B,            // right hand side matrix B
   matrixcf&amp;           X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionTriangular(
   ENUM_EQUATIONS_FORM trans,¬†       // form of the system of equations
   vectorcf&amp;           B,            // right hand side vector B
   vectorcf&amp;           X             // solution vector X
   );
</code></pre>
<p>
<h3>Parameters</h3>
trans
[in]  ENUM_EQUATIONS_FORM enumeration value which specifies the form of the system of
equations.
<h3>B</h3>
[in]  Matrix B whose columns are the right-hand sides for the systems of equations. Vector B
contains one column of right-hand side.
<h3>X</h3>
[out]  Matrix or vector X with solutions of linear equations system.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Output matrix X has the same sizes as input matrix B. Output vector X has the same size as input
vector B.
<h3>ENUM_EQUATIONS_FORM</h3>
An enumeration defining which form of the equations&#x27; system calculated.
<h3>ID</h3>
<h3>Description</h3>
<h3>EQUATIONSFORM_N</h3>
&#x27;N&#x27;: A * X = B  (No transpose)
<h3>EQUATIONSFORM_T</h3>
&#x27;T&#x27;: A**T * X = B  (Transpose)
<h3>EQUATIONSFORM_C</h3>
&#x27;C&#x27;: A**H * X = B  (Conjugate transpose)
In case of real matrices the value EQUATIONSFORM_C assumed as Transpose.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1670
<h3>LinearEquationsSolutionSy</h3>
Computes the solution to the system of linear equations with a symmetric or Hermitian conjugated
matrix A and multiple right-hand sides. A*X = B, where A is an n-by-n symmetric or unitary matrix, the
columns of matrix B are individual right-hand sides, and the columns of X are the corresponding
solutions. Lapack functions SYSV, HESV.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSy(
   matrix&amp;         B,            // right hand side matrix B
   matrix&amp;         X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSy(
   vector&amp;         B,            // right hand side vector B
   vector&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSy(
   matrixf&amp;        B,            // right hand side matrix B
   matrixf&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSy(
   vectorf&amp;         B,            // right hand side vector B
   vectorf&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSy(
   matrixc&amp;        B,            // right hand side matrix B
   matrixc&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSy(
   vectorc&amp;        B,            // right hand side vector B
   vectorc&amp;        X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSy(
   matrixcf&amp;       B,            // right hand side matrix B
   matrixcf&amp;       X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSy(</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1671
</p>
<pre><code class="language-mql5">
   vectorcf&amp;       B,            // right hand side vector B
   vectorcf&amp;       X             // solution vector X
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  Matrix B whose columns are the right-hand sides for the systems of equations. Vector B
contains one column of right-hand side.
<h3>X</h3>
[out]  Matrix or vector X with solutions of linear equations system.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Output matrix X has the same sizes as input matrix B. Output vector X has the same size as input
vector B.
The input can be a symmetric (Hermitian conjugated), upper triangular or lower triangular matrix.
Triangular matrices are assumed to be symmetric (Hermitian conjugated).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1672
<h3>LinearEquationsSolutionComplexSy</h3>
Computes the solution to the system of linear equations with a complex symmetric (not Hermitian
conjugated!) matrix A and multiple right-hand sides. A*X = B, where A is an n-by-n complex symmetric
matrix, the columns of matrix B are individual right-hand sides, and the columns of X are the
corresponding solutions. Lapack function SYSV.
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionComplexSy(
   matrixc&amp;        B,            // right hand side matrix B
   matrixc&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionComplexSy(
   vectorc&amp;        B,            // right hand side vector B
   vectorc&amp;        X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionComplexSy(
   matrixcf&amp;       B,            // right hand side matrix B
   matrixcf&amp;       X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionComplexSy(
   vectorcf&amp;       B,            // right hand side vector B
   vectorcf&amp;       X             // solution vector X
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  Matrix B whose columns are the right-hand sides for the systems of equations. Vector B
contains one column of right-hand side.
<h3>X</h3>
[out]  Matrix or vector X with solutions of linear equations system.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Output matrix X has the same sizes as input matrix B. Output vector X has the same size as input
vector B.
The input can be a complex symmetric, upper triangular or lower triangular matrix. Triangular
matrices are assumed to be complex symmetric.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1673
<h3>LinearEquationsSolutionSyPD</h3>
Computes the solution to the system of linear equations with a symmetric or Hermitian conjugated
positive-definite matrix A and multiple right-hand sides. A*X = B, where A is an n-by-n symmetric or
unitary positive-definite matrix, the columns of matrix B are individual right-hand sides, and the
columns of X are the corresponding solutions. Lapack function POSV.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyPD(
   matrix&amp;         B,            // right hand side matrix B
   matrix&amp;         X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyPD(
   vector&amp;         B,            // right hand side vector B
   vector&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyPD(
   matrixf&amp;        B,            // right hand side matrix B
   matrixf&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyPD(
   vectorf&amp;         B,            // right hand side vector B
   vectorf&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyPD(
   matrixc&amp;        B,            // right hand side matrix B
   matrixc&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyPD(
   vectorc&amp;        B,            // right hand side vector B
   vectorc&amp;        X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyPD(
   matrixcf&amp;       B,            // right hand side matrix B
   matrixcf&amp;       X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyPD(</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1674
</p>
<pre><code class="language-mql5">
   vectorcf&amp;       B,            // right hand side vector B
   vectorcf&amp;       X             // solution vector X
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  Matrix B whose columns are the right-hand sides for the systems of equations. Vector B
contains one column of right-hand side.
<h3>X</h3>
[out]  Matrix or vector X with solutions of linear equations system.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Output matrix X has the same sizes as input matrix B. Output vector X has the same size as input
vector B.
The input can be a symmetric (Hermitian conjugated), upper triangular or lower triangular matrix.
Triangular matrices are assumed to be symmetric (Hermitian conjugated).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1675
<h3>LinearEquationsSolutionGeTrid</h3>
Computes the solution to the system of linear equations with a general (nonsymmetric) tridiagonal
coefficient matrix A and multiple right-hand sides. A*X = B, where A is an n-by-n general tridiagonal
matrix, the columns of matrix B are individual right-hand sides, and the columns of X are the
corresponding solutions. Lapack function GTSV.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionGeTrid(
   matrix&amp;         B,            // right hand side matrix B
   matrix&amp;         X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionGeTrid(
   vector&amp;         B,            // right hand side vector B
   vector&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionGeTrid(
   matrixf&amp;        B,            // right hand side matrix B
   matrixf&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionGeTrid(
   vectorf&amp;         B,            // right hand side vector B
   vectorf&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionGeTrid(
   matrixc&amp;        B,            // right hand side matrix B
   matrixc&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionGeTrid(
   vectorc&amp;        B,            // right hand side vector B
   vectorc&amp;        X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionGeTrid(
   matrixcf&amp;       B,            // right hand side matrix B
   matrixcf&amp;       X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionGeTrid(</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1676
</p>
<pre><code class="language-mql5">
   vectorcf&amp;       B,            // right hand side vector B
   vectorcf&amp;       X             // solution vector X
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  Matrix B whose columns are the right-hand sides for the systems of equations. Vector B
contains one column of right-hand side.
<h3>X</h3>
[out]  Matrix or vector X with solutions of linear equations system.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Output matrix X has the same sizes as input matrix B. Output vector X has the same size as input
vector B.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1677
<h3>LinearEquationsSolutionSyTridPD</h3>
Computes the solution to the system of linear equations with a symmetric tridiagonal positive-definite
coefficient matrix A and multiple right-hand sides. A*X = B, where A is an n-by-n symmetric tridiagonal
matrix, the columns of matrix B are individual right-hand sides, and the columns of X are the
corresponding solutions. Lapack function PTSV.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyTridPD(
   matrix&amp;         B,            // right hand side matrix B
   matrix&amp;         X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyTridPD(
   vector&amp;         B,            // right hand side vector B
   vector&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyTridPD(
   matrixf&amp;        B,            // right hand side matrix B
   matrixf&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyTridPD(
   vectorf&amp;         B,            // right hand side vector B
   vectorf&amp;         X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyTridPD(
   matrixc&amp;        B,            // right hand side matrix B
   matrixc&amp;        X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyTridPD(
   vectorc&amp;        B,            // right hand side vector B
   vectorc&amp;        X             // solution vector X
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::LinearEquationsSolutionSyTridPD(
   matrixcf&amp;       B,            // right hand side matrix B
   matrixcf&amp;       X             // solution matrix X
   );
bool¬† matrix::LinearEquationsSolutionSyTridPD(</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1678
</p>
<pre><code class="language-mql5">
   vectorcf&amp;       B,            // right hand side vector B
   vectorcf&amp;       X             // solution vector X
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[in]  Matrix B whose columns are the right-hand sides for the systems of equations. Vector B
contains one column of right-hand side.
<h3>X</h3>
[out]  Matrix or vector X with solutions of linear equations system.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
Output matrix X has the same sizes as input matrix B. Output vector X has the same size as input
vector B.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1679
<h3>Factorizations</h3>
The Factorizations section contains functions for performing various types of matrix factorizations
used in numerical solutions of linear systems, stability analysis, and other linear algebra tasks. These
factorizations transform the original matrix into simpler forms, making subsequent computations
more efficient. All functions are implemented using LAPACK routines and support the types double,
float, complex, and complexf.
The functions in this section are used for:
¬∑ Preprocessing matrices when solving systems of linear equations;
¬∑ Computing determinants, ranks, and matrix inverses;
¬∑ Assessing the stability of numerical methods;
¬∑ Solving problems in spectral theory and optimization methods.
Matrix factorization is a critical step in many linear algebra algorithms, and this section provides
access to the most efficient and well-established factorization techniques.
<h3>Function</h3>
<h3>Action</h3>
<h3>FactorizationPLU</h3>
Computes an LU factorization of a general M-by-N
matrix 
<h3>A</h3>
using 
partial 
pivoting 
with 
row
interchanges. The factorization has the form A = P *
L * U. Lapack function GETRF.
<h3>FactorizationPLUGeTrid</h3>
Computes an LU factorization of a general (non-
symmetric) tridiagonal N-by-N matrix A using
elimination 
with 
partial 
pivoting 
and 
row
interchanges. The factorization has the form A = P *
L * U. Lapack function GTTRF.
<h3>FactorizationLDL</h3>
Computes the factorization of a real symmetric or
complex Hermitian matrix A using the Bunch-
<h3>Kaufman diagonal pivoting method. Lapack functions</h3>
SYTRF, HETRF.
<h3>FactorizationLDLSyTridPD</h3>
Forms the factorization of a symmetric positive-
definite or, for complex data, Hermitian positive-
definite tridiagonal matrix A. Lapack function
PTTRF.
<h3>FactorizationCholesky</h3>
Computes the factorization of a real symmetric or
complex Hermitian positive-definite matrix A. 
Lapack function POTRF.
<h3>FactorizationCholeskySyPS</h3>
<h3>Computes the Cholesky factorization with complete</h3>
pivoting of a real symmetric (complex Hermitian)
positive semidefinite N-by-N matrix. Lapack function
PSTRF.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1680
<h3>FactorizationPLU</h3>
Computes an LU factorization of a general M-by-N matrix A using partial pivoting with row
interchanges. The factorization has the form
</p>
<pre><code class="language-mql5">
    A = P * L * U
</code></pre>
<p>
where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if
m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). Lapack function GETRF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLU(
   matrix&amp;         P,            // permutation matrix P
   matrix&amp;         L,            // lower triangular matrix L
   matrix&amp;         U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLU(
   matrixf&amp;        P,            // permutation matrix P
   matrixf&amp;        L,            // lower triangular matrix L
   matrixf&amp;        U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLU(
   matrixc&amp;        P,            // permutation matrix P
   matrixc&amp;        L,            // lower triangular matrix L
   matrixc&amp;        U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLU(
   matrixcf&amp;       P,            // permutation matrix P
   matrixcf&amp;       L,            // lower triangular matrix L
   matrixcf&amp;       U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>P</h3>
[out]  Permutation matrix P.
<h3>L</h3>
[out]  Lower triangular matrix L with unit diagonal elements.
<h3>U</h3>
[out]  Upper triangular matrix U.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1681
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1682
<h3>FactorizationPLUGeTrid</h3>
Computes an LU factorization of a general (non-symmetric) tridiagonal N-by-N matrix A using
elimination with partial pivoting and row interchanges. The factorization has the form
</p>
<pre><code class="language-mql5">
    A = P * L * U
</code></pre>
<p>
where P is a permutation matrix, L is lower triangular with unit diagonal elements, and U is upper
triangular. Lapack function GTTRF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLUGeTrid(
   matrix&amp;         P,            // permutation matrix P
   matrix&amp;         L,            // lower triangular matrix L
   matrix&amp;         U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLUGeTrid(
   matrixf&amp;        P,            // permutation matrix P
   matrixf&amp;        L,            // lower triangular matrix L
   matrixf&amp;        U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLUGeTrid(
   matrixc&amp;        P,            // permutation matrix P
   matrixc&amp;        L,            // lower triangular matrix L
   matrixc&amp;        U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationPLUGeTrid(
   matrixcf&amp;       P,            // permutation matrix P
   matrixcf&amp;       L,            // lower triangular matrix L
   matrixcf&amp;       U             // upper triangular matrix U
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>P</h3>
[out]  Permutation matrix P.
<h3>L</h3>
[out]  Lower triangular matrix L with unit diagonal elements.
<h3>U</h3>
[out]  Upper triangular matrix U.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1683
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1684
<h3>FactorizationLDL</h3>
Computes the factorization of a real symmetric or complex Hermitian matrix A using the Bunch-
Kaufman diagonal pivoting method. The form of the factorization is:
</p>
<pre><code class="language-mql5">
    A = L * D * L**T in case of lower triangular or symmetric matrix A
</code></pre>
<p>
or
</p>
<pre><code class="language-mql5">
    A = U**T * D * U in case of upper triangular matrix A
</code></pre>
<p>
where L is lower triangular with unit diagonal elements, U is upper triangular with unit diagonal
elements. D is a symmetric block-diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks. Lapack
functions SYTRF, HETRF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDL(
   matrix&amp;         L,            // lower or upper triangular matrix
   matrix&amp;         D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDL(
   matrixf&amp;        L,            // lower or upper triangular matrix
   matrixf&amp;        D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDL(
   matrixc&amp;        L,            // lower or upper triangular matrix
   matrixc&amp;        D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDL(
   matrixcf&amp;       L,            // lower or upper triangular matrix
   matrixcf&amp;       D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>L</h3>
[out]  Lower or upper triangular matrix with unit diagonal elements.
<h3>D</h3>
[out]  Symmetric block-diagonal matrix D.
<h3>Return Value</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1685
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1686
<h3>FactorizationLDLSyTridPD</h3>
Forms the factorization of a symmetric positive-definite or, for complex data, Hermitian positive-
definite tridiagonal matrix A:
</p>
<pre><code class="language-mql5">
    A = L * D * L**T in case of lower triangular or symmetric matrix A
</code></pre>
<p>
or
</p>
<pre><code class="language-mql5">
    A = U**T * D * U in case of upper triangular matrix A
</code></pre>
<p>
where L is lower triangular with unit diagonal elements, U is upper triangular with unit diagonal
elements. D is diagonal matrix. Lapack function PTTRF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDLSyTridPD(
   matrix&amp;         L,            // lower or upper triangular matrix
   matrix&amp;         D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDLSyTridPD(
   matrixf&amp;        L,            // lower or upper triangular matrix
   matrixf&amp;        D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDLSyTridPD(
   matrixc&amp;        L,            // lower or upper triangular matrix
   matrixc&amp;        D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationLDLSyTridPD(
   matrixcf&amp;       L,            // lower or upper triangular matrix
   matrixcf&amp;       D             // diagonal matrix D
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>L</h3>
[out]  Lower or upper triangular matrix with unit diagonal elements.
<h3>D</h3>
[out]  Diagonal matrix D.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1687
<h3>Note</h3>
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1688
<h3>FactorizationCholesky</h3>
Computes the factorization of a real symmetric or complex Hermitian positive-definite matrix A. The
factorization has the form:
</p>
<pre><code class="language-mql5">
    A = L *  L**T in case of lower triangular or symmetric matrix A
</code></pre>
<p>
or
</p>
<pre><code class="language-mql5">
    A = U**T  * U in case of upper triangular matrix A
</code></pre>
<p>
where L is lower triangular, U is upper triangular. Lapack function POTRF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholesky(
   matrix&amp;         L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholesky(
   matrixf&amp;        L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholesky(
   matrixc&amp;        L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholesky(
   matrixcf&amp;       L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>L</h3>
[out]  Lower or upper triangular matrix.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1689
<h3>FactorizationCholeskySyPS</h3>
Computes the Cholesky factorization with complete pivoting of a real symmetric (complex Hermitian)
positive semidefinite N-by-N matrix. The form of the factorization is:
</p>
<pre><code class="language-mql5">
    P**T * A * P = L *  L**T in case of lower triangular or symmetric matrix A
</code></pre>
<p>
or
</p>
<pre><code class="language-mql5">
    P**T * A * P = U**T  * U in case of upper triangular matrix A
</code></pre>
<p>
where P is a permutation matrix, L is lower triangular, U is upper triangular. Lapack function PSTRF.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholeskySyPS(
   double          tol           // tolerance
   matrix&amp;         P,            // permutation matrix P
   matrix&amp;         L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholeskySyPS(
   float           tol           // tolerance
   matrixf&amp;        P,            // permutation matrix P
   matrixf&amp;        L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholeskySyPS(
   double          tol           // tolerance
   matrixc&amp;        P,            // permutation matrix P
   matrixc&amp;        L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::FactorizationCholeskySyPS(
   float           tol           // tolerance
   matrixcf&amp;       P,            // permutation matrix P
   matrixcf&amp;       L             // lower or upper triangular matrix
   );
</code></pre>
<p>
<h3>Parameters</h3>
tol
[in]  User defined tolerance. If tol &lt; 0, then n*Œµ*max(A[k,k]), where Œµ is the machine precision, will
be used. The algorithm terminates at the (k-1)st step, if the pivot &lt;=tol.
<h3>P</h3>
[out]  Permutation matrix P.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1690
<h3>L</h3>
[out]  Lower or upper triangular matrix.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The input can be a symmetric (Hermitian), upper triangular or lower triangular matrix. Triangular
matrices are assumed to be symmetric (Hermitian conjugated).</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1691
<h3>Dynamic Mode Decomposition</h3>
The Dynamic Mode Decomposition (DMD) functions are designed to compute an evolution operator
from data snapshots, enabling efficient analysis of linear dynamics in extended phase spaces. The
methods 
provide 
memory-efficient 
representations 
of 
evolution 
operators, 
with
DynamicModeDecompositionQR incorporating QR-based data compression for improved computational
efficiency.
<h3>Function</h3>
<h3>Action</h3>
<h3>DynamicModeDecomposition</h3>
<h3>Compute the Dynamic Mode Decomposition (DMD)</h3>
</p>
<pre><code class="language-mql5">
for a pair of data snapshot matrices. Lapack
</code></pre>
<p>
function GEDMD. 
<h3>DynamicModeDecompositionQR</h3>
<h3>Compute the Dynamic Mode Decomposition (DMD)</h3>
</p>
<pre><code class="language-mql5">
for a pair of data snapshot matrices, using a QR
</code></pre>
<p>
factorization based compression of the data. Lapack
function GEDMDQ.
The Dynamic mode decomposition (DMD) method is an algorithm for searching for an evolution
operator (inverse operator problem solutions) in a finite-dimensional problem solution space
(numerical or experimentally obtained) in a set of solutions (slices, &quot;snapshots&quot;) in some consecutive
moments of time. Expansion of the phase space due to the use of a nonlinear basis (relative to the
variables of the problem) allows us to construct a global linear operator describing a linear evolution in
the extended &quot;rectifying space&quot; (the Coopman operator) and the Perron-Frobenius operator that is its
adjoint one. The DMD method is equivalent to a compressed representation of a linear evolution
operator in the form of a product of rectangular matrices, which provides significant savings in the
required memory during calculations. </p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1692
<h3>DynamicModeDecomposition</h3>
Compute the Dynamic Mode Decomposition(–ø–æ-—Ä—É—Å—Å–∫–∏ &quot;—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –ø–æ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º –º–æ–¥–∞–º&quot;) (DMD)
</p>
<pre><code class="language-mql5">
for a pair of data snapshot matrices. Lapack function GEDMD. For the input matrices X and Y such that
</code></pre>
<p>
Y = A*X with an unaccessible matrix A, GEDMD computes a certain number of Ritz pairs of A using the
standard Rayleigh-Ritz extraction from a subspace of  range(X) that is determined using the leading
left singular vectors of X. Optionally, GEDMD returns the residuals of the computed Ritz pairs, the
information needed for a refinement of the Ritz vectors, or the eigenvectors of the Exact DMD. Both
matrices must be the same size.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::DynamicModeDecomposition(
   matrix&amp;               B,¬†                      // second snapshot matrix in the pai
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMD_EIGV         jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   double                tol,¬†                    // the tolerance for truncating smal
   vectorc&amp;              eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrix&amp;               left_vectors,¬†           // matrix of left singular vectors
   matrix&amp;               Z¬†                       // matrix of Ritz vectors
   vector&amp;               residuals,               // residuals for the Ritz pairs
   matrix&amp;               res_vectors,             // residual vectors for the Ritz pai
   matrix&amp;               B,¬†                      // computed vectors
   matrix&amp;               W,¬†                      // eigenvectors of the matrix Raylei
   matrix&amp;               S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::DynamicModeDecomposition(
   matrixf&amp;              B,¬†                      // second snapshot matrix in the pai
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMD_EIGV         jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   float                 tol,¬†                    // the tolerance for truncating smal
   vectorcf&amp;             eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrixf&amp;              left_vectors,¬†           // matrix of left singular vectors
   matrixf&amp;              Z¬†                       // matrix of Ritz vectors
   vectorf&amp;              residuals,               // residuals for the Ritz pairs
   matrixf&amp;              res_vectors,             // residual vectors for the Ritz pai
   matrixf&amp;              B,¬†                      // computed vectors
   matrixf&amp;              W,¬†                      // eigenvectors of the matrix Raylei</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1693
</p>
<pre><code class="language-mql5">
   matrixf&amp;              S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::DynamicModeDecomposition(
   matrixc&amp;              B,¬†                      // second snapshot matrix in the pai
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMD_EIGV         jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   double                tol,¬†                    // the tolerance for truncating smal
   vectorc&amp;              eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrixc&amp;              left_vectors,¬†           // matrix of left singular vectors
   matrixc&amp;              Z¬†                       // matrix of Ritz vectors
   vector&amp;               residuals,               // residuals for the Ritz pairs
   matrixc&amp;              res_vectors,             // residual vectors for the Ritz pai
   matrixc&amp;              B,¬†                      // computed vectors
   matrixc&amp;              W,¬†                      // eigenvectors of the matrix Raylei
   matrixc&amp;              S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::DynamicModeDecomposition(
   matrixcf&amp;             B,¬†                      // second snapshot matrix in the pai
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMD_EIGV         jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   float                 tol,¬†                    // the tolerance for truncating smal
   vectorcf&amp;             eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrixcf&amp;             left_vectors,¬†           // matrix of left singular vectors
   matrixcf&amp;             Z¬†                       // matrix of Ritz vectors
   vectorf&amp;              residuals,               // residuals for the Ritz pairs
   matrixcf&amp;             res_vectors,             // residual vectors for the Ritz pai
   matrixcf&amp;             B,¬†                      // computed vectors
   matrixcf&amp;             W,¬†                      // eigenvectors of the matrix Raylei
   matrixcf&amp;             S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>Y</h3>
[in]  The second snapshot matrix in the pair.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1694
jobs
[in]  Value from the ENUM_DMD_SCALE enumeration which determines whether the initial data
snapshots are scaled by a diagonal matrix.
jobz
[in]   Value from the ENUM_DMD_EIGV enumeration which determines whether the eigenvectors
(Koopman modes) will be computed.
jobr
[in]   Value from the ENUM_DMD_RESIDUALS enumeration which determines whether to compute
the residuals.
jobf
[in]   Value from the ENUM_DMD_REFINE enumeration which specifies whether to store information
needed for post-processing (e.g. computing refined Ritz vectors).
whtsvd
[in]   Value from the ENUM_SVD_ALG enumeration which allows for a selection of the SVD algorithm
from the LAPACK library.
nrnk
[in]   Value determines the mode how to compute the numerical rank, i.e. how to truncate small
singular values of the input matrix X. If
</p>
<pre><code class="language-mql5">
        NRNK = -1 :: i-th singular value sigma(i) is truncated if sigma(i) &lt;= TOL*sigma(1). This
</code></pre>
<p>
option is recommended.
</p>
<pre><code class="language-mql5">
        NRNK = -2 :: i-th singular value sigma(i) is truncated if sigma(i) &lt;= TOL*sigma(i-1). This
</code></pre>
<p>
option is included for R&amp;D purposes. It requires highly accurate SVD, which may not be feasible.
</p>
<pre><code class="language-mql5">
        The numerical rank can be enforced by using positive value of NRNK as follows: 0 &lt; NRNK &lt;=
</code></pre>
<p>
N :: at most NRNK largest singular values will be used. If the number of the computed nonzero
singular values is less than NRNK, then only those nonzero values will be used and the actually used
dimension is less than NRNK.
tol
[in]   The tolerance for truncating small singular values. 0 &lt;= TOL &lt; 1
eigen_values
[out] Vector of eigenvalues of size K. The leading K (K&lt;=N) entries of EIGS contain the computed
eigenvalues (Ritz values).
left_vectors
[out] Matrix of left singular vectors. The leading K columns contain a POD basis (POD - Proper
Orthogonal Decomposition, –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è), i.e. the leading K left
singular vectors of the input data matrix X  All N columns of contain all left singular vectors of the
</p>
<pre><code class="language-mql5">
input matrix X.
</code></pre>
<p>
<h3>Z</h3>
[out] Matrix of Ritz vectors. If JOBZ ==&#x27;V&#x27; then Z contains the  Ritz vectors.  Z(:,i) is an
eigenvector of the i-th Ritz value; ||Z(:,i)||_2=1. If JOBZ == &#x27;F&#x27;, then the Z(:,i)&#x27;s are given
implicitly as the columns of X(:,1:K)*W(1:K,1:K), i.e. X(:,1:K)*W(:,i) is an eigenvector
corresponding to EIGS(i). The columns of W(1:k,1:K) are the computed eigenvectors of the K-by-K
Rayleigh quotient.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1695
residuals
[out]  Residuals for the K computed Ritz pairs.
res_vectors
[out]  Residual vectors for the K computed Ritz pairs.
<h3>B</h3>
[out]  M-by-K matrix (K&lt;=N).
</p>
<pre><code class="language-mql5">
         If JOBF ==&#x27;R&#x27;, B(1:M,1:K) contains A*U(:,1:K), and can be used for computing the refined
</code></pre>
<p>
vectors; see further details in the provided references.
</p>
<pre><code class="language-mql5">
         If JOBF == &#x27;E&#x27;, B(1:M,1:K) contains A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
</code></pre>
<p>
Exact DMD, up to scaling by the inverse eigenvalues.
</p>
<pre><code class="language-mql5">
         If JOBF ==&#x27;N&#x27;, then B is not referenced.
</code></pre>
<p>
<h3>W</h3>
[out]  K-by-K matrix (K&lt;=N). Contains the K computed eigenvectors of the matrix Rayleigh
quotient. The Ritz vectors (returned in Z) are the product of X (containing a POD basis for the
</p>
<pre><code class="language-mql5">
input matrix X) and W.
</code></pre>
<p>
<h3>S</h3>
[out]  K-by-K matrix (K&lt;=N). The array S(1:K,1:K) is used for the matrix Rayleigh quotient. This
content is overwritten during the eigenvalue decomposition by GEEV.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
The number of matrices rows (M) must not be less than the number of columns (N).
<h3>ENUM_DMD_SCALE</h3>
An enumeration that determines whether the initial data snapshots are scaled by a diagonal matrix.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDSCALE_S</h3>
&#x27;S&#x27;: The data snapshots matrices X and Y are multiplied with a
diagonal matrix D so that X*D has unit nonzero columns
<h3>DMDSCALE_C</h3>
&#x27;C&#x27;: The snapshots are scaled as with the &#x27;S&#x27; option.If it is found
that an i-th column of X is zero vector and the corresponding i-
th column of Y is non-zero, then the i-th column of Y is set to
zero
<h3>DMDSCALE_Y</h3>
&#x27;Y&#x27;: The data snapshots matrices X and Y are multiplied with a
diagonal matrix D so that Y*D has unit nonzero columns
<h3>DMDSCALE_N</h3>
&#x27;N&#x27;: No data scaling</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1696
<h3>ENUM_DMD_EIGV</h3>
An enumeration which determines whether the eigenvectors (Koopman modes) will be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDEIGV_V</h3>
&#x27;V&#x27;: The eigenvectors (Koopman modes) will be computed
<h3>DMDEIGV_F</h3>
&#x27;F&#x27;: The eigenvectors (Koopman modes) will be returned in
factored form
<h3>DMDEIGV_N</h3>
&#x27;N&#x27;: The eigenvectors are not computed
<h3>ENUM_DMD_RESIDUALS</h3>
An enumeration which determines whether to compute the residuals.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDRESIDUALS_R</h3>
&#x27;R&#x27;: The residuals for the computed eigenpairs will be computed
<h3>DMDRESIDUALS_N</h3>
&#x27;N&#x27;: The residuals are not computed
<h3>ENUM_DMD_REFINE</h3>
An enumeration which specifies whether to store information needed for post-processing.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDREFINE_R</h3>
&#x27;R&#x27;: The matrix needed for the refinement of the Ritz vectors is
computed and stored in the array B
<h3>DMDREFINE_E</h3>
&#x27;E&#x27;: The unscaled eigenvectors of the Exact DMD are computed
and returned in the array B
<h3>DMDREFINE_N</h3>
&#x27;N&#x27;: No eigenvector refinement data is computed
<h3>ENUM_SVD_ALG</h3>
An enumeration selecting the SVD algorythm.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDALG_1</h3>
1: GESVD (the QR SVD algorithm)
<h3>SVDALG_2</h3>
2: GESDD (the Divide and Conquer algorithm)</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1697
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDALG_3</h3>
3: GESVDQ (the preconditioned QR SVD; this and 4 are the
most accurate options)
<h3>SVDALG_4</h3>
4: GEJSV (the preconditioned Jacobi SVD; this and 3 are the
most accurate options)</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1698
<h3>DynamicModeDecompositionQR</h3>
Compute the Dynamic Mode Decomposition(–ø–æ-—Ä—É—Å—Å–∫–∏ &quot;–¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö –º–æ–¥&quot;) (DMD) for
a pair of data snapshot matrices, using a QR factorization based compression of the data. Lapack
function GEDMDQ. For the input matrices X and Y such that Y = A*X with an unaccessible matrix A,
GEDMDQ computes a certain number of Ritz pairs of A using the standard Rayleigh-Ritz extraction
from a subspace of  range(X) that is determined using the leading left singular vectors of X.
Optionally, GEDMDQ returns the residuals of the computed Ritz pairs, the information needed for a
refinement of the Ritz vectors, or the eigenvectors of the Exact DMD.
The input M-by-N matrix F. The columns of F are the sequence of data snapshots from a single
trajectory, taken at equidistant discrete times. It is assumed that the column norms of F are in the
range of the normalized floating point numbers.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::DynamicModeDecompositionQR(
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMDQ_EIGV        jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMDQ_Q           jobq,¬†                   // specifies whether to explicitly c
   ENUM_DMDQ_R           jobt,¬†                   // specifies whether to return the u
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   double                tol,¬†                    // the tolerance for truncating smal
   vectorc&amp;              eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrix&amp;               Q,                       // Q factor from the QR factorizatio
   matrix&amp;               R,                       // R factor from the QR factorizatio
   matrix&amp;               left_vectors,¬†           // matrix of left singular vectors
   matrix&amp;               Z¬†                       // matrix of Ritz vectors
   vector&amp;               residuals,               // residuals for the Ritz pairs
   matrix&amp;               B,¬†                      // computed vectors
   matrix&amp;               V,¬†                      // eigenvectors of the matrix Raylei
   matrix&amp;               S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixf::DynamicModeDecompositionQR(
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMDQ_EIGV        jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMDQ_Q           jobq,¬†                   // specifies whether to explicitly c
   ENUM_DMDQ_R           jobt,¬†                   // specifies whether to return the u
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   float                 tol,¬†                    // the tolerance for truncating smal</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1699
</p>
<pre><code class="language-mql5">
   vectorcf&amp;             eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrixf&amp;              Q,                       // Q factor from the QR factorizatio
   matrixf&amp;              R,                       // R factor from the QR factorizatio
   matrixf&amp;              left_vectors,¬†           // matrix of left singular vectors
   matrixf&amp;              Z¬†                       // matrix of Ritz vectors
   vectorf&amp;              residuals,               // residuals for the Ritz pairs
   matrixf&amp;              B,¬†                      // computed vectors
   matrixf&amp;              V,¬†                      // eigenvectors of the matrix Raylei
   matrixf&amp;              S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixc::DynamicModeDecompositionQR(
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMDQ_EIGV        jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMDQ_Q           jobq,¬†                   // specifies whether to explicitly c
   ENUM_DMDQ_R           jobt,¬†                   // specifies whether to return the u
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   double                tol,¬†                    // the tolerance for truncating smal
   vectorc&amp;              eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrixc&amp;              Q,                       // Q factor from the QR factorizatio
   matrixc&amp;              R,                       // R factor from the QR factorizatio
   matrixc&amp;              left_vectors,¬†           // matrix of left singular vectors
   matrixc&amp;              Z¬†                       // matrix of Ritz vectors
   vector&amp;               residuals,               // residuals for the Ritz pairs
   matrixc&amp;              B,¬†                      // computed vectors
   matrixc&amp;              V,¬†                      // eigenvectors of the matrix Raylei
   matrixc&amp;              S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrixcf::DynamicModeDecompositionQR(
   ENUM_DMD_SCALE        jobs,¬†                   // determines whether the initial da
   ENUM_DMDQ_EIGV        jobz,¬†                   // determines whether the eigenvecto
   ENUM_DMD_RESIDUALS    jobr,¬†                   // determines whether to compute the
   ENUM_DMDQ_Q           jobq,¬†                   // specifies whether to explicitly c
   ENUM_DMDQ_R           jobt,¬†                   // specifies whether to return the u
   ENUM_DMD_REFINE       jobf,¬†                   // specifies whether to store inform
   ENUM_SVD_ALG          whtsvd,¬†                 // allows for a selection of the SVD
   long                  nrnk,¬†                   // determines the mode how to comput
   float                 tol,¬†                    // the tolerance for truncating smal
   vectorcf&amp;             eigen_values,¬†           // vector of eigenvalues (Ritz value
   matrixcf&amp;             Q,                       // Q factor from the QR factorizatio</p>
<p></code></pre>
<p>
<h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1700
</p>
<pre><code class="language-mql5">
   matrixcf&amp;             R,                       // R factor from the QR factorizatio
   matrixcf&amp;             left_vectors,¬†           // matrix of left singular vectors
   matrixcf&amp;             Z¬†                       // matrix of Ritz vectors
   vectorf&amp;              residuals,               // residuals for the Ritz pairs
   matrixcf&amp;             B,¬†                      // computed vectors
   matrixcf&amp;             V,¬†                      // eigenvectors of the matrix Raylei
   matrixcf&amp;             S¬†                       // computed vectors
   );
</code></pre>
<p>
<h3>Parameters</h3>
jobs
[in]  Value from the ENUM_DMD_SCALE enumeration which determines whether the initial data
snapshots are scaled by a diagonal matrix. The data snapshots are the columns of F. The leading
N-1 columns of F are denoted X and the trailing N-1 columns are denoted Y.
jobz
[in]   Value from the ENUM_DMDQ_EIGV enumeration which determines whether the eigenvectors
(Koopman modes) will be computed.
jobr
[in]   Value from the ENUM_DMD_RESIDUALS enumeration which determines whether to compute
the residuals.
jobq
[in]   Value from the ENUM_DMDQ_Q enumeration which specifies whether to explicitly compute
and return the unitary matrix from the QR factorization of the data snapshot matrix.
jobt
[in]   Value from the ENUM_DMDQ_R enumeration which specifies whether to return the upper
triangular factor from the QR factorization of the data snapshot matrix.
jobf
[in]   Value from the ENUM_DMD_REFINE enumeration which specifies whether to store information
needed for post-processing (e.g. computing refined Ritz vectors).
whtsvd
[in]   Value from the ENUM_SVD_ALG enumeration which allows for a selection of the SVD algorithm
from the LAPACK library.
nrnk
[in]   Value determines the mode how to compute the numerical rank, i.e. how to truncate small
singular values of the input matrix X. If
</p>
<pre><code class="language-mql5">
        NRNK = -1 :: i-th singular value sigma(i) is truncated if sigma(i) &lt;= TOL*sigma(1). This
</code></pre>
<p>
option is recommended.
</p>
<pre><code class="language-mql5">
        NRNK = -2 :: i-th singular value sigma(i) is truncated if sigma(i) &lt;= TOL*sigma(i-1). This
</code></pre>
<p>
option is included for R&amp;D purposes. It requires highly accurate SVD, which may not be feasible.
</p>
<pre><code class="language-mql5">
        The numerical rank can be enforced by using positive value of NRNK as follows: 0 &lt; NRNK &lt;=
</code></pre>
<p>
N-1 :: at most NRNK largest singular values will be used. If the number of the computed nonzero</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1701
singular values is less than NRNK, then only those nonzero values will be used and the actually used
dimension is less than NRNK.
tol
[in]   The tolerance for truncating small singular values. 0 &lt;= TOL &lt; 1
eigen_values
[out] Vector of eigenvalues of size K. The leading K (K&lt;N) entries of EIGS contain the computed
eigenvalues (Ritz values).
<h3>Q</h3>
[out]  Orthogonal matrix/factor of the QR factorization of the initial data snapshots matrix F.
<h3>R</h3>
[out]  N-by-N upper triangular factor from the QR factorization of the data snapshot matrix F.
left_vectors
[out] Matrix of left singular vectors. The leading K columns of X contain the leading K left singular
vectors of the hold representations of the leading N-1 snapshots in the orthonormal basis
computed in the QR factorization of F. To lift them to the space of the left singular vectors
U(:,1:K) of the input data, pre-multiply with the Q factor from the initial QR factorization.
<h3>Z</h3>
[out] M-by-K matrix
</p>
<pre><code class="language-mql5">
       If JOBZ ==&#x27;V&#x27; then Z contains the Ritz vectors. Z(:,i) is an eigenvector of the i-th Ritz value;
</code></pre>
<p>
||Z(:,i)||_2=1.
</p>
<pre><code class="language-mql5">
      If JOBZ == &#x27;F&#x27;, then the Z(:,i)&#x27;s are given implicitly as Z*V, where Z contains orthonormal matrix
</code></pre>
<p>
(the product of Q from the initial QR factorization and the SVD/POD_basis returned by GEDMD in
X) and the second factor (the eigenvectors of the Rayleigh quotient) is in the matrix V, as returned
by GEDMD. That is,  X(:,1:K)*V(:,i) is an eigenvector corresponding to EIGS(i). The columns of
V(1:K,1:K) are the computed eigenvectors of the K-by-K Rayleigh quotient.
residuals
[out]  Residuals for the K computed Ritz pairs.
<h3>B</h3>
[out]  N-by-K matrix (K&lt;N).
</p>
<pre><code class="language-mql5">
       If JOBF ==&#x27;R&#x27;, B(1:N,1:K) contains A*U(:,1:K), and can be used for computing the refined
</code></pre>
<p>
vectors.
</p>
<pre><code class="language-mql5">
       If JOBF == &#x27;E&#x27;, B(1:N,1;K) contains A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
</code></pre>
<p>
Exact DMD, up to scaling by the inverse eigenvalues.
In both cases, the content of B can be lifted to the original dimension of the input data by pre-
multiplying with the Q factor from the initial QR factorization. Here A denotes a compression of
the underlying operator.
</p>
<pre><code class="language-mql5">
       If JOBF ==&#x27;N&#x27;, then B is not referenced.
</code></pre>
<p>
<h3>V</h3>
[out]  K-by-K matrix (K&lt;N). Contains the the K eigenvectors of the Rayleigh quotient. The Ritz
vectors (returned in Z) are the product of Q from the initial QR factorization.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1702
<h3>S</h3>
[out]  K-by-K matrix (K&lt;N). The array S(1:K,1:K) is used for the matrix Rayleigh quotient. This
content is overwritten during the eigenvalue decomposition by GEEV.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
The number of matrices rows (M) must not be less than the number of columns (N).
<h3>ENUM_DMD_SCALE</h3>
An enumeration that determines whether the initial data snapshots are scaled by a diagonal matrix.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDSCALE_S</h3>
&#x27;S&#x27;: The data snapshots matrices X and Y are multiplied with a
diagonal matrix D so that X*D has unit nonzero columns
<h3>DMDSCALE_C</h3>
&#x27;C&#x27;: The snapshots are scaled as with the &#x27;S&#x27; option.If it is found
that an i-th column of X is zero vector and the corresponding i-
th column of Y is non-zero, then the i-th column of Y is set to
zero
<h3>DMDSCALE_Y</h3>
&#x27;Y&#x27;: The data snapshots matrices X and Y are multiplied with a
diagonal matrix D so that Y*D has unit nonzero columns
<h3>DMDSCALE_N</h3>
&#x27;N&#x27;: No data scaling
<h3>ENUM_DMDQ_EIGV</h3>
An enumeration which determines whether the eigenvectors (Koopman modes) will be computed.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDQEIGV_V</h3>
&#x27;V&#x27;: The eigenvectors (Koopman modes) will be computed
<h3>DMDQEIGV_F</h3>
&#x27;F&#x27;: The eigenvectors (Koopman modes) will be returned in
factored form as the product Z*V
<h3>DMDQEIGV_Q</h3>
&#x27;Q&#x27;: The eigenvectors (Koopman modes) will be returned in
factored form as the product Q*Z
<h3>DMDQEIGV_N</h3>
&#x27;N&#x27;: The eigenvectors are not computed
<h3>ENUM_DMD_RESIDUALS</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1703
An enumeration which determines whether to compute the residuals.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDRESIDUALS_R</h3>
&#x27;R&#x27;: The residuals for the computed eigenpairs will be computed
<h3>DMDRESIDUALS_N</h3>
&#x27;N&#x27;: The residuals are not computed
<h3>ENUM_DMDQ_Q</h3>
An enumeration which specifies whether to explicitly compute and return the unitary matrix from the
QR factorization.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDQQ_Q</h3>
&#x27;Q&#x27;: The matrix Q of the QR factorization of the data snapshot
matrix is computed
<h3>DMDQQ_N</h3>
&#x27;N&#x27;: The matrix Q is not explicitly computed
<h3>ENUM_DMDQ_R</h3>
An enumeration whichspecifies whether to return the upper triangular factor from the QR
factorization.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDQR_R</h3>
&#x27;R&#x27;: The matrix R of the QR factorization of the data snapshot
matrix is computed
<h3>DMDQR_N</h3>
&#x27;N&#x27;: The matrix R is not explicitly computed
<h3>ENUM_DMD_REFINE</h3>
An enumeration which specifies whether to store information needed for post-processing.
<h3>ID</h3>
<h3>Description</h3>
<h3>DMDREFINE_R</h3>
&#x27;R&#x27;: The matrix needed for the refinement of the Ritz vectors is
computed and stored in the array B
<h3>DMDREFINE_E</h3>
&#x27;E&#x27;: The unscaled eigenvectors of the Exact DMD are computed
and returned in the array B
<h3>DMDREFINE_N</h3>
&#x27;N&#x27;: No eigenvector refinement data is computed</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1704
<h3>ENUM_SVD_ALG</h3>
An enumeration selecting the SVD algorythm.
<h3>ID</h3>
<h3>Description</h3>
<h3>SVDALG_1</h3>
1: GESVD (the QR SVD algorithm)
<h3>SVDALG_2</h3>
2: GESDD (the Divide and Conquer algorithm)
<h3>SVDALG_3</h3>
3: GESVDQ (the preconditioned QR SVD; this and 4 are the
most accurate options)
<h3>SVDALG_4</h3>
4: GEJSV (the preconditioned Jacobi SVD; this and 3 are the
most accurate options)</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1705
<h3>Singular Spectrum Analysis</h3>
The section contains functions for decomposing a matrix into three components: orthogonal matrices
and a diagonal matrix of singular values. SVD is applied to solve various linear algebra problems such
as data dimensionality reduction, image compression, solving systems of equations, as well as data
analysis and optimization. The main functions allow calculating singular values and vectors,
reconstruct matrices, as well as approximate them with reduced rank accuracy.
<h3>Function</h3>
<h3>Action</h3>
<h3>SingularSpectrumAnalysisSpectrum</h3>
<h3>A method function for calculating the</h3>
relative 
contributions 
of 
spectral
components based on their eigenvalues.
<h3>SingularSpectrumAnalysisForecast</h3>
<h3>A</h3>
method 
function 
</p>
<pre><code class="language-mql5">
for 
</code></pre>
<p>
calculating
reconstructed and predicted data using
spectral components of the input time
series.
<h3>SingularSpectrumAnalysisReconstructComponents</h3>
<h3>A</h3>
method 
function 
</p>
<pre><code class="language-mql5">
for 
</code></pre>
<p>
calculating
reconstructed components of the input
time series and their contributions.
<h3>SingularSpectrumAnalysisReconstructSeries</h3>
<h3>A method function for calculating the</h3>
reconstructed time series using the first
component_count components.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1706
<h3>SingularSpectrumAnalysisSpectrum</h3>
A method function for calculating the relative contributions of spectral components based on their
eigenvalues.
<h3>Calculations for vector&lt;double&gt; type</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisSpectrum(
   ulong   window_length,      // window size for constructing the trajectory matrix
   vector&amp; spectrum            // vector of component contributions to the input serie
   );
</code></pre>
<p>
<h3>Calculations for vector&lt;complex&gt; type</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisSpectrum(
   ulong   window_length,      // window size for constructing the trajectory matrix
   vector—Å&amp; spectrum           // vector of component contributions to the input serie
   );
</code></pre>
<p>
<h3>Parameters</h3>
window_length
[in]  Window size for constructing the trajectory matrix, the number of components the input time
series should be decomposed into.
spectrum
[out]  Vector of component contributions to the input series - eigenvalues of the covariance matrix
of the input time series.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
The window_length parameter value should be less than the size of the input time series. To
construct a full-fledged trajectory matrix, the optimal size is considered to be approximately equal
to half the size of the input time series.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1707
<h3>SingularSpectrumAnalysisForecast</h3>
A method function for calculating reconstructed and predicted data using spectral components of the
</p>
<pre><code class="language-mql5">
input time series.
</code></pre>
<p>
<h3>Calculations for vector&lt;double&gt; type</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisForecast(
   ulong    window_length,         // window size for constructing the trajectory matr
   ulong    component_count,       // number of components used for forecasting
   ulong    forecast_horizon,      // number of points to forecast
   vector&amp;  forecast               // vector consisting of reconstructed and predicted
   );
</code></pre>
<p>
<h3>Calculations for vector&lt;complex&gt; type</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisForecast(
   ulong    window_length,         // window size for constructing the trajectory matr
   ulong    component_count,       // number of components used for forecasting
   ulong    forecast_horizon,      // number of points to forecast
   vector—Å&amp; forecast               // vector consisting of reconstructed and predicted
   );
</code></pre>
<p>
<h3>Parameters</h3>
window_length
[in]  Window size for constructing the trajectory matrix, the number of components the input time
series should be decomposed into.
component_count
[in]  Number of components used for forecasting.
forecast_horizon
[in]  Number of points to forecast.
forecast
[out]  Combining points reconstructed by component_count plus forecast_horizon points predicted
using the first component_count components. Thus, the forecast vector has the size of
(T+forecast_horizon), where T is the input series length.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
The window_length parameter value should be less than the size of the input time series. To
construct a full-fledged trajectory matrix, the optimal size is considered to be approximately equal
to half the size of the input time series.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1708
<h3>SingularSpectrumAnalysisReconstructComponents</h3>
A method function for calculating reconstructed components of the input time series and their
contributions.
Calculations for vector&lt;double&gt; and matrix&lt;double&gt; types
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisReconstructComponents(
   ulong    window_length,      // window size for constructing the trajectory matrix
   matrix&amp;  components,         // matrix of reconstructed components
   vector&amp;  contributions       // vector of component contributions to the input seri
   );
</code></pre>
<p>
Calculations for vector&lt;complex&gt; and matrix&lt;complex&gt; types
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisReconstructComponents(
   ulong    window_length,      // window size for constructing the trajectory matrix
   matrixc&amp; components,         // matrix of reconstructed components
   vectorc&amp; contributions       // vector of component contributions to the input seri
   );
</code></pre>
<p>
<h3>Parameters</h3>
window_length
[in]  Window size for constructing the trajectory matrix, the number of components the input time
series should be decomposed into.
components
[out]  A matrix of reconstructed components, where each column describes a separate component.
contributions
[out]  Vector of component contributions to the input series (eigenvalues of the covariance matrix
of the input time series).
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
The window_length parameter value should be less than the size of the input time series. To
construct a full-fledged trajectory matrix, the optimal size is considered to be approximately equal
to half the size of the input time series.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1709
<h3>SingularSpectrumAnalysisReconstructSeries</h3>
A method function for calculating the reconstructed time series using the first component_count
components.
<h3>Calculations for vector&lt;double&gt; type</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisReconstructSeries(
   ulong    window_length,       // window size for constructing the trajectory matrix
   ulong    component_count,     // number of components used for reconstruction
   vector&amp;  reconstructed        // reconstructed time series
   );
</code></pre>
<p>
<h3>Calculations for vector&lt;complex&gt; type</h3>
</p>
<pre><code class="language-mql5">
bool¬† vector::SingularSpectrumAnalysisReconstructSeries(
   ulong    window_length,       // window size for constructing the trajectory matrix
   ulong    component_count,     // number of components used for reconstruction
   vector—Å&amp; reconstructed        // reconstructed time series
   );
</code></pre>
<p>
<h3>Parameters</h3>
window_length
[in]  Window size for constructing the trajectory matrix, the number of components the input time
series should be decomposed into.
component_count
[out]  Number of components used for time series reconstruction.
reconstructed
[out]  Vector containing the reconstructed output series.
<h3>Return Value</h3>
The function returns &#x27;true&#x27; on success or &#x27;false&#x27; if an error occurs.
<h3>Note</h3>
The window_length parameter value should be less than the size of the input time series. To
construct a full-fledged trajectory matrix, the optimal size is considered to be approximately equal
to half the size of the input time series.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1710
<h3>Reductions</h3>
Functions designed to transform matrices into special forms using orthogonal transformations. These
methods are widely used in numerical computations, such as spectral analysis, eigenvalue problems,
and singular value decomposition (SVD) of matrices.
These functions enable efficient matrix transformations essential for solving linear algebra problems,
including computing Singular Value Decomposition (SVD) and finding eigenvalues of symmetric
matrices. The use of LAPACK functions ensures high performance and computational accuracy.
<h3>Function</h3>
<h3>Action</h3>
<h3>ReduceToBidiagonal</h3>
Reduces a general real or complex m-by-n
matrix A to upper or lower bidiagonal form
B by an orthogonal transformation: Q**T *
A * P = B. If m &gt;= n, B is upper bidiagonal;
</p>
<pre><code class="language-mql5">
if m &lt; n, B is lower bidiagonal. Lapack
</code></pre>
<p>
function GEBRD.
<h3>ReflectBidiagonalToQP</h3>
<h3>Generates orthogonal matrices Q and P**T</h3>
(or P**H for complex types) determined by
<h3>ReduceToBidiagonal method when reducing</h3>
a real or complex matrix A to bidiagonal
form: A = Q * B * P**T.  Q and P**T are
defined 
as 
products 
of 
elementary
reflectors H(i) or G(i) respectively. Lapack
functions ORGBR, UNGBR.
<h3>ReduceSymmetricToTridiagonal</h3>
<h3>Reduces a real symmetric or complex</h3>
Hermitian matrix A to trdiagonal form B by
an orthogonal similarity transformation:
Q**T * A * Q = B. Lapack functions SYTRD,
HETRD.
<h3>ReflectTridiagonalToQ</h3>
<h3>Generates orthogonal matrix Q  which is</h3>
defined as the product of n-1 elementary
reflectors of order n, as returned by
<h3>ReduceSymmetricToTridiagonal</h3></p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1711
<h3>ReduceToBidiagonal</h3>
Reduces a general real or complex m-by-n matrix A to upper or lower bidiagonal form B by an
orthogonal transformation: Q**T * A * P = B. If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower
bidiagonal. Lapack function GEBRD.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceToBidiagonal(
   matrix&amp;         B,            // bidiagonal matrix
   matrix&amp;         reflect_qp,¬†  // q and p-reflectors
   vector&amp;         tau_q,¬†       // scalar factors of the elementary reflectors Q
   vector&amp;         tau_p ¬†       // scalar factors of the elementary reflectors P
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceToBidiagonal(
   matrixf&amp;        B,            // bidiagonal matrix
   matrixf&amp;        reflect_qp,¬†  // q and p-reflectors
   vectorf&amp;        tau_q,¬†       // scalar factors of the elementary reflectors Q
   vectorf&amp;        tau_p ¬†       // scalar factors of the elementary reflectors P
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceToBidiagonal(
   matrixc&amp;        B,            // bidiagonal matrix
   matrixc&amp;        reflect_qp,¬†  // q and p-reflectors
   vectorc&amp;        tau_q,¬†       // scalar factors of the elementary reflectors Q
   vectorc&amp;        tau_p ¬†       // scalar factors of the elementary reflectors P
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceToBidiagonal(
   matrixcf&amp;       B,            // bidiagonal matrix
   matrixcf&amp;       reflect_qp,¬†  // q and p-reflectors
   vectorcf&amp;       tau_q,¬†       // scalar factors of the elementary reflectors Q
   vectorcf&amp;       tau_p ¬†       // scalar factors of the elementary reflectors P
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[out]  Upper or lower bidiagonal matrix.
reflect_qp
[out]  Transformed matrix A. If m &gt;= n, the diagonal and the first superdiagonal are overwritten
with the upper bidiagonal matrix B; the elements below the diagonal, with the vector tau_q,
represent the orthogonal matrix Q as a product of elementary reflectors, and the elements above
the first superdiagonal, with the vector tau_p, represent the orthogonal matrix P as a product of</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1712
elementary reflectors; if m &lt; n, the diagonal and the first subdiagonal are overwritten with the
lower bidiagonal matrix B; the elements below the first subdiagonal, with the vector tau_q,
represent the orthogonal matrix Q as a product of elementary reflectors, and the elements above
the diagonal, with the vector tau_p, represent the orthogonal matrix P as a product of elementary
reflectors.
tau_q
[out] Vector of the scalar factors of the elementary reflectors which represent the orthogonal
matrix Q.
tau_p
[out] Vector of the scalar factors of the elementary reflectors which represent the orthogonal
matrix P.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
The matrices Q and P are represented as products of elementary reflectors:
<h3>If m &gt;= n,</h3>
</p>
<pre><code class="language-mql5">
     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
</code></pre>
<p>
Each H(i) and G(i) has the form:
</p>
<pre><code class="language-mql5">
     H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
</code></pre>
<p>
where tauq and taup are scalars, and v and u are vectors;
v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
tauq is stored in tau_q(i) and taup in tau_p(i).
<h3>If m &lt; n,</h3>
</p>
<pre><code class="language-mql5">
     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
</code></pre>
<p>
Each H(i) and G(i) has the form:
</p>
<pre><code class="language-mql5">
     H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
</code></pre>
<p>
where tauq and taup are scalars, and v and u are vectors;
v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
tauq is stored in tau_q(i) and taup in tau_p(i).
The contents of A on exit (output matrix reflect_qp) are illustrated by the following examples:</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1713
m = 6 and n = 5 (m &gt; n):          m = 5 and n = 6 (m &lt; n):
  (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
  (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
  (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
  (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
  (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
  (  v1  v2  v3  v4  v5 )
where d and e denote diagonal and off-diagonal elements of B, vi denotes an element of the vector
defining H(i), and ui an element of the vector defining G(i).
Matrices Q and P can be produced with ReflectBidiagonalToQP method.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1714
<h3>ReflectBidiagonalToQP</h3>
Generates orthogonal matrices Q and P**T (or P**H for complex types) determined by
ReduceToBidiagonal method when reducing a real or complex matrix A to bidiagonal form: A = Q * B *
P**T.  Q and P**T are defined as products of elementary reflectors H(i) or G(i) respectively. Lapack
functions ORGBR, UNGBR.
As input is used transformed matrix reflect_qp with the same sizes m-by-n as in original matrix A.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectBidiagonalToQP(
   vector&amp;         tau_q,¬†       // scalar factors of the elementary reflectors Q
   vector&amp;         tau_p,¬†       // scalar factors of the elementary reflectors P
   matrix&amp;         Q,            // matrix Q
   matrix&amp;         PT            // transposed matrix P
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectBidiagonalToQP(
   vectorf&amp;        tau_q,¬†       // scalar factors of the elementary reflectors Q
   vectorf&amp;        tau_p, ¬†      // scalar factors of the elementary reflectors P
   matrixf&amp;        Q,            // matrix Q
   matrixf&amp;        PT            // transposed matrix P
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectBidiagonalToQP(
   vectorc&amp;        tau_q,¬†       // scalar factors of the elementary reflectors Q
   vectorc&amp;        tau_p,¬†       // scalar factors of the elementary reflectors P
   matrixc&amp;        Q,            // matrix Q
   matrixc&amp;        PH            // hermitian conjugated matrix P
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectBidiagonalToQP(
   vectorcf&amp;       tau_q,¬†       // scalar factors of the elementary reflectors Q
   vectorcf&amp;       tau_p,¬†       // scalar factors of the elementary reflectors P
   matrixcf&amp;       Q,            // matrix Q
   matrixcf&amp;       PH            // hermitian conjugated matrix P
   );
</code></pre>
<p>
<h3>Parameters</h3>
tau_q
[in] Vector of the scalar factors of the elementary reflectors which represent the orthogonal matrix
Q.
tau_p</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1715
[in] Vector of the scalar factors of the elementary reflectors which represent the orthogonal matrix
P.
<h3>Q</h3>
[out]  Orthogonal matrix Q.
<h3>PT (PH)</h3>
[out]  Transposed (or hermitian conjugated) matrix P.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
If m &gt;= n, matrix Q is of m-by-n sizes, matrix PT is of n-by-n sizes.
If m &lt; n, matrix Q is of m-by-m sizes, matrix PT is of m-by-n sizes.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1716
<h3>ReduceSymmetricToTridiagonal</h3>
Reduces a real symmetric or complex Hermitian matrix A to trdiagonal form B by an orthogonal
similarity transformation: Q**T * A * Q = B. Lapack functions SYTRD, HETRD.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceSymmetricToTridiagonal(
   matrix&amp;         B,            // tridiagonal matrix
   matrix&amp;         reflect_q,¬†   // q-reflectors
   vector&amp;         tau_q ¬†       // scalar factors of the elementary reflectors Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceSymmetricToTridiagonal(
   matrixf&amp;        B,            // tridiagonal matrix
   matrixf&amp;        reflect_q,    // q-reflectors
   vectorf&amp;        tau_q ¬†       // scalar factors of the elementary reflectors Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceSymmetricToTridiagonal(
   matrixc&amp;        B,            // tridiagonal matrix
   matrixc&amp;        reflect_q,    // q-reflectors
   vectorc&amp;        tau_q ¬†       // scalar factors of the elementary reflectors Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReduceSymmetricToTridiagonal(
   matrixcf&amp;       B,            // tridiagonal matrix
   matrixcf&amp;       reflect_q,    // q and p-reflectors
   vectorcf&amp;       tau_q ¬†       // scalar factors of the elementary reflectors Q
   );
</code></pre>
<p>
<h3>Parameters</h3>
<h3>B</h3>
[out]  Symmetric (or Hermitian) tridiagonal matrix.
reflect_q
[out] Upper or lower triangular matrix, it depends on the input matrix A. In upper case the
diagonal and first superdiagonal of A are overwritten by the corresponding elements of the
tridiagonal matrix B, and the elements above the first superdiagonal, with the array tau_q,
represent the orthogonal matrix Q as a product of elementary reflectors; in lower case the diagonal
and first subdiagonal of A are overwritten by the corresponding elements of the tridiagonal matrix
B, and the elements below the first subdiagonal, with the array tau_q, represent the orthogonal
matrix Q as a product of elementary reflectors.
tau_q</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1717
[out] Vector of the scalar factors of the elementary reflectors which represent the orthogonal
matrix Q.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.
<h3>Note</h3>
In upper case the matrix Q is represented as a product of elementary reflectors
</p>
<pre><code class="language-mql5">
     Q = H(n-1) . . . H(2) H(1)
</code></pre>
<p>
<h3>Each H(i) has the form</h3>
</p>
<pre><code class="language-mql5">
     H(i) = I - tau * v * v**T 
</code></pre>
<p>
where tau is a scalar, and v is a vector with v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
A(1:i-1,i+1), and tau in tau_q(i).
In lower case the matrix Q is represented as a product of elementary reflectors
</p>
<pre><code class="language-mql5">
     Q = H(1) H(2) . . . H(n-1)
</code></pre>
<p>
<h3>Each H(i) has the form</h3>
</p>
<pre><code class="language-mql5">
     H(i) = I - tau * v * v**T
</code></pre>
<p>
where tau is a scalar, and v is a vector with v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in
<h3>A(i+2:n,i), and tau in tau_q(i). */</h3>
The contents of A on exit (output matrix reflect_q) are illustrated by the following examples with
n = 5:
  upper case:                          lower case:
  (  d   e   v2  v3  v4 )              (  d                  )
  (      d   e   v3  v4 )              (  e   d              )
  (          d   e   v4 )              (  v1  e   d          )
  (              d   e  )              (  v1  v2  e   d      )
  (                  d  )              (  v1  v2  v3  e   d  )
where d and e denote diagonal and off-diagonal elements of B and vi denotes an element of the
vector defining H(i).
Matrix Q can be produced with ReflectTridiagonalToQ method.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1718
<h3>ReflectTridiagonalToQ</h3>
Generates orthogonal matrix Q  which is defined as the product of n-1 elementary reflectors of order
n, as returned by ReduceSymmetricToTridiagonal:
in upper case Q = H(n-1) . . . H(2) H(1),
in lower case Q = H(1) H(2) . . . H(n-1).
Lapack functions ORGTR, UNGTR.
As input is used transformed matrix reflect_q with the same sizes n-by-n as in original matrix A.
<h3>Computing for type matrix&lt;double&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectTridiagonalToQ(
   vector&amp;         tau_q,¬†       // scalar factors of the elementary reflectors Q
   matrix&amp;         Q             // matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;float&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectTridiagonalToQ(
   vectorf&amp;        tau_q,¬†       // scalar factors of the elementary reflectors Q
   matrixf&amp;        Q             // matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complex&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectTridiagonalToQ(
   vectorc&amp;        tau_q,¬†       // scalar factors of the elementary reflectors Q
   matrixc&amp;        Q             // matrix Q
   );
</code></pre>
<p>
<h3>Computing for type matrix&lt;complexf&gt;</h3>
</p>
<pre><code class="language-mql5">
bool¬† matrix::ReflectTridiagonalToQ(
   vectorcf&amp;       tau_q,¬†       // scalar factors of the elementary reflectors Q
   matrixcf&amp;       Q             // matrix Q
   );
</code></pre>
<p>
<h3>Parameters</h3>
tau_q
[in] Vector of the scalar factors of the elementary reflectors which represent the orthogonal matrix
Q.
<h3>Q</h3>
[out]  Orthogonal matrix Q.
<h3>Return Value</h3>
Return true if successful, otherwise false in case of an error.</p>
<p><h3>M√©todos matriciais e vetoriais</h3>
¬© 2000-2025, MetaQuotes Ltd.
1719
</p>
        </article>
        
        <footer>
            <p>Documenta√ß√£o MQL5 - Fonte: MetaQuotes Ltd.</p>
        </footer>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function toggleSidebar() {
            document.querySelector('.sidebar').classList.toggle('open');
        }
        
        function filterNav() {
            const filter = document.getElementById('search').value.toLowerCase();
            const items = document.querySelectorAll('.nav-list li');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }
    </script>
</body>
</html>