<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manipula√ß√£o de eventos - MQL5 Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>MQL5 Docs</h1>
            <p>Documenta√ß√£o Completa</p>
        </div>
        <div class="search-box">
            <input type="text" id="search" placeholder="Buscar..." onkeyup="filterNav()">
        </div>
        <ul class="nav-list" id="nav-list">
            <li class=""><a href="index.html">üìö √çndice</a></li>
            <li class=""><a href="introducao.html">Introducao</a></li>
<li class=""><a href="refer√™ncia_mql5.html">Refer√™ncia MQL5</a></li>
<li class=""><a href="elementos_b√°sicos_da_linguagem.html">Elementos B√°sicos da Linguagem</a></li>
<li class=""><a href="constantes,_enumeradores_e_estruturas.html">Constantes, Enumeradores e Estruturas</a></li>
<li class=""><a href="programas_mql5.html">Programas MQL5</a></li>
<li class=""><a href="vari√°veis_predefinidas.html">Vari√°veis Predefinidas</a></li>
<li class=""><a href="fun√ß√µes_comuns.html">Fun√ß√µes Comuns</a></li>
<li class=""><a href="fun√ß√µes_para_array.html">Fun√ß√µes para Array</a></li>
<li class=""><a href="m√©todos_matriciais_e_vetoriais.html">M√©todos matriciais e vetoriais</a></li>
<li class=""><a href="fun√ß√µes_de_convers√£o.html">Fun√ß√µes de Convers√£o</a></li>
<li class=""><a href="fun√ß√µes_matem√°ticas.html">Fun√ß√µes Matem√°ticas</a></li>
<li class=""><a href="fun√ß√µes_de_string.html">Fun√ß√µes de String</a></li>
<li class=""><a href="data_e_hora.html">Data e Hora</a></li>
<li class=""><a href="informa√ß√µes_de_conta.html">Informa√ß√µes de Conta</a></li>
<li class=""><a href="verificando_estado.html">Verificando Estado</a></li>
<li class="active"><a href="manipula√ß√£o_de_eventos.html">Manipula√ß√£o de eventos</a></li>
<li class=""><a href="informa√ß√µes_de_mercado.html">Informa√ß√µes de Mercado</a></li>
<li class=""><a href="calend√°rio_econ√¥mico.html">Calend√°rio econ√¥mico</a></li>
<li class=""><a href="s√©ries_temporais_e_acesso_a_indicadores.html">S√©ries Temporais e Acesso a Indicadores</a></li>
<li class=""><a href="s√≠mbolos_personalizados.html">S√≠mbolos personalizados</a></li>
<li class=""><a href="opera√ß√µes_de_gr√°ficos.html">Opera√ß√µes de Gr√°ficos</a></li>
<li class=""><a href="fun√ß√µes_de_negocia√ß√£o.html">Fun√ß√µes de Negocia√ß√£o</a></li>
<li class=""><a href="gerenciamento_de_sinais.html">Gerenciamento de sinais</a></li>
<li class=""><a href="fun√ß√µes_de_rede.html">Fun√ß√µes de rede</a></li>
<li class=""><a href="vari√°veis_globais_do_terminal.html">Vari√°veis Globais do Terminal</a></li>
<li class=""><a href="fun√ß√µes_de_arquivo.html">Fun√ß√µes de Arquivo</a></li>
<li class=""><a href="indicadores_customizados.html">Indicadores Customizados</a></li>
<li class=""><a href="fun√ß√µes_de_objeto.html">Fun√ß√µes de Objeto</a></li>
<li class=""><a href="indicadores_t√©cnicos.html">Indicadores T√©cnicos</a></li>
<li class=""><a href="trabalhando_com_resultados_de_otimiza√ß√£o.html">Trabalhando com Resultados de Otimiza√ß√£o</a></li>
<li class=""><a href="trabalhando_com_eventos.html">Trabalhando com Eventos</a></li>
<li class=""><a href="trabalhando_com_opencl.html">Trabalhando com OpenCL</a></li>
<li class=""><a href="trabalhar_com_bancos_de_dados.html">Trabalhar com bancos de dados</a></li>
<li class=""><a href="trabalho_com_directx.html">Trabalho com DirectX</a></li>
<li class=""><a href="metatrader_para_python.html">MetaTrader para Python</a></li>
<li class=""><a href="modelos_onnx.html">Modelos ONNX</a></li>
<li class=""><a href="biblioteca_padr√£o.html">Biblioteca Padr√£o</a></li>
<li class=""><a href="migrando_do_mql4.html">Migrando do MQL4</a></li>
<li class=""><a href="lista_de_fun√ß√µes_mql5.html">Lista de Fun√ß√µes MQL5</a></li>
<li class=""><a href="lista_de_constantes_mql5.html">Lista de Constantes MQL5</a></li>

        </ul>
    </nav>
    
    <main class="content">
        <header>
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1>Manipula√ß√£o de eventos</h1>
        </header>
        
        <article>
            <p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1916
<h3>Manipula√ß√£o de eventos</h3>
A linguagem MQL5 providencia o processamento de eventos predefinidos. As fun√ß√µes para processar
esses eventos devem ser definidas no programa MQL5: o nome da fun√ß√£o, o tipo de retorno, a
composi√ß√£o dos par√¢metros (se houver) e seus tipos devem corresponder estritamente √† descri√ß√£o da
fun√ß√£o do manipulador de eventos.
√â pelo tipo do valor de retorno e pelos tipos de par√¢metros que o manipulador de eventos do terminal
do cliente identifica as fun√ß√µes que manipulam eventos. Se, para a respectiva fun√ß√£o, forem definidos
outros par√¢metros que n√£o correspondem √†s seguintes descri√ß√µes, ou se for especificado um tipo de
retorno diferente, essa fun√ß√£o n√£o ser√° usada para processar o evento.
<h3>Fun√ß√£o</h3>
<h3>Descri√ß√£o</h3>
<h3>OnStart</h3>
√â chamada no script quando ocorre um evento Start para executar
a√ß√µes definidas no script
<h3>OnInit</h3>
√â chamada em indicadores e EAs quando ocorre um evento Init para
inicializar um programa MQL5 em execu√ß√£o
<h3>OnDeinit</h3>
√â chamada em indicadores e EAs quando ocorre um evento Deinit
para desinicializar um programa MQL5 em execu√ß√£o
<h3>OnTick</h3>
√â chamada em EAs quando ocorre um evento NewTick para
processar uma nova cota√ß√£o
<h3>OnCalculate</h3>
√â chamada em indicadores quando ocorre um evento Calculate para
processar altera√ß√µes de dados de pre√ßo
<h3>OnTimer</h3>
√â chamada em indicadores e EAs no in√≠cio de um evento peri√≥dico
Timer que √© gerado pelo terminal com o intervalo de tempo
definido
<h3>OnTrade</h3>
√â chamada em EAs quando ocorre um evento Trade que √© gerado no
final da negocia√ß√£o no servidor de negocia√ß√£o
<h3>OnTradeTransaction</h3>
√â chamada em EAs quando ocorre um evento TradeTransaction
para processar os resultados de uma solicita√ß√£o de negocia√ß√£o
<h3>OnBookEvent</h3>
√â chamada em EAs quando ocorre um evento BookEvent para
processar altera√ß√µes no livro de ofertas
<h3>OnChartEvent</h3>
√â chamada em indicadores e Eas quando ocorre um evento
ChartEvent para processar mudan√ßas no gr√°fico causadas por a√ß√µes
do usu√°rio ou pelo funcionamento de programas MQL5
<h3>OnTester</h3>
√â chamada em EAs quando ocorre um evento Tester para executar
as a√ß√µes necess√°rias no final do teste
<h3>OnTesterInit</h3>
√â chamada em EAs quando ocorre um evento TesterInit para
executar as a√ß√µes necess√°rias antes do in√≠cio da otimiza√ß√£o
<h3>OnTesterDeinit</h3>
√â chamada em EAs quando ocorre um evento TesterDeinit para
realizar as a√ß√µes necess√°rias ap√≥s a otimiza√ß√£o do EA</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1917
<h3>Fun√ß√£o</h3>
<h3>Descri√ß√£o</h3>
<h3>OnTesterPass</h3>
√â chamada em EAs quando ocorre um evento TesterPass para
processar a chegada de um novo quadro de dados durante a
otimiza√ß√£o do EA
O terminal do cliente envia os novos eventos para os respectivos gr√°ficos abertos. Al√©m disso, os
eventos podem ser gerados por gr√°ficos (evento de gr√°fico) ou por programas MQL5 (eventos
personalizados). A gera√ß√£o de eventos para criar e excluir objetos gr√°ficos no gr√°fico pode ser ativada
e 
desativada 
definindo 
as 
propriedades 
do 
gr√°fico 
<h3>CHART_EVENT_OBJECT_CREATE</h3>
e
CHART_EVENT_OBJECT_DELETE. Cada programa MQL5 e cada gr√°fico tem sua pr√≥pria fila de eventos,
√† qual s√£o adicionados todos os eventos rec√©m-chegados.
O programa recebe eventos apenas do gr√°fico em que est√° sendo executado. Todos os eventos s√£o
processados um ap√≥s o outro na ordem em que s√£o recebidos. Se na fila j√° houver um evento NewTick
ou este evento estiver no estado de processamento, o novo evento NewTick n√£o ser√° colocado na fila
do programa MQL5. Da mesma forma, se na fila do programa MQL5 j√° estiver o evento ChartEvent ou
tal evento estiver sendo processado, n√£o ser√° enfileirado um novo evento desse tipo. Os eventos do
temporizador s√£o processados da mesma maneira, isto √©, se um evento estiver na fila ou o evento
Timer j√° estiver sendo processado, n√£o ser√° enfileirado um novo evento do temporizador.
Filas de eventos s√£o de tamanho limitado, mas suficiente, portanto, para um programa escrito
corretamente, o estouro da fila √© improv√°vel. Quando a fila estourar, novos eventos s√£o descartados
sem serem enfileirados.
Evite usar loops infinitos para manipular eventos. Uma exce√ß√£o a essa regra podem ser apenas os
scripts que lidam com o evento √∫nico Start.
As bibliotecas n√£o processam nenhum evento.</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1918
<h3>OnStart</h3>
√â chamado em scripts e servi√ßos quando ocorre um evento Start. A fun√ß√£o se destina √† execu√ß√£o √∫nica
de a√ß√µes estabelecidas pelo programa. Existem duas vers√µes da fun√ß√£o.
<h3>Vers√£o com retorno de resultado</h3>
</p>
<pre><code class="language-mql5">
int¬† OnStart(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
Valor de tipo int que √© exibido na guia &quot;Di√°rio&quot;.
Ap√≥s o script ser conclu√≠do, no log do terminal ser√° criada uma entrada de tipo &quot;script
nome_do_script removed (result code N)&quot;, onde N √© o valor retornado pela fun√ß√£o OnStart().
Ap√≥s o servi√ßo ser conclu√≠do, no log do terminal ser√° criada uma entrada de tipo &quot;service
–∏–º—è_—Å–µ—Ä–≤–∏—Å–∞ stopped (result code N)&quot;, onde N √© o valor retornado pela fun√ß√£o OnStart().
O uso da chamada da OnStart() com o retorno de resultado √© prioridade, pois este m√©todo permite n√£o
apenas iniciar o script, mas tamb√©m retornar um c√≥digo de erro ou outras informa√ß√µes √∫teis para
analisar o resultado da execu√ß√£o do script.
Vers√£o sem retorno do resultado √© deixada apenas para compatibilidade com c√≥digos antigos. N√£o √©
recomendada
</p>
<pre><code class="language-mql5">
void¬† OnStart(void);
</code></pre>
<p>
<h3>Observa√ß√£o</h3>
OnStart() √© a √∫nica fun√ß√£o para manipular eventos em scripts e servi√ßos, outros eventos n√£o s√£o
enviados para esses programas. Por sua vez, o evento Start n√£o √© enviado para EAs e indicadores
personalizados.
<h3>Exemplo de script:</h3>
</p>
<pre><code class="language-mql5">
//--- macros para trabalhar com cores
#define XRGB(r,g,b)    (0xFF000000|(uchar(r)&lt;&lt;16)|(uchar(g)&lt;&lt;8)|uchar(b))
#define GETRGB(clr)    ((clr)&amp;0xFFFFFF)
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- definimos a cor a vela de baixa
   Comment(&quot;Definimos a cor da vela de baixa&quot;); 
   ChartSetInteger(0,CHART_COLOR_CANDLE_BEAR,GetRandomColor());
   ChartRedraw(); // atualizamos imediatamente o gr√°fico sem esperar por um novo tick
   Sleep(1000);   // fazemos uma pausa de 1 segundo, para poder ver as altera√ß√µes
//--- definimos a cor da vela de alta
   Comment(&quot;Definimos a cor da vela de alta&quot;); 
   ChartSetInteger(0,CHART_COLOR_CANDLE_BULL,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   </p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1919
</p>
<pre><code class="language-mql5">
//--- definimos a cor de fundo
   Comment(&quot;Definimos a cor de fundo&quot;); 
   ChartSetInteger(0,CHART_COLOR_BACKGROUND,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor da linha Ask
   Comment(&quot;Definimos a cor da linha Ask&quot;); 
   ChartSetInteger(0,CHART_COLOR_ASK,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor da linha Bid
   Comment(&quot;Definimos a cor da linha Bid&quot;); 
   ChartSetInteger(0,CHART_COLOR_BID,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);    
//--- definimos a cor da barra baixista e as bordas da vela baixista
   Comment(&quot;Definimos a cor da barra baixista e as bordas da vela baixista&quot;); 
   ChartSetInteger(0,CHART_COLOR_CHART_DOWN,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor da linha do gr√°fico e das velas do tipo &quot;Doji&quot;
   Comment(&quot;Definimos a cor da linha do gr√°fico e das velas do tipo Doji&quot;); 
   ChartSetInteger(0,CHART_COLOR_CHART_LINE,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor da barra altista e a borda da vela altista  
   Comment(&quot;Definimos a cor da barra altista e a borda da vela altista&quot;); 
   ChartSetInteger(0,CHART_COLOR_CHART_UP,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor dos eixos, da escala e da linha OHLC
   Comment(&quot;Definimos a cor dos eixos, da escala e da linha OHLC&quot;); 
   ChartSetInteger(0,CHART_COLOR_FOREGROUND,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor da grade
   Comment(&quot;Definimos a cor da grade&quot;); 
   ChartSetInteger(0,CHART_COLOR_GRID,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor do pre√ßo Last
   Comment(&quot;Definimos a cor do pre√ßo Last&quot;); 
   ChartSetInteger(0,CHART_COLOR_LAST,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- definimos a cor dos n√≠veis das ordens Stop Loss e Take Profit
   Comment(&quot;Definimos a cor dos n√≠veis das ordens Stop Loss e Take Profit&quot;); 
   ChartSetInteger(0,CHART_COLOR_STOP_LEVEL,GetRandomColor());
   ChartRedraw(); </p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1920
</p>
<pre><code class="language-mql5">
   Sleep(1000);   
//--- definimos a cor dos volumes e dos n√≠veis de abertura das posi√ß√µes
   Comment(&quot;Definimos a cor dos volumes e dos n√≠veis de abertura das posi√ß√µes&quot;); 
   ChartSetInteger(0,CHART_COLOR_VOLUME,GetRandomColor());
   ChartRedraw();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna uma cor gerada aleatoriamente                            |
//+------------------------------------------------------------------+
</code></pre>
<p>
color GetRandomColor()
</p>
<pre><code class="language-mql5">
  {
   color clr=(color)GETRGB(XRGB(rand()%255,rand()%255,rand()%255));
   return clr;
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
Fun√ß√µes de processamento de eventos, Execu√ß√£o de programas, Eventos do terminal do cliente</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1921
<h3>OnInit</h3>
√â chamada em indicadores e EAs quando ocorre o evento Init. A fun√ß√£o √© projetada para inicializa√ß√£o
de um programa MQL5 em execu√ß√£o. Existem duas vers√µes da fun√ß√£o.
<h3>Vers√£o com retorno de resultado</h3>
</p>
<pre><code class="language-mql5">
int¬† OnInit(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
Valor de tipo int, zero significa inicializa√ß√£o bem-sucedida.
Ao retornar o valor INIT_FAILED o Expert Advisor ser√° retirado √† for√ßa do gr√°fico. 
Ao retornar o valor INIT_FAILED o indicador n√£o ser√° removido do gr√°fico. Nesse caso, o indicador
restante no gr√°fico estar√° inoperante ‚Äî os manipuladores de eventos n√£o s√£o chamados no
indicador. 
O uso da chamada da OnInit() com o retorno de resultado √© prioridade, pois este m√©todo permite n√£o
apenas inicializar o programa, mas tamb√©m retornar o c√≥digo de erro em caso de t√©rmino antecipado
do programa.
Vers√£o sem retorno do resultado √© deixada apenas para compatibilidade com c√≥digos antigos. N√£o √©
recomendada
</p>
<pre><code class="language-mql5">
void  OnInit(void);
</code></pre>
<p>
<h3>Observa√ß√£o</h3>
O evento Init √© gerado imediatamente ap√≥s o especialista ou indicador ser carregado, este evento
n√£o √© gerado para scripts. A fun√ß√£o OnInit() √© usada para inicializa√ß√£o do programa MQL5. Se a
OnInit() tiver um valor retornado do tipo int, um c√≥digo de retorno diferente de zero significa uma
inicializa√ß√£o mal-sucedida e gera o evento Deinit com c√≥digo de motivo de desinicializa√ß√£o
REASON_INITFAILED.
A fun√ß√£o OnInit() do tipo void sempre significa uma inicializa√ß√£o bem-sucedida e n√£o √©
recomendada.
Ao otimizar os par√¢metros de entrada do EA, recomenda-se usar como c√≥digo de retorno os valores
da enumera√ß√£o ENUM_INIT_RETCODE. Estes valores se destinam a organizar o gerenciamento do
progresso da otimiza√ß√£o e, inclusive, a selecionar os mais adequados agentes de teste. Na
inicializa√ß√£o do EA, mesmo antes de executar o teste, voc√™ pode solicitar informa√ß√µes sobre a
configura√ß√£o e sobre os recursos do agente (o n√∫mero de n√∫cleos, a quantidade de mem√≥ria livre,
etc.) usando a fun√ß√£o TerminalInfoInteger(). Com base nas informa√ß√µes recebidas, voc√™ pode
permitir que esse agente de teste seja usado ou n√£o ao ser otimizado.
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>INIT_SUCCEEDED</h3>
Inicializa√ß√£o bem-sucedida, o teste do EA pode continuar.
Esse c√≥digo significa o mesmo que o valor zero ‚Äì inicializa√ß√£o
do EA no testador bem-sucedida.
<h3>INIT_FAILED</h3>
Inicializa√ß√£o mal-sucedida, n√£o faz sentido continuar o teste
devido a erros irrecuper√°veis. Por exemplo, n√£o foi poss√≠vel</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1922
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
criar o indicador necess√°rio para o trabalho do EA.
O retorno deste valor significa o mesmo que o retorno,
retrocesso de um valor diferente de zero ‚Äì inicializa√ß√£o do EA
no testador mal-sucedida.
<h3>INIT_PARAMETERS_INCORRECT</h3>
Projetado para denotar um conjunto incorreto de par√¢metros de
entrada, na tabela de otimiza√ß√£o geral, a sequ√™ncia de
resultados com esse c√≥digo de retorno ser√° destacada em
vermelho.
O teste para este conjunto de par√¢metros do EA n√£o ser√°
executado, o agente estar√° livre para receber um novo
trabalho.
Quando esse valor √© recebido, o testador de estrat√©gia tem a
garantia de n√£o transferir essa tarefa para outros agentes para
reexecu√ß√£o.
<h3>INIT_AGENT_NOT_SUITABLE</h3>
N√£o h√° erros no programa durante a inicializa√ß√£o, mas por
algum motivo este agente n√£o √© adequado para testes. Por
exemplo, n√£o h√° RAM suficiente, sem suporte de OpenCL e
assim por diante. 
Ap√≥s retornar este c√≥digo, o agente n√£o receber√° mais tarefas
at√© o final desta otimiza√ß√£o.
O uso da OnInit() com retorno de INIT_FAILED/INIT_PARAMETERS_INCORRECT no testador tem
v√°rias caracter√≠sticas que devem ser consideradas ao otimizar EAs:
¬∑ o conjunto de par√¢metros para o qual a OnInit() retornou INIT_PARAMETERS_INCORRECT √©
considerado inadequado para testes e n√£o ser√° usado para obter a pr√≥xima popula√ß√£o
duranteotimiza√ß√µes gen√©ticas. O fato de haver muitos conjuntos de par√¢metros rejeitados pode
levar a resultados de pesquisa incorretos de par√¢metros ideais de EAs. O algoritmo de busca
pressup√µe que a fun√ß√£o de crit√©rio de otimiza√ß√£o √© suave e n√£o tem descontinuidades em todo o
conjunto de par√¢metros de entrada.
¬∑ se a OnInit() retornar INIT_FAILED, o teste n√£o poder√° ser iniciado e o EA ser√° descarregado da
mem√≥ria do agente. Para executar a pr√≥xima passagem, o novo EA ser√° carregado com o novo
conjunto de par√¢metros. Isso faz com que inciar o teste da pr√≥xima passagem de otimiza√ß√£o leve
mais tempo do que se fosse chamada a TesterStop().
Exemplo da fun√ß√£o OnInit() para um EA
</p>
<pre><code class="language-mql5">
//--- input parameters
input int      ma_period=20; // per√≠odo de m√©dia m√≥vel
//--- identificador do indicador usado no Expert Advisor
int indicator_handle;   
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- verificamos se o valor ma_period √© correto</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1923
</p>
<pre><code class="language-mql5">
   if(ma_period&lt;=0)
     {
      PrintFormat(&quot;Valor inv√°lido do par√¢metro de entrada ma_period: %d&quot;,ma_period);
      return (INIT_PARAMETERS_INCORRECT);
     }
//--- ao otimizar
   if(MQLInfoInteger(MQL_OPTIMIZATION))
     {
      //--- verificamos a quantidade de RAM dispon√≠vel para o agente
      int available_memory_mb=TerminalInfoInteger(TERMINAL_MEMORY_TOTAL);
      if(available_memory_mb&lt;2000)
        {
         PrintFormat(&quot;Mem√≥ria insuficiente para o agente de teste: %d MB&quot;,
                     available_memory_mb);
         return (INIT_AGENT_NOT_SUITABLE);
        }
     }
//--- verificamos se existe indicador
   indicator_handle=iCustom(_Symbol,_Period,&quot;My_Indicator&quot;,ma_period);
   if(indicator_handle==INVALID_HANDLE)
     {
      PrintFormat(&quot;N√£o foi poss√≠vel criar o indicador My_Indicator. C√≥digo de erro %d&quot;
                  GetLastError());
      return (INIT_FAILED);
     }
//--- inicializa√ß√£o do EA bem-sucedida
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
OnDeinit, TesterHideIndicators, Fun√ß√µes de processamento de eventos, Execu√ß√£o de programas,
Evento do terminal do cliente, Inicializa√ß√£o de vari√°veis, Criando e destruindo objetos</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1924
<h3>OnDeinit</h3>
√â chamada em indicadores e EAs quando ocorre o evento Deinit. A fun√ß√£o √© projetada para
desinicializa√ß√£o de um programa MQL5 em execu√ß√£o.
</p>
<pre><code class="language-mql5">
void  OnDeinit(
   const int¬† reason¬†        // c√≥digo de motivo da desinicializa√ß√£o
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
reason
[in]  C√≥digo de motivo da desinicializa√ß√£o.
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
O evento Deinit √© gerado para EAs e para indicadores nos seguintes casos:
¬∑ antes de uma reinicializa√ß√£o devida √† mudan√ßa do s√≠mbolo ou do per√≠odo do gr√°fico ao qual o
programa MQL5 est√° associado;
¬∑ antes de uma reinicializa√ß√£o devida √† mudan√ßa dos par√¢metros de entrada;
¬∑ antes de descarregar o programa MQL%.
O par√¢metro reason pode pegar os seguintes valores:
<h3>Constante</h3>
<h3>Valor</h3>
<h3>Descri√ß√£o</h3>
<h3>REASON_PROGRAM</h3>
0
O Expert Advisor parou seu trabalho chamando a
fun√ß√£o ExpertRemove()
<h3>REASON_REMOVE</h3>
1
<h3>Programa exclu√≠do do gr√°fico</h3>
<h3>REASON_RECOMPILE</h3>
2
<h3>Programa recompilado</h3>
<h3>REASON_CHARTCHANGE</h3>
3
<h3>S√≠mbolo ou per√≠odo alterado</h3>
<h3>REASON_CHARTCLOSE</h3>
4
<h3>Gr√°fico fechado</h3>
<h3>REASON_PARAMETERS</h3>
5
<h3>Par√¢metros de entrada alterados pelo usu√°rio</h3>
<h3>REASON_ACCOUNT</h3>
6
Outra conta ativada ou reconectada ao servidor de
negocia√ß√£o como resultado da 
altera√ß√£o 
das
configura√ß√µes da conta
<h3>REASON_TEMPLATE</h3>
7
<h3>Outro modelo de gr√°fico implementado</h3>
<h3>REASON_INITFAILED</h3>
8
Manipulador de OnInit() retornou um valor diferente
de zero
<h3>REASON_CLOSE</h3>
9
<h3>Terminal fechado</h3>
C√≥digos de motivo de desinicializa√ß√£o do EA podem ser obtidos pela fun√ß√£o UninitializeReason() ou a
partir da vari√°vel predefinida _UninitReason.</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1925
Exemplo da fun√ß√µes OnInit() e OnDeinit() para o EA
</p>
<pre><code class="language-mql5">
input int fake_parameter=3;      // par√¢metro in√∫til
//+----------¬¥--------------------------------------------------------+
//| Expert initialization function                                    |
//+----------¬¥--------------------------------------------------------+
int OnInit()
  {
//--- Obtemos o n√∫mero da compila√ß√£o do programa
   Print(__FUNCTION__,&quot; Build #&quot;,__MQLBUILD__);
//--- C√≥digo de motivo de reinicializa√ß√£o pode ser obtido na OnInit()
   Print(__FUNCTION__,&quot; Ao reinicializar o EA, voc√™ pode obter o c√≥digo de motivo da d
//--- Primeira maneira de obter o c√≥digo de motivo de desinicializa√ß√£o
   Print(__FUNCTION__,&quot; _UninitReason = &quot;,getUninitReasonText(_UninitReason));
//--- Segunda maneira de obter o c√≥digo de motivo de desinicializa√ß√£o  
   Print(__FUNCTION__,&quot; UninitializeReason() = &quot;,getUninitReasonText(UninitializeReaso
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+----------¬¥--------------------------------------------------------+
//| Expert deinitialization function                                  |
//+----------¬¥--------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- Primeira maneira de obter o c√≥digo de motivo de desinicializa√ß√£o
   Print(__FUNCTION__,&quot; C√≥digo de motivo da desinicializa√ß√£o = &quot;,reason);
//--- Segunda maneira de obter o c√≥digo de motivo de desinicializa√ß√£o
   Print(__FUNCTION__,&quot; _UninitReason = &quot;,getUninitReasonText(_UninitReason));
//--- Terceira maneira de obter o c√≥digo de motivo de desinicializa√ß√£o  
   Print(__FUNCTION__,&quot; UninitializeReason() = &quot;,getUninitReasonText(UninitializeReaso
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna a descri√ß√£o do motivo da desinicializa√ß√£o                |
//+------------------------------------------------------------------+
string getUninitReasonText(int reasonCode)
  {
   string text=&quot;&quot;;
//---
   switch(reasonCode)
     {
      case REASON_ACCOUNT:
         text=&quot;Account was changed&quot;;break;
      case REASON_CHARTCHANGE:
         text=&quot;Symbol or timeframe was changed&quot;;break;
      case REASON_CHARTCLOSE:
         text=&quot;Chart was closed&quot;;break;
      case REASON_PARAMETERS:
         text=&quot;Input-parameter was changed&quot;;break;
      case REASON_RECOMPILE:</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1926
</p>
<pre><code class="language-mql5">
         text=&quot;Program &quot;+__FILE__+&quot; was recompiled&quot;;break;
      case REASON_REMOVE:
         text=&quot;Program &quot;+__FILE__+&quot; was removed from chart&quot;;break;
      case REASON_TEMPLATE:
         text=&quot;New template was applied to chart&quot;;break;
      default:text=&quot;Another reason&quot;;
     }
//---
   return text;
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
OnInit, Fun√ß√µes de processamento de eventos, Execu√ß√£o de programas, Eventos do terminal do
cliente, Motivos de desinicializa√ß√£o, Escopo de visibilidade e tempo de vida das vari√°veis, Criando e
destruindo objetos</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1927
<h3>OnTick</h3>
√â chamada em EAs quando ocorre o evento NewTick para processar uma nova cota√ß√£o.
</p>
<pre><code class="language-mql5">
void¬† OnTick(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
O evento NewTick √© gerado apenas para EAs ap√≥s a chegada de um novo tick do s√≠mbolo cujo EA √©
anexado ao gr√°fico. √â in√∫til definir a fun√ß√£o OnTick() no indicador personalizado ou no script, pois o
evento NewTick n√£o √© gerado para eles. 
O evento Tick √© gerado apenas para EAs, mas isso n√£o significa que os EAs precisam ter a fun√ß√£o
OnTick(), porque n√£o apenas os eventos NewTick s√£o gerados para EAs, mas tamb√©m os eventos
Timer, BookEvent e ChartEvent.
Todos os eventos s√£o processados um ap√≥s o outro na ordem em que s√£o recebidos. Se na fila j√°
houver um evento NewTick ou este evento estiver no estado de processamento, o novo evento
NewTick n√£o ser√° colocado na fila do programa MQL5.
O evento NewTick √© gerado independentemente de se a negocia√ß√£o autom√°tica est√° habilitada ou
desabilitada (o bot√£o &quot;Negocia√ß√£o autom√°tica&quot;). Ao desabilitar a negocia√ß√£o autom√°tica, ser√°
apenas desativado o envio de solicita√ß√µes de negocia√ß√£o a partir do EA, ao mesmo tempo, o EA
continua trabalhando.
Ao desativar a negocia√ß√£o autom√°tica clicando no bot√£o &quot;Negocia√ß√£o autom√°tica&quot;, n√£o se
interrompe a execu√ß√£o atual da fun√ß√£o OnTick().
Exemplo de EA em que toda a l√≥gica de negocia√ß√£o √© colocada na fun√ß√£o OnTick()
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                   TradeByATR.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo de EA que opera segundo a dire√ß√£o da vela \&quot;detonante\&quot;
#property description &quot;O corpo da vela \&quot;detonante\&quot; tem um tamanho maior que k*ATR&quot;
#property description &quot;O par√¢metro \&quot;revers\&quot; inverte a dire√ß√£o do sinal&quot;
input double lots=0.1;        // volume em lotes
input double kATR=3;          // tamanho da vela de sinal no ATR
input int    ATRperiod=20;    // per√≠odo do indicador ATR
input int    holdbars=8;      // n√∫mero de barras para manter a posi√ß√£o
input int    slippage=10;     // derrapagem admiss√≠vel
input bool   revers=false;    // invertemos o sinal? 
input ulong  EXPERT_MAGIC=0;  // MagicNumber do EA</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1928
</p>
<pre><code class="language-mql5">
//--- para armazenar o identificador do indicador ATR
int atr_handle;
//--- aqui vamos armazenar os √∫ltimos valores do ATR e o corpo da vela
double last_atr,last_body;
</code></pre>
<p>
datetime lastbar_timeopen;
</p>
<pre><code class="language-mql5">
double trade_lot;
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- inicializamos as vari√°veis globais
   last_atr=0;
   last_body=0;
//--- definimos o volume correto
   double min_lot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   trade_lot=lots&gt;min_lot? lots:min_lot;   
//--- criamos o identificador do indicador ATR
   atr_handle=iATR(_Symbol,_Period,ATRperiod);
   if(atr_handle==INVALID_HANDLE)
     {
      PrintFormat(&quot;%s: n√£o foi poss√≠vel criar o iATR, c√≥digo de erro %d&quot;,__FUNCTION__,
      return(INIT_FAILED);
     }
//--- inicializa√ß√£o bem-sucedida do EA
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- relatamos o c√≥digo de desligamento do EA
   Print(__FILE__,&quot;: C√≥digo de motivo da desinicializa√ß√£o = &quot;,reason);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- sinal de negocia√ß√£o
   static int signal=0; // +1 significa um sinal de compra, -1 significa um sinal de v
//--- verificamos e fechamos as posi√ß√µes abertas antigas, abertas h√° mais de holdbars 
   ClosePositionsByBars(holdbars,slippage,EXPERT_MAGIC);
//--- verificamos o surgimento de uma nova barra
   if(isNewBar())
     {
      //--- verificamos a presen√ßa de sinal      
      signal=CheckSignal();</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1929
</p>
<pre><code class="language-mql5">
     }
//--- se aberta uma posi√ß√£o de &#x27;netting&#x27;, ignoramos o sinal e esperamos at√© que ele fe
   if(signal!=0 &amp;&amp; PositionsTotal()&gt;0 &amp;&amp; (ENUM_ACCOUNT_MARGIN_MODE)AccountInfoInteger
     {
      signal=0;
      return; // sa√≠mos do manipulador de eventos NewTick e n√£o entramos no mercado at
     }
//--- para contas de cobertura (&#x27;hedge&#x27;), casa posi√ß√£o tem vida e fecha separadamente
   if(signal!=0)
     {
      //--- sinal de compra
      if(signal&gt;0)
        {
         PrintFormat(&quot;%s: Existe um sinal de compra! Revers=%s&quot;,__FUNCTION__,string(re
         if(Buy(trade_lot,slippage,EXPERT_MAGIC))
            signal=0;
        }
      //--- sinal de venda
      if(signal&lt;0)
        {
         PrintFormat(&quot;%s: Existe um sinal de venda! Revers=%s&quot;,__FUNCTION__,string(rev
         if(Sell(trade_lot,slippage,EXPERT_MAGIC))
            signal=0;
        }
     }
//--- fim da fun√ß√£o OnTick
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Verificando se √° sinal de negocia√ß√£o                             |
//+------------------------------------------------------------------+
int CheckSignal()
  {
//--- 0 significa que n√£o h√° sinal
   int res=0;
//--- obtemos o valor do ATR na pen√∫ltima barra conclu√≠da (o √≠ndice da barra igual a 2
   double atr_value[1];
   if(CopyBuffer(atr_handle,0,2,1,atr_value)!=-1)
     {
      last_atr=atr_value[0];
      //--- recebemos os dados da √∫ltima barra fechada numa matriz do tipo MqlRates
      MqlRates bar[1];
      if(CopyRates(_Symbol,_Period,1,1,bar)!=-1)
        {
         //--- calculamos o tamanho do corpo da barra na √∫ltima barra fechada
         last_body=bar[0].close-bar[0].open;
         //--- se o corpo da √∫ltima barra (com √≠ndice 1) exceder o valor anterior do A
         if(MathAbs(last_body)&gt;kATR*last_atr)
            res=last_body&gt;0?1:-1; // para a leva altista um valor positivo
        }</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1930
</p>
<pre><code class="language-mql5">
      else
         PrintFormat(&quot;%s: N√£o foi poss√≠vel obter a √∫ltima barra! Erro&quot;,__FUNCTION__,Ge
     }
   else
      PrintFormat(&quot;%s: N√£o foi poss√≠vel obter o valor do indicador ATR! Erro&quot;,__FUNCTI
//--- se estiver ativado o modo de negocia√ß√£o de revers√£o
   res=revers?-res:res;  // se necess√°rio, revertemos o sinal (em vez de 1, retornamos
//--- retornamos o valor do sinal de negocia√ß√£o
   return (res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Retornando true quando aparece uma nova barra                   |
//+------------------------------------------------------------------+
bool isNewBar(const bool print_log=true)
  {
   static datetime bartime=0; // armazenamos o tempo de abertura da barra atual
//--- obtemos o tempo de abertura da barra zero
   datetime currbar_time=iTime(_Symbol,_Period,0);
//--- se o tempo de abertura mudar, √© porque apareceu uma nova barra
   if(bartime!=currbar_time)
     {
      bartime=currbar_time;
      lastbar_timeopen=bartime;
      //--- exibir no log informa√ß√µes sobre o tempo de abertura da nova barra      
      if(print_log &amp;&amp; !(MQLInfoInteger(MQL_OPTIMIZATION)||MQLInfoInteger(MQL_TESTER)))
        {
         //--- exibimos uma mensagem sobre o tempo de abertura da nova barra
         PrintFormat(&quot;%s: new bar on %s %s opened at %s&quot;,__FUNCTION__,_Symbol,
                     StringSubstr(EnumToString(_Period),7),
                     TimeToString(TimeCurrent(),TIME_SECONDS));
         //--- obtemos os dados do √∫ltimo tick
         MqlTick last_tick;
         if(!SymbolInfoTick(Symbol(),last_tick))
            Print(&quot;SymbolInfoTick() failed, error = &quot;,GetLastError());
         //--- exibimos o tempo do √∫ltimo tick em segundos
         PrintFormat(&quot;Last tick was at %s.%03d&quot;,
                     TimeToString(last_tick.time,TIME_SECONDS),last_tick.time_msc%1000
        }
      //--- temos uma nova barra
      return (true);
     }
//--- n√£o h√° nenhuma barra nova
   return (false);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Comprando a mercado com o volume especificado                    |
//+------------------------------------------------------------------+
bool Buy(double volume,ulong deviation=10,ulong  magicnumber=0)
  {</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1931
</p>
<pre><code class="language-mql5">
//--- compramos a mercado
   return (MarketOrder(ORDER_TYPE_BUY,volume,deviation,magicnumber));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Vendendo a mercado com o volume definido                          |
//+------------------------------------------------------------------+
bool Sell(double volume,ulong deviation=10,ulong  magicnumber=0)
  {
//--- vendemos a mercado
   return (MarketOrder(ORDER_TYPE_SELL,volume,deviation,magicnumber));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fechando posi√ß√µes segundo o tempo de reten√ß√£o nas barras         |
//+------------------------------------------------------------------+
void ClosePositionsByBars(int holdtimebars,ulong deviation=10,ulong  magicnumber=0)
  {
   int total=PositionsTotal(); // n√∫mero de posi√ß√µes abertas   
//--- pesquisa detalhada de todas as posi√ß√µes abertas
   for(int i=total-1; i&gt;=0; i--)
     {
      //--- par√¢metros da posi√ß√£o
      ulong  position_ticket=PositionGetTicket(i);                                    
      string position_symbol=PositionGetString(POSITION_SYMBOL);                      
      ulong  magic=PositionGetInteger(POSITION_MAGIC);                                
      datetime position_open=(datetime)PositionGetInteger(POSITION_TIME);             
      int bars=iBarShift(_Symbol,PERIOD_CURRENT,position_open)+1;                     
      //--- se a posi√ß√£o tem vivido por um longo tempo, e tamb√©m o MagicNumber e o s√≠m
      if(bars&gt;holdtimebars &amp;&amp; magic==magicnumber &amp;&amp; position_symbol==_Symbol)
        {
         int    digits=(int)SymbolInfoInteger(position_symbol,SYMBOL_DIGITS);         
         double volume=PositionGetDouble(POSITION_VOLUME);                            
         ENUM_POSITION_TYPE type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE)
         string str_type=StringSubstr(EnumToString(type),14);
         StringToLower(str_type); // reduzimos o registro do texto para uma correta fo
         PrintFormat(&quot;Fechamos a posi√ß√£o #%I64u %s %s %.2f&quot;,
                     position_ticket,position_symbol,str_type,volume);
         //--- definindo o tipo de ordem e de envio do pedido de negocia√ß√£o
         if(type==POSITION_TYPE_BUY)
            MarketOrder(ORDER_TYPE_SELL,volume,deviation,magicnumber,position_ticket);
         else
            MarketOrder(ORDER_TYPE_BUY,volume,deviation,magicnumber,position_ticket);
        }
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preparando e enviando uma solicita√ß√£o de negocia√ß√£o              |
//+------------------------------------------------------------------+
bool MarketOrder(ENUM_ORDER_TYPE type,double volume,ulong slip,ulong magicnumber,ulong</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1932
</p>
<pre><code class="language-mql5">
  {
//--- declara√ß√£o e inicializa√ß√£o de estruturas
   MqlTradeRequest request={};
   MqlTradeResult  result={};
   double price=SymbolInfoDouble(Symbol(),SYMBOL_BID);
   if(type==ORDER_TYPE_BUY)
      price=SymbolInfoDouble(Symbol(),SYMBOL_ASK);
//--- par√¢metros da solicita√ß√£o
   request.action   =TRADE_ACTION_DEAL;                     // tipo de opera√ß√£o de neg
   request.position =pos_ticket;                            // boleta da posi√ß√£o, se f
   request.symbol   =Symbol();                              // s√≠mbolo
   request.volume   =volume;                                // volume 
   request.type     =type;                                  // tipo de ordem
   request.price    =price;                                 // pre√ßo de transa√ß√£o
   request.deviation=slip;                                  // desvio permitido em rel
   request.magic    =magicnumber;                           // MagicNumber da ordem
//--- envio do pedido
   if(!OrderSend(request,result))
     {
      //--- exibimos as informa√ß√µes sobre a falha
      PrintFormat(&quot;OrderSend %s %s %.2f at %.5f error %d&quot;,
                  request.symbol,EnumToString(type),volume,request.price,GetLastError
      return (false);
     }
//--- relatamos sobre a opera√ß√£o bem-sucedida
   PrintFormat(&quot;retcode=%u  deal=%I64u  order=%I64u&quot;,result.retcode,result.deal,result
   return (true);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
Fun√ß√µes de processamento de eventos, Execu√ß√£o de programas, Eventos do terminal do cliente,
<h3>OnTimer, OnBookEvent, OnChartEvent</h3></p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1933
<h3>OnCalculate</h3>
√â chamada em indicadores quando ocorre o evento Calculate para processar altera√ß√µes nos dados de
pre√ßo. Existem duas vers√µes da fun√ß√£o, voc√™ n√£o pode usar as duas dentro do mesmo indicador.
<h3>C√°lculo baseado numa matriz de dados</h3>
</p>
<pre><code class="language-mql5">
int  OnCalculate(
   const int¬†       rates_total,       // tamanho da matriz price[]
   const int¬†       prev_calculated,   // n√∫mero de barras processadas na chamada ante
   const int¬†       begin,             // n√∫mero do √≠ndice na matriz price[] a partir 
   const double&amp;¬†   price[]            // matriz de valores para c√°lculo
   );
</code></pre>
<p>
C√°lculos baseados nas s√©ries temporais do timeframe atual
</p>
<pre><code class="language-mql5">
int  OnCalculate(
   const int¬†       rates_total,       // tamanho das s√©ries temporais de entrada
   const int¬†       prev_calculated,   // n√∫mero de barras processadas na chamada ante
   const datetime&amp;¬† time[],            // matriz Time
   const double&amp;¬†   open[],            // matriz Open
   const double&amp;¬†   high[],            // matriz High
   const double&amp;¬†   low[],             // matriz Low
   const double&amp;¬†   close[],           // matriz Close
   const long&amp;¬†     tick_volume[],     // matriz Tick Volume
   const long&amp;¬†     volume[],          // matriz Real Volume
   const int&amp;¬†      spread[]           // matriz Spread
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
rates_total
[in]  Tamanho da matriz price[] ou das s√©ries temporais de entrada dispon√≠veis para o indicador
para c√°lculo. Na segunda vers√£o da fun√ß√£o, o valor do par√¢metro corresponde ao n√∫mero de barras
no gr√°fico em que est√° sendo executado.
prev_calculated
[in]  Cont√©m o valor retornado pela fun√ß√£o OnCalculate() na chamada anterior. Ele √© usado para
ignorar nos c√°lculos as barras que n√£o mudaram desde a √∫ltima inicializa√ß√£o desta fun√ß√£o.
begin
[in]  valor do √≠ndice na matriz price[] a partir do qual come√ßam os dados significativos. Permite
ignorar nos c√°lculos os dados ausentes ou iniciais, para os quais n√£o h√° valores corretos.
price[]
[in]  Matriz de valores para executar c√°lculos. Como matriz price[] pode ser transferida uma das
s√©ries temporais de pre√ßos ou o buffer calculado de qualquer indicador. O tipo de dados que foi
transferido para o c√°lculo pode ser determinado usando a vari√°vel predefinida _AppliedTo.
time{}
[in]  Matriz com os valores de tempo da abertura das barras.</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1934
open[]
[in]  Matriz com os valores dos pre√ßos de abertura.
high[]
[in]  Matriz com os valores dos pre√ßos m√°ximos.
low[]
[in]  Matriz com os valores dos pre√ßos m√≠nimos.
close[]
[in]  Matriz com os valores dos pre√ßos de fechamento.
tick_volume[]
[in]  Matriz com valores dos volumes de ticks.
volume[]
[in]  Matriz com valores dos volumes de negocia√ß√£o.
spread[]
[in]  Matriz com os valores de spread para barras.
<h3>Valor retornado</h3>
Valor de tipo int que ser√° transferido como par√¢metro prev_calculated, da pr√≥xima vez que a fun√ß√£o
</p>
<pre><code class="language-mql5">
for chamada.
</code></pre>
<p>
<h3>Observa√ß√£o</h3>
Se a fun√ß√£o OnCalculate() retornar um valor zero, a janela DataWindow do terminal do cliente n√£o
exibir√° os valores do indicador.
Se os dados de pre√ßo foram alterados desde a √∫ltima chamada da fun√ß√£o OnCalculate() (um hist√≥rico
mais profundo foi carregado ou o hist√≥rico estava ausente), o valor do par√¢metro de entrada
prev_calculated ser√° definido como zero pelo pr√≥prio terminal.
Para determinar a dire√ß√£o da indexa√ß√£o nas matrizes time[], open[], high[], low[], close[],
tick_volume[], volume[] e spread[], √© necess√°rio chamar a fun√ß√£o ArrayGetAsSeries(). Para n√£o
depender dos padr√µes, √© absolutamente necess√°rio chamar a fun√ß√£o ArraySetAsSeries() para aquelas
matrizes com as quais se deve trabalhar.
Ao usar a primeira vers√£o da fun√ß√£o, a s√©ries temporais ou o indicador necess√°rio como uma matriz
price[] √© selecionado pelo usu√°rio na guia Parameters quando o indicador √© iniciado. Para fazer isso,
voc√™ deve especificar o elemento desejado na lista suspensa do campo &quot;Apply to&quot;.
Para obter os valores do indicador personalizado a partir de outros programas MQL5, √© usada a
fun√ß√£o iCustom() que retorna o identificador do indicador para as opera√ß√µes subsequentes. Neste
caso, voc√™ pode especificar a matriz necess√°ria price[] ou o identificador da outro indicador. Este
par√¢metro deve ser o √∫ltimo a ser passado na lista de vari√°veis de entrada do indicador
personalizado.
√â necess√°rio usar o relacionamento entre o valor retornado pela fun√ß√£o OnCalculate() e o segundo
par√¢metro de entrada prev_calculated. O par√¢metro prev_calculated, ao chamar a fun√ß√£o, cont√©m o
valor retornado pela fun√ß√£o OnCalculate() na chamada anterior. Isso possibilita a implementa√ß√£o de
algoritmos econ√¥micos para o c√°lculo do indicador personalizado, a fim de evitar c√°lculos repetitivos
para as barras que n√£o foram alteradas desde a √∫ltima inicializa√ß√£o desta fun√ß√£o. </p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1935
<h3>Exemplo de indicador</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                           OnCalculate_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo de c√°lculo do indicador Momentum&quot;
//---- indicator settings
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_type1   DRAW_LINE
#property indicator_color1  Blue
//---- par√¢metros de entrada
input int MomentumPeriod=14; // Per√≠odo para c√°lculo
//---- buffer de indicador
double    MomentumBuffer[];
//--- vari√°vel global para armazenar o per√≠odo de c√°lculos
int       IntPeriod;
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
void OnInit()
  {
//--- verificamos o par√¢metro de entrada
   if(MomentumPeriod&lt;0)
     {
      IntPeriod=14;
      Print(&quot;par√¢metro Per√≠odo possui um valor inv√°lido. Para c√°lculos, ser√° usado o v
     }
   else
      IntPeriod=MomentumPeriod;
//---- buffers  
   SetIndexBuffer(0,MomentumBuffer,INDICATOR_DATA);
//---- o nome do indicador a ser exibido na DataWindow e na subjanela
   IndicatorSetString(INDICATOR_SHORTNAME,&quot;Momentum&quot;+&quot;(&quot;+string(IntPeriod)+&quot;)&quot;);
//--- definimos o n√∫mero da barra a partir da qual come√ßa a plotagem
   PlotIndexSetInteger(0,PLOT_DRAW_BEGIN,IntPeriod-1);
//--- definimos 0.0 como um valor vazio que n√£o √© plotado
   PlotIndexSetDouble(0,PLOT_EMPTY_VALUE,0.0);
//--- precis√£o para mostrar os valores do indicador
   IndicatorSetInteger(INDICATOR_DIGITS,2);</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1936
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  C√°lculo do indicador Momentum                                   |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,     // tamanho da matriz price[] 
                const int prev_calculated, // n√∫mero de barras processadas anteriormen
                const int begin,           // come√ßo dos valores significativos
                const double &amp;price[])     // matriz para o valor a ser processado
  {
//--- posi√ß√£o inicial para c√°lculos
   int StartCalcPosition=(IntPeriod-1)+begin;
//---- se n√£o houver suficientes dados para c√°lculo
   if(rates_total&lt;StartCalcPosition)
      return(0);  // sa√≠mos com valor nulo - indicador n√£o √© calculado
//--- correct draw begin
   if(begin&gt;0)
      PlotIndexSetInteger(0,PLOT_DRAW_BEGIN,StartCalcPosition+(IntPeriod-1));
//--- come√ßamos os c√°lculos, calculamos a posi√ß√£o do in√≠cio
   int pos=prev_calculated-1;
   if(pos&lt;StartCalcPosition)
      pos=begin+IntPeriod;
//--- ciclo principal de c√°lculos
   for(int i=pos;i&lt;rates_total &amp;&amp; !IsStopped();i++)
      MomentumBuffer[i]=price[i]*100/price[i-IntPeriod];
//--- execu√ß√£o da OnCalculate conclu√≠da. Retornamos o novo valor de prev_calculated pa
   return(rates_total);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
ArrayGetAsSeries, ArraySetAsSeries, iCustom, Fun√ß√µes de processamento de eventos, Execu√ß√£o de
programas, Eventos do terminal do cliente, Acesso a s√©ries temporais e indicadores</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1937
<h3>OnTimer</h3>
√â chamada em EAs quando o ocorre o evento Timer gerado pelo terminal com um intervalo
predeterminado.
</p>
<pre><code class="language-mql5">
void¬† OnTimer(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
O evento Timer √© gerado periodicamente pelo terminal do cliente para o EA que ativa o
temporizador usando a fun√ß√£o EventSetTimer(). Geralmente, esta fun√ß√£o √© chamada na fun√ß√£o
OnInit(). Ao concluir o trabalho do EA, √© necess√°rio destruir o temporizador criado com a ajuda da
EventKillTimer() que, normalmente √© chamada na fun√ß√£o OnDeinit().
Cada EA e cada indicador trabalha com seu temporizador e recebe eventos apenas dele. No final do
trabalho do programa MQL5, o temporizador √© for√ßosamente destru√≠do, se foi criado, mas n√£o foi
desabilitado pela fun√ß√£o EventKillTimer().
Se precisar receber eventos do temporizador mais de uma vez por segundo, use a
EventSetMillisecondTimer() para criar um temporizador de alta resolu√ß√£o. 
Em geral, √† medida que o per√≠odo do temporizador diminui, o tempo de teste aumenta, uma vez que
o n√∫mero de chamadas do manipulador de eventos do tempo total aumenta. Ao trabalhar em tempo
real, os eventos do temporizador s√£o gerados no m√°ximo 1 vez a cada 10-16 milissegundos, o que √©
devido a limita√ß√µes de hardware.
Para cada programa, n√£o pode ser iniciado mais do que um temporizador. Cada programa MQL5 e
cada gr√°fico t√™m sua pr√≥pria fila de eventos, √† qual s√£o adicionados todos os eventos rec√©m-
chegados. Se na fila j√° houver um evento Timer ou este evento estiver no estado de
processamento, o novo evento Timer n√£o ser√° colocado na fila do programa MQL5. 
<h3>Exemplo de EA com manipulador OnTimer()</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                               OnTimer_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo de uso de temporizador para calcular a hora do servidor
#property description &quot;√â melhor iniciar o EA no final da semana de negocia√ß√£o, antes d
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- criamos um temporizador com um per√≠odo de 1 segundo</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1938
</p>
<pre><code class="language-mql5">
   EventSetTimer(1);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destru√≠mos o temporizador no final do trabalho
   EventKillTimer();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+----------¬¥--------------------------------------------------------+
//| Expert tck function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//--- hora da primeira chamada da OnTimer()
   static datetime start_time=TimeCurrent();
//--- hora do servidor de negocia√ß√£o na primeira chamada da OnTimer();
   static datetime start_tradeserver_time=0;
//--- hora do servidor de negocia√ß√£o calculada
   static datetime calculated_server_time=0;
//--- hora local no computador
   datetime local_time=TimeLocal();
//--- hora estimada atual do servidor de negocia√ß√£o
   datetime trade_server_time=TimeTradeServer();
//--- se por algum motivo a hora do servidor for desconhecida, sairemos antecipadament
   if(trade_server_time==0)
      return;
//--- se o valor inicial do servidor de negocia√ß√£o ainda n√£o estiver definido
   if(start_tradeserver_time==0)
     {
      start_tradeserver_time=trade_server_time;
      //--- definimos a hora calculada do servidor de negocia√ß√£o      
      Print(trade_server_time);
      calculated_server_time=trade_server_time;
     }
   else</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1939
</p>
<pre><code class="language-mql5">
     {
      //--- aumentamos o tempo da primeira chamada da OnTimer()
      if(start_tradeserver_time!=0)
         calculated_server_time=calculated_server_time+1;;
     }
//--- 
   string com=StringFormat(&quot;                  Start time: %s\r\n&quot;,TimeToString(start_t
   com=com+StringFormat(&quot;                  Local time: %s\r\n&quot;,TimeToString(local_time
   com=com+StringFormat(&quot;TimeTradeServer time: %s\r\n&quot;,TimeToString(trade_server_time,
   com=com+StringFormat(&quot; EstimatedServer time: %s\r\n&quot;,TimeToString(calculated_server
//--- exibimos no gr√°fico os valores de todos os contadores
   Comment(com);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
EventSetTimer, EventSetMillisecondTimer, EventKillTimer, GetTickCount, GetMicrosecondCount,
<h3>Eventos do terminal do cliente</h3></p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1940
<h3>OnTrade</h3>
√â chamada em EAs quando ocorre o evento Trade. A fun√ß√£o se destina ao processamento de altera√ß√µes
em listas de ordens, de posi√ß√µes e de transa√ß√µes.
</p>
<pre><code class="language-mql5">
void¬† OnTrade(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
A OnTrade() √© chamada apenas para EAs, √© ignorada em indicadores e em scripts, mesmo se voc√™
adicionar uma fun√ß√£o com esse nome e tipo a eles.
Para qualquer a√ß√£o de negocia√ß√£o (coloca√ß√£o de uma ordem pendente, abertura/fechamento de uma
posi√ß√£o, defini√ß√£o de stops, desencadeamento de ordens pendentes, etc.), s√£o devidamente
modificados o hist√≥rico de ordens e de transa√ß√µes e/ou a lista de posi√ß√µes e de ordens atuais.
Ao processar a ordem, o servidor de negocia√ß√£o envia uma mensagem ao terminal sobre a
ocorr√™ncia do evento Trade. Para obter a partir do hist√≥rico dados atuais sobre ordens e transa√ß√µes,
voc√™ deve primeiro executar uma solicita√ß√£o de hist√≥rico de negocia√ß√£o usando HistorySelect().
Eventos de negocia√ß√£o s√£o gerados pelo servidor nos seguintes casos:
¬∑ altera√ß√µes nas ordens atuais,
¬∑ altera√ß√µes nas posi√ß√µes,
¬∑ altera√ß√µes nas transa√ß√µes,
¬∑ altera√ß√µes no hist√≥rico de negocia√ß√£o.
Cada evento Trade pode ser o resultado de uma ou mais solicita√ß√µes de negocia√ß√£o. As solicita√ß√µes
de negocia√ß√£o s√£o enviadas para o servidor usando OrderSend() ou OrderSendAsync(). Cada
solicita√ß√£o pode gerar v√°rios eventos de negocia√ß√£o. Voc√™ n√£o pode confiar na regra ¬´Uma
solicita√ß√£o - Um evento &#x27;Trade&#x27;¬ª, j√° que o processamento de solicita√ß√µes pode ocorrer em v√°rios
est√°gios e cada opera√ß√£o pode alterar o status de ordens, de posi√ß√µes e do hist√≥rico de negocia√ß√£o.
O manipulador OnTrade() √© chamado ap√≥s a chamadas correspondentes da OnTradeTransaction().
Em geral, n√£o h√° correla√ß√£o exata no n√∫mero 
de 
chamadas 
da 
<h3>OnTrade()</h3>
e 
da
OnTradeTransaction(). Uma chamada da OnTrade() corresponde a uma ou mais chamadas da
OnTradeTransaction.
<h3>Exemplo de EA com manipulador OnTrade()</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                               OnTrade_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1941
</p>
<pre><code class="language-mql5">
input    int days=7;            // profundidade do hist√≥rico de negocia√ß√£o em dias
//--- definimos no n√≠vel global os limites do hist√≥rico de negocia√ß√£o
</code></pre>
<p>
datetime     start;             // data de in√≠cio do hist√≥rico de negocia√ß√£o em cache
datetime     end;               // data final do hist√≥rico de negocia√ß√£o em cache
</p>
<pre><code class="language-mql5">
//--- contadores globais
int          orders;            // n√∫mero de ordens vigentes
int          positions;         // n√∫mero de posi√ß√µes abertas
int          deals;             // n√∫mero de transa√ß√µes no cache do hist√≥rico de negoc
int          history_orders;    // n√∫mero de ordens no cache do hist√≥rico de negocia√ß√£
bool         started=false;     // sinalizador da relev√¢ncia dos contadores
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   end=TimeCurrent();
   start=end-days*PeriodSeconds(PERIOD_D1);
   PrintFormat(&quot;Limites do hist√≥rico de negocia√ß√£o carregado: in√≠cio - %s, fim - %s&quot;,
               TimeToString(start),TimeToString(end));
   InitCounters();
//---
   return(0);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Inicializando contadores de posi√ß√µes, de ordens e de transa√ß√µes |
//+------------------------------------------------------------------+
void InitCounters()
  {
   ResetLastError();
//--- carregamos o hist√≥rico
   bool selected=HistorySelect(start,end);
   if(!selected)
     {
      PrintFormat(&quot;%s. N√£o foi poss√≠vel carregar no cache o hist√≥rico de %s a %s. C√≥di
                  __FUNCTION__,TimeToString(start),TimeToString(end),GetLastError());
      return;
     }
//--- obtemos os valores atuais
   orders=OrdersTotal();
   positions=PositionsTotal();
   deals=HistoryDealsTotal();
   history_orders=HistoryOrdersTotal();
   started=true;
   Print(&quot;Inicializa√ß√£o de contadores de ordens, de posi√ß√µes e de transa√ß√µes bem-suced
</code></pre>
<p>
  }  
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1942
</p>
<pre><code class="language-mql5">
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   if(started) SimpleTradeProcessor();
   else InitCounters();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| chamado quando ocorre o evento Trade                             |
//+------------------------------------------------------------------+
void OnTrade()
  {
   if(started) SimpleTradeProcessor();
   else InitCounters();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| exemplo de processamento de altera√ß√µes na negocia√ß√£o e no hist√≥rico
//+------------------------------------------------------------------+
void SimpleTradeProcessor()
  {
   end=TimeCurrent();
   ResetLastError();
//--- carregamos no cache do programa o hist√≥rico de negocia√ß√£o a partir do intervalo 
   bool selected=HistorySelect(start,end);
   if(!selected)
     {
      PrintFormat(&quot;%s. N√£o foi poss√≠vel carregar no cache o hist√≥rico de %s a %s. C√≥di
                  __FUNCTION__,TimeToString(start),TimeToString(end),GetLastError());
      return;
     }
//--- obtemos os valores atuais
   int curr_orders=OrdersTotal();
   int curr_positions=PositionsTotal();
   int curr_deals=HistoryDealsTotal();
   int curr_history_orders=HistoryOrdersTotal();
//--- verificamos as altera√ß√µes na quantidade de ordens vigentes
   if(curr_orders!=orders)
     {
      //--- n√∫mero de ordens vigentes alterado
      PrintFormat(&quot;O n√∫mero de ordens foi alterado de %d para %d&quot;,
                  orders,curr_orders);
      //--- atualizamo o valor
      orders=curr_orders;
     }
//--- altera√ß√£o no n√∫mero de posi√ß√µes abertas
   if(curr_positions!=positions)
     {
      //--- o n√∫mero de posi√ß√µes abertas foi alterado
      PrintFormat(&quot;O n√∫mero de posi√ß√µes abertas foi alterado de %d para %d&quot;,</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1943
</p>
<pre><code class="language-mql5">
                  positions,curr_positions);
      //--- atualizamo o valor
      positions=curr_positions;
     }
//--- altera√ß√µes no n√∫mero de transa√ß√µes no cache do hist√≥rico de negocia√ß√£o
   if(curr_deals!=deals)
     {
      //--- n√∫mero de transa√ß√µes no cache do hist√≥rico de negocia√ß√£o foi alterado
      PrintFormat(&quot;O n√∫mero de transa√ß√µes foi alterado de %d para %d&quot;,
                  deals,curr_deals);
      //--- atualizamo o valor
      deals=curr_deals;
     }
//--- altera√ß√µes no n√∫mero de ordens hist√≥ricas no cache do hist√≥rico de negocia√ß√£o
   if(curr_history_orders!=history_orders)
     {
      //--- n√∫mero de ordens hist√≥ricas no cache do hist√≥rico de negocia√ß√£o foi altera
      PrintFormat(&quot;O n√∫mero de ordens no hist√≥rico foi alterado de %d para %d&quot;,
                  history_orders,curr_history_orders);
     //--- atualizamos o valor
     history_orders=curr_history_orders;
     }
//--- verificamos se √© necess√°rio alterar os limites do hist√≥rico de negocia√ß√£o para s
   CheckStartDateInTradeHistory();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  altera√ß√µes da data de in√≠cio para a solicita√ß√£o do hist√≥rico de negocia√ß√£o      
//+------------------------------------------------------------------+
void CheckStartDateInTradeHistory()
  {
//--- intervalo de in√≠cio, se come√ßarmos a trabalhar agora
   datetime curr_start=TimeCurrent()-days*PeriodSeconds(PERIOD_D1);
//--- verificamos que o limite do in√≠cio do hist√≥rico de transa√ß√µes seja inferior
//--- a 1 dia a partir da data planejada
   if(curr_start-start&gt;PeriodSeconds(PERIOD_D1))
     {
      //--- deve-se corrigir a data de in√≠cio do hist√≥rico carregado no cache
      start=curr_start;
      PrintFormat(&quot;Novo limite de in√≠cio do hist√≥rico de negocia√ß√£o carregado: in√≠cio 
                  TimeToString(start));
      //--- agora recarregamos o hist√≥rico de transa√ß√µes para o intervalo atualizado
      HistorySelect(start,end);
      //--- corrigimos os contadores de transa√ß√µes e de ordens no hist√≥rico para a pr√≥
      history_orders=HistoryOrdersTotal();
      deals=HistoryDealsTotal();
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
/* Exemplo de exibi√ß√£o:</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1944
¬† Limites do hist√≥rico de negocia√ß√£o carregado: in√≠cio - 2018.07.16 18:11, fim - 2018.
¬† Contadores de ordens, deposi√ß√µes e de transa√ß√µes inicializados com sucesso
¬† O n√∫mero de ordens foi alterado. Havia 0, h√° 1
¬† O n√∫mero de ordens foi alterado. Havia 1, h√° 0
¬† O n√∫mero de posi√ß√µes foi alterado. Havia 0, h√° 1
¬† O n√∫mero de transa√ß√µes foi alterado. Havia 0, h√° 1
¬† O n√∫mero de ordens no hist√≥rico foi alterado. Havia 0, h√° 1
*/
<h3>Veja tamb√©m</h3>
OrderSend, OrderSendAsync, OnTradeTransaction,  Eventos do terminal do cliente</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1945
<h3>OnTradeTransaction</h3>
√â chamada em EAs quando ocorre o evento TradeTransaction. A fun√ß√£o √© projetada para processar os
resultados de execu√ß√£o da solicita√ß√£o de negocia√ß√£o.
</p>
<pre><code class="language-mql5">
void¬† OnTradeTransaction()
   const MqlTradeTransaction&amp;¬†   trans,     // estrutura da transa√ß√£o comercial
   const MqlTradeRequest&amp;¬†       request,   // estrutura da solicita√ß√£o
   const MqlTradeResult&amp;¬†        result     // estrutura da resposta
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
trans
[in]  Vari√°vel do tipo MqlTradeTransaction com descri√ß√£o da transa√ß√£o feita na conta de
negocia√ß√£o.
request
[in]  Vari√°vel do tipo MqlTradeRequest com descri√ß√£o da solicita√ß√£o que gerou a transa√ß√£o.
Cont√©m os valores apenas para a transa√ß√£o de tipo TRADE_TRANSACTION_REQUEST.
result
[in]  Vari√°vel do tipo MqlTradeResult com resultado da execu√ß√£o da solicita√ß√£o que gerou a
transa√ß√£o. Cont√©m os valores apenas para a transa√ß√£o de tipo TRADE_TRANSACTION_REQUEST.
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
OnTradeTransaction() √© chamada para manipular o evento TradeTransaction que o servidor de
negocia√ß√£o envia para o terminal nos seguintes casos:
¬∑ envio da solicita√ß√£o de negocia√ß√£o a partir do programa MQL5 usando as fun√ß√µes
<h3>OrderSend()/OrderSendAsync() e sua posterior execu√ß√£o;</h3>
¬∑ envio manual da solicita√ß√£o de negocia√ß√£o atrav√©s da interface gr√°fica e sua posterior execu√ß√£o;
¬∑ desencadeamento de ordens pendentes e ordens stop no servidor;
¬∑ execu√ß√£o de opera√ß√µes no lado do servidor de negocia√ß√£o.
Informa√ß√µes sobre o tipo de transa√ß√£o s√£o contidas no campo type da vari√°vel trans. Os tipos de
trasa√ß√µes comerciais s√£o descritas na enumera√ß√£o ENUM_TRADE_TRANSACTION_TYPE:
¬∑ TRADE_TRANSACTION_ORDER_ADD ‚Äì adi√ß√£o de uma nova ordem ativa
¬∑ TRADE_TRANSACTION_ORDER_UPDATE ‚Äì altera√ß√£o da ordem ativa
¬∑ TRADE_TRANSACTION_ORDER_DELETE ‚Äì remo√ß√£o da ordem da lista de ordens ativas
¬∑ TRADE_TRANSACTION_DEAL_ADD ‚Äì adi√ß√£o da transa√ß√£o ao hist√≥rico
¬∑ TRADE_TRANSACTION_DEAL_UPDATE ‚Äì altera√ß√£o da transa√ß√£o no hist√≥rico
¬∑ TRADE_TRANSACTION_DEAL_DELETE ‚Äì remo√ß√£o da transa√ß√£o do hist√≥rico
¬∑ TRADE_TRANSACTION_HISTORY_ADD ‚Äì adi√ß√£o da ordem ao hist√≥rico como resultado da execu√ß√£o
ou do cancelamento
¬∑ TRADE_TRANSACTION_HISTORY_UPDATE ‚Äì altera√ß√£o da ordem que se encontra no hist√≥rico de
ordens</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1946
¬∑ TRADE_TRANSACTION_HISTORY_DELETE ‚Äì remo√ß√£o da ordem do hist√≥rico de ordens
¬∑ TRADE_TRANSACTION_POSITION ‚Äì altera√ß√£o da posi√ß√£o n√£o relacionada √† execu√ß√£o da transa√ß√£o
¬∑ TRADE_TRANSACTION_REQUEST ‚Äì notifica√ß√£o de que a solicita√ß√£o de negocia√ß√£o foi processada
pelo servidor e o resultado de seu processamento foi recebido.
Ao processar transa√ß√µes do tipo TRADE_TRANSACTION_REQUEST, para obter informa√ß√µes
adicionais, √© necess√°rio analisar os segundo e terceiro par√¢metros da fun√ß√£o OnTradeTransaction()
‚Äì request e result.
O envio de uma solicita√ß√£o de compra leva a uma cadeia de transa√ß√µes comerciais feitas na conta
de negocia√ß√£o: 1) a solicita√ß√£o √© aceita para ser processada, 2) para a conta √© criada a respectiva
solicita√ß√£o de compra, 3) √© executada a ordem, 4) a ordem executada √© removida da lista de ordens
ativas, 5) adicionada ao hist√≥rico de ordens, 6) a transa√ß√£o correspondente √© adicionada ao
hist√≥rico e 7) √© criada uma nova posi√ß√£o. Todas essas a√ß√µes s√£o transa√ß√µes comerciais. A chegada
de cada transa√ß√£o desse tipo no terminal √© um evento TradeTransaction. FFNeste caso, n√£o √©
garantida a ordem de recep√ß√£o destas transa√ß√µes ao terminal, portanto, n√£o se pode construir seu
pr√≥prio algoritmo de negocia√ß√£o na expectativa de receber certas transa√ß√µes comerciais ap√≥s a
chegada de outras.
Quando EA processa transa√ß√µes comerciais usando o manipulador OnTradeTransaction(), o terminal
continua processando as transa√ß√µes rec√©m-chegadas. Assim, o estado da conta de negocia√ß√£o pode
mudar j√° durante o funcionamento da OnTradeTransaction(). Por exemplo, enquanto o programa
MQL5 manipula o evento de adi√ß√£o de nova ordem, ela pode ser executada, exclu√≠da da lista de
pedidos ordens abertas e movida para o hist√≥rico. No futuro, o programa ser√° notificado de todos
esses eventos.
O comprimento da fila de transa√ß√µes √© de 1 024 itens. Se a OnTradeTransaction() demorar a
processar a seguinte transa√ß√£o muito tempo, as transa√ß√µes anteriores na fila poder√£o ser
substitu√≠das por transa√ß√µes mais recentes.
O manipulador OnTrade() √© chamado ap√≥s as respectivas chamadas da OnTradeTransaction(). Em
geral, n√£o h√° correla√ß√£o exata no n√∫mero de chamadas da OnTrade() e da OnTradeTransaction().
Uma chamada da OnTrade() corresponde a uma ou mais chamadas da OnTradeTransaction.
Cada evento Trade pode ser o resultado de uma ou mais solicita√ß√µes de negocia√ß√£o. As solicita√ß√µes
de negocia√ß√£o s√£o enviadas para o servidor usando OrderSend() ou OrderSendAsync(). Cada
solicita√ß√£o pode gerar v√°rios eventos de negocia√ß√£o. Voc√™ n√£o pode confiar na regra ¬´Uma
solicita√ß√£o - Um evento &#x27;Trade&#x27;¬ª, j√° que o processamento de solicita√ß√µes pode ocorrer em v√°rios
est√°gios e cada opera√ß√£o pode alterar o status de ordens, de posi√ß√µes e do hist√≥rico de negocia√ß√£o.
<h3>Exemplo de EA  com manipulador OnTradeTransaction()</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                    OnTradeTransaction_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo de ouvinte do evento TradeTransaction&quot;
//+------------------------------------------------------------------+
//| Expert initialization function                                   |</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1947
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   PrintFormat(&quot;LAST PING=%.f ms&quot;,
               TerminalInfoInteger(TERMINAL_PING_LAST)/1000.);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| TradeTransaction function                                        |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction &amp;trans,
                        const MqlTradeRequest &amp;request,
                        const MqlTradeResult &amp;result)
  {
//---
   static int counter=0;   // contador de chamadas da OnTradeTransaction()
   static uint lasttime=0; // hora da √∫ltima chamada da OnTradeTransaction()
//---
   uint time=GetTickCount();
//--- se a √∫ltima opera√ß√£o tiver sido realizada h√° mais de 1 segundo,
   if(time-lasttime&gt;1000)
     {
      counter=0; // significa que se trata de uma nova opera√ß√£o de negocia√ß√£o e, porta
      if(IS_DEBUG_MODE)
         Print(&quot; Nova opera√ß√£o de negocia√ß√£o&quot;);
     }
   lasttime=time;
   counter++;
   Print(counter,&quot;. &quot;,__FUNCTION__);
//--- resultado da execu√ß√£o do pedido de negocia√ß√£o
   ulong            lastOrderID   =trans.order;
   ENUM_ORDER_TYPE  lastOrderType =trans.order_type;
   ENUM_ORDER_STATE lastOrderState=trans.order_state;
//--- nome do s√≠mbolo segundo o qual foi realizada a transa√ß√£o
   string trans_symbol=trans.symbol;
//--- tipo de transa√ß√£o
   ENUM_TRADE_TRANSACTION_TYPE  trans_type=trans.type;
   switch(trans.type)
     {</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1948
</p>
<pre><code class="language-mql5">
      case  TRADE_TRANSACTION_POSITION:   // altera√ß√£o da posi√ß√£o
        {
         ulong pos_ID=trans.position;
         PrintFormat(&quot;MqlTradeTransaction: Position  #%I64u %s modified: SL=%.5f TP=%.
                     pos_ID,trans_symbol,trans.price_sl,trans.price_tp);
        }
      break;
      case TRADE_TRANSACTION_REQUEST:     // envio do pedido de negocia√ß√£o
         PrintFormat(&quot;MqlTradeTransaction: TRADE_TRANSACTION_REQUEST&quot;);
         break;
      case TRADE_TRANSACTION_DEAL_ADD:    // adi√ß√£o da transa√ß√£o
        {
         ulong          lastDealID   =trans.deal;
         ENUM_DEAL_TYPE lastDealType =trans.deal_type;
         double        lastDealVolume=trans.volume;
         //--- identificador da transa√ß√£o no sistema externo - bilhete atribu√≠do pela 
         string Exchange_ticket=&quot;&quot;;
         if(HistoryDealSelect(lastDealID))
            Exchange_ticket=HistoryDealGetString(lastDealID,DEAL_EXTERNAL_ID);
         if(Exchange_ticket!=&quot;&quot;)
            Exchange_ticket=StringFormat(&quot;(Exchange deal=%s)&quot;,Exchange_ticket);
         PrintFormat(&quot;MqlTradeTransaction: %s deal #%I64u %s %s %.2f lot   %s&quot;,EnumToS
                     lastDealID,EnumToString(lastDealType),trans_symbol,lastDealVolume
        }
      break;
      case TRADE_TRANSACTION_HISTORY_ADD: // adi√ß√£o da ordem ao hist√≥rico
        {
         //--- identificador da transa√ß√£o no sistema externo - bilhete atribu√≠do pela 
         string Exchange_ticket=&quot;&quot;;
         if(lastOrderState==ORDER_STATE_FILLED)
           {
            if(HistoryOrderSelect(lastOrderID))
               Exchange_ticket=HistoryOrderGetString(lastOrderID,ORDER_EXTERNAL_ID);
            if(Exchange_ticket!=&quot;&quot;)
               Exchange_ticket=StringFormat(&quot;(Exchange ticket=%s)&quot;,Exchange_ticket);
           }
         PrintFormat(&quot;MqlTradeTransaction: %s order #%I64u %s %s %s   %s&quot;,EnumToString
                     lastOrderID,EnumToString(lastOrderType),trans_symbol,EnumToString
        }
      break;
      default: // outras transa√ß√µes  
        {
         //--- identificador da ordem no sistema externo - bilhete atribu√≠do pela Bols
         string Exchange_ticket=&quot;&quot;;
         if(lastOrderState==ORDER_STATE_PLACED)
           {
            if(OrderSelect(lastOrderID))
               Exchange_ticket=OrderGetString(ORDER_EXTERNAL_ID);</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1949
</p>
<pre><code class="language-mql5">
            if(Exchange_ticket!=&quot;&quot;)
               Exchange_ticket=StringFormat(&quot;Exchange ticket=%s&quot;,Exchange_ticket);
           }
         PrintFormat(&quot;MqlTradeTransaction: %s order #%I64u %s %s   %s&quot;,EnumToString(tr
                     lastOrderID,EnumToString(lastOrderType),EnumToString(lastOrderSta
        }
      break;
     }
//--- bilhete da ordem    
   ulong orderID_result=result.order;
   string retcode_result=GetRetcodeID(result.retcode);
   if(orderID_result!=0)
      PrintFormat(&quot;MqlTradeResult: order #%d retcode=%s &quot;,orderID_result,retcode_resul
//---   
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| converte c√≥digos num√©ricos de respostas em c√≥digos Mnemonic de string¬†      
//+------------------------------------------------------------------+
string GetRetcodeID(int retcode)
  {
   switch(retcode)
     {
      case 10004: return(&quot;TRADE_RETCODE_REQUOTE&quot;);             break;
      case 10006: return(&quot;TRADE_RETCODE_REJECT&quot;);              break;
      case 10007: return(&quot;TRADE_RETCODE_CANCEL&quot;);              break;
      case 10008: return(&quot;TRADE_RETCODE_PLACED&quot;);              break;
      case 10009: return(&quot;TRADE_RETCODE_DONE&quot;);                break;
      case 10010: return(&quot;TRADE_RETCODE_DONE_PARTIAL&quot;);        break;
      case 10011: return(&quot;TRADE_RETCODE_ERROR&quot;);               break;
      case 10012: return(&quot;TRADE_RETCODE_TIMEOUT&quot;);             break;
      case 10013: return(&quot;TRADE_RETCODE_INVALID&quot;);             break;
      case 10014: return(&quot;TRADE_RETCODE_INVALID_VOLUME&quot;);      break;
      case 10015: return(&quot;TRADE_RETCODE_INVALID_PRICE&quot;);       break;
      case 10016: return(&quot;TRADE_RETCODE_INVALID_STOPS&quot;);       break;
      case 10017: return(&quot;TRADE_RETCODE_TRADE_DISABLED&quot;);      break;
      case 10018: return(&quot;TRADE_RETCODE_MARKET_CLOSED&quot;);       break;
      case 10019: return(&quot;TRADE_RETCODE_NO_MONEY&quot;);            break;
      case 10020: return(&quot;TRADE_RETCODE_PRICE_CHANGED&quot;);       break;
      case 10021: return(&quot;TRADE_RETCODE_PRICE_OFF&quot;);           break;
      case 10022: return(&quot;TRADE_RETCODE_INVALID_EXPIRATION&quot;);  break;
      case 10023: return(&quot;TRADE_RETCODE_ORDER_CHANGED&quot;);       break;
      case 10024: return(&quot;TRADE_RETCODE_TOO_MANY_REQUESTS&quot;);   break;
      case 10025: return(&quot;TRADE_RETCODE_NO_CHANGES&quot;);          break;
      case 10026: return(&quot;TRADE_RETCODE_SERVER_DISABLES_AT&quot;);  break;
      case 10027: return(&quot;TRADE_RETCODE_CLIENT_DISABLES_AT&quot;);  break;
      case 10028: return(&quot;TRADE_RETCODE_LOCKED&quot;);              break;
      case 10029: return(&quot;TRADE_RETCODE_FROZEN&quot;);              break;
      case 10030: return(&quot;TRADE_RETCODE_INVALID_FILL&quot;);        break;
      case 10031: return(&quot;TRADE_RETCODE_CONNECTION&quot;);          break;</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1950
</p>
<pre><code class="language-mql5">
      case 10032: return(&quot;TRADE_RETCODE_ONLY_REAL&quot;);           break;
      case 10033: return(&quot;TRADE_RETCODE_LIMIT_ORDERS&quot;);        break;
      case 10034: return(&quot;TRADE_RETCODE_LIMIT_VOLUME&quot;);        break;
      case 10035: return(&quot;TRADE_RETCODE_INVALID_ORDER&quot;);       break;
      case 10036: return(&quot;TRADE_RETCODE_POSITION_CLOSED&quot;);     break;
      default:
         return(&quot;TRADE_RETCODE_UNKNOWN=&quot;+IntegerToString(retcode));
         break;
     }
//---
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
OrderSend, OrderSendAsync, OnTradeTransaction, Estrutura do pedido de negocia√ß√£o, Estrutura da
transa√ß√£o comercial, Tipos de transa√ß√µes comerciais, Tipos de opera√ß√µes de negocia√ß√£o, Eventos do
terminal do cliente</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1951
<h3>OnBookEvent</h3>
√â chamada em indicadores e EAs quando ocorre o evento BookEvent. A fun√ß√£o √© projetada para
processar altera√ß√µes no livro de ofertas (Depth of Market).
</p>
<pre><code class="language-mql5">
void  OnBookEvent(
   const string&amp;¬† symbol¬†        // s√≠mbolo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome do instrumento financeiro em que ocorre o evento BookEvent
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
Para receber eventos BookEvent em qualquer s√≠mbolo, basta fazer uma pr√©-assinatura a fim de
receber esses eventos para este s√≠mbolo usando a fun√ß√£o MarketBookAdd(). Para cancelar a
assinatura de recebimento do evento BookEvent num s√≠mbolo espec√≠fico, voc√™ deve chamar a fun√ß√£o
MarketBookRelease().
O evento BookEvent √© difundido no gr√°fico. Isso significa que basta que um aplicativo no gr√°fico
assine a recep√ß√£o do evento BookEvent usando a fun√ß√£o MarketBookAdd, para todos os outros
indicadores e EAs - que est√£o sendo executados neste gr√°fico e que t√™m o manipulador
OnBookEvent() - receberem esse evento. Por isso, voc√™ precisa analisar o nome do s√≠mbolo que √©
transferido para o manipulador OnBookEvent() como um par√¢metro symbol.
Para todos os aplicativos em andamento no mesmo gr√°fico, s√£o executados contadores separados
para receber eventos BookEvent na se√ß√£o de s√≠mbolos. Isso significa que em cada gr√°fico pode
haver assinaturas de diferentes s√≠mbolos, e para cada s√≠mbolo existe seu pr√≥prio contador.
Assinatura e remo√ß√£o de assinatura de eventos BookEvent alteram o contador de assinaturas s√≥ dos
s√≠mbolos especificados, apenas dentro do mesmo gr√°fico. Isso significa que, em dois gr√°ficos
adjacentes, pode haver assinaturas de eventos BookEvent para o mesmo s√≠mbolo, mas com valores
diferentes para o contador de assinaturas.
O valor inicial do contador de assinaturas √© zero. Ap√≥s cada chamada da MarketBookAdd(), o
contador de assinaturas para o s√≠mbolo especificado neste gr√°fico √© aumentado em 1 (n√£o √©
necess√°rio o s√≠mbolo do gr√°fico e o s√≠mbolo na MarketBookAdd() coincidirem). Ap√≥s a chamada da
MarketBookRelease(), o contador de assinaturas para o s√≠mbolo especificado dentro do gr√°fico √©
reduzido em 1. A transmiss√£o de eventos BookEvent em qualquer s√≠mbolo dentro do gr√°fico continua
at√© que o contador de assinaturas para este s√≠mbolo se torne zero. Portanto, √© importante que cada
programa MQL5 contendo chamadas da MarketBookAdd(), ao concluir seu trabalho, corretamente
cancele a recep√ß√£o de eventos para cada s√≠mbolo com a ajuda da MarketBookRelease(). Para isso,
basta que - para cada chamada - o n√∫mero de chamadas da MarketBookAdd() e da
MarketBookRelease() seja par durante toda a vida √∫til do programa MQL5. Usar sinalizadores ou
pr√≥prios contadores de assinaturas dentro do programa permite trabalhar com seguran√ßa com
eventos BookEvent e impede a remo√ß√£o de assinaturas de recep√ß√£o desse evento em programas de
terceiros dentro do mesmo gr√°fico.</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1952
Os eventos BookEvent nunca s√£o ignorados e sempre s√£o enfileirados, mesmo que o processamento
do evento BookEvent anterior ainda n√£o tenha sido conclu√≠do. Deve-se ter em mente que os eventos
BookEvent s√£o entregues por eles mesmos e n√£o levam consigo o status do livro de ofertas. Isso
significa que a chamada da MarketBookGet() a partir do manipulador OnBookEvent() permite - em
vez do status do livro de ofertas que causou o envio do evento BookEvent - obter o status atual do
livro de ofertas no momento da chamada. Para garantir que todos os status exclusivos sejam
obtidos, a fun√ß√£o OnBookEvent() deve ser o mais r√°pida poss√≠vel. 
<h3>Exemplo</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                           OnBookEvent_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com/pt/articles/2635&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo de medi√ß√£o da velocidade de atualiza√ß√£o do livro de ofe
#property description &quot;C√≥digo √© retirado do artigo https://www.mql5.com/pt/articles/26
//--- par√¢metros de entrada
input ulong ExtCollectTime   =30;  // tempo de teste em segundos
input ulong ExtSkipFirstTicks=10;  // n√∫mero de ticks ignorados no in√≠cio
//--- sinalizador da presen√ßa de assinatura de recep√ß√£o de eventos BookEvent
bool book_subscribed=false;
//--- matriz para receber solicita√ß√µes a partir do livro de ofertas
</code></pre>
<p>
<h3>MqlBookInfo  book[];</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- definimos o in√≠cio
   Comment(StringFormat(&quot;Aguardamos a recep√ß√£o dos primeiros %I64u ticks&quot;,ExtSkipFirst
   PrintFormat(&quot;Aguardamos a recep√ß√£o dos primeiros %I64u ticks&quot;,ExtSkipFirstTicks);
//--- ativamos a transmiss√£o do livro de ofertas
   if(MarketBookAdd(_Symbol))
     {
      book_subscribed=true;
      PrintFormat(&quot;%s: Fun√ß√£o MarketBookAdd(%s) retornou true&quot;,__FUNCTION__,_Symbol);
     }
   else
      PrintFormat(&quot;%s: Fun√ß√£o MarketBookAdd(%s) retornou false! GetLastError()=%d&quot;,__F
//--- inicializa√ß√£o bem-sucedida
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Deinitialize expert                                              |</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1953
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- exibimos o c√≥digo de motivo da desinicializa√ß√£o
   Print(__FUNCTION__,&quot;: C√≥digo de motivo da desinicializa√ß√£o = &quot;,reason);  
//--- cancelamos nossa assinatura de recep√ß√£o de eventos a partir do livro de ofertas
   if(book_subscribed)
     {
      if(!MarketBookRelease(_Symbol))
         PrintFormat(&quot;%s: MarketBookRelease(%s) retornou false! GetLastError()=%d&quot;,_Sy
      else
         book_subscribed=false;
     }
//--- 
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| BookEvent function                                               |
//+------------------------------------------------------------------+
void OnBookEvent(const string &amp;symbol)
  {
   static ulong starttime=0;             // tempo de in√≠cio do teste
   static ulong tickcounter=0;           // contador de atualiza√ß√£o do livro de oferta
//--- trabalhamos com eventos do livro de ofertas somente se ele tiver sido assinado p
   if(!book_subscribed)
      return;
//--- consideramos atualiza√ß√µes apenas do pr√≥prio s√≠mbolo
   if(symbol!=_Symbol)
      return;
//--- pulamos os primeiros ticks para a limpeza prim√°ria da fila e para aquecimento
   tickcounter++;
   if(tickcounter&lt;ExtSkipFirstTicks)
      return;
//--- lembramo-nos do tempo de in√≠cio
   if(tickcounter==ExtSkipFirstTicks) 
      starttime=GetMicrosecondCount();
//--- consultamos os dados do livro de ofertas
   MarketBookGet(symbol,book);
//--- quando se deve parar?  
   ulong endtime=GetMicrosecondCount()-starttime;
   ulong ticks  =1+tickcounter-ExtSkipFirstTicks;
// quanto tempo passou em microssegundos desde o in√≠cio do teste?
   if(endtime&gt;ExtCollectTime*1000*1000) 
     {
      PrintFormat(&quot;%I64u ticks for %.1f seconds: %.1f ticks/sec &quot;,ticks,endtime/1000.0
      ExpertRemove();
      return;
     }
//--- exibi√ß√£o dos contadores no campo de coment√°rios</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1954
</p>
<pre><code class="language-mql5">
   if(endtime&gt;0)
      Comment(StringFormat(&quot;%I64u ticks for %.1f seconds: %.1f ticks/sec &quot;,ticks,endti
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
MarketBookAdd, MarketBookRelease, MarketBookGet, OnTrade, OnTradeTransaction, OnTick,
Fun√ß√£o de manipula√ß√£o de eventos, Execu√ß√£o do programa, Eventos do terminal do cliente</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1955
<h3>OnChartEvent</h3>
√â chamada em EAs e indicadores quando ocorre o evento ChartEvent. A fun√ß√£o √© projetada para
processar mudan√ßas no gr√°fico causadas por a√ß√µes do usu√°rio ou pelo funcionamento de programas
<h3>MQL5</h3>
</p>
<pre><code class="language-mql5">
void¬† OnChartEvent()
   const int ¬†     id,       // identificador de evento
   const long&amp;¬†    lparam,   // par√¢metro do evento de tipo long
   const double&amp;¬†  dparam,   // par√¢metro do evento de tipo double
   const string&amp;¬†  sparam    // par√¢metro do evento de tipo string
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
id
[in]  Identificador do evento a partir da enumera√ß√£o ENUM_CHART_EVENT.
lparam
[in]  Par√¢metro do evento de tipo long
dparam
[in]  Par√¢metro do evento de tipo double
sparam
[in]  Par√¢metro do evento de tipo string
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
Existem 11 tipos de eventos que podem ser processados usando a fun√ß√£o predefinida
OnChartEvent() . Para eventos personalizados, s√£o fornecidos 65 535 identificadores no intervalo de
CHARTEVENT_CUSTOM a CHARTEVENT_CUSTOM_LAST. Para gerar um evento personalizado, voc√™
deve usar a fun√ß√£o EventChartCustom().
Breve descri√ß√£o dos eventos da enumera√ß√£o ENUM_CHART_EVENT:
¬∑ CHARTEVENT_KEYDOWN ‚Äî pressionamento do teclado quando a janela do gr√°fico est√° em foco;
¬∑ CHARTEVENT_MOUSE_MOVE ‚Äî deslocamento do mouse e pressionamento dos bot√µes do mouse
(se para o gr√°fico estiver definida a propriedade CHART_EVENT_MOUSE_MOVE=true);
¬∑ CHARTEVENT_OBJECT_CREATE ‚Äî cria√ß√£o do objeto gr√°fico (se para o gr√°fico estiver definida a
propriedade CHART_EVENT_OBJECT_CREATE=true);
¬∑ CHARTEVENT_OBJECT_CHANGE ‚Äî altera√ß√£o das propriedades do objeto atrav√©s do di√°logo de
propriedades;
¬∑ CHARTEVENT_OBJECT_DELETE ‚Äî remo√ß√£o do objeto gr√°fico (se para o gr√°fico estiver definida a
propriedade CHART_EVENT_OBJECT_DELETE=true);
¬∑ CHARTEVENT_CLICK ‚Äî clique do mouse no gr√°fico;
¬∑ CHARTEVENT_OBJECT_CLICK ‚Äî clique do mouse no objeto gr√°fico que pertence ao gr√°fico;
¬∑ CHARTEVENT_OBJECT_DRAG ‚Äî deslocamento do objeto gr√°fico com o mouse;</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1956
¬∑ CHARTEVENT_OBJECT_ENDEDIT ‚Äî fim da edi√ß√£o de texto no campo inserido do objeto gr√°fico
<h3>Edit (OBJ_EDIT);</h3>
¬∑ CHARTEVENT_CHART_CHANGE ‚Äî altera√ß√£o do gr√°fico;
¬∑ CHARTEVENT_CUSTOM+n ‚Äî identificador do evento personalizado, onde n est√° no intervalo de 0 a
65 535. CHARTEVENT_CUSTOM_LAST cont√©m o √∫ltimo identificador v√°lido de evento
personalizado (CHARTEVENT_CUSTOM+65535).
Todos os programas MQL5 trabalham em fluxos diferentes do fluxo principal do aplicativo. O fluxo
principal do terminal √© respons√°vel pelo processamento de todas as mensagens de sistema do
Windows e, como resultado dele, gera mensagens do Windows para seu pr√≥prio aplicativo. Por
exemplo, o deslocamento do mouse no gr√°fico (evento WM_MOUSE_MOVE) gera v√°rias mensagens
de sistema para a plotagem subsequente da janela do aplicativo, bem como envia mensagens
internas para EAs e para indicadores que est√£o sendo executados neste gr√°fico. Neste caso, pode
acontecer que o fluxo principal do aplicativo ainda n√£o consiga processar a mensagem de sistema
WM_PAINT (e, portanto, ainda n√£o plote a gr√°fico alterado), enquanto o EA ou indicador j√° tenha
recebido o evento sobre o movimento do cursor do mouse. Assim, a propriedade do gr√°fico
CHART_FIRST_VISIBLE_BAR ser√° alterada somente ap√≥s a plotagem do gr√°fico.
Para cada tipo de evento, os par√¢metros de entrada da fun√ß√£o OnChartEvent() possuem
determinados valores necess√°rios para manipular este evento. A tabela lista os eventos e valores
que s√£o transferidos atrav√©s dos par√¢metros.
<h3>Evento</h3>
<h3>Valor</h3>
do
par√¢metro id
<h3>Valor</h3>
do
par√¢metro
lparam
<h3>Valor</h3>
do
par√¢metro
dparam
<h3>Valor</h3>
do
par√¢metro
sparam
<h3>Evento</h3>
de
teclado
<h3>CHARTEVENT_KE</h3>
<h3>YDOWN</h3>
c√≥digo de tecla
pressionada
<h3>N√∫mero</h3>
de
pressionamentos
da tecla gerados
durante o tempo
em 
que 
√©
mantida
pressionada
<h3>Valor de string</h3>
da bitmask que
descreve 
o
status 
dos
bot√µes 
do
teclado
<h3>Eventos</h3>
do
mouse (se para
o gr√°fico estiver
definida 
a
propriedade
<h3>CHART_EVENT_</h3>
<h3>MOUSE_MOVE=tr</h3>
ue)
<h3>CHARTEVENT_M</h3>
<h3>OUSE_MOVE</h3>
<h3>Coordenada X</h3>
<h3>Coordenada Y</h3>
<h3>Valor de string</h3>
da bitmask que
descreve 
o
status 
dos
bot√µes do mouse
<h3>Evento da roda</h3>
do mouse 
(se
para o gr√°fico
estiver definida
a 
propriedade
<h3>CHART_EVENT_</h3>
<h3>MOUSE_WHEEL=</h3>
true)
<h3>CHARTEVENT_M</h3>
<h3>OUSE_WHEEL</h3>
<h3>Sinalizadores de</h3>
estados 
das
teclas 
e 
dos
bot√µes 
do
mouse,
coordenadas X e
<h3>Y do cursor. A</h3>
descri√ß√£o √© dada
no exemplo
<h3>Valor Delta de</h3>
rolagem da roda
do mouse
‚Äî</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1957
<h3>Evento</h3>
<h3>Valor</h3>
do
par√¢metro id
<h3>Valor</h3>
do
par√¢metro
lparam
<h3>Valor</h3>
do
par√¢metro
dparam
<h3>Valor</h3>
do
par√¢metro
sparam
<h3>Evento</h3>
de
cria√ß√£o 
do
objeto 
gr√°fico
(se 
para 
o
gr√°fico 
for
definida 
a
propriedade
<h3>CHART_EVENT_</h3>
<h3>OBJECT_CREATE</h3>
=true)
<h3>CHARTEVENT_O</h3>
<h3>BJECT_CREATE</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico criado
<h3>Evento</h3>
de
altera√ß√£o 
das
propriedades do
objeto 
atrav√©s
do di√°logo 
de
propriedades
<h3>CHARTEVENT_O</h3>
<h3>BJECT_CHANGE</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico alterado
<h3>Evento</h3>
de
remo√ß√£o 
do
objeto 
gr√°fico
(se 
para 
o
gr√°fico 
estiver
definida 
a
propriedade
<h3>CHART_EVENT_</h3>
<h3>OBJECT_DELETE</h3>
=true)
<h3>CHARTEVENT_O</h3>
<h3>BJECT_DELETE</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico exclu√≠do
<h3>Evento de clique</h3>
no gr√°fico
<h3>CHARTEVENT_C</h3>
<h3>LICK</h3>
<h3>Coordenada X</h3>
<h3>Coordenada Y</h3>
‚Äî
<h3>Evento de clique</h3>
do 
mouse 
no
objeto gr√°fico
<h3>CHARTEVENT_O</h3>
<h3>BJECT_CLICK</h3>
<h3>Coordenada X</h3>
<h3>Coordenada Y</h3>
<h3>Nome do objeto</h3>
gr√°fico no qual
ocorreu o evento
<h3>Evento</h3>
de
movimento 
do
objeto 
gr√°fico
com o mouse
<h3>CHARTEVENT_O</h3>
<h3>BJECT_DRAG</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico movido
<h3>Evento de fim</h3>
da 
edi√ß√£o 
de
texto no campo
inserido 
do
objeto 
gr√°fico
&quot;Caixa 
de
edi√ß√£o&quot;
<h3>CHARTEVENT_O</h3>
<h3>BJECT_ENDEDIT</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico &quot;Campo
de entrada&quot; no
qual 
foi
conclu√≠da 
a
edi√ß√£o de texto</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1958
<h3>Evento</h3>
<h3>Valor</h3>
do
par√¢metro id
<h3>Valor</h3>
do
par√¢metro
lparam
<h3>Valor</h3>
do
par√¢metro
dparam
<h3>Valor</h3>
do
par√¢metro
sparam
<h3>Evento</h3>
de
redimensioname
nto do gr√°fico
ou altera√ß√£o das
propriedades do
gr√°fico atrav√©s
do di√°logo 
de
propriedades
<h3>CHARTEVENT_C</h3>
<h3>HART_CHANGE</h3>
‚Äî
‚Äî
‚Äî
<h3>Evento</h3>
personalizado
com n√∫mero N
<h3>CHARTEVENT_C</h3>
<h3>USTOM+N</h3>
<h3>Valor</h3>
definido
pela 
fun√ß√£o
<h3>EventChartCusto</h3>
m()
<h3>Valor</h3>
definido
pela 
fun√ß√£o
<h3>EventChartCusto</h3>
m()
<h3>Valor</h3>
definido
pela 
fun√ß√£o
<h3>EventChartCusto</h3>
m()
Exemplo de um ouvinte dos eventos do gr√°fico:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                          OnChartEvent_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo do ouvinte dos eventos do gr√°fico e do gerador de event
//--- identificadores das teclas Enter, Shift, Caps Lock, Space, Backspace, Ctrl, Alt 
#define KEY_NUMPAD_5       12
#define KEY_LEFT           37
#define KEY_UP             38
#define KEY_RIGHT          39
#define KEY_DOWN           40
#define KEY_NUMLOCK_DOWN   98
#define KEY_NUMLOCK_LEFT  100
#define KEY_NUMLOCK_5     101
#define KEY_NUMLOCK_RIGHT 102
#define KEY_NUMLOCK_UP    104
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- exibimos o valor da constante CHARTEVENT_CUSTOM
   Print(&quot;CHARTEVENT_CUSTOM=&quot;,CHARTEVENT_CUSTOM);
//---
   Print(&quot;Executado o EA com nome &quot;,MQLInfoString(MQL5_PROGRAM_NAME));
//--- definindo o sinalizador de recep√ß√£o dos eventos de cria√ß√£o de objetos do gr√°fico</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1959
</p>
<pre><code class="language-mql5">
   ChartSetInteger(ChartID(),CHART_EVENT_OBJECT_CREATE,true);
//--- definindo o sinalizador de recep√ß√£o dos eventos de remo√ß√£o de objetos do gr√°fico
   ChartSetInteger(ChartID(),CHART_EVENT_OBJECT_DELETE,true);
//--- ativa√ß√£o da mensagem de rolagem de roda do mouse
   ChartSetInteger(0,CHART_EVENT_MOUSE_WHEEL,1);
//--- a atualiza√ß√£o for√ßada das propriedades do gr√°fico garante a prontid√£o para o pro
   ChartRedraw();
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- contador de ticks para gerar o evento personalizado
   static int tick_counter=0;
//--- vamos dividir os ticks acumulados por este n√∫mero
   int simple_number=113;
//--- 
   tick_counter++;
//--- enviamos o m evento personalizado se o contador de ticks for um m√∫ltiplo de simp
   if(tick_counter%simple_number==0)
     {
      //--- formaremos o identificador do evento personalizado no intervalo de 0 a 655
      ushort custom_event_id=ushort(tick_counter%65535);
      //---  enviamos um evento personalizado com preenchimento dos par√¢metros
      EventChartCustom(ChartID(),custom_event_id,tick_counter,SymbolInfoDouble(Symbol
      //--- fazemos a exibi√ß√£o do log para estudar e analisar os resultados do exemplo
      Print(__FUNCTION__,&quot;: Evento personalizado enviado com ID=&quot;,custom_event_id);
     }
//---     
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &amp;lparam,
                  const double &amp;dparam,
                  const string &amp;sparam)
  {
//--- pressionamento de tecla
   if(id==CHARTEVENT_KEYDOWN)
     {
      switch((int)lparam)
        {
         case KEY_NUMLOCK_LEFT:  Print(&quot;KEY_NUMLOCK_LEFT pressionado&quot;);   break;
         case KEY_LEFT:          Print(&quot;KEY_LEFT pressionado&quot;);           break;
         case KEY_NUMLOCK_UP:    Print(&quot;KEY_NUMLOCK_UP pressionado&quot;);     break;</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1960
</p>
<pre><code class="language-mql5">
         case KEY_UP:            Print(&quot;KEY_UP pressionado&quot;);             break;
         case KEY_NUMLOCK_RIGHT: Print(&quot;KEY_NUMLOCK_RIGHT pressionado&quot;);  break;
         case KEY_RIGHT:         Print(&quot;KEY_RIGHT pressionado&quot;);          break;
         case KEY_NUMLOCK_DOWN:  Print(&quot;KEY_NUMLOCK_DOWN pressionado&quot;);   break;
         case KEY_DOWN:          Print(&quot;KEY_DOWN pressionado&quot;);           break;
         case KEY_NUMPAD_5:      Print(&quot;KEY_NUMPAD_5 pressionado&quot;);       break;
         case KEY_NUMLOCK_5:     Print(&quot;KEY_NUMLOCK_5 pressionado&quot;);      break;
         default:                Print(&quot;Tecla n√£o listada pressionada&quot;);
        }
     }
//--- clique com o bot√£o esquerdo do mouse no gr√°fico
   if(id==CHARTEVENT_CLICK)
      Print(&quot;Coordenadas do clique do mouse no gr√°fico: x = &quot;,lparam,&quot;  y = &quot;,dparam);
//--- clique no objeto gr√°fico
   if(id==CHARTEVENT_OBJECT_CLICK)
      Print(&quot;Clique no objeto com nome &#x27;&quot;+sparam+&quot;&#x27;&quot;);
//--- objeto exclu√≠do
   if(id==CHARTEVENT_OBJECT_DELETE)
      Print(&quot;Exclu√≠do objeto com nome &quot;,sparam);
//--- objeto criado
   if(id==CHARTEVENT_OBJECT_CREATE)
      Print(&quot;Criado objeto com nome &quot;,sparam);
//--- objeto alterado
   if(id==CHARTEVENT_OBJECT_CHANGE)
      Print(&quot;Alterado objeto com nome &quot;,sparam);
//--- objeto deslocado ou coordenadas dos pontos de ancoragem alteradas
   if(id==CHARTEVENT_OBJECT_DRAG)
      Print(&quot;Altera√ß√£o de pontos de ancoragem do objeto com nome &quot;,sparam);
//--- alterado o texto no campo inserido do objeto gr√°fico Edit
   if(id==CHARTEVENT_OBJECT_ENDEDIT)
      Print(&quot;Alterado o texto no objeto Edit &quot;,sparam,&quot;  id=&quot;,id);
//--- eventos de movimento do mouse
   if(id==CHARTEVENT_MOUSE_MOVE)
      Comment(&quot;POINT: &quot;,(int)lparam,&quot;,&quot;,(int)dparam,&quot;\n&quot;,MouseState((uint)sparam));
   if(id==CHARTEVENT_MOUSE_WHEEL)
     {
      //--- analisemos o estado dos bot√µes e da roda do mouse para este evento
      int flg_keys = (int)(lparam&gt;&gt;32);          // sinalizador de estado de teclas Ct
      int x_cursor = (int)(short)lparam;         // coordenada X, em que acontece o ev
      int y_cursor = (int)(short)(lparam&gt;&gt;16);   // coordenada Y, em que acontece o ev
      int delta    = (int)dparam;                // valor total de rolagem da roda, √© 
      //--- processamos o sinalizador 
      string str_keys=&quot;&quot;;
      if((flg_keys&amp;0x0001)!=0)
         str_keys+=&quot;LMOUSE &quot;;
      if((flg_keys&amp;0x0002)!=0)
         str_keys+=&quot;RMOUSE &quot;;
      if((flg_keys&amp;0x0004)!=0)
         str_keys+=&quot;SHIFT &quot;;</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1961
</p>
<pre><code class="language-mql5">
      if((flg_keys&amp;0x0008)!=0)
         str_keys+=&quot;CTRL &quot;;
      if((flg_keys&amp;0x0010)!=0)
         str_keys+=&quot;MMOUSE &quot;;
      if((flg_keys&amp;0x0020)!=0)
         str_keys+=&quot;X1MOUSE &quot;;
      if((flg_keys&amp;0x0040)!=0)
         str_keys+=&quot;X2MOUSE &quot;;
      if(str_keys!=&quot;&quot;)
         str_keys=&quot;, keys=&#x27;&quot;+StringSubstr(str_keys,0,StringLen(str_keys)-1)+&quot;&#x27;&quot;;
      PrintFormat(&quot;%s: X=%d, Y=%d, delta=%d%s&quot;,EnumToString(CHARTEVENT_MOUSE_WHEEL),x_
     }
//--- redimensionando o gr√°fico ou alterando as propriedades do gr√°fico atrav√©s do di√°
   if(id==CHARTEVENT_CHART_CHANGE)
      Print(&quot;Redimensionamento ou altera√ß√£o das propriedades do gr√°fico&quot;);
//--- evento personalizado
   if(id&gt;CHARTEVENT_CUSTOM)
      PrintFormat(&quot;Evento personalizado ID=%d, lparam=%d, dparam=%G, sparam=%s&quot;,id,lpa
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| MouseState                                                       |
//+------------------------------------------------------------------+
string MouseState(uint state)
  {
   string res;
   res+=&quot;\nML: &quot;   +(((state&amp; 1)== 1)?&quot;DN&quot;:&quot;UP&quot;);   // mouse left
   res+=&quot;\nMR: &quot;   +(((state&amp; 2)== 2)?&quot;DN&quot;:&quot;UP&quot;);   // mouse right 
   res+=&quot;\nMM: &quot;   +(((state&amp;16)==16)?&quot;DN&quot;:&quot;UP&quot;);   // mouse middle
   res+=&quot;\nMX: &quot;   +(((state&amp;32)==32)?&quot;DN&quot;:&quot;UP&quot;);   // mouse first X key
   res+=&quot;\nMY: &quot;   +(((state&amp;64)==64)?&quot;DN&quot;:&quot;UP&quot;);   // mouse second X key
   res+=&quot;\nSHIFT: &quot;+(((state&amp; 4)== 4)?&quot;DN&quot;:&quot;UP&quot;);   // shift key
   res+=&quot;\nCTRL: &quot; +(((state&amp; 8)== 8)?&quot;DN&quot;:&quot;UP&quot;);   // control key
   return(res);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
EventChartCustom, Tipos de eventos do gr√°fico, Fun√ß√µes de processamento de eventos, Execu√ß√£o
do programa, Evento do terminal do cliente</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1962
<h3>OnTester</h3>
√â chamada em EAs quando ocorre o evento Tester para executar as a√ß√µes necess√°rias no final do
teste.
</p>
<pre><code class="language-mql5">
double¬† OnTester(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
Valor de um crit√©rio de otimiza√ß√£o personalizado para avaliar os resultados do teste.  
<h3>Observa√ß√£o</h3>
A fun√ß√£o OnTester() s√≥ pode ser usada em EAs durante o teste e √© projetada principalmente para
calcular um determinado valor a ser usado como crit√©rio &quot;Custom max&quot; ao otimizar par√¢metros de
entrada.
Durante a otimiza√ß√£o gen√©tica, a classifica√ß√£o de resultados numa gera√ß√£o √© feita em ordem
decrescente. Isso significa que, do ponto de vista do crit√©rio de otimiza√ß√£o, os melhores s√£o os
resultados com o maior valor. Os piores valores para esta classifica√ß√£o s√£o colocados no final e,
posteriormente, descartados, n√£o participando da forma√ß√£o da pr√≥xima gera√ß√£o.
Assim, usando a fun√ß√£o OnTester(), voc√™ pode n√£o apenas criar e salvar seus pr√≥prios relat√≥rios de
resultados de testes, mas tamb√©m controlar o processo de otimiza√ß√£o para encontrar os melhores
par√¢metros da estrat√©gia de negocia√ß√£o.
Exemplo de c√°lculo de um crit√©rio de otimiza√ß√£o personalizado. A ideia √© calcular a regress√£o linear do
gr√°fico de saldo descrita no artigo Otimizando uma estrat√©gia usando o gr√°fico do saldo e comparando
os resultados com o crit√©rio &quot;Balance + max Sharpe Ratio&quot;
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                              OnTester_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo de EA com manipulador OnTester()&quot;
#property description &quot;Como crit√©rio de otimiza√ß√£o personalizado &quot;
#property description &quot;√© retornado o coeficiente de regress√£o linear do gr√°fico de sal
#property description &quot;dividido pelo erro quadr√°tico m√©dio do desvio&quot;
//--- conectamos a classe de opera√ß√µes de negocia√ß√£o
#include &lt;Trade\Trade.mqh&gt;
//--- par√¢metros de entrada do EA
input double Lots               = 0.1;     // Volume
input int    Slippage           = 10;      // Derrapagem admiss√≠vel
input int    MovingPeriod       = 80;      // Per√≠odo de m√©dia m√≥vel
input int    MovingShift        = 6;       // Deslocamento de m√©dia m√≥vel
//--- vari√°veis globais
int    IndicatorHandle=0;  // identificador do indicador
bool   IsHedging=false;    //sinal da conta </p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1963
CTrade trade;              // para realizar opera√ß√µes de negocia√ß√£o
</p>
<pre><code class="language-mql5">
//--- 
#define EA_MAGIC 18052018
//+------------------------------------------------------------------+
//| Verificando as condi√ß√µes para abertura da posi√ß√£o                |
//+------------------------------------------------------------------+
void CheckForOpen(void)
  {
   MqlRates rt[2];
//--- negociamos apenas no in√≠cio da barra nova
   if(CopyRates(_Symbol,_Period,0,2,rt)!=2)
     {
      Print(&quot;CopyRates of &quot;,_Symbol,&quot; failed, no history&quot;);
      return;
     }
//--- volume de ticks
   if(rt[1].tick_volume&gt;1)
      return;
//--- obtemos os valores da m√©dia m√≥vel
   double   ma[1];
   if(CopyBuffer(IndicatorHandle,0,1,1,ma)!=1)
     {
      Print(&quot;CopyBuffer from iMA failed, no data&quot;);
      return;
     }
//--- verificamos a presen√ßa do sinal
   ENUM_ORDER_TYPE signal=WRONG_VALUE;
//--- a vela se abriu mais alto, mas fechou abaixo da m√©dia m√≥vel
   if(rt[0].open&gt;ma[0] &amp;&amp; rt[0].close&lt;ma[0])
      signal=ORDER_TYPE_BUY;    // sinal de compra
   else // a vela se abriu mais abaixo, mas fechou acima da m√©dia m√≥vel
     {
      if(rt[0].open&lt;ma[0] &amp;&amp; rt[0].close&gt;ma[0])
         signal=ORDER_TYPE_SELL;// sinal de venda
     }
//--- verifica√ß√µes adicionais
   if(signal!=WRONG_VALUE)
     {
      if(TerminalInfoInteger(TERMINAL_TRADE_ALLOWED) &amp;&amp; Bars(_Symbol,_Period)&gt;100)
        {
         double price=SymbolInfoDouble(_Symbol,signal==ORDER_TYPE_SELL ? SYMBOL_BID:SY
         trade.PositionOpen(_Symbol,signal,Lots,price,0,0);
        }
     }
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Verificando as condi√ß√µes de fechamento da posi√ß√£o                |
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1964
</p>
<pre><code class="language-mql5">
void CheckForClose(void)
  {
   MqlRates rt[2];
//--- negociamos apenas no in√≠cio da barra nova
   if(CopyRates(_Symbol,_Period,0,2,rt)!=2)
     {
      Print(&quot;CopyRates of &quot;,_Symbol,&quot; failed, no history&quot;);
      return;
     }
   if(rt[1].tick_volume&gt;1)
      return;
//--- obtemos os valores da m√©dia m√≥vel
   double   ma[1];
   if(CopyBuffer(IndicatorHandle,0,1,1,ma)!=1)
     {
      Print(&quot;CopyBuffer from iMA failed, no data&quot;);
      return;
     }
//--- posi√ß√£o j√° foi selecionada usando PositionSelect()
   bool signal=false;
   long type=PositionGetInteger(POSITION_TYPE);
//--- a vela se abriu mais acima, mas fechou abaixo da m√©dia m√≥vel - fechamos a posi√ß√£
   if(type==(long)POSITION_TYPE_SELL &amp;&amp; rt[0].open&gt;ma[0] &amp;&amp; rt[0].close&lt;ma[0])
      signal=true;
//--- a vela se abriu mais abaixo, mas fechou acima da m√©dia m√≥vel - fechamos a posi√ß√£
   if(type==(long)POSITION_TYPE_BUY &amp;&amp; rt[0].open&lt;ma[0] &amp;&amp; rt[0].close&gt;ma[0])
      signal=true;
//--- verifica√ß√µes adicionais
   if(signal)
     {
      if(TerminalInfoInteger(TERMINAL_TRADE_ALLOWED) &amp;&amp; Bars(_Symbol,_Period)&gt;100)
         trade.PositionClose(_Symbol,Slippage);
     }
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Selecionamos a posi√ß√£o com base no tipo de conta: Netting ou Hedging        
//+------------------------------------------------------------------+
bool SelectPosition()
  {
   bool res=false;
//--- sele√ß√£o da posi√ß√£o para a conta Hedging
   if(IsHedging)
     {
      uint total=PositionsTotal();
      for(uint i=0; i&lt;total; i++)
        {
         string position_symbol=PositionGetSymbol(i);
         if(_Symbol==position_symbol &amp;&amp; EA_MAGIC==PositionGetInteger(POSITION_MAGIC))</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1965
</p>
<pre><code class="language-mql5">
           {
            res=true;
            break;
           }
        }
     }
//--- sele√ß√£o da posi√ß√£o para a conta Netting
   else
     {
      if(!PositionSelect(_Symbol))
         return(false);
      else
         return(PositionGetInteger(POSITION_MAGIC)==EA_MAGIC); //---verifica√ß√£o do Mag
     }
//--- resultado da execu√ß√£o
   return(res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit(void)
  {
//--- definimos o tipo de negocia√ß√£o: Netting ou Hedging
   IsHedging=((ENUM_ACCOUNT_MARGIN_MODE)AccountInfoInteger(ACCOUNT_MARGIN_MODE)==ACCOU
//--- inicializamos o objeto para o controle correto das posi√ß√µes
   trade.SetExpertMagicNumber(EA_MAGIC);
   trade.SetMarginMode();
   trade.SetTypeFillingBySymbol(Symbol());
   trade.SetDeviationInPoints(Slippage);
//--- criamos o indicador Moving Average
   IndicatorHandle=iMA(_Symbol,_Period,MovingPeriod,MovingShift,MODE_SMA,PRICE_CLOSE);
   if(IndicatorHandle==INVALID_HANDLE)
     {
      printf(&quot;Erro ao criar o indicador iMA&quot;);
      return(INIT_FAILED);
     }
//--- ok
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick(void)
  {
//--- se a posi√ß√£o j√° estiver aberta, verificamos condi√ß√£o de fechamento
   if(SelectPosition())
      CheckForClose();
// verificamos a condi√ß√£o para abertura da posi√ß√£o
   CheckForOpen();</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1966
</p>
<pre><code class="language-mql5">
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Tester function                                                  |
//+------------------------------------------------------------------+
double OnTester()
  {
//--- valor do crit√©rio de otimiza√ß√£o personalizado (quanto mais, melhor)
   double ret=0.0;
//--- obtemos os resultados dos trades na matriz
   double array[];
   double trades_volume;
   GetTradeResultsToArray(array,trades_volume);
   int trades=ArraySize(array);
//--- se h√° menos de 10 trades, o teste n√£o gerou resultados positivos
   if(trades&lt;10)
      return (0);
//--- resultado m√©dio no trade
   double average_pl=0;
   for(int i=0;i&lt;ArraySize(array);i++)
      average_pl+=array[i];
   average_pl/=trades;
//--- exibimos uma mensagem para o modo de teste √∫nico
   if(MQLInfoInteger(MQL_TESTER) &amp;&amp; !MQLInfoInteger(MQL_OPTIMIZATION))
      PrintFormat(&quot;%s: Trades=%d, Lucro m√©dio=%.2f&quot;,__FUNCTION__,trades,average_pl);
//--- calculamos os coeficientes de regress√£o linear para o gr√°fico de lucro
   double a,b,std_error;
   double chart[];
   if(!CalculateLinearRegression(array,chart,a,b))
      return (0);
//--- calculamos o erro de desvio do gr√°fico em rela√ß√£o √† linha de regress√£o
   if(!CalculateStdError(chart,a,b,std_error))
      return (0);
//--- calculamos o r√°cio do lucro de tend√™ncia em rela√ß√£o ao desvio padr√£o
   ret=(std_error == 0.0) ? a*trades : a*trades/std_error;
//--- retornamos o valor do crit√©rio de otimiza√ß√£o personalizado
   return(ret);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Obtendo a matriz de lucros/perdas de transa√ß√µes                  |
//+------------------------------------------------------------------+
bool GetTradeResultsToArray(double &amp;pl_results[],double &amp;volume)
  {
//--- consultamos o hist√≥rico de negocia√ß√£o completo
   if(!HistorySelect(0,TimeCurrent()))
      return (false);
   uint total_deals=HistoryDealsTotal();
   volume=0;
//--- definimos o tamanho inicial da matriz pelo n√∫mero de transa√ß√µes no hist√≥rico</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1967
</p>
<pre><code class="language-mql5">
   ArrayResize(pl_results,total_deals);
//--- contador de trades que fixam o resultado da negocia√ß√£o - lucro ou perda
   int counter=0;
   ulong ticket_history_deal=0;
//--- passar por todos os trades
   for(uint i=0;i&lt;total_deals;i++)
     {
      //--- selecionamos o trade 
      if((ticket_history_deal=HistoryDealGetTicket(i))&gt;0)
        {
         ENUM_DEAL_ENTRY deal_entry  =(ENUM_DEAL_ENTRY)HistoryDealGetInteger(ticket_hi
         long            deal_type   =HistoryDealGetInteger(ticket_history_deal,DEAL_T
         double          deal_profit =HistoryDealGetDouble(ticket_history_deal,DEAL_PR
         double          deal_volume =HistoryDealGetDouble(ticket_history_deal,DEAL_VO
         //--- estamos interessados apenas em opera√ß√µes de negocia√ß√£o        
         if((deal_type!=DEAL_TYPE_BUY) &amp;&amp; (deal_type!=DEAL_TYPE_SELL))
            continue;
         //--- somente trades com fixa√ß√£o de lucro/perda
         if(deal_entry!=DEAL_ENTRY_IN)
           {
            //--- escrevemos o resultado da negocia√ß√£o na matriz e aumentamos o contad
            pl_results[counter]=deal_profit;
            volume+=deal_volume;
            counter++;
           }
        }
     }
//--- definimos o tamanho final da matriz
   ArrayResize(pl_results,counter);
   return (true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Calculando a regress√£o linear de tipo y=a*x+b                    |
//+------------------------------------------------------------------+
bool CalculateLinearRegression(double  &amp;change[],double &amp;chartline[],
                               double  &amp;a_coef,double  &amp;b_coef)
  {
//--- verificamos se h√° suficientes dados
   if(ArraySize(change)&lt;3)
      return (false);
//--- criamos a matriz do gr√°fico com acumula√ß√£o
   int N=ArraySize(change);
   ArrayResize(chartline,N);
   chartline[0]=change[0];
   for(int i=1;i&lt;N;i++)
      chartline[i]=chartline[i-1]+change[i];
//--- agora calculamos os coeficientes de regress√£o
   double x=0,y=0,x2=0,xy=0;
   for(int i=0;i&lt;N;i++)</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1968
</p>
<pre><code class="language-mql5">
     {
      x=x+i;
      y=y+chartline[i];
      xy=xy+i*chartline[i];
      x2=x2+i*i;
     }
   a_coef=(N*xy-x*y)/(N*x2-x*x);
   b_coef=(y-a_coef*x)/N;
//---
   return (true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Calcula o erro quadr√°tico m√©dio do desvio para os a e b definidos    
//+------------------------------------------------------------------+
bool  CalculateStdError(double  &amp;data[],double  a_coef,double  b_coef,double &amp;std_err)
  {
//--- soma dos quadrados dos erros
   double error=0;
   int N=ArraySize(data);
   if(N&lt;=2)
      return (false);
   for(int i=0;i&lt;N;i++)
      error+=MathPow(a_coef*i+b_coef-data[i],2);
   std_err=MathSqrt(error/(N-2));
//--- 
   return (true);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
Teste de estrat√©gias de negocia√ß√£o, TesterHideIndicators, Trabalhando com os resultados da
otimiza√ß√£o, 
<h3>TesterStatistics,</h3>
<h3>OnTesterInit,</h3>
<h3>OnTesterDeinit,</h3>
<h3>OnTesterPass,</h3>
<h3>MQL_TESTER,</h3>
<h3>MQL_OPTIMIZATION, FileOpen, FileWrite, FileLoad, FileSave</h3></p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1969
<h3>OnTesterInit</h3>
√â chamada em EAs quando ocorre o evento TesterInit para executar as a√ß√µes necess√°rias antes do
in√≠cio da otimiza√ß√£o no testador de estrat√©gia. Existem duas vers√µes da fun√ß√£o.
<h3>Vers√£o com retorno de resultado</h3>
</p>
<pre><code class="language-mql5">
int¬† OnTesterInit(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
Valor do tipo int, zero significa inicializa√ß√£o bem-sucedida do EA em execu√ß√£o no gr√°fico antes do
in√≠cio da otimiza√ß√£o.
O uso da chamada da OnTesterInit() com o retorno de resultado √© prioridade, pois este m√©todo
permite n√£o apenas inicializar o programa, mas tamb√©m retornar o c√≥digo de erro em caso de t√©rmino
antecipado da otimiza√ß√£o. Retorno de qualquer valor diferente de INIT_SUCCEEDED (0) significa um
erro e n√£o ser√° inicializada a otimiza√ß√£o.
Vers√£o sem retorno do resultado √© deixada apenas para compatibilidade com c√≥digos antigos. N√£o √©
recomendada
</p>
<pre><code class="language-mql5">
void¬† OnTesterInit(void);
</code></pre>
<p>
<h3>Observa√ß√£o</h3>
O evento TesterInit √© gerado automaticamente antes do in√≠cio da otimiza√ß√£o do EA no testador de
estrat√©gias.Para esse evento, o EA com manipulador OnTesterDeinit() e/ou OnTesterPass() √©
carregado automaticamente num gr√°fico de terminal separado com o s√≠mbolo e o per√≠odo
especificados no testador. 
Esse EA recebe os eventos TesterInit, TesterDeinit e TesterPass, mas, n√£o, os eventos Init, Deinit e
NewTick. Assim, toda l√≥gica necess√°ria para processar os resultados de cada passagem durante a
otimiza√ß√£o deve ser implementada nos manipuladores OnTesterInit(), OnTesterDeinit() e
OnTesterPass(). 
O resultado de cada passagem √∫nica ao otimizar uma estrat√©gia pode ser passado por um quadro a
partir do manipulador OnTester() com a ajuda da fun√ß√£o FrameAdd(). 
A fun√ß√£o OnTesterInit() se destina a inicializar o EA antes de iniciar a otimiza√ß√£o para o seguinte
processamento de resultados de otimiza√ß√£o. √â sempre usada em conjunto com o manipulador
OnTesterDeinit().
√Ä execu√ß√£o da OnTesterInit() √© atribu√≠do um tempo limitado, ap√≥s o qual o trabalho do EA √©
for√ßadamente conclu√≠do, e, consequentemente, √© cancelada a pr√≥pria otimiza√ß√£o. Nesse caso, uma
mensagem √© exibida no log do testador:
TesterOnTesterInit works too long. Tester cannot be initialized.
Exemplo tirado da OnTick, adicionado o manipulador OnTesterInit() para definir os par√¢metros de
otimiza√ß√£o:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                          OnTesterInit_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1970
</p>
<pre><code class="language-mql5">
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Exemplo de EA com manipulador OnTesterInit()&quot;
#property description &quot;em que s√£o definidos valores e limites &quot;
#property description &quot;de par√¢metros de entrada ao otimizar&quot;
input double lots=0. 1;       // volume em lotes
input double kATR=3;          // tamanho da vela de sinal no ATR
input int    ATRperiod=20;    // per√≠odo do indicador ATR
input int    holdbars=8;      // n√∫mero de barras para manter a posi√ß√£o
input int    slippage=10;     // derrapagem admiss√≠vel
input bool   revers=false;    // invertemos o sinal? 
input ulong  EXPERT_MAGIC=0;  // MagicNumber do EA
//--- para armazenar o identificador do indicador ATR
int atr_handle;
//--- aqui vamos armazenar os √∫ltimos valores do ATR e o corpo da vela
double last_atr,last_body;
</code></pre>
<p>
datetime lastbar_timeopen;
</p>
<pre><code class="language-mql5">
double trade_lot;
//--- lembramo-nos da hora de in√≠cio da otimiza√ß√£o
</code></pre>
<p>
datetime optimization_start;
</p>
<pre><code class="language-mql5">
//--- para exibir no gr√°fico a dura√ß√£o ap√≥s o final da otimiza√ß√£o
string report;
//+------------------------------------------------------------------+
//| TesterInit function                                              |
//+------------------------------------------------------------------+
void OnTesterInit()
  {
//--- definimos os valores dos par√¢metros de entrada para a otimiza√ß√£o
   ParameterSetRange(&quot;lots&quot;,false,0.1,0,0,0);
   ParameterSetRange(&quot;kATR&quot;,true,3.0,1.0,0.3,7.0);
   ParameterSetRange(&quot;ATRperiod&quot;,true,10,15,1,30);
   ParameterSetRange(&quot;holdbars&quot;,true,5,3,1,15);
   ParameterSetRange(&quot;slippage&quot;,false,10,0,0,0);
   ParameterSetRange(&quot;revers&quot;,true,false,false,1,true);
   ParameterSetRange(&quot;EXPERT_MAGIC&quot;,false,123456,0,0,0);
   Print(&quot;Definidos os valores iniciais e limites dos par√¢metros de otimiza√ß√£o&quot;);
//--- lembramo-nos do in√≠cio da otimiza√ß√£o
   optimization_start=TimeLocal();
   report=StringFormat(&quot;%s: otimiza√ß√£o iniciada em %s&quot;,
                       __FUNCTION__,TimeToString(TimeLocal(),TIME_MINUTES|TIME_SECONDS
//--- exibimos uma mensagem no gr√°fico e no log do terminal
   Print(report);
   Comment(report);
//---   
</code></pre>
<p>
  }</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1971
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| TesterDeinit function                                            |
//+------------------------------------------------------------------+
void OnTesterDeinit()
  {
//--- dura√ß√£o da otimiza√ß√£o
   string log_message=StringFormat(&quot;%s: a otimiza√ß√£o demorou %d segundos&quot;,
                                   __FUNCTION__,TimeLocal()-optimization_start);
   PrintFormat(log_message);
   report=report+&quot;\r\n&quot;+log_message;
   Comment(report);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- inicializamos as vari√°veis globais
   last_atr=0;
   last_body=0;
//--- definimos o volume correto
   double min_lot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   trade_lot=lots&gt;min_lot? lots:min_lot;   
//--- criamos o identificador do indicador ATR
   atr_handle=iATR(_Symbol,_Period,ATRperiod);
   if(atr_handle==INVALID_HANDLE)
     {
      PrintFormat(&quot;%s: n√£o foi poss√≠vel criar o iATR, c√≥digo de erro %d&quot;,__FUNCTION__,
      return(INIT_FAILED);
     }
//--- inicializa√ß√£o bem-sucedida do EA
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- sinal de negocia√ß√£o
   static int signal=0; // +1 significa um sinal de compra, -1 significa um sinal de v
//--- verificamos e fechamos as posi√ß√µes abertas antigas, abertas h√° mais de holdbars 
   ClosePositionsByBars(holdbars,slippage,EXPERT_MAGIC);
//--- verificamos o surgimento de uma nova barra
   if(isNewBar())
     {
      //--- verificamos a presen√ßa de sinal      
      signal=CheckSignal();
     }
//--- se aberta uma posi√ß√£o de &#x27;netting&#x27;, ignoramos o sinal e esperamos at√© que ele fe</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1972
</p>
<pre><code class="language-mql5">
   if(signal!=0 &amp;&amp; PositionsTotal()&gt;0 &amp;&amp; (ENUM_ACCOUNT_MARGIN_MODE)AccountInfoInteger
     {
      signal=0;
      return; // sa√≠mos do manipulador de eventos NewTick e n√£o entramos no mercado at
     }
//--- para contas de cobertura (&#x27;hedge&#x27;), casa posi√ß√£o tem vida e fecha separadamente
   if(signal!=0)
     {
      //--- sinal de compra
      if(signal&gt;0)
        {
         PrintFormat(&quot;%s: Existe um sinal de compra! Revers=%s&quot;,__FUNCTION__,string(re
         if(Buy(trade_lot,slippage,EXPERT_MAGIC))
            signal=0;
        }
      //--- sinal de venda
      if(signal&lt;0)
        {
         PrintFormat(&quot;%s: Existe um sinal de venda! Revers=%s&quot;,__FUNCTION__,string(rev
         if(Sell(trade_lot,slippage,EXPERT_MAGIC))
            signal=0;
        }
     }
//--- fim da fun√ß√£o OnTick
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Verificando se √° sinal de negocia√ß√£o                             |
//+------------------------------------------------------------------+
int CheckSignal()
  {
//--- 0 significa que n√£o h√° sinal
   int res=0;
//--- obtemos o valor do ATR na pen√∫ltima barra conclu√≠da (o √≠ndice da barra igual a 2
   double atr_value[1];
   if(CopyBuffer(atr_handle,0,2,1,atr_value)!=-1)
     {
      last_atr=atr_value[0];
      //--- recebemos os dados da √∫ltima barra fechada numa matriz do tipo MqlRates
      MqlRates bar[1];
      if(CopyRates(_Symbol,_Period,1,1,bar)!=-1)
        {
         //--- calculamos o tamanho do corpo da barra na √∫ltima barra fechada
         last_body=bar[0].close-bar[0].open;
         //--- se o corpo da √∫ltima barra (com √≠ndice 1) exceder o valor anterior do A
         if(MathAbs(last_body)&gt;kATR*last_atr)
            res=last_body&gt;0?1:-1; // para a leva altista um valor positivo
        }
      else
         PrintFormat(&quot;%s: N√£o foi poss√≠vel obter a √∫ltima barra! Erro&quot;,__FUNCTION__,Ge</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1973
</p>
<pre><code class="language-mql5">
     }
   else
      PrintFormat(&quot;%s: N√£o foi poss√≠vel obter o valor do indicador ATR! Erro&quot;,__FUNCTI
//--- se estiver ativado o modo de negocia√ß√£o de revers√£o
   res=revers?-res:res;  // se necess√°rio, revertemos o sinal (em vez de 1, retornamos
//--- retornamos o valor do sinal de negocia√ß√£o
   return (res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Retornando true quando aparece uma nova barra                   |
//+------------------------------------------------------------------+
bool isNewBar(const bool print_log=true)
  {
   static datetime bartime=0; // armazenamos o tempo de abertura da barra atual
//--- obtemos o tempo de abertura da barra zero
   datetime currbar_time=iTime(_Symbol,_Period,0);
//--- se o tempo de abertura mudar, √© porque apareceu uma nova barra
   if(bartime!=currbar_time)
     {
      bartime=currbar_time;
      lastbar_timeopen=bartime;
      //--- exibir no log informa√ß√µes sobre o tempo de abertura da nova barra      
      if(print_log &amp;&amp; !(MQLInfoInteger(MQL_OPTIMIZATION)||MQLInfoInteger(MQL_TESTER)))
        {
         //--- exibimos uma mensagem sobre o tempo de abertura da nova barra
         PrintFormat(&quot;%s: new bar on %s %s opened at %s&quot;,__FUNCTION__,_Symbol,
                     StringSubstr(EnumToString(_Period),7),
                     TimeToString(TimeCurrent(),TIME_SECONDS));
         //--- obtemos os dados do √∫ltimo tick
         MqlTick last_tick;
         if(!SymbolInfoTick(Symbol(),last_tick))
            Print(&quot;SymbolInfoTick() failed, error = &quot;,GetLastError());
         //--- exibimos o tempo do √∫ltimo tick em segundos
         PrintFormat(&quot;Last tick was at %s.%03d&quot;,
                     TimeToString(last_tick.time,TIME_SECONDS),last_tick.time_msc%1000
        }
      //--- temos uma nova barra
      return (true);
     }
//--- n√£o h√° nenhuma barra nova
   return (false);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Comprando a mercado com o volume especificado                    |
//+------------------------------------------------------------------+
bool Buy(double volume,ulong deviation=10,ulong  magicnumber=0)
  {
//--- compramos a mercado
   return (MarketOrder(ORDER_TYPE_BUY,volume,deviation,magicnumber));</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1974
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Vendendo a mercado com o volume definido                         |
//+------------------------------------------------------------------+
bool Sell(double volume,ulong deviation=10,ulong  magicnumber=0)
  {
//--- vendemos a mercado
   return (MarketOrder(ORDER_TYPE_SELL,volume,deviation,magicnumber));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fechando posi√ß√µes segundo o tempo de reten√ß√£o nas barras         |
//+------------------------------------------------------------------+
void ClosePositionsByBars(int holdtimebars,ulong deviation=10,ulong  magicnumber=0)
  {
   int total=PositionsTotal(); // n√∫mero de posi√ß√µes abertas   
//--- pesquisa detalhada de todas as posi√ß√µes abertas
   for(int i=total-1; i&gt;=0; i--)
     {
      //--- par√¢metros da posi√ß√£o
      ulong  position_ticket=PositionGetTicket(i);                                    
      string position_symbol=PositionGetString(POSITION_SYMBOL);                      
      ulong  magic=PositionGetInteger(POSITION_MAGIC);                                
      datetime position_open=(datetime)PositionGetInteger(POSITION_TIME);             
      int bars=iBarShift(_Symbol,PERIOD_CURRENT,position_open)+1;                     
      //--- se a posi√ß√£o tem vivido por um longo tempo, e tamb√©m o MagicNumber e o s√≠m
      if(bars&gt;holdtimebars &amp;&amp; magic==magicnumber &amp;&amp; position_symbol==_Symbol)
        {
         int    digits=(int)SymbolInfoInteger(position_symbol,SYMBOL_DIGITS);         
         double volume=PositionGetDouble(POSITION_VOLUME);                            
         ENUM_POSITION_TYPE type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE)
         string str_type=StringSubstr(EnumToString(type),14);
         StringToLower(str_type); // reduzimos o registro do texto para uma correta fo
         PrintFormat(&quot;Fechamos a posi√ß√£o #%I64u %s %s %.2f&quot;,
                     position_ticket,position_symbol,str_type,volume);
         //--- definindo o tipo de ordem e de envio do pedido de negocia√ß√£o
         if(type==POSITION_TYPE_BUY)
            MarketOrder(ORDER_TYPE_SELL,volume,deviation,magicnumber,position_ticket);
         else
            MarketOrder(ORDER_TYPE_BUY,volume,deviation,magicnumber,position_ticket);
        }
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preparando e enviando uma solicita√ß√£o de negocia√ß√£o              |
//+------------------------------------------------------------------+
bool MarketOrder(ENUM_ORDER_TYPE type,double volume,ulong slip,ulong magicnumber,ulong
  {
//--- declara√ß√£o e inicializa√ß√£o de estruturas</p>
<p></code></pre>
<p>
<h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1975
</p>
<pre><code class="language-mql5">
   MqlTradeRequest request={};
   MqlTradeResult  result={};
   double price=SymbolInfoDouble(Symbol(),SYMBOL_BID);
   if(type==ORDER_TYPE_BUY)
      price=SymbolInfoDouble(Symbol(),SYMBOL_ASK);
//--- par√¢metros da solicita√ß√£o
   request.action   =TRADE_ACTION_DEAL;                     // tipo de opera√ß√£o de neg
   request.position =pos_ticket;                            // boleta da posi√ß√£o, se f
   request.symbol   =Symbol();                              // s√≠mbolo
   request.volume   =volume;                                // volume 
   request.type     =type;                                  // tipo de ordem
   request.price    =price;                                 // pre√ßo de transa√ß√£o
   request.deviation=slip;                                  // desvio permitido em rel
   request.magic    =magicnumber;                           // MagicNumber da ordem
//--- envio do pedido
   if(!OrderSend(request,result))
     {
      //--- exibimos as informa√ß√µes sobre a falha
      PrintFormat(&quot;OrderSend %s %s %.2f at %.5f error %d&quot;,
                  request.symbol,EnumToString(type),volume,request.price,GetLastError
      return (false);
     }
//--- relatamos sobre a opera√ß√£o bem-sucedida
   PrintFormat(&quot;retcode=%u  deal=%I64u  order=%I64u&quot;,result.retcode,result.deal,result
   return (true);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
Teste de estrat√©gias de negocia√ß√£o, Trabalhando com resultados de otimiza√ß√£o, OnTesterDeinit,
<h3>OnTesterPass, ParameterGetRange, ParameterSetRange</h3></p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1976
<h3>OnTesterDeinit</h3>
√â chamada em EAs quando ocorre o evento TesterDeinit para realizar as a√ß√µes necess√°rias ap√≥s a
otimiza√ß√£o do EA.
</p>
<pre><code class="language-mql5">
void¬† OnTesterDeinit(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
O evento TesterDeinit √© gerado automaticamente no final da otimiza√ß√£o do EA no testador de
estrat√©gia. 
EA com manipulador OnTesterDeinit() ou OnTesterPass() que √© carregado automaticamente num
gr√°fico de terminal separado com o s√≠mbolo e o per√≠odo especificados no testador quando √© iniciada
a otimiza√ß√£o. A fun√ß√£o se destina ao processamento final de todos os resultados de otimiza√ß√£o.
Deve ser lembrado que os quadros de otimiza√ß√£o enviados pelos agentes de teste usando a fun√ß√£o
FrameAdd() podem vir em pacotes e levar tempo para serem entregues. Portanto, nem todos os
quadros e, consequentemente, os eventos TesterPass, podem ser recebidos e processados antes do
final da otimiza√ß√£o na OnTesterPass(). Portanto, para garantir o recebimento de todos os quadros
atrasados na OnTesterDeinit(), voc√™ precisa colocar um bloco de c√≥digo usando a fun√ß√£o
FrameNext().
<h3>Veja tamb√©m</h3>
Teste de estrat√©gias de negocia√ß√£o, Trabalhando com os resultados da otimiza√ß√£o, TesterStatistics,
OnTesterInit, OnTesterPass, ParameterGetRange, ParameterSetRange</p>
<p><h3>Manipula√ß√£o de eventos</h3>
¬© 2000-2025, MetaQuotes Ltd.
1977
<h3>OnTesterPass</h3>
√â chamada em EAs quando ocorre o evento TesterPass para processar o novo quadro de dados durante
a otimiza√ß√£o do EA.
</p>
<pre><code class="language-mql5">
void¬† OnTesterPass(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
<h3>Sem valor retornado</h3>
<h3>Observa√ß√£o</h3>
O evento TesterPass √© gerado automaticamente quando chega um quadro durante a otimiza√ß√£o do
EA no testador de estrat√©gia.
EA com manipulador OnTesterDeinit() ou OnTesterPass() que √© carregado automaticamente num
gr√°fico de terminal separado com o s√≠mbolo e o per√≠odo especificados no testador quando √© iniciada
a otimiza√ß√£o. A fun√ß√£o √© projetada para processar quadros recebidos de agentes de teste durante a
otimiza√ß√£o. O envio do quadro com resultados de teste deve ser feito a partir do manipulador
OnTester() usando a fun√ß√£o FrameAdd().
Deve ser lembrado que os quadros de otimiza√ß√£o enviados pelos agentes de teste usando a fun√ß√£o
FrameAdd() podem vir em pacotes e levar tempo para serem entregues. Portanto, nem todos os
quadros e, consequentemente, os eventos TesterPass, podem ser recebidos e processados antes do
final da otimiza√ß√£o na OnTesterPass(). Portanto, para garantir o recebimento de todos os quadros
atrasados na OnTesterDeinit(), voc√™ precisa colocar um bloco de c√≥digo usando a fun√ß√£o
FrameNext().
Ap√≥s conclu√≠da a otimiza√ß√£o de OnTesterDeinit(), voc√™ pode classificar novamente todos os quadros
com a ajuda das fun√ß√µes FrameFirst()/FrameFilter e FrameNext().
<h3>Veja tamb√©m</h3>
Teste de estrat√©gias de negocia√ß√£o, Trabalhando com resultados de otimiza√ß√£o, OnTesterInit,
OnTesterDeinit, FrameFirst, FrameFilter, FrameNext, FrameInputs
</p>
        </article>
        
        <footer>
            <p>Documenta√ß√£o MQL5 - Fonte: MetaQuotes Ltd.</p>
        </footer>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function toggleSidebar() {
            document.querySelector('.sidebar').classList.toggle('open');
        }
        
        function filterNav() {
            const filter = document.getElementById('search').value.toLowerCase();
            const items = document.querySelectorAll('.nav-list li');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }
    </script>
</body>
</html>