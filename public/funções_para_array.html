<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fun√ß√µes para Array - MQL5 Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>MQL5 Docs</h1>
            <p>Documenta√ß√£o Completa</p>
        </div>
        <div class="search-box">
            <input type="text" id="search" placeholder="Buscar..." onkeyup="filterNav()">
        </div>
        <ul class="nav-list" id="nav-list">
            <li class=""><a href="index.html">üìö √çndice</a></li>
            <li class=""><a href="introducao.html">Introducao</a></li>
<li class=""><a href="refer√™ncia_mql5.html">Refer√™ncia MQL5</a></li>
<li class=""><a href="elementos_b√°sicos_da_linguagem.html">Elementos B√°sicos da Linguagem</a></li>
<li class=""><a href="constantes,_enumeradores_e_estruturas.html">Constantes, Enumeradores e Estruturas</a></li>
<li class=""><a href="programas_mql5.html">Programas MQL5</a></li>
<li class=""><a href="vari√°veis_predefinidas.html">Vari√°veis Predefinidas</a></li>
<li class=""><a href="fun√ß√µes_comuns.html">Fun√ß√µes Comuns</a></li>
<li class="active"><a href="fun√ß√µes_para_array.html">Fun√ß√µes para Array</a></li>
<li class=""><a href="m√©todos_matriciais_e_vetoriais.html">M√©todos matriciais e vetoriais</a></li>
<li class=""><a href="fun√ß√µes_de_convers√£o.html">Fun√ß√µes de Convers√£o</a></li>
<li class=""><a href="fun√ß√µes_matem√°ticas.html">Fun√ß√µes Matem√°ticas</a></li>
<li class=""><a href="fun√ß√µes_de_string.html">Fun√ß√µes de String</a></li>
<li class=""><a href="data_e_hora.html">Data e Hora</a></li>
<li class=""><a href="informa√ß√µes_de_conta.html">Informa√ß√µes de Conta</a></li>
<li class=""><a href="verificando_estado.html">Verificando Estado</a></li>
<li class=""><a href="manipula√ß√£o_de_eventos.html">Manipula√ß√£o de eventos</a></li>
<li class=""><a href="informa√ß√µes_de_mercado.html">Informa√ß√µes de Mercado</a></li>
<li class=""><a href="calend√°rio_econ√¥mico.html">Calend√°rio econ√¥mico</a></li>
<li class=""><a href="s√©ries_temporais_e_acesso_a_indicadores.html">S√©ries Temporais e Acesso a Indicadores</a></li>
<li class=""><a href="s√≠mbolos_personalizados.html">S√≠mbolos personalizados</a></li>
<li class=""><a href="opera√ß√µes_de_gr√°ficos.html">Opera√ß√µes de Gr√°ficos</a></li>
<li class=""><a href="fun√ß√µes_de_negocia√ß√£o.html">Fun√ß√µes de Negocia√ß√£o</a></li>
<li class=""><a href="gerenciamento_de_sinais.html">Gerenciamento de sinais</a></li>
<li class=""><a href="fun√ß√µes_de_rede.html">Fun√ß√µes de rede</a></li>
<li class=""><a href="vari√°veis_globais_do_terminal.html">Vari√°veis Globais do Terminal</a></li>
<li class=""><a href="fun√ß√µes_de_arquivo.html">Fun√ß√µes de Arquivo</a></li>
<li class=""><a href="indicadores_customizados.html">Indicadores Customizados</a></li>
<li class=""><a href="fun√ß√µes_de_objeto.html">Fun√ß√µes de Objeto</a></li>
<li class=""><a href="indicadores_t√©cnicos.html">Indicadores T√©cnicos</a></li>
<li class=""><a href="trabalhando_com_resultados_de_otimiza√ß√£o.html">Trabalhando com Resultados de Otimiza√ß√£o</a></li>
<li class=""><a href="trabalhando_com_eventos.html">Trabalhando com Eventos</a></li>
<li class=""><a href="trabalhando_com_opencl.html">Trabalhando com OpenCL</a></li>
<li class=""><a href="trabalhar_com_bancos_de_dados.html">Trabalhar com bancos de dados</a></li>
<li class=""><a href="trabalho_com_directx.html">Trabalho com DirectX</a></li>
<li class=""><a href="metatrader_para_python.html">MetaTrader para Python</a></li>
<li class=""><a href="modelos_onnx.html">Modelos ONNX</a></li>
<li class=""><a href="biblioteca_padr√£o.html">Biblioteca Padr√£o</a></li>
<li class=""><a href="migrando_do_mql4.html">Migrando do MQL4</a></li>
<li class=""><a href="lista_de_fun√ß√µes_mql5.html">Lista de Fun√ß√µes MQL5</a></li>
<li class=""><a href="lista_de_constantes_mql5.html">Lista de Constantes MQL5</a></li>

        </ul>
    </nav>
    
    <main class="content">
        <header>
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1>Fun√ß√µes para Array</h1>
        </header>
        
        <article>
            <p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1213
Grupo de Fun√ß√µes para Trabalhar com Arrays
Arrays podem ter no m√°ximo quatro dimens√µes. Cada dimens√£o √© indexada de 0 a dimension_size-1.
No caso particular de um array de uma dimens√£o de 50 elementos, a chamada do primeiro elemento
aparece como array[0], do √∫ltimo elemento - como array[49].
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>ArrayBsearch</h3>
Retorna o √≠ndice do primeiro elemento encontrado na primeira dimens√£o
do array
<h3>ArrayCopy</h3>
<h3>Copia um array em outro array</h3>
<h3>ArrayCompare</h3>
Retorna o resultado da compara√ß√£o entre dois arrays de tipos simples ou
estruturas personalizados sem objetos complexos
<h3>ArrayFree</h3>
Libera buffer de qualquer array din√¢mico e define o tamanho da
dimens√£o zero em 0.
<h3>ArrayGetAsSeries</h3>
Verifica a dire√ß√£o da indexa√ß√£o de um array
<h3>ArrayInitialize</h3>
Define todos os elementos de um array num√©rico para um √∫nico valor
<h3>ArrayFill</h3>
Preenche um array com o valor especificado
<h3>ArrayIsSeries</h3>
Verifica se um √© array √© uma s√©rie de tempo
<h3>ArrayIsDynamic</h3>
<h3>Verifica se um array √© din√¢mico</h3>
<h3>ArrayMaximum</h3>
Busca por um elemento com o valor m√°ximo
<h3>ArrayPrint</h3>
No log, exibe uma matriz de tipo ou estrutura simples
<h3>ArrayMinimum</h3>
Busca por um elemento com o valor m√≠nimo
<h3>ArrayRange</h3>
Retorna o n√∫mero de elementos na dimens√£o especifica do array
<h3>ArrayResize</h3>
Define o novo tamanho da primeira dimens√£o do array
<h3>ArrayInsert</h3>
Insere na matriz de destino o n√∫mero especificado de elementos da
matriz de origem, iniciando no √≠ndice especificado
<h3>ArrayRemove</h3>
Remove o n√∫mero especificado de elementos da matriz, iniciando no
√≠ndice especificado
<h3>ArrayReverse</h3>
Expande o n√∫mero de elementos especificado na matriz, iniciando no
√≠ndice especificado
<h3>ArraySetAsSeries</h3>
Define a dire√ß√£o de indexa√ß√£o de um array
<h3>ArraySize</h3>
Retorna o n√∫mero de elemento no array
<h3>ArraySort</h3>
<h3>Ordena arrays n√∫meros pela primeira dimens√£o</h3>
<h3>ArraySwap</h3>
Troca entre si o conte√∫do de duas matrizes do tipo din√¢mico
<h3>ArrayToFP16</h3>
Realiza a c√≥pia de um array do tipo float ou double para um array do tipo
ushort com o formato especificado.</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1214
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>ArrayToFP8</h3>
Realiza a c√≥pia de um array do tipo float ou double para um array do tipo
uchar com o formato especificado.
<h3>ArrayFromFP16</h3>
Realiza a c√≥pia de um array do tipo ushort para um array do tipo float ou
</p>
<pre><code class="language-mql5">
double com um formato especificado.
</code></pre>
<p>
<h3>ArrayFromFP8</h3>
Realiza a c√≥pia de um array do tipo uchar para um array do tipo float ou
</p>
<pre><code class="language-mql5">
double com um formato especificado.</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1215
<h3>ArrayBsearch</h3>
Procura um valor especificado em um array num√©rico multidimensional ordenado em ordem crescente.
A pesquisa √© realizada atrav√©s dos elementos da primeira dimens√£o.
Para buscar em um array de tipo double
</p>
<pre><code class="language-mql5">
int¬† ArrayBsearch(
   const double&amp;  ¬† array[],   // array para busca
   double¬†          value¬†     // o que √© pesquisada por
   );
</code></pre>
<p>
Para buscar em um array de tipo float
</p>
<pre><code class="language-mql5">
int¬† ArrayBsearch(
   const float&amp;  ¬†  array[],   // array para busca
   float¬†           value¬†     // o que √© pesquisada por
   );
</code></pre>
<p>
Para buscar em um array de tipo long
</p>
<pre><code class="language-mql5">
int¬† ArrayBsearch(
   const long&amp;  ¬†   array[],   // array para busca
   long¬†            value¬†     // o que √© pesquisada por
   );
</code></pre>
<p>
Para buscar em um array de tipo int
</p>
<pre><code class="language-mql5">
int¬† ArrayBsearch(
   const int&amp;     ¬† array[],   // array para busca
   int¬†             value¬†     // o que √© pesquisada por
   );
</code></pre>
<p>
Para buscar em um array de tipo short
</p>
<pre><code class="language-mql5">
int¬† ArrayBsearch(
   const short&amp;  ¬†  array[],   // array para busca
   short¬†           value¬†     // o que √© pesquisada por
   );
</code></pre>
<p>
Para buscar em um array de tipo char
</p>
<pre><code class="language-mql5">
int¬† ArrayBsearch(
   const char&amp;    ¬† array[],   // array para busca
   char¬†            value¬†     // o que √© pesquisada por
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Array num√©rico para busca.
value</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1216
[in]  Valor para busca.
<h3>Valor do Retorno</h3>
A fun√ß√£o retorna o √≠ndice de um elemento encontrado. Se o valor desejado n√£o for encontrado, a
fun√ß√£o retorna o √≠ndice de um elemento mais pr√≥ximo em valor.
<h3>Observa√ß√£o</h3>
A busca bin√°ria processa somente arrays ordenados. Para ordenar arrays num√©ricos use a fun√ß√£o
ArraySort().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property description &quot;Script baseado no indicador RSI para visualiza√ß√£o de dados&quot;
#property description &quot;quantas vezes o mercado ficou em&quot;
#property description &quot;√°reas sobre-compradas e sobre-vendidas em intervalo de tempo es
//--- mosta a janela dos par√¢metros de entrada quando lan√ßado o script
#property script_show_inputs
//--- par√¢metros de entrada
input int                InpMAPeriod=14;                    // Per√≠odo de m√©dia m√≥vel
input ENUM_APPLIED_PRICE InpAppliedPrice=PRICE_CLOSE;       // Tipo de pre√ßo
input double             InpOversoldValue=30.0;             // N√≠vel sobre-vendido
input double             InpOverboughtValue=70.0;           // N√≠vel sobre-comprado
input datetime           InpDateStart=D&#x27;2012.01.01 00:00&#x27;;  // Data de in√≠cio para an√°
input datetime           InpDateFinish=D&#x27;2013.01.01 00:00&#x27;; // Data final para an√°lise
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
   double rsi_buff[]; // array do valores do indicador
   int    size=0;     // tamanho de array
//--- receber a manipula√ß√£o do indicador RSI
   ResetLastError();
   int rsi_handle=iRSI(Symbol(),Period(),InpMAPeriod,InpAppliedPrice);
   if(rsi_handle==INVALID_HANDLE)
     {
      //--- falha para receber a manipula√ß√£o do indicador
      PrintFormat(&quot;Manipulador de indicator recebido com erro. C√≥digo de erro = %d&quot;,Ge
      return;
     }
//--- fica no loop, at√© que o indicador calcula todos os seus valores
   while(BarsCalculated(rsi_handle)==-1)
     {
      //--- sair se o indicador concluir for√ßadamente a opera√ß√£o de script
      if(IsStopped())
         return;
      //--- uma pausa para permitir que o indicador calcule todos os seus valores
      Sleep(10);
     }</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1217
</p>
<pre><code class="language-mql5">
//--- copiar os valores do indicador para um determinado per√≠odo de tempo
   ResetLastError();
   if(CopyBuffer(rsi_handle,0,InpDateStart,InpDateFinish,rsi_buff)==-1)
     {
      PrintFormat(&quot;Falha para copiar valores do indicador. C√≥digo de erro = %d&quot;,GetLas
      return;
     }
//--- recebe o tamanho do array
   size=ArraySize(rsi_buff);
//--- classificar o array
   ArraySort(rsi_buff);
//--- descobrir o tempo (em termos percentuais) que o mercado ficou na √°rea sobre-vend
   double ovs=(double)ArrayBsearch(rsi_buff,InpOversoldValue)*100/(double)size;
//--- descobrir o tempo (em termos percentuais) que o mercado ficou na √°rea sobre-comp
   double ovb=(double)(size-ArrayBsearch(rsi_buff,InpOverboughtValue))*100/(double)siz
//--- formar as strings para exibir os dados
   string str=&quot;A partir de &quot;+TimeToString(InpDateStart,TIME_DATE)+&quot; para &quot;
              +TimeToString(InpDateFinish,TIME_DATE)+&quot; o mercado ficou:&quot;;
   string str_ovb=&quot;em √°rea sobre-comprada &quot;+DoubleToString(ovb,2)+&quot;% do tempo&quot;;
   string str_ovs=&quot;em √°rea sobre-vendida &quot;+DoubleToString(ovs,2)+&quot;% do tempo&quot;;
//--- mostrar os dados no gr√°fico
   CreateLabel(&quot;topo&quot;,5,60,str,clrDodgerBlue);
   CreateLabel(&quot;sobre-comprado&quot;,5,35,str_ovb,clrDodgerBlue);
   CreateLabel(&quot;sobre-vendido&quot;,5,10,str_ovs,clrDodgerBlue);
//--- redesenhar o gr√°fico
   ChartRedraw(0);
//--- pausa
   Sleep(10000);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Mostrar coment√°rio no canto inferior esquerdo do gr√°fico¬†        |
//+------------------------------------------------------------------+
void CreateLabel(const string name,const int x,const int y,
                 const string str,const color clr)
  {
//--- cria um r√≥tulo (label)
   ObjectCreate(0,name,OBJ_LABEL,0,0,0);
//--- colocar a etiqueta no canto inferior esquerdo
   ObjectSetInteger(0,name,OBJPROP_CORNER,CORNER_LEFT_LOWER);
//--- alterar a posi√ß√£o do ponto de ancoragem
   ObjectSetInteger(0,name,OBJPROP_ANCHOR,ANCHOR_LEFT_LOWER);
//--- dist√¢ncia a partir do ponto de ancoragem na dire√ß√£o X
   ObjectSetInteger(0,name,OBJPROP_XDISTANCE,x);
//--- dist√¢ncia a partir do ponto de ancoragem na dire√ß√£o Y
   ObjectSetInteger(0,name,OBJPROP_YDISTANCE,y);
//--- texto do r√≥tulo
   ObjectSetString(0,name,OBJPROP_TEXT,str);
//--- cor do texto
   ObjectSetInteger(0,name,OBJPROP_COLOR,clr);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1218
</p>
<pre><code class="language-mql5">
//--- tamanho do texto
   ObjectSetInteger(0,name,OBJPROP_FONTSIZE,12);
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1219
<h3>ArrayCopy</h3>
Copia um array em um outro array.
</p>
<pre><code class="language-mql5">
int¬† ArrayCopy(
   void&amp;¬†       dst_array[],¬†        // array de destino
   const void&amp;¬† src_array[],¬†        // array de origem
   int¬†         dst_start=0,¬†        // √≠ndice de in√≠cio do array destino a partir do 
   int¬†         src_start=0,¬†        // primeiro √≠ndice de um array de origem
   int¬†         count=WHOLE_ARRAY    // n√∫mero de elementos
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
dst_array[]
[out]  Array destino
src_array[]
[in]  Array fonte
dst_start=0
[in]  √çndice de in√≠cio do array destino. Por padr√£o, o √≠ndice de in√≠cio √© 0.
src_start=0
[in]  √çndice de in√≠cio para o array fonte. Por padr√£o, o √≠ndice de in√≠cio √© 0.
count=WHOLE_ARRAY
[in]  N√∫mero de elementos que devem ser copiados. Por padr√£o, todo conjunto array √© copiado
(count=WHOLE_ARRAY).
<h3>Valor do Retorno</h3>
Retorna o n√∫mero de elementos copiados.
<h3>Observa√ß√£o</h3>
Se count&lt;0 ou count&gt;src_size-src_start, toda a parte restante do array √© copiada. Arrays s√£o
copiados da esquerda para direita. Para arrays de s√©rie, a posi√ß√£o de in√≠cio √© corretamente ajustada
para copiar da esquerda para direita.
Se os arrays s√£o de tipos diferentes, durante a c√≥pia a fun√ß√£o tenta transformar cada elemento do
array fonte para o tipo do array destino. Um array de string pode ser copiado somente em um array
de string. Arrays de classes e estruturas contendo objetos que requerem inicializa√ß√£o n√£o s√£o
copiados. Um array de estruturas pode ser copiado somente em um array do mesmo tipo.
For dynamic arrays with indexing as in timeseries, the size of a destination array is automatically
increased to the amount of copied data (if the latter exceeds the array size). The destination array
size is not decreased automatically.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property description &quot;O indicador destaca os candlesticks que s√£o local&quot;
#property description &quot;altos e baixos. Comprimento do intervalo para encontrar&quot;
#property description &quot;valores extremos usando par√¢metros de entrada.&quot;</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1220
</p>
<pre><code class="language-mql5">
//--- configura√ß√µes do indicador
#property indicator_chart_window
#property indicator_buffers 5
#property indicator_plots   1
//---- plotar
#property indicator_label1  &quot;Extremums&quot;
#property indicator_type1   DRAW_COLOR_CANDLES
#property indicator_color1  clrLightSteelBlue,clrRed,clrBlue
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- constante pr√©-definida
#define INDICATOR_EMPTY_VALUE 0.0
//--- par√¢metros de entrada
input int InpNum=4; // Meio intervalo de comprimento
//--- buffers do indicador
double ExtOpen[];
double ExtHigh[];
double ExtLow[];
double ExtClose[];
double ExtColor[];
//--- vari√°veis globais
int    ExtStart=0; // √≠ndice do primeiro candlestick que n√£o √© um extremo
int    ExtCount=0; // n√∫mero de n√£o extremos no intervalo
//+------------------------------------------------------------------+
//| Preenchimento dos candlesticks n√£o extremos¬†                     |
//+------------------------------------------------------------------+
void FillCandles(const double &amp;open[],const double &amp;high[],
                 const double &amp;low[],const double &amp;close[])
  {
//--- preencher os candlesticks
   ArrayCopy(ExtOpen,open,ExtStart,ExtStart,ExtCount);
   ArrayCopy(ExtHigh,high,ExtStart,ExtStart,ExtCount);
   ArrayCopy(ExtLow,low,ExtStart,ExtStart,ExtCount);
   ArrayCopy(ExtClose,close,ExtStart,ExtStart,ExtCount);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,ExtOpen);
   SetIndexBuffer(1,ExtHigh);
   SetIndexBuffer(2,ExtLow);
   SetIndexBuffer(3,ExtClose);
   SetIndexBuffer(4,ExtColor,INDICATOR_COLOR_INDEX);
//--- especificar o valor que n√£o √© apresentado
   PlotIndexSetDouble(0,PLOT_EMPTY_VALUE,INDICATOR_EMPTY_VALUE);
//--- especificar os nomes dos buffers do indicador para exibir na janela de dados</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1221
</p>
<pre><code class="language-mql5">
   PlotIndexSetString(0,PLOT_LABEL,&quot;Open;High;Low;Close&quot;);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])
  {
//--- definir a indexa√ß√£o direta em s√©ries de tempo
   ArraySetAsSeries(open,false);
   ArraySetAsSeries(high,false);
   ArraySetAsSeries(low,false);
   ArraySetAsSeries(close,false);
//--- vari√°vel da barra para iniciar c√°lculo
   int start=prev_calculated;
//--- c√°lculo n√£o √© realizado pela primeira InpNum*2 barras
   if(start==0)
     {
      start+=InpNum*2;
      ExtStart=0;
      ExtCount=0;
     }
//--- se a barra acabou de se formar, verifique o seguinte extremo potencial
   if(rates_total-start==1)
      start--;
//--- √≠ndice da barra a ser verificado para o extremo
   int ext;
//--- valor do indicador para c√°lculo do loop
   for(int i=start;i&lt;rates_total-1;i++)
     {
      //--- inicialmente num bar sem desenhar
      ExtOpen[i]=0;
      ExtHigh[i]=0;
      ExtLow[i]=0;
      ExtClose[i]=0;
      //--- √≠ndice extremo para verifica√ß√£o
      ext=i-InpNum;
      //--- verificar o m√°ximo local
      if(IsMax(high,ext))</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1222
</p>
<pre><code class="language-mql5">
        {
         //--- destacar um candlestick extremo
         ExtOpen[ext]=open[ext];
         ExtHigh[ext]=high[ext];
         ExtLow[ext]=low[ext];
         ExtClose[ext]=close[ext];
         ExtColor[ext]=1;
         //--- destacar outros candles at√© o extremo com uma cor neutra
         FillCandles(open,high,low,close);
         //--- alterar as cores vari√°veis
         ExtStart=ext+1;
         ExtCount=0;
         //--- passar para a pr√≥xima itera√ß√£o
         continue;
        }
      //--- verifique o m√≠nimo local
      if(IsMin(low,ext))
        {
         //--- destacar um candlestick extremo
         ExtOpen[ext]=open[ext];
         ExtHigh[ext]=high[ext];
         ExtLow[ext]=low[ext];
         ExtClose[ext]=close[ext];
         ExtColor[ext]=2;
         //--- destacar outros candles at√© o extremo com uma cor neutra
         FillCandles(open,high,low,close);
         //--- alterar os valores das vari√°veis
         ExtStart=ext+1;
         ExtCount=0;
         //--- passar para a pr√≥xima itera√ß√£o
         continue;
        }
      //--- aumentar o n√∫mero de n√£o extremos no intervalo
      ExtCount++;
     }
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Verificar se o atual elemento array √© um local m√°ximo (high)¬†    |
//+------------------------------------------------------------------+
bool IsMax(const double &amp;price[],const int ind)
  {
//--- vari√°vel do in√≠cio do intervalo
   int i=ind-InpNum;
//--- final do per√≠odo do intervalo
   int finish=ind+InpNum+1;
//--- verificar a primeiro metade do intervalo
   for(;i&lt;ind;i++)</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1223
</p>
<pre><code class="language-mql5">
     {
      if(price[ind]&lt;=price[i])
         return(false);
     }
//--- verificar a segunda metade do intervalo
   for(i=ind+1;i&lt;finish;i++)
     {
      if(price[ind]&lt;=price[i])
         return(false);
     }
//--- este √© um extremo
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Verificar se o atual elemento array √© um local m√≠nimo (low)¬†    |
//+------------------------------------------------------------------+
bool IsMin(const double &amp;price[],const int ind)
  {
//--- vari√°vel do in√≠cio do intervalo
   int i=ind-InpNum;
//--- vari√°vel do final do intervalo
   int finish=ind+InpNum+1;
//--- verificar a primeiro metade do intervalo
   for(;i&lt;ind;i++)
     {
      if(price[ind]&gt;=price[i])
         return(false);
     }
//--- verificar a segunda metade do intervalo
   for(i=ind+1;i&lt;finish;i++)
     {
      if(price[ind]&gt;=price[i])
         return(false);
     }
//--- este √© um extremo
   return(true);
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1224
<h3>ArrayCompare</h3>
A fun√ß√£o retorna o resultado da compara√ß√£o de dois arrays de mesmo tipo. Pode ser usado para
comparar arrays de tipos simples ou estruturas customizadas sem objetos complexos, isto √©,
estruturas customizadas que n√£o cont√©m strings, arrays din√¢micos, classes e outras estruturas com
objetos complexos.
</p>
<pre><code class="language-mql5">
int¬† ArrayCompare(
   const void&amp;¬† array1[],¬†           // primeiro array
   const void&amp;¬† array2[],¬†           // segundo array
   int¬†         start1=0,¬†           // deslocamento inicial no primeiro array
   int¬†         start2=0,¬†           // deslocamento inicial no segundo array
   int¬†         count=WHOLE_ARRAY    // n√∫mero de elementos para compara√ß√£o
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array1[]
[in]  Primeiro array.
array2[]
[in]  Segundo array.
start1=0
[in]  O √≠ndice inicial do elemento no primeiro array, a partir do qual a compara√ß√£o come√ßa. O
√≠ndice de come√ßo default - 0.
start2=0
[in]  O √≠ndice inicial do elemento no segundo array, a partir do qual a compara√ß√£o come√ßa. O
√≠ndice de come√ßo default - 0.
count=WHOLE_ARRAY
[in]  N√∫mero de elementos a ser comparados. Todos os elementos de ambos os arrays participam
da compara√ß√£o por default (count=WHOLE_ARRAY).
<h3>Valor de retorno</h3>
¬∑ -1, se array1[] menos que array2[]
¬∑ 0, se array1[] igual a array2[]
¬∑ 1, se array1[] mais que array2[]
¬∑ -2, se um erro ocorrer devido a incompatibilidade dos tipos dos arrays comparados ou se os
valores start1, start2 ou count levarem a cair para fora do array.
<h3>Observa√ß√£o</h3>
A fun√ß√£o n√£o retornar√° 0 (os arrays n√£o ser√£o considerados iguais) se os arrays diferirem em
tamanho e count=WHOLE_ARRAY para o caso em que um array √© um subconjunto fiel do outro.
Neste caso, o resultado da compara√ß√£o de tamanhos destes arrays ir√£o retornar: -1, se o tamanho
de array1[] for menor que o tamanho de array2[] , caso contr√°rio 1.
<h3>Exemplo:</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1225
</p>
<pre><code class="language-mql5">
//--- vari√°veis globais
double   ExtArrayFirst[];
double   ExtArraySecond[];
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- definimos as dimens√µes dos arrays
   if(ArrayResize(ExtArrayFirst,10)!=10)
     {
      Print(&quot;ArrayResize() failed for ExtArrayFirst. Error code: &quot;,GetLastError());
      return;
     }
   if(ArrayResize(ExtArraySecond,10)!=10)
     {
      Print(&quot;ArrayResize() failed for ExtArraySecond. Error code: &quot;,GetLastError());
      return;
     }
     
//--- no ciclo, preenchemos os arrays com os valores dos √≠ndices i e j
   int total=ArraySize(ExtArrayFirst);
   for(int i=0, j=total-1; i&lt;total; i++,j--)
     {
      //--- preenchemos o array ExtArrayFirst da esquerda para a direita
      //--- preenchemos o array ExtArraySecond da direita para a esquerda
      ExtArrayFirst[i]=i;
      ExtArraySecond[i]=j;
     }
//--- comparamos os arrays e imprimimos o resultado no log
   ArrayComparePrint(ExtArrayFirst,ExtArraySecond);
  /*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   ExtArrayFirst:
   0.00000 1.00000 2.00000 3.00000 4.00000 5.00000 6.00000 7.00000 8.00000 9.00000
   ExtArraySecond:
   9.00000 8.00000 7.00000 6.00000 5.00000 4.00000 3.00000 2.00000 1.00000 0.00000
   Result ArrayCompare(): ExtArrayFirst is smaller than ExtArraySecond (result = -1)
</code></pre>
<p>
  */
</p>
<pre><code class="language-mql5">
   
//--- agora invertemos os arrays
//--- no ciclo, preenchemos os arrays com os valores dos √≠ndices i e j
   for(int i=0, j=total-1; i&lt;total; i++,j--)
     {
      //--- preenchemos o array ExtArrayFirst da direita para a esquerda
      //--- preenchemos o array ExtArraySecond da esquerda para a direita
      ExtArrayFirst[i]=j;
      ExtArraySecond[i]=i;</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1226
</p>
<pre><code class="language-mql5">
     }
//--- comparamos os arrays e imprimimos o resultado no log
   ArrayComparePrint(ExtArrayFirst,ExtArraySecond);
   /*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   ExtArrayFirst:
   9.00000 8.00000 7.00000 6.00000 5.00000 4.00000 3.00000 2.00000 1.00000 0.00000
   ExtArraySecond:
   0.00000 1.00000 2.00000 3.00000 4.00000 5.00000 6.00000 7.00000 8.00000 9.00000
   Result ArrayCompare(): ExtArrayFirst is larger than ExtArraySecond (result = 1)
   */
   
//--- agora preencheremos os arrays na mesma dire√ß√£o
//--- no ciclo, preenchemos os arrays com os valores do √≠ndice i
   for(int i=0; i&lt;total; i++)
     {
      //--- preenchemos ambos os arrays da esquerda para a direita
      ExtArrayFirst[i]=i;
      ExtArraySecond[i]=i;
     }
//--- comparamos os arrays e imprimimos o resultado no log
   ArrayComparePrint(ExtArrayFirst,ExtArraySecond);
   /*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   ExtArrayFirst:
   0.00000 1.00000 2.00000 3.00000 4.00000 5.00000 6.00000 7.00000 8.00000 9.00000
   ExtArraySecond:
   0.00000 1.00000 2.00000 3.00000 4.00000 5.00000 6.00000 7.00000 8.00000 9.00000
   Result ArrayCompare(): ExtArrayFirst and ExtArraySecond are equal (result = 0)
   */
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Compara√ß√£o e impress√£o do resultado                              |
//+------------------------------------------------------------------+
void ArrayComparePrint(const double &amp;array1[], const double &amp;array2[])
  {
   //--- imprimimos o cabe√ßalho e o conte√∫do dos arrays
   Print(&quot;ExtArrayFirst:&quot;);
   ArrayPrint(array1);
   Print(&quot;ExtArraySecond:&quot;);
   ArrayPrint(array2);
   //--- comparamos os arrays e imprimimos o resultado da compara√ß√£o
   int    res=ArrayCompare(array1,array2);
   string res_str=(res&gt;0 ? &quot;ExtArrayFirst is larger than ExtArraySecond&quot; : res&lt;0 ? &quot;Ex
   PrintFormat(&quot;Result ArrayCompare(): %s (result = %d)\n&quot;,res_str,res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1227
<h3>ArrayFree</h3>
Libera um buffer de qualquer array din√¢mico e define o tamanho da dimens√£o zero para 0.
</p>
<pre><code class="language-mql5">
void¬† ArrayFree(
   void&amp;¬† array[]¬†     // array
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Array din√¢mico.
<h3>Valor do Retorno</h3>
Sem valor de retorno.
<h3>Observa√ß√£o</h3>
A necessidade de usar a fun√ß√£o ArrayFree() pode n√£o aparecer com muita freq√º√™ncia, considerando
que toda a mem√≥ria utilizada √© liberada de uma s√≥ vez e o principal trabalho com os arrays
compreende o acesso aos buffers dos indicadores. Os tamanhos dos buffers s√£o controlados
automaticamente pelo subsistema executivo do terminal.
No caso, √© necess√°rio controlar manualmente a mem√≥ria no ambiente din√¢mico complexo da
aplica√ß√£o, a fun√ß√£o ArrayFree() permite que os usu√°rios possam liberar a mem√≥ria ocupada pelo
array din√¢mico desnecess√°rio de forma direta e imediata.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#include &lt;Controls\Dialog.mqh&gt;
#include &lt;Controls\Button.mqh&gt;
#include &lt;Controls\Label.mqh&gt;
#include &lt;Controls\ComboBox.mqh&gt;
//--- constantes predefinidas
#define X_START 0
#define Y_START 0
#define X_SIZE 280
#define Y_SIZE 300
//+------------------------------------------------------------------+
//| Uma classe para trabalhar com uma mem√≥ria¬†                       |
//+------------------------------------------------------------------+
class CMemoryControl : public CAppDialog
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   //--- tamanho de array
   int               m_arr_size;
   //--- arrays
   char              m_arr_char[];
   int               m_arr_int[];
   float             m_arr_float[];
   double            m_arr_double[];</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1228
</p>
<pre><code class="language-mql5">
   long              m_arr_long[];
   //--- r√≥tulos
   CLabel            m_lbl_memory_physical;
   CLabel            m_lbl_memory_total;
   CLabel            m_lbl_memory_available;
   CLabel            m_lbl_memory_used;
   CLabel            m_lbl_array_size;
   CLabel            m_lbl_array_type;
   CLabel            m_lbl_error;
   CLabel            m_lbl_change_type;
   CLabel            m_lbl_add_size;
   //--- bot√µes
   CButton           m_button_add;
   CButton           m_button_free;
   //--- caixas de combina√ß√£o
   CComboBox         m_combo_box_step;
   CComboBox         m_combo_box_type;
   //--- valor atual do tipo array da caixa de combina√ß√£o
   int               m_combo_box_type_value;
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CMemoryControl(void);
                    ~CMemoryControl(void);
   //--- m√©todo de cria√ß√£o de objeto de classe
   virtual bool      Create(const long chart,const string name,const int subwin,const 
   //--- manipulador de eventos gr√°fico
   virtual bool      OnEvent(const int id,const long &amp;lparam,const double &amp;dparam,cons
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   //--- cria um r√≥tulos
   bool              CreateLabel(CLabel &amp;lbl,const string name,const int x,const int y
   //--- criar elementos de controle
   bool              CreateButton(CButton &amp;button,const string name,const int x,const 
   bool              CreateComboBoxStep(void);
   bool              CreateComboBoxType(void);
   //--- manipuladores de evento
   void              OnClickButtonAdd(void);
   void              OnClickButtonFree(void);
   void              OnChangeComboBoxType(void);
   //--- m√©todos para trabalhar com o atual array
   void              CurrentArrayFree(void);
   bool              CurrentArrayAdd(void);
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Liberar mem√≥ria do atual array¬†                                  |
//+------------------------------------------------------------------+
void CMemoryControl::CurrentArrayFree(void)
  {
//--- restabelecer o tamanho do array</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1229
</p>
<pre><code class="language-mql5">
   m_arr_size=0;
//--- liberar o array
   if(m_combo_box_type_value==0)
      ArrayFree(m_arr_char);
   if(m_combo_box_type_value==1)
      ArrayFree(m_arr_int);
   if(m_combo_box_type_value==2)
      ArrayFree(m_arr_float);
   if(m_combo_box_type_value==3)
      ArrayFree(m_arr_double);
   if(m_combo_box_type_value==4)
      ArrayFree(m_arr_long);
</code></pre>
<p>
  }  
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Tentativa de adicionar mem√≥ria para o atual array¬†               |
//+------------------------------------------------------------------+
bool CMemoryControl::CurrentArrayAdd(void)
  {
//--- se o tamanho da mem√≥ria usada excede o tamanho da mem√≥ria f√≠sica, sair
   if(TerminalInfoInteger(TERMINAL_MEMORY_PHYSICAL)/TerminalInfoInteger(TERMINAL_MEMOR
      return(false);
//--- tentativa para alocar mem√≥ria de acordo com o atual tipo
   if(m_combo_box_type_value==0 &amp;&amp; ArrayResize(m_arr_char,m_arr_size)==-1)
      return(false);
   if(m_combo_box_type_value==1 &amp;&amp; ArrayResize(m_arr_int,m_arr_size)==-1)
      return(false);
   if(m_combo_box_type_value==2 &amp;&amp; ArrayResize(m_arr_float,m_arr_size)==-1)
      return(false);
   if(m_combo_box_type_value==3 &amp;&amp; ArrayResize(m_arr_double,m_arr_size)==-1)
      return(false);
   if(m_combo_box_type_value==4 &amp;&amp; ArrayResize(m_arr_long,m_arr_size)==-1)
      return(false);
//--- mem√≥ria alocada
   return(true);
</code></pre>
<p>
  }  
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Manipula√ß√£o de eventos¬†                                          |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>EVENT_MAP_BEGIN(CMemoryControl)</h3>
<h3>ON_EVENT(ON_CLICK,m_button_add,OnClickButtonAdd)</h3>
<h3>ON_EVENT(ON_CLICK,m_button_free,OnClickButtonFree)</h3>
<h3>ON_EVENT(ON_CHANGE,m_combo_box_type,OnChangeComboBoxType)</h3>
<h3>EVENT_MAP_END(CAppDialog)</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Construtor                                                      |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CMemoryControl::CMemoryControl(void)</h3>
</p>
<pre><code class="language-mql5">
  {
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1230
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Destrutor                                                       |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CMemoryControl::~CMemoryControl(void)</h3>
</p>
<pre><code class="language-mql5">
  {
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| M√©todo para cria√ß√£o de objeto de classe¬†                         |
//+------------------------------------------------------------------+
bool CMemoryControl::Create(const long chart,const string name,const int subwin,
                            const int x1,const int y1,const int x2,const int y2)
  {
//--- base criada de objetos de classe
   if(!CAppDialog::Create(chart,name,subwin,x1,y1,x2,y2))
      return(false);
//--- preparar strings para etiquetas
   string str_physical=&quot;Mem√≥ria F√≠sica = &quot;+(string)TerminalInfoInteger(TERMINAL_MEMORY
   string str_total=&quot;Mem√≥ria total = &quot;+(string)TerminalInfoInteger(TERMINAL_MEMORY_TOT
   string str_available=&quot;Mem√≥ria dispon√≠vel = &quot;+(string)TerminalInfoInteger(TERMINAL_M
   string str_used=&quot;Mem√≥ria usada = &quot;+(string)TerminalInfoInteger(TERMINAL_MEMORY_USED
//--- cria um r√≥tulos
   if(!CreateLabel(m_lbl_memory_physical,&quot;physical_label&quot;,X_START+10,Y_START+5,str_phy
      return(false);
   if(!CreateLabel(m_lbl_memory_total,&quot;total_label&quot;,X_START+10,Y_START+30,str_total,12
      return(false);
   if(!CreateLabel(m_lbl_memory_available,&quot;available_label&quot;,X_START+10,Y_START+55,str_
      return(false);
   if(!CreateLabel(m_lbl_memory_used,&quot;used_label&quot;,X_START+10,Y_START+80,str_used,12,cl
      return(false);
   if(!CreateLabel(m_lbl_array_type,&quot;type_label&quot;,X_START+10,Y_START+105,&quot;Array type = 
      return(false);
   if(!CreateLabel(m_lbl_array_size,&quot;size_label&quot;,X_START+10,Y_START+130,&quot;Array size = 
      return(false);
   if(!CreateLabel(m_lbl_error,&quot;error_label&quot;,X_START+10,Y_START+155,&quot;&quot;,12,clrRed))
      return(false);
   if(!CreateLabel(m_lbl_change_type,&quot;change_type_label&quot;,X_START+10,Y_START+185,&quot;Chang
      return(false);
   if(!CreateLabel(m_lbl_add_size,&quot;add_size_label&quot;,X_START+10,Y_START+210,&quot;Add to arra
      return(false);
//--- create control elements
   if(!CreateButton(m_button_add,&quot;add_button&quot;,X_START+15,Y_START+245,&quot;Adicionar&quot;,12,cl
      return(false);
   if(!CreateButton(m_button_free,&quot;free_button&quot;,X_START+75,Y_START+245,&quot;Livre&quot;,12,clrB
      return(false);
   if(!CreateComboBoxType())
      return(false);
   if(!CreateComboBoxStep())
      return(false);
//--- inicializar a vari√°vel</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1231
</p>
<pre><code class="language-mql5">
   m_arr_size=0;
//--- sucesso na execu√ß√£o
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Criar o bot√£o¬†                                                   |
//+------------------------------------------------------------------+
bool CMemoryControl::CreateButton(CButton &amp;button,const string name,const int x,
                                  const int y,const string str,const int font_size,
                                  const int clr)
  {
//--- criar o bot√£o
   if(!button.Create(m_chart_id,name,m_subwin,x,y,x+50,y+20))
      return(false);
//--- texto
   if(!button.Text(str))
      return(false);
//--- tamanho de fonte
   if(!button.FontSize(font_size))
      return(false);
//--- cor de r√≥tulo
   if(!button.Color(clr))
      return(false);
//--- adicionar o bot√£o para os elementos de controle
   if(!Add(button))
      return(false);
//--- sucesso na execu√ß√£o
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Criar uma caixa de combina√ß√£o para o tamanho do array¬†           |
//+------------------------------------------------------------------+
bool CMemoryControl::CreateComboBoxStep(void)
  {
//--- criar a caixa de combina√ß√£o
   if(!m_combo_box_step.Create(m_chart_id,&quot;step_combobox&quot;,m_subwin,X_START+100,Y_START
      return(false);
//--- adicionar elementos para a caixa de combina√ß√£o
   if(!m_combo_box_step.ItemAdd(&quot;100 000&quot;,100000))
      return(false);
   if(!m_combo_box_step.ItemAdd(&quot;1 000 000&quot;,1000000))
      return(false);
   if(!m_combo_box_step.ItemAdd(&quot;10 000 000&quot;,10000000))
      return(false);
   if(!m_combo_box_step.ItemAdd(&quot;100 000 000&quot;,100000000))
      return(false);
//--- definir o elemento atual da caixa de combina√ß√£o
   if(!m_combo_box_step.SelectByValue(1000000))
      return(false);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1232
</p>
<pre><code class="language-mql5">
//--- adicionar a caixa de combina√ß√£o para controlar elementos
   if(!Add(m_combo_box_step))
      return(false);
//--- sucesso na execu√ß√£o
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Criar uma caixa de combina√ß√£o para o tipo de array¬†              |
//+------------------------------------------------------------------+
bool CMemoryControl::CreateComboBoxType(void)
  {
//--- criar a caixa de combina√ß√£o
   if(!m_combo_box_type.Create(m_chart_id,&quot;type_combobox&quot;,m_subwin,X_START+100,Y_START
      return(false);
//--- adicionar elementos para a caixa de combina√ß√£o
   if(!m_combo_box_type.ItemAdd(&quot;char&quot;,0))
      return(false);
   if(!m_combo_box_type.ItemAdd(&quot;int&quot;,1))
      return(false);
   if(!m_combo_box_type.ItemAdd(&quot;float&quot;,2))
      return(false);
   if(!m_combo_box_type.ItemAdd(&quot;double&quot;,3))
      return(false);
   if(!m_combo_box_type.ItemAdd(&quot;long&quot;,4))
      return(false);
//--- definir o elemento atual da caixa de combina√ß√£o
   if(!m_combo_box_type.SelectByValue(3))
      return(false);
//--- armazenar o elemento da caixa de combina√ß√£o atual
   m_combo_box_type_value=3;
//--- adicionar a caixa de combina√ß√£o para controlar elementos
   if(!Add(m_combo_box_type))
      return(false);
//--- sucesso na execu√ß√£o
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| criar um r√≥tulo¬†                                                 |
//+------------------------------------------------------------------+
bool CMemoryControl::CreateLabel(CLabel &amp;lbl,const string name,const int x,
                                 const int y,const string str,const int font_size,
                                 const int clr)
  {
//--- criar um r√≥tulo
   if(!lbl.Create(m_chart_id,name,m_subwin,x,y,0,0))
      return(false);
//--- texto
   if(!lbl.Text(str))
      return(false);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1233
</p>
<pre><code class="language-mql5">
//--- tamanho de fonte
   if(!lbl.FontSize(font_size))
      return(false);
//--- cor
   if(!lbl.Color(clr))
      return(false);
//--- adicionar a etiqueta para controlar elementos
   if(!Add(lbl))
      return(false);
//--- sucesso
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Manipulador criando bot√£o de evento &quot;Adicionar&quot;¬†                 |
//+------------------------------------------------------------------+
void CMemoryControl::OnClickButtonAdd(void)
  {
//--- aumentar o tamanho do array
   m_arr_size+=(int)m_combo_box_step.Value();
//--- tentativa de alocar mem√≥ria para o atual array
   if(CurrentArrayAdd())
     {
      //--- mem√≥ria alocada, exibir o status atual na tela
      m_lbl_memory_available.Text(&quot;Mem√≥ria dispon√≠vel = &quot;+(string)TerminalInfoInteger
      m_lbl_memory_used.Text(&quot;Mem√≥ria usada = &quot;+(string)TerminalInfoInteger(TERMINAL_M
      m_lbl_array_size.Text(&quot;Tamanho de array = &quot;+IntegerToString(m_arr_size));
      m_lbl_error.Text(&quot;&quot;);
     }
   else
     {
      //--- falha para alocar mem√≥ria, exibir a mensagem de erro
      m_lbl_error.Text(&quot;Array √© muito grande, erro!&quot;);
      //--- retornar o tamanho do array anterior
      m_arr_size-=(int)m_combo_box_step.Value();
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Manipulador criando o bot√£o de evento &quot;Livre&quot;¬†                   |
//+------------------------------------------------------------------+
void CMemoryControl::OnClickButtonFree(void)
  {
//--- liberar mem√≥ria do atual array
   CurrentArrayFree();
//--- exibir o status atual na tela
   m_lbl_memory_available.Text(&quot;Mem√≥ria dispon√≠vel = &quot;+(string)TerminalInfoInteger(TER
   m_lbl_memory_used.Text(&quot;Mem√≥ria usada = &quot;+(string)TerminalInfoInteger(TERMINAL_MEMO
   m_lbl_array_size.Text(&quot;Tamanho de array = 0&quot;);
   m_lbl_error.Text(&quot;&quot;);
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1234
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Manipulador da caixa de combina√ß√£o para alterar evento¬†          |
//+------------------------------------------------------------------+
void CMemoryControl::OnChangeComboBoxType(void)
  {
//--- verificar se o tipo de array foi alterado
   if(m_combo_box_type.Value()!=m_combo_box_type_value)
     {
      //--- liberar mem√≥ria do atual array
      OnClickButtonFree();
      //--- trabalhar com outro tipo de array
      m_combo_box_type_value=(int)m_combo_box_type.Value();
      //--- exibir um novo tipo de array na tela
      if(m_combo_box_type_value==0)
         m_lbl_array_type.Text(&quot;Tipo de array = char&quot;);
      if(m_combo_box_type_value==1)
         m_lbl_array_type.Text(&quot;Tipo de array = int&quot;);
      if(m_combo_box_type_value==2)
         m_lbl_array_type.Text(&quot;Tipo de array = float&quot;);
      if(m_combo_box_type_value==3)
         m_lbl_array_type.Text(&quot;Tipo de array = double&quot;);
      if(m_combo_box_type_value==4)
         m_lbl_array_type.Text(&quot;Tipo de array = long&quot;);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//--- objeto de classe CMemoryControl
</code></pre>
<p>
<h3>CMemoryControl ExtDialog;</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- criar o di√°logo
   if(!ExtDialog.Create(0,&quot;MemoryControl&quot;,0,X_START,Y_START,X_SIZE,Y_SIZE))
      return(INIT_FAILED);
//--- lan√ßamento
   ExtDialog.Run();
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de Desinicializa√ß√£o do Expert                             |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
   ExtDialog.Destroy(reason);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1235
</p>
<pre><code class="language-mql5">
//| Expert chart event function                                      |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &amp;lparam,
                  const double &amp;dparam,
                  const string &amp;sparam)
  {
   ExtDialog.ChartEvent(id,lparam,dparam,sparam);
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1236
<h3>ArrayGetAsSeries</h3>
Verifica a dire√ß√£o do √≠ndice de um array.
</p>
<pre><code class="language-mql5">
bool¬† ArrayGetAsSeries(
   const void&amp;¬† array[]    // array para verifica√ß√£o
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array
[in]  Array verificado.
<h3>Valor do Retorno</h3>
Retorna true, se o array especificado tem o flag AS_SERIES definido, isto √©, o acesso ao array √©
realizado de tr√°s para frente como em s√©ries de tempo. A indexa√ß√£o em times√©ries de tempo difere
da indexa√ß√£o de um array comum, na medida que os elementos de s√©ries de tempo s√£o indexados
do fim para o come√ßo (dos dados mais novos para os mais antigos).
<h3>Observa√ß√£o</h3>
Para verificar se um array se comporta como uma s√©rie de tempo, use a fun√ß√£o ArrayIsSeries().
Array de dados de pre√ßos passados como par√¢metros de entrada na fun√ß√£o OnCalculate() n√£o
obrigatoriamente t√™m a mesma dire√ß√£o de uma s√©rie de tempo. A dire√ß√£o de indexa√ß√£o necess√°ria
pode ser definida usando a fun√ß√£o ArraySetAsSeries().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property description &quot;Indicador calcula os valores absolutos das diferen√ßas entre&quot;
#property description &quot;Pre√ßos de Open (Abertura) e Close (Fechamento) ou High (Alto) e
#property description &quot;como um histograma.&quot;
//--- configura√ß√µes do indicador
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
//---- plotar
#property indicator_type1   DRAW_HISTOGRAM
#property indicator_style1  STYLE_SOLID
#property indicator_width1  3
//--- par√¢metros de entrada
input bool InpAsSeries=true; // Dire√ß√£o de indexa√ß√£o no buffer de indicador
input bool InpPrices=true;   // C√°lculo de pre√ßos (true - Abertura, Fechamento; false 
//--- buffer do indicador
double ExtBuffer[];
//+------------------------------------------------------------------+
//| Calcule os valores do indicador¬†                                 |
//+------------------------------------------------------------------+
void CandleSizeOnBuffer(const int rates_total,const int prev_calculated,
                        const double &amp;first[],const double &amp;second[],double &amp;buffer[])
  {
//--- iniciar vari√°vel para o c√°lculo das barras</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1237
</p>
<pre><code class="language-mql5">
   int start=prev_calculated;
//--- trabalho na √∫ltima barra se os valores do indicador j√° foram calculados no tick 
   if(prev_calculated&gt;0)
      start--;
//--- definir a dire√ß√£o de indexa√ß√£o nos arrays
   bool as_series_first=ArrayGetAsSeries(first);
   bool as_series_second=ArrayGetAsSeries(second);
   bool as_series_buffer=ArrayGetAsSeries(buffer);
//--- substituir a dire√ß√£o de indexa√ß√£o com um direto, se necess√°rio
   if(as_series_first)
      ArraySetAsSeries(first,false);
   if(as_series_second)
      ArraySetAsSeries(second,false);
   if(as_series_buffer)
      ArraySetAsSeries(buffer,false);
//--- calcule valores do indicador
   for(int i=start;i&lt;rates_total;i++)
      buffer[i]=MathAbs(first[i]-second[i]);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- vincular buffers de indicador
   SetIndexBuffer(0,ExtBuffer);
//--- conjunto de elementos de indexa√ß√£o no buffer de indicador
   ArraySetAsSeries(ExtBuffer,InpAsSeries);
//--- verificar quais os pre√ßos do indicador s√£o calculados
   if(InpPrices)
     {
      //--- Pre√ßos Open (abrir) e Close (fechar)
      PlotIndexSetString(0,PLOT_LABEL,&quot;BodySize&quot;);
      //--- definir a cor do indicador
      PlotIndexSetInteger(0,PLOT_LINE_COLOR,clrOrange);
     }
   else
     {
      //--- Pre√ßos High (m√°ximo) e Low (m√≠nimo)
      PlotIndexSetString(0,PLOT_LABEL,&quot;ShadowSize&quot;);
      //--- definir a cor do indicador
      PlotIndexSetInteger(0,PLOT_LINE_COLOR,clrDodgerBlue);
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1238
</p>
<pre><code class="language-mql5">
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])
  {
//--- calcular o indicador de acordo com o valor do sinalizador
   if(InpPrices)
      CandleSizeOnBuffer(rates_total,prev_calculated,open,close,ExtBuffer);
   else
      CandleSizeOnBuffer(rates_total,prev_calculated,high,low,ExtBuffer);
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
<h3>Aceso a s√©ries de tempo, ArraySetAsSeries</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1239
<h3>ArrayInitialize</h3>
A fun√ß√£o inicializa um array num√©rico com um valor predefinido.
For initialization of an array of char type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   char¬†   array[],¬†    // array inicializado
   char¬†   value¬†       // valor que ser√° definido
   );
</code></pre>
<p>
For initialization of an array of short type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   short¬†  array[],¬†    // array inicializado
   short¬†  value¬†       // valor que ser√° definido
   );
</code></pre>
<p>
For initialization of an array of int type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   int¬†    array[],¬†    // array inicializado
   int¬†    value¬†       // valor que ser√° definido
   );
</code></pre>
<p>
For initialization of an array of long type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   long¬†   array[],¬†    // array inicializado
   long¬†   value¬†       // valor que ser√° definido
   );
</code></pre>
<p>
For initialization of an array of float type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   float¬†  array[],¬†    // array inicializado
   float¬†  value¬†       // valor que ser√° definido
   );
</code></pre>
<p>
For initialization of an array of double type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   double¬† array[],¬†    // array inicializado
   double¬† value¬†       // valor que ser√° definido
   );
</code></pre>
<p>
For initialization of an array of bool type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   bool¬†   array[],¬†    // array inicializado
   bool¬†   value¬†       // valor que ser√° definido
   );</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1240
For initialization of an array of uint type
</p>
<pre><code class="language-mql5">
int¬† ArrayInitialize(
   uint¬†   array[],¬†    // array inicializado
   uint¬†   value¬†       // valor que ser√° definido
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[out]  Array num√©rico que deve ser inicializado.
value
[in]  Novo valor que deve ser definido para todos os elementos do array.
<h3>Valor do Retorno</h3>
N√∫mero de elementos.
<h3>Observa√ß√£o</h3>
A fun√ß√£o ArrayResize() permite definir o tamanho de um array com uma reserva para expans√£o
posterior sem a realoca√ß√£o de mem√≥ria. √â implementada para uma melhor performance, porque as
opera√ß√µes de realoca√ß√£o de mem√≥ria s√£o razoavelmente lentas.
A inicializa√ß√£o de um array usando ArrayInitialize(array, init_val) n√£o significa a inicializa√ß√£o com o
mesmo valor dos elementos da reserva alocados para este array. Em uma expans√£o posterior do
array usando a fun√ß√£o ArrayResize(), os elementos ser√£o adicionados no final do array, seus valores
ser√£o indefinidos e na maioria dos casos n√£o ser√£o iguais ao init_value.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- array din√¢mico
   double array[];
//--- vamos definir o tamanho do array para 100 elementos e reservar um buffer para ou
   ArrayResize(array,100,10);
//--- inicializa os elementos do array com valor EMPTY_VALUE=DBL_MAX
   ArrayInitialize(array,EMPTY_VALUE);
   Print(&quot;Valores dos 10 √∫ltimos elementos antes da inicializa√ß√£o&quot;);
   for(int i=90;i&lt;100;i++) printf(&quot;array[%d] = %G&quot;,i,array[i]);
//--- expande o array em 5 elementos
   ArrayResize(array,105);
   Print(&quot;Valores dos 10 √∫ltimos elementos antes do ArrayResize(array,105)&quot;);
//--- valores dos 5 √∫ltimos elementos s√£o obtidos do buffer de reserva
   for(int i=95;i&lt;105;i++) printf(&quot;array[%d] = %G&quot;,i,array[i]);
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1241
<h3>ArrayFill</h3>
A fun√ß√£o preenche um array com o valor especificado.
</p>
<pre><code class="language-mql5">
void¬† ArrayFill(
   void&amp;¬† array[],¬†     // array
   int¬†   start,¬†       // √≠ndice de in√≠cio
   int¬†   count,¬†       // n√∫mero de elementos para preencher
   void¬†  value¬†        // valor
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[out]  Array de tipo simples (char, uchar, short, ushort, int, uint, long, ulong, bool, color,
datetime, float, double).
start
[in]  √çndice de in√≠cio.  Neste caso, flag AS_SERIES espec√≠fico √© ignorado.
count
[in]  N√∫mero de elementos para preencher.
value
[in]  Valor usado no preenchimento do array.
<h3>Valor de retorno</h3>
Sem valor de retorno.
<h3>Observa√ß√£o</h3>
Quando a fun√ß√£o ArrayFill() √© chamada, a dire√ß√£o de indexa√ß√£o normal( da esquerda para direita) √©
sempre impl√≠cita. Isso significa que a altera√ß√£o da ordem de acesso dos elementos do array usando
a fun√ß√£o ArraySetAsSeries() √© ignorada. 
Um array multidimensional √© exibido como unidimensional quando processado pela fun√ß√£o
ArrayFill(). Por exemplo, array[2][4] √© processado como array[8]. Portanto, voc√™ deve especificar o
√≠ndice do elemento inicial para ser igual a 5 quando trabalhar com este array. Assim, a chamada de
ArrayFill(array, 5, 2, 3.14) para array[2][4] preenche os elementos array[1][1] e array[1][2] com
3.14.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- declara um array din√¢mico
   int a[];
//--- define tamanho
   ArrayResize(a,10);
//--- preenche os primeiros 5 elementos com 123
   ArrayFill(a,0,5,123);
//--- preenche os primeiros 5 elementos com 456</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1242
</p>
<pre><code class="language-mql5">
   ArrayFill(a,5,5,456);
//--- mostrar valores
   for(int i=0;i&lt;ArraySize(a);i++) printf(&quot;a[%d] = %d&quot;,i,a[i]);
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1243
<h3>ArrayIsDynamic</h3>
A fun√ß√£o verifica se um array √© din√¢mico.
</p>
<pre><code class="language-mql5">
bool¬† ArrayIsDynamic(
   const void&amp;¬† array[]    // array verificado
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Array verificado.
<h3>Valor do Retorno</h3>
Retorna true se o array selecionado √© din√¢mico, caso contr√°rio retorna false.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property description &quot;Este indicador n√£o calcula valores. Faz uma √∫nica tentativa par
#property description &quot;aplicar a chamada da fun√ß√£o ArrayFree() para tr√™s arrays: din√¢m
#property description &quot;um buffer de indicador. Os resultados s√£o mostrados no jornal d
//--- configura√ß√µes do indicador
#property indicator_chart_window
#property indicator_buffers 1
#property indicator_plots   1
//--- vari√°veis globais
double ExtDynamic[];   // array din√¢mico
double ExtStatic[100]; // array est√°tico
bool   ExtFlag=true;   // bandeira
double ExtBuff[];      // buffer do indicador
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- alocar mem√≥ria para o array
   ArrayResize(ExtDynamic,100);
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,ExtBuff);
   PlotIndexSetDouble(0,PLOT_EMPTY_VALUE,0);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,
                const double &amp;price[])</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1244
</p>
<pre><code class="language-mql5">
  {
//--- executar uma an√°lise √∫nica
   if(ExtFlag)
     {
      //--- tentativa para liberar mem√≥ria para os arrays
      //--- 1. Array din√¢mico
      Print(&quot;+============================+&quot;);
      Print(&quot;1. Verificar o array din√¢mico:&quot;);
      Print(&quot;Antes do tamanho da mem√≥ria ser liberada = &quot;,ArraySize(ExtDynamic));
      Print(&quot;Isto √© um array din√¢mico = &quot;,ArrayIsDynamic(ExtDynamic) ? &quot;Sim&quot; : &quot;N√£o&quot;);
      //--- tentativa de liberar mem√≥ria do array
      ArrayFree(ExtDynamic);
      Print(&quot;Ap√≥s o tamanho da mem√≥ria ser liberada = &quot;,ArraySize(ExtDynamic));
      //--- 2. Array est√°tico
      Print(&quot;2. Verificar array est√°tico:&quot;);
      Print(&quot;Antes do tamanho da mem√≥ria ser liberada = &quot;,ArraySize(ExtStatic));
      Print(&quot;Isto √© um array din√¢mico = &quot;,ArrayIsDynamic(ExtStatic) ? &quot;Sim&quot; : &quot;N√£o&quot;);
      //--- tentativa de liberar mem√≥ria do array
      ArrayFree(ExtStatic);
      Print(&quot;Ap√≥s do tamanho da mem√≥ria ser liberada = &quot;,ArraySize(ExtStatic));
      //--- 3. Buffer do indicador
      Print(&quot;3. Verificar buffer do indicador:&quot;);
      Print(&quot;Antes do tamanho da mem√≥ria ser liberada = &quot;,ArraySize(ExtBuff));
      Print(&quot;Isto √© um array din√¢mico = &quot;,ArrayIsDynamic(ExtBuff) ? &quot;Sim&quot; : &quot;N√£o&quot;);
      //--- tentativa de liberar mem√≥ria do array
      ArrayFree(ExtBuff);
      Print(&quot;Ap√≥s do tamanho da mem√≥ria ser liberada = &quot;,ArraySize(ExtBuff));
      //--- alterar o valor do sinalizador
      ExtFlag=false;
     }
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
Acesso a s√©ries de tempo e indicadores </p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1245
<h3>ArrayIsSeries</h3>
A fun√ß√£o verifica se um array √© uma s√©rie de tempo.
</p>
<pre><code class="language-mql5">
bool¬† ArrayIsSeries(
   const void&amp;¬† array[]    // array verificado
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Array verificado.
<h3>Valor do Retorno</h3>
Retorna true, se o array verificado √© um array de s√©rie de tempo, caso contr√°rio, retorna false.
Arrays passados como par√¢metro para a fun√ß√£o OnCalculate() devem ser verificados quanto a ordem
de acesso dos elementos do array atrav√©s de ArrayGetAsSeries().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property indicator_chart_window
#property indicator_buffers 1
#property indicator_plots   1
//---- Plotar Etiqueta1
#property indicator_label1  &quot;Etiqueta1&quot;
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrRed
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- buffers do indicador
double         Label1Buffer[];
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
void OnInit()
  {
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,Label1Buffer,INDICATOR_DATA);
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1246
</p>
<pre><code class="language-mql5">
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])
  {
//---
   if(ArrayIsSeries(open))
      Print(&quot;open[] √© timeseries&quot;);
   else
      Print(&quot;open[] n√£o √© timeseries!!!&quot;);
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
Acesso a s√©ries de tempo e indicadores </p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1247
<h3>ArrayMaximum</h3>
Procura o maior elemento na primeira dimens√£o de um array num√©rico multidimensional.
</p>
<pre><code class="language-mql5">
int¬† ArrayMaximum(
   const void&amp;¬†  array[],¬†            // array para busca
   int¬†          start=0,             // √≠ndice a partir do qual come√ßa a verifica√ß√£o
   int¬†          count=WHOLE_ARRAY    // n√∫mero de elementos verificados
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Um array n√∫merico, na qual a busca √© feita.
start=0
[in]  √çndice a partir do qual come√ßa a verifica√ß√£o.
count=WHOLE_ARRAY
[in] 
 
<h3>N√∫mero</h3>
de 
elementos 
para 
busca. 
<h3>Por</h3>
padr√£o, 
busca 
no 
array 
inteiro
(count=WHOLE_ARRAY)..
<h3>Valor do Retorno</h3>
A fun√ß√£o retorna um √≠ndice de um elemento encontrado levando em considera√ß√£o a s√©rie do array.
Em caso de falha, retorna -1.
<h3>Observa√ß√£o</h3>
O valor da bandeira AS_SERIES √â levado em considera√ß√£o durante a procura de um m√°ximo.
Fun√ß√µes ArrayMaximum e ArrayMinimum aceitam arrays multi-dimensionais como um par√¢metro. No
entanto, a pesquisa √© sempre aplicada √† primeira (zero) dimens√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property description &quot;O indicador mostra sobre as barras (candlesticks) um prazo de t
//--- configura√ß√µes do indicador
#property indicator_chart_window
#property indicator_buffers 16
#property indicator_plots   8
//---- plot 1
#property indicator_label1  &quot;BearBody&quot;
#property indicator_color1  clrSeaGreen,clrSeaGreen
//---- plot 2
#property indicator_label2  &quot;BearBodyEnd&quot;
#property indicator_color2  clrSeaGreen,clrSeaGreen
//---- plot 3
#property indicator_label3  &quot;BearShadow&quot;
#property indicator_color3  clrSalmon,clrSalmon
//---- plot 4
#property indicator_label4  &quot;BearShadowEnd&quot;
#property indicator_color4  clrSalmon,clrSalmon</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1248
</p>
<pre><code class="language-mql5">
//---- plot 5
#property indicator_label5  &quot;BullBody&quot;
#property indicator_color5  clrOlive,clrOlive
//---- plot 6
#property indicator_label6  &quot;BullBodyEnd&quot;
#property indicator_color6  clrOlive,clrOlive
//---- plot 7
#property indicator_label7  &quot;BullShadow&quot;
#property indicator_color7  clrSkyBlue,clrSkyBlue
//---- plot 8
#property indicator_label8  &quot;BullShadowEnd&quot;
#property indicator_color8  clrSkyBlue,clrSkyBlue
//--- constante pr√©-definida
#define INDICATOR_EMPTY_VALUE 0.0
//--- par√¢metros de entrada
input ENUM_TIMEFRAMES InpPeriod=PERIOD_H4;              // Prazo de tempo para calcula
input datetime        InpDateStart=D&#x27;2013.01.01 00:00&#x27;; // Analisar a partir desta dat
//--- buffers do indicador para candlesticks de baixa
double   ExtBearBodyFirst[];
double   ExtBearBodySecond[];
double   ExtBearBodyEndFirst[];
double   ExtBearBodyEndSecond[];
double   ExtBearShadowFirst[];
double   ExtBearShadowSecond[];
double   ExtBearShadowEndFirst[];
double   ExtBearShadowEndSecond[];
//--- buffers do indicador para candlesticks de alta
double   ExtBullBodyFirst[];
double   ExtBullBodySecond[];
double   ExtBullBodyEndFirst[];
double   ExtBullBodyEndSecond[];
double   ExtBullShadowFirst[];
double   ExtBullShadowSecond[];
double   ExtBullShadowEndFirst[];
double   ExtBullShadowEndSecond[];
//--- vari√°veis globais
</code></pre>
<p>
datetime ExtTimeBuff[];      // buffer de tempo para maior periodicidade
</p>
<pre><code class="language-mql5">
int      ExtSize=0;          // tamanho do buffer de tempo
int      ExtCount=0;         // √≠ndice dentro do buffer de tempo
int      ExtStartPos=0;      // posi√ß√£o inicial para c√°lculo do indicador
bool     ExtStartFlag=true;  // sinalizador auxiliar para receber a posi√ß√£o inicial
</code></pre>
<p>
datetime ExtCurrentTime[1];  // √∫ltimo tempo na gera√ß√£o da barra de maior periodicidad
datetime ExtLastTime;        // √∫ltimo tempo a partir da barra de maior periodicidade,
</p>
<pre><code class="language-mql5">
bool     ExtBearFlag=true;   // flag para definir a ordem de escrita do dados para os 
bool     ExtBullFlag=true;   // flag para definir a ordem de escrita do dados para os 
int      ExtIndexMax=0;      // √≠ndice do elemento m√°ximo do array
int      ExtIndexMin=0;      // √≠ndice do elemento m√≠nimo do array
int      ExtDirectionFlag=0; // dire√ß√£o de movimento de pre√ßos para o atual candlestic
//--- alternar entre o pre√ßo de abertura e fechamento do candlestick para desenhar cor</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1249
const double ExtEmptyBodySize=0.2*SymbolInfoDouble(Symbol(),SYMBOL_POINT);
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preenchendo a parte b√°sica do candlestick¬†                       |
//+------------------------------------------------------------------+
void FillCandleMain(const double &amp;open[],const double &amp;close[],
                    const double &amp;high[],const double &amp;low[],
                    const int start,const int last,const int fill_index,
                    int &amp;index_max,int &amp;index_min)
  {
//--- encontrar o √≠ndice dos elementos m√°ximo e m√≠nimo nos arrays
   index_max=ArrayMaximum(high,ExtStartPos,last-start+1); // m√°ximo em Alta
   index_min=ArrayMinimum(low,ExtStartPos,last-start+1);  // m√≠nimo em Baixa
//--- definir quantas barras do per√≠odo de tempo atual ser√£o preenchidas
   int count=fill_index-start+1;
//--- se o pre√ßo de fechamento no primeiro bar √© excede ao do √∫ltimo bar, o candlestic
   if(open[start]&gt;close[last])
     {
      //--- antes que o candlestick seja de alta, limpar os valores de alta dos buffer
      if(ExtDirectionFlag!=-1)
         ClearCandle(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShad
      //--- candlestick de baixa
      ExtDirectionFlag=-1;
      //--- gerar o candlestick
      FormCandleMain(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
                     close[last],high[index_max],low[index_min],start,count,ExtBearFla
      //--- sair da fun√ß√£o
      return;
     }
//--- se o pre√ßo de fechamento no primeiro bar √© menor do que √∫ltimo bar, o candlestic
   if(open[start]&lt;close[last])
     {
      //--- antes que o candlestick seja de baixa, limpar os valores de baixa dos buff
      if(ExtDirectionFlag!=1)
         ClearCandle(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
      //--- candlesticks de alta
      ExtDirectionFlag=1;
      //--- gerar o candlestick
      FormCandleMain(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShad
                     open[start],high[index_max],low[index_min],start,count,ExtBullFla
      //--- sair da fun√ß√£o
      return;
     }
//--- se voc√™ est√° nesta parte da fun√ß√£o, o pre√ßo de abertura no primeiro bar √© igual 
//--- pre√ßo de fechamento no √∫ltimo bar; ent√£o o candlestick √© considerado de baixa
//--- antes que o candlestick seja de alta, limpar os valores de alta dos buffers do i
   if(ExtDirectionFlag!=-1)
      ClearCandle(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShadowS
//--- candlestick de baixa
   ExtDirectionFlag=-1;</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1250
</p>
<pre><code class="language-mql5">
//--- se os pre√ßos de fechamento e de abertura s√£o iguais, use o deslocamento para a e
   if(high[index_max]!=low[index_min])
      FormCandleMain(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
                     open[start]-ExtEmptyBodySize,high[index_max],low[index_min],start
   else
      FormCandleMain(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
                     open[start],open[start]-ExtEmptyBodySize,high[index_max],
                     high[index_max]-ExtEmptyBodySize,start,count,ExtBearFlag);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preencher o final do candlestick¬†                                |
//+------------------------------------------------------------------+
void FillCandleEnd(const double &amp;open[],const double &amp;close[],
                   const double &amp;high[],const double &amp;low[],
                   const int start,const int last,const int fill_index,
                   const int index_max,const int index_min)
  {
//--- n√£o desenhar em caso de uma √∫nica barra
   if(last-start==0)
      return;
//--- se o pre√ßo de fechamento no primeiro bar √© excede ao do √∫ltimo bar, o candlestic
   if(open[start]&gt;close[last])
     {
      //--- gerar o final do candelstick
      FormCandleEnd(ExtBearBodyEndFirst,ExtBearBodyEndSecond,ExtBearShadowEndFirst,Ext
                    open[start],close[last],high[index_max],low[index_min],fill_index,
      //--- sair da fun√ß√£o
      return;
     }
//--- se o pre√ßo de fechamento no primeiro bar √© menor do que √∫ltimo bar, o candlestic
   if(open[start]&lt;close[last])
     {
      //--- gerar o final do candelstick
      FormCandleEnd(ExtBullBodyEndFirst,ExtBullBodyEndSecond,ExtBullShadowEndFirst,Ext
                    close[last],open[start],high[index_max],low[index_min],fill_index,
      //--- sair da fun√ß√£o
      return;
     }
//--- se voc√™ est√° nesta parte da fun√ß√£o, o pre√ßo de abertura no primeiro bar √© igual 
//--- pre√ßo de fechamento no √∫ltimo bar; ent√£o o candlestick √© considerado de baixa
//--- gerar o final do candelstick
   if(high[index_max]!=low[index_min])
      FormCandleEnd(ExtBearBodyEndFirst,ExtBearBodyEndSecond,ExtBearShadowEndFirst,Ext
                    open[start]-ExtEmptyBodySize,high[index_max],low[index_min],fill_i
   else
      FormCandleEnd(ExtBearBodyEndFirst,ExtBearBodyEndSecond,ExtBearShadowEndFirst,Ext
                    open[start]-ExtEmptyBodySize,high[index_max],high[index_max]-ExtEm
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1251
</p>
<pre><code class="language-mql5">
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- verificar o per√≠odo do indicador
   if(!CheckPeriod((int)Period(),(int)InpPeriod))
      return(INIT_PARAMETERS_INCORRECT);
//--- exibir dados de pre√ßo num primeiro plano
   ChartSetInteger(0,CHART_FOREGROUND,0,1);
//--- vincular buffers do indicador
   SetIndexBuffer(0,ExtBearBodyFirst);
   SetIndexBuffer(1,ExtBearBodySecond);
   SetIndexBuffer(2,ExtBearBodyEndFirst);
   SetIndexBuffer(3,ExtBearBodyEndSecond);
   SetIndexBuffer(4,ExtBearShadowFirst);
   SetIndexBuffer(5,ExtBearShadowSecond);
   SetIndexBuffer(6,ExtBearShadowEndFirst);
   SetIndexBuffer(7,ExtBearShadowEndSecond);
   SetIndexBuffer(8,ExtBullBodyFirst);
   SetIndexBuffer(9,ExtBullBodySecond);
   SetIndexBuffer(10,ExtBullBodyEndFirst);
   SetIndexBuffer(11,ExtBullBodyEndSecond);
   SetIndexBuffer(12,ExtBullShadowFirst);
   SetIndexBuffer(13,ExtBullShadowSecond);
   SetIndexBuffer(14,ExtBullShadowEndFirst);
   SetIndexBuffer(15,ExtBullShadowEndSecond);
//--- definir alguns valores de propriedade para a cria√ß√£o do indicador
   for(int i=0;i&lt;8;i++)
     {
      PlotIndexSetInteger(i,PLOT_DRAW_TYPE,DRAW_FILLING); // tipo de constru√ß√£o gr√°fic
      PlotIndexSetInteger(i,PLOT_LINE_STYLE,STYLE_SOLID); // estilo de linha de desenh
      PlotIndexSetInteger(i,PLOT_LINE_WIDTH,1);           // largura de linha de desen
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1252
</p>
<pre><code class="language-mql5">
  {
//--- neste caso ainda n√£o existe c√°lculos de barras
   if(prev_calculated==0)
     {
      //--- receber a maior periodicidade das barra no tempo de chegada
      if(!GetTimeData())
         return(0);
     }
//--- definir a indexa√ß√£o direta
   ArraySetAsSeries(time,false);
   ArraySetAsSeries(high,false);
   ArraySetAsSeries(low,false);
   ArraySetAsSeries(open,false);
   ArraySetAsSeries(close,false);
//--- iniciar vari√°vel para o c√°lculo das barras
   int start=prev_calculated;
//--- se uma barra √© gerada, recalcular o valor do indicador sobre ela
   if(start!=0 &amp;&amp; start==rates_total)
      start--;
//--- o loop para c√°lculos dos valores do indicador
   for(int i=start;i&lt;rates_total;i++)
     {
      //--- preencher i elementos dos buffers do indicador por valores vazios
      FillIndicatorBuffers(i);
      //--- executar c√°lculos para as barras iniciando a partir dos dados InpDateStart
      if(time[i]&gt;=InpDateStart)
        {
         //--- definir posi√ß√£o, a partir do qual os valores s√£o exibidos pela primeira
         if(ExtStartFlag)
           {
            //--- armazenar o n√∫mero do bar inicial
            ExtStartPos=i;
            //--- definir a primeira data a partir da maior periodicidade excedendo ti
            while(time[i]&gt;=ExtTimeBuff[ExtCount])
               if(ExtCount&lt;ExtSize-1)
                  ExtCount++;
            //--- alterar o valor da sinaliza√ß√£o em ordem n√£o executada neste bloco no
            ExtStartFlag=false;
           }
         //--- verificar se ainda existem quaisquer elementos no array
         if(ExtCount&lt;ExtSize)
           {
            //--- esperar o valor da periodicidade atual para chegar a um maior per√≠od
            if(time[i]&gt;=ExtTimeBuff[ExtCount])
              {
               //--- desenhar a parte principal do candlestick (sem preencher o espa√ßo
               FillCandleMain(open,close,high,low,ExtStartPos,i-1,i-2,ExtIndexMax,ExtI
               //--- preencher o final do candlestick(a √°rea entre a √∫ltima e a pen√∫lt
               FillCandleEnd(open,close,high,low,ExtStartPos,i-1,i-1,ExtIndexMax,ExtIn</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1253
</p>
<pre><code class="language-mql5">
               //--- deslocar a posi√ß√£o inicial para desenhar o pr√≥ximo candlestick
               ExtStartPos=i;
               //--- aumentar o contador de array
               ExtCount++;
              }
            else
               continue;
           }
         else
           {
            //--- redefinir os valores de array
            ResetLastError();
            //--- receber a √∫ltima data do maior per√≠odo de tempo
            if(CopyTime(Symbol(),InpPeriod,0,1,ExtCurrentTime)==-1)
              {
               Print(&quot;Erro na c√≥pia dos dados, c√≥digo = &quot;,GetLastError());
               return(0);
              }
            //--- se a nova data for posterior, parar de gerar o candlestick
            if(ExtCurrentTime[0]&gt;ExtLastTime)
              {
               //--- limpar a √°rea entre a √∫ltima e a pen√∫ltima barra nos principais b
               ClearEndOfBodyMain(i-1);
               //--- preencher a √°rea usando buffers auxiliares do indicador
               FillCandleEnd(open,close,high,low,ExtStartPos,i-1,i-1,ExtIndexMax,ExtIn
               //--- deslocar a posi√ß√£o inicial para desenhar o pr√≥ximo candlestick
               ExtStartPos=i;
               //--- restabelecer flag da dire√ß√£o do pre√ßo
               ExtDirectionFlag=0;
               //--- armazenar a nova √∫ltima data
               ExtLastTime=ExtCurrentTime[0];
              }
            else
              {
               //--- gerar o candlestick
               FillCandleMain(open,close,high,low,ExtStartPos,i,i,ExtIndexMax,ExtIndex
              }
           }
        }
     }
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Verificar a exatid√£o do per√≠odo do indicador determinado¬†        |
//+------------------------------------------------------------------+
bool CheckPeriod(int current_period,int high_period)
  {
//--- o per√≠odo do indicador deve ultrapassar o per√≠odo de tempo que √© exibido sobre</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1254
</p>
<pre><code class="language-mql5">
   if(current_period&gt;=high_period)
     {
      Print(&quot;Erro! O valor do per√≠odo do indicador deve exceder o valor do intervalo d
      return(false);
     }
//--- se o per√≠odo do indicador √© de uma semana ou um m√™s, o per√≠odo est√° correto
   if(high_period&gt;32768)
      return(true);
//--- converter valores do per√≠odo para minutos
   if(high_period&gt;30)
      high_period=(high_period-16384)*60;
   if(current_period&gt;30)
      current_period=(current_period-16384)*60;
//--- o per√≠odo do indicador deve ser m√∫ltiplo do per√≠odo de tempo, √© exibido sobre
   if(high_period%current_period!=0)
     {
      Print(&quot;Erro! O valor do per√≠odo do indicador deve ser m√∫ltiplo ao valor do atual
      return(false);
     }
//--- o per√≠odo do indicador deve exceder o prazo de tempo quando apresentado de 3 ou 
   if(high_period/current_period&lt;3)
     {
      Print(&quot;Erro! O per√≠odo do indicador deve exceder o prazo atual de 3 ou mais veze
      return(false);
     }
//--- O per√≠odo do indicador √© o correto para a atual periodicidade
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Receber dados de tempo a partir da maior prazo de tempo¬†         |
//+------------------------------------------------------------------+
bool GetTimeData(void)
  {
//--- redefine o valor de erro
   ResetLastError();
//--- copiar todos os dados para o tempo atual
   if(CopyTime(Symbol(),InpPeriod,InpDateStart,TimeCurrent(),ExtTimeBuff)==-1)
     {
      //--- receber o c√≥digo de erro
      int code=GetLastError();
      //--- imprimir a mensagem de erro
      PrintFormat(&quot;Erro de c√≥pia de dados! %s&quot;,code==4401
                  ? &quot;Hist√≥rico ainda est√° sendo carregado!&quot;
                  : &quot;C√≥digo = &quot;+IntegerToString(code));
      //--- retornar falso para fazer uma tentativa de repetir o download de dados
      return(false);
     }
//--- recebe o tamanho do array
   ExtSize=ArraySize(ExtTimeBuff);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1255
</p>
<pre><code class="language-mql5">
//--- definir o √≠ndice do loop para o array zero
   ExtCount=0;
//--- definir a posi√ß√£o atual do candlestick no per√≠odo de tempo para zero
   ExtStartPos=0;
   ExtStartFlag=true;
//--- armazenar o √∫ltimo valor de tempo a partir da maior periodicidade
   ExtLastTime=ExtTimeBuff[ExtSize-1];
//--- sucesso na execu√ß√£o
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------------------+
//| Fun√ß√£o constitui a parte principal do candlestick. Dependendo do sinalizador |
//| valor, a fun√ß√£o define quais dados e arrays ser√£o¬†                       |
//| usados para exibi√ß√£o correta.¬†                                               |
//+------------------------------------------------------------------------------+
void FormCandleMain(double &amp;body_fst[],double &amp;body_snd[],
                    double &amp;shadow_fst[],double &amp;shadow_snd[],
                    const double fst_value,const double snd_value,
                    const double fst_extremum,const double snd_extremum,
                    const int start,const int count,const bool flag)
  {
//--- verificar o valor do flag
   if(flag)
     {
      //--- gerar o corpo do candlestick
      FormMain(body_fst,body_snd,fst_value,snd_value,start,count);
      //--- gerar a sombra do candlestick
      FormMain(shadow_fst,shadow_snd,fst_extremum,snd_extremum,start,count);
     }
   else
     {
      //--- gerar o corpo do candlestick
      FormMain(body_fst,body_snd,snd_value,fst_value,start,count);
      //--- gerar a sombra do candlestick
      FormMain(shadow_fst,shadow_snd,snd_extremum,fst_extremum,start,count);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+-------------------------------------------------------------------------------+
//| A fun√ß√£o para formar o final do candlestick. Depende do valor do sinalizador, |
//| a fun√ß√£o define quais dados e arrays s√£o¬†                                     |
//| usados para exibi√ß√£o correta.¬†                                                |
//+-------------------------------------------------------------------------------+
void FormCandleEnd(double &amp;body_fst[],double &amp;body_snd[],
                   double &amp;shadow_fst[],double &amp;shadow_snd[],
                   const double fst_value,const double snd_value,
                   const double fst_extremum,const double snd_extremum,
                   const int end,bool &amp;flag)
  {
//--- verificar o valor do flag</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1256
</p>
<pre><code class="language-mql5">
   if(flag)
     {
      //--- gerar o final do corpo do candlestick
      FormEnd(body_fst,body_snd,fst_value,snd_value,end);
      //--- gerar o final da sombra do candlestick
      FormEnd(shadow_fst,shadow_snd,fst_extremum,snd_extremum,end);
      //--- alterar o valor do sinalizador para o oposto
      flag=false;
     }
   else
     {
      //--- gerar o final do corpo do candlestick
      FormEnd(body_fst,body_snd,snd_value,fst_value,end);
      //--- gerar o final da sombra do candlestick
      FormEnd(shadow_fst,shadow_snd,snd_extremum,fst_extremum,end);
      //--- alterar o valor do sinalizador para o oposto
      flag=true;
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+---------------------------------------------------------------------------------+
//| Limpar o fim do candlestick (a √°rea entre a √∫ltima e a pen√∫ltima¬†               |
//| barra)                                                                          |
//+---------------------------------------------------------------------------------+
void ClearEndOfBodyMain(const int ind)
  {
   ClearCandle(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShadowSeco
   ClearCandle(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShadowSeco
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+--------------------------------------------------------------------------+
//| Limpar o candlestick¬†                                                    |
//+--------------------------------------------------------------------------+
void ClearCandle(double &amp;body_fst[],double &amp;body_snd[],double &amp;shadow_fst[],
                 double &amp;shadow_snd[],const int start,const int count)
  {
//--- verificar
   if(count!=0)
     {
      //--- preencher buffers do indicador com valores vazios
      ArrayFill(body_fst,start,count,INDICATOR_EMPTY_VALUE);
      ArrayFill(body_snd,start,count,INDICATOR_EMPTY_VALUE);
      ArrayFill(shadow_fst,start,count,INDICATOR_EMPTY_VALUE);
      ArrayFill(shadow_snd,start,count,INDICATOR_EMPTY_VALUE);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+--------------------------------------------------------------------------+
//| Gerar a parte principal do candlestick¬†                                  |
//+--------------------------------------------------------------------------+
void FormMain(double &amp;fst[],double &amp;snd[],const double fst_value,
              const double snd_value,const int start,const int count)</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1257
</p>
<pre><code class="language-mql5">
  {
//--- verificar
   if(count!=0)
     {
      //--- preencher o buffer do indicador com valores
      ArrayFill(fst,start,count,fst_value);
      ArrayFill(snd,start,count,snd_value);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+-----------------------------------------------------------------------------+
//| Gerar o final do candlestick¬†                                               |
//+-----------------------------------------------------------------------------+
void FormEnd(double &amp;fst[],double &amp;snd[],const double fst_value,
             const double snd_value,const int last)
  {
//--- preencher o buffer do indicador com valores
   ArrayFill(fst,last-1,2,fst_value);
   ArrayFill(snd,last-1,2,snd_value);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preencher i elemento dos buffers do indicador por valores vazios¬†|
//+------------------------------------------------------------------+
void FillIndicatorBuffers(const int i)
  {
//--- definir um valor vazio na c√©lula dos buffers do indicador
   ExtBearBodyFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearBodySecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBearBodyEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearBodyEndSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowEndSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodyFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodySecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodyEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodyEndSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowEndSecond[i]=INDICATOR_EMPTY_VALUE;
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1258
<h3>ArrayMinimum</h3>
Procura o elemento mais baixo na primeira dimens√£o de um array num√©rico multidimensional.
</p>
<pre><code class="language-mql5">
int¬† ArrayMinimum(
   const void&amp;¬†  array[],¬†            // array para busca
   int¬†          start=0,             // √≠ndice a partir do qual come√ßa a verifica√ß√£o
   int¬†          count=WHOLE_ARRAY    // n√∫mero de elementos verificados
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Um array n√∫merico, na qual a busca √© feita.
start=0
[in]  √çndice a partir do qual come√ßa a verifica√ß√£o.
count=WHOLE_ARRAY
[in] 
 
<h3>N√∫mero</h3>
de 
elementos 
para 
busca. 
<h3>Por</h3>
padr√£o, 
busca 
no 
array 
inteiro
(count=WHOLE_ARRAY)..
<h3>Valor do Retorno</h3>
A fun√ß√£o retorna um √≠ndice de um elemento encontrado levando em considera√ß√£o a s√©rie do array.
Em caso de falha, retorna -1.
<h3>Observa√ß√£o</h3>
O valor da flag AS_SERIES √© levado em conta durante a busca de um m√≠nimo.
Fun√ß√µes ArrayMaximum e ArrayMinimum aceitam arrays multi-dimensionais como um par√¢metro. No
entanto, a pesquisa √© sempre aplicada √† primeira (zero) dimens√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property description &quot;O indicador mostra sobre as barras (candlesticks) um prazo de t
//--- configura√ß√µes do indicador
#property indicator_chart_window
#property indicator_buffers 16
#property indicator_plots   8
//---- plot 1
#property indicator_label1  &quot;BearBody&quot;
#property indicator_color1  clrSeaGreen,clrSeaGreen
//---- plot 2
#property indicator_label2  &quot;BearBodyEnd&quot;
#property indicator_color2  clrSeaGreen,clrSeaGreen
//---- plot 3
#property indicator_label3  &quot;BearShadow&quot;
#property indicator_color3  clrSalmon,clrSalmon
//---- plot 4
#property indicator_label4  &quot;BearShadowEnd&quot;
#property indicator_color4  clrSalmon,clrSalmon</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1259
</p>
<pre><code class="language-mql5">
//---- plot 5
#property indicator_label5  &quot;BullBody&quot;
#property indicator_color5  clrOlive,clrOlive
//---- plot 6
#property indicator_label6  &quot;BullBodyEnd&quot;
#property indicator_color6  clrOlive,clrOlive
//---- plot 7
#property indicator_label7  &quot;BullShadow&quot;
#property indicator_color7  clrSkyBlue,clrSkyBlue
//---- plot 8
#property indicator_label8  &quot;BullShadowEnd&quot;
#property indicator_color8  clrSkyBlue,clrSkyBlue
//--- constante pr√©-definida
#define INDICATOR_EMPTY_VALUE 0.0
//--- par√¢metros de entrada
input ENUM_TIMEFRAMES InpPeriod=PERIOD_H4;              // Prazo de tempo para calcula
input datetime        InpDateStart=D&#x27;2013.01.01 00:00&#x27;; // Analisar a partir desta dat
//--- buffers do indicador para candlesticks de baixa
double   ExtBearBodyFirst[];
double   ExtBearBodySecond[];
double   ExtBearBodyEndFirst[];
double   ExtBearBodyEndSecond[];
double   ExtBearShadowFirst[];
double   ExtBearShadowSecond[];
double   ExtBearShadowEndFirst[];
double   ExtBearShadowEndSecond[];
//--- buffers do indicador para candlesticks de alta
double   ExtBullBodyFirst[];
double   ExtBullBodySecond[];
double   ExtBullBodyEndFirst[];
double   ExtBullBodyEndSecond[];
double   ExtBullShadowFirst[];
double   ExtBullShadowSecond[];
double   ExtBullShadowEndFirst[];
double   ExtBullShadowEndSecond[];
//--- vari√°veis globais
</code></pre>
<p>
datetime ExtTimeBuff[];      // buffer de tempo para maior periodicidade
</p>
<pre><code class="language-mql5">
int      ExtSize=0;          // tamanho do buffer de tempo
int      ExtCount=0;         // √≠ndice dentro do buffer de tempo
int      ExtStartPos=0;      // posi√ß√£o inicial para c√°lculo do indicador
bool     ExtStartFlag=true;  // sinalizador auxiliar para receber a posi√ß√£o inicial
</code></pre>
<p>
datetime ExtCurrentTime[1];  // √∫ltimo tempo na gera√ß√£o da barra de maior periodicidad
datetime ExtLastTime;        // √∫ltimo tempo a partir da barra de maior periodicidade,
</p>
<pre><code class="language-mql5">
bool     ExtBearFlag=true;   // flag para definir a ordem de escrita do dados para os 
bool     ExtBullFlag=true;   // flag para definir a ordem de escrita do dados para os 
int      ExtIndexMax=0;      // √≠ndice do elemento m√°ximo do array
int      ExtIndexMin=0;      // √≠ndice do elemento m√≠nimo do array
int      ExtDirectionFlag=0; // dire√ß√£o de movimento de pre√ßos para o atual candlestic
//--- alternar entre o pre√ßo de abertura e fechamento do candlestick para desenhar cor</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1260
const double ExtEmptyBodySize=0.2*SymbolInfoDouble(Symbol(),SYMBOL_POINT);
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preenchendo a parte b√°sica do candlestick¬†                       |
//+------------------------------------------------------------------+
void FillCandleMain(const double &amp;open[],const double &amp;close[],
                    const double &amp;high[],const double &amp;low[],
                    const int start,const int last,const int fill_index,
                    int &amp;index_max,int &amp;index_min)
  {
//--- encontrar o √≠ndice dos elementos m√°ximo e m√≠nimo nos arrays
   index_max=ArrayMaximum(high,ExtStartPos,last-start+1); // m√°ximo em Alta
   index_min=ArrayMinimum(low,ExtStartPos,last-start+1);  // m√≠nimo em Baixa
//--- definir quantas barras do per√≠odo de tempo atual ser√£o preenchidas
   int count=fill_index-start+1;
//--- se o pre√ßo de fechamento no primeiro bar √© excede ao do √∫ltimo bar, o candlestic
   if(open[start]&gt;close[last])
     {
      //--- antes que o candlestick seja de alta, limpar os valores de alta dos buffer
      if(ExtDirectionFlag!=-1)
         ClearCandle(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShad
      //--- candlestick de baixa
      ExtDirectionFlag=-1;
      //--- gerar o candlestick
      FormCandleMain(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
                     close[last],high[index_max],low[index_min],start,count,ExtBearFla
      //--- sair da fun√ß√£o
      return;
     }
//--- se o pre√ßo de fechamento no primeiro bar √© menor do que √∫ltimo bar, o candlestic
   if(open[start]&lt;close[last])
     {
      //--- antes que o candlestick seja de baixa, limpar os valores de baixa dos buff
      if(ExtDirectionFlag!=1)
         ClearCandle(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
      //--- candlesticks de alta
      ExtDirectionFlag=1;
      //--- gerar o candlestick
      FormCandleMain(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShad
                     open[start],high[index_max],low[index_min],start,count,ExtBullFla
      //--- sair da fun√ß√£o
      return;
     }
//--- se voc√™ est√° nesta parte da fun√ß√£o, o pre√ßo de abertura no primeiro bar √© igual 
//--- pre√ßo de fechamento no √∫ltimo bar; ent√£o o candlestick √© considerado de baixa
//--- antes que o candlestick seja de alta, limpar os valores de alta dos buffers do i
   if(ExtDirectionFlag!=-1)
      ClearCandle(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShadowS
//--- candlestick de baixa
   ExtDirectionFlag=-1;</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1261
</p>
<pre><code class="language-mql5">
//--- se os pre√ßos de fechamento e de abertura s√£o iguais, use o deslocamento para a e
   if(high[index_max]!=low[index_min])
      FormCandleMain(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
                     open[start]-ExtEmptyBodySize,high[index_max],low[index_min],start
   else
      FormCandleMain(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShad
                     open[start],open[start]-ExtEmptyBodySize,high[index_max],
                     high[index_max]-ExtEmptyBodySize,start,count,ExtBearFlag);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preencher o final do candlestick¬†                                |
//+------------------------------------------------------------------+
void FillCandleEnd(const double &amp;open[],const double &amp;close[],
                   const double &amp;high[],const double &amp;low[],
                   const int start,const int last,const int fill_index,
                   const int index_max,const int index_min)
  {
//--- n√£o desenhar em caso de uma √∫nica barra
   if(last-start==0)
      return;
//--- se o pre√ßo de fechamento no primeiro bar √© excede ao do √∫ltimo bar, o candlestic
   if(open[start]&gt;close[last])
     {
      //--- gerar o final do candelstick
      FormCandleEnd(ExtBearBodyEndFirst,ExtBearBodyEndSecond,ExtBearShadowEndFirst,Ext
                    open[start],close[last],high[index_max],low[index_min],fill_index,
      //--- sair da fun√ß√£o
      return;
     }
//--- se o pre√ßo de fechamento no primeiro bar √© menor do que √∫ltimo bar, o candlestic
   if(open[start]&lt;close[last])
     {
      //--- gerar o final do candelstick
      FormCandleEnd(ExtBullBodyEndFirst,ExtBullBodyEndSecond,ExtBullShadowEndFirst,Ext
                    close[last],open[start],high[index_max],low[index_min],fill_index,
      //--- sair da fun√ß√£o
      return;
     }
//--- se voc√™ est√° nesta parte da fun√ß√£o, o pre√ßo de abertura no primeiro bar √© igual 
//--- pre√ßo de fechamento no √∫ltimo bar; ent√£o o candlestick √© considerado de baixa
//--- gerar o final do candelstick
   if(high[index_max]!=low[index_min])
      FormCandleEnd(ExtBearBodyEndFirst,ExtBearBodyEndSecond,ExtBearShadowEndFirst,Ext
                    open[start]-ExtEmptyBodySize,high[index_max],low[index_min],fill_i
   else
      FormCandleEnd(ExtBearBodyEndFirst,ExtBearBodyEndSecond,ExtBearShadowEndFirst,Ext
                    open[start]-ExtEmptyBodySize,high[index_max],high[index_max]-ExtEm
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1262
</p>
<pre><code class="language-mql5">
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- verificar o per√≠odo do indicador
   if(!CheckPeriod((int)Period(),(int)InpPeriod))
      return(INIT_PARAMETERS_INCORRECT);
//--- exibir dados de pre√ßo num primeiro plano
   ChartSetInteger(0,CHART_FOREGROUND,0,1);
//--- vincular buffers do indicador
   SetIndexBuffer(0,ExtBearBodyFirst);
   SetIndexBuffer(1,ExtBearBodySecond);
   SetIndexBuffer(2,ExtBearBodyEndFirst);
   SetIndexBuffer(3,ExtBearBodyEndSecond);
   SetIndexBuffer(4,ExtBearShadowFirst);
   SetIndexBuffer(5,ExtBearShadowSecond);
   SetIndexBuffer(6,ExtBearShadowEndFirst);
   SetIndexBuffer(7,ExtBearShadowEndSecond);
   SetIndexBuffer(8,ExtBullBodyFirst);
   SetIndexBuffer(9,ExtBullBodySecond);
   SetIndexBuffer(10,ExtBullBodyEndFirst);
   SetIndexBuffer(11,ExtBullBodyEndSecond);
   SetIndexBuffer(12,ExtBullShadowFirst);
   SetIndexBuffer(13,ExtBullShadowSecond);
   SetIndexBuffer(14,ExtBullShadowEndFirst);
   SetIndexBuffer(15,ExtBullShadowEndSecond);
//--- definir alguns valores de propriedade para a cria√ß√£o do indicador
   for(int i=0;i&lt;8;i++)
     {
      PlotIndexSetInteger(i,PLOT_DRAW_TYPE,DRAW_FILLING); // tipo de constru√ß√£o gr√°fic
      PlotIndexSetInteger(i,PLOT_LINE_STYLE,STYLE_SOLID); // estilo de linha de desenh
      PlotIndexSetInteger(i,PLOT_LINE_WIDTH,1);           // largura de linha de desen
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1263
</p>
<pre><code class="language-mql5">
  {
//--- neste caso ainda n√£o existe c√°lculos de barras
   if(prev_calculated==0)
     {
      //--- receber a maior periodicidade das barra no tempo de chegada
      if(!GetTimeData())
         return(0);
     }
//--- definir a indexa√ß√£o direta
   ArraySetAsSeries(time,false);
   ArraySetAsSeries(high,false);
   ArraySetAsSeries(low,false);
   ArraySetAsSeries(open,false);
   ArraySetAsSeries(close,false);
//--- iniciar vari√°vel para o c√°lculo das barras
   int start=prev_calculated;
//--- se uma barra √© gerada, recalcular o valor do indicador sobre ela
   if(start!=0 &amp;&amp; start==rates_total)
      start--;
//--- o loop para c√°lculos dos valores do indicador
   for(int i=start;i&lt;rates_total;i++)
     {
      //--- preencher i elementos dos buffers do indicador por valores vazios
      FillIndicatorBuffers(i);
      //--- executar c√°lculos para as barras iniciando a partir dos dados InpDateStart
      if(time[i]&gt;=InpDateStart)
        {
         //--- definir posi√ß√£o, a partir do qual os valores s√£o exibidos pela primeira
         if(ExtStartFlag)
           {
            //--- armazenar o n√∫mero do bar inicial
            ExtStartPos=i;
            //--- definir a primeira data a partir da maior periodicidade excedendo ti
            while(time[i]&gt;=ExtTimeBuff[ExtCount])
               if(ExtCount&lt;ExtSize-1)
                  ExtCount++;
            //--- alterar o valor da sinaliza√ß√£o em ordem n√£o executada neste bloco no
            ExtStartFlag=false;
           }
         //--- verificar se ainda existem quaisquer elementos no array
         if(ExtCount&lt;ExtSize)
           {
            //--- esperar o valor da periodicidade atual para chegar a um maior per√≠od
            if(time[i]&gt;=ExtTimeBuff[ExtCount])
              {
               //--- desenhar a parte principal do candlestick (sem preencher o espa√ßo
               FillCandleMain(open,close,high,low,ExtStartPos,i-1,i-2,ExtIndexMax,ExtI
               //--- preencher o final do candlestick(a √°rea entre a √∫ltima e a pen√∫lt
               FillCandleEnd(open,close,high,low,ExtStartPos,i-1,i-1,ExtIndexMax,ExtIn</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1264
</p>
<pre><code class="language-mql5">
               //--- deslocar a posi√ß√£o inicial para desenhar o pr√≥ximo candlestick
               ExtStartPos=i;
               //--- aumentar o contador de array
               ExtCount++;
              }
            else
               continue;
           }
         else
           {
            //--- redefinir os valores de array
            ResetLastError();
            //--- receber a √∫ltima data do maior per√≠odo de tempo
            if(CopyTime(Symbol(),InpPeriod,0,1,ExtCurrentTime)==-1)
              {
               Print(&quot;Erro na c√≥pia dos dados, c√≥digo = &quot;,GetLastError());
               return(0);
              }
            //--- se a nova data for posterior, parar de gerar o candlestick
            if(ExtCurrentTime[0]&gt;ExtLastTime)
              {
               //--- limpar a √°rea entre a √∫ltima e a pen√∫ltima barra nos principais b
               ClearEndOfBodyMain(i-1);
               //--- preencher a √°rea usando buffers auxiliares do indicador
               FillCandleEnd(open,close,high,low,ExtStartPos,i-1,i-1,ExtIndexMax,ExtIn
               //--- deslocar a posi√ß√£o inicial para desenhar o pr√≥ximo candlestick
               ExtStartPos=i;
               //--- restabelecer flag da dire√ß√£o do pre√ßo
               ExtDirectionFlag=0;
               //--- armazenar a nova √∫ltima data
               ExtLastTime=ExtCurrentTime[0];
              }
            else
              {
               //--- gerar o candlestick
               FillCandleMain(open,close,high,low,ExtStartPos,i,i,ExtIndexMax,ExtIndex
              }
           }
        }
     }
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Verificar a exatid√£o do per√≠odo do indicador determinado¬†        |
//+------------------------------------------------------------------+
bool CheckPeriod(int current_period,int high_period)
  {
//--- o per√≠odo do indicador deve ultrapassar o per√≠odo de tempo que √© exibido sobre</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1265
</p>
<pre><code class="language-mql5">
   if(current_period&gt;=high_period)
     {
      Print(&quot;Erro! O valor do per√≠odo do indicador deve exceder o valor do intervalo d
      return(false);
     }
//--- se o per√≠odo do indicador √© de uma semana ou um m√™s, o per√≠odo est√° correto
   if(high_period&gt;32768)
      return(true);
//--- converter valores do per√≠odo para minutos
   if(high_period&gt;30)
      high_period=(high_period-16384)*60;
   if(current_period&gt;30)
      current_period=(current_period-16384)*60;
//--- o per√≠odo do indicador deve ser m√∫ltiplo do per√≠odo de tempo, √© exibido sobre
   if(high_period%current_period!=0)
     {
      Print(&quot;Erro! O valor do per√≠odo do indicador deve ser m√∫ltiplo ao valor do atual
      return(false);
     }
//--- o per√≠odo do indicador deve exceder o prazo de tempo quando apresentado de 3 ou 
   if(high_period/current_period&lt;3)
     {
      Print(&quot;Erro! O per√≠odo do indicador deve exceder o prazo atual de 3 ou mais veze
      return(false);
     }
//--- O per√≠odo do indicador √© o correto para a atual periodicidade
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Receber dados de tempo a partir da maior prazo de tempo¬†         |
//+------------------------------------------------------------------+
bool GetTimeData(void)
  {
//--- redefine o valor de erro
   ResetLastError();
//--- copiar todos os dados para o tempo atual
   if(CopyTime(Symbol(),InpPeriod,InpDateStart,TimeCurrent(),ExtTimeBuff)==-1)
     {
      //--- receber o c√≥digo de erro
      int code=GetLastError();
      //--- imprimir a mensagem de erro
      PrintFormat(&quot;Erro de c√≥pia de dados! %s&quot;,code==4401
                  ? &quot;Hist√≥rico ainda est√° sendo carregado!&quot;
                  : &quot;C√≥digo = &quot;+IntegerToString(code));
      //--- retornar falso para fazer uma tentativa de repetir o download de dados
      return(false);
     }
//--- recebe o tamanho do array
   ExtSize=ArraySize(ExtTimeBuff);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1266
</p>
<pre><code class="language-mql5">
//--- definir o √≠ndice do loop para o array zero
   ExtCount=0;
//--- definir a posi√ß√£o atual do candlestick no per√≠odo de tempo para zero
   ExtStartPos=0;
   ExtStartFlag=true;
//--- armazenar o √∫ltimo valor de tempo a partir da maior periodicidade
   ExtLastTime=ExtTimeBuff[ExtSize-1];
//--- sucesso na execu√ß√£o
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+--------------------------------------------------------------------------+
//| Fun√ß√£o constitui a parte principal do candlestick. Dependendo do sinalizador |
//| valor, a fun√ß√£o define quais dados e arrays ser√£o¬†                       |
//| usados para exibi√ß√£o correta.¬†                                           |
//+--------------------------------------------------------------------------+
void FormCandleMain(double &amp;body_fst[],double &amp;body_snd[],
                    double &amp;shadow_fst[],double &amp;shadow_snd[],
                    const double fst_value,const double snd_value,
                    const double fst_extremum,const double snd_extremum,
                    const int start,const int count,const bool flag)
  {
//--- verificar o valor do flag
   if(flag)
     {
      //--- gerar o corpo do candlestick
      FormMain(body_fst,body_snd,fst_value,snd_value,start,count);
      //--- gerar a sombra do candlestick
      FormMain(shadow_fst,shadow_snd,fst_extremum,snd_extremum,start,count);
     }
   else
     {
      //--- gerar o corpo do candlestick
      FormMain(body_fst,body_snd,snd_value,fst_value,start,count);
      //--- gerar a sombra do candlestick
      FormMain(shadow_fst,shadow_snd,snd_extremum,fst_extremum,start,count);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+--------------------------------------------------------------------------------+
//| A fun√ß√£o para formar o final do candlestick. Dependendo do valor da flag,  |
//| A fun√ß√£o define quais dados e arrays s√£o¬†                                      |
//| usados para exibi√ß√£o correta.¬†                                                 |
//+--------------------------------------------------------------------------------+
void FormCandleEnd(double &amp;body_fst[],double &amp;body_snd[],
                   double &amp;shadow_fst[],double &amp;shadow_snd[],
                   const double fst_value,const double snd_value,
                   const double fst_extremum,const double snd_extremum,
                   const int end,bool &amp;flag)
  {
//--- verificar o valor do flag</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1267
</p>
<pre><code class="language-mql5">
   if(flag)
     {
      //--- gerar o final do corpo do candlestick
      FormEnd(body_fst,body_snd,fst_value,snd_value,end);
      //--- gerar o final da sombra do candlestick
      FormEnd(shadow_fst,shadow_snd,fst_extremum,snd_extremum,end);
      //--- alterar o valor do sinalizador para o oposto
      flag=false;
     }
   else
     {
      //--- gerar o final do corpo do candlestick
      FormEnd(body_fst,body_snd,snd_value,fst_value,end);
      //--- gerar o final da sombra do candlestick
      FormEnd(shadow_fst,shadow_snd,snd_extremum,fst_extremum,end);
      //--- alterar o valor do sinalizador para o oposto
      flag=true;
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+-----------------------------------------------------------------------------------
//| Limpar o final do candlestick (a √°rea entre a √∫ltima e a pen√∫ltima¬†               
//| barra)                                                                            
//+-----------------------------------------------------------------------------------
void ClearEndOfBodyMain(const int ind)
  {
   ClearCandle(ExtBearBodyFirst,ExtBearBodySecond,ExtBearShadowFirst,ExtBearShadowSeco
   ClearCandle(ExtBullBodyFirst,ExtBullBodySecond,ExtBullShadowFirst,ExtBullShadowSeco
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Limpar o candlestick¬†                                            |
//+------------------------------------------------------------------+
void ClearCandle(double &amp;body_fst[],double &amp;body_snd[],double &amp;shadow_fst[],
                 double &amp;shadow_snd[],const int start,const int count)
  {
//--- verificar
   if(count!=0)
     {
      //--- preencher buffers do indicador com valores vazios
      ArrayFill(body_fst,start,count,INDICATOR_EMPTY_VALUE);
      ArrayFill(body_snd,start,count,INDICATOR_EMPTY_VALUE);
      ArrayFill(shadow_fst,start,count,INDICATOR_EMPTY_VALUE);
      ArrayFill(shadow_snd,start,count,INDICATOR_EMPTY_VALUE);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Gerar a parte principal do candlestick¬†                          |
//+------------------------------------------------------------------+
void FormMain(double &amp;fst[],double &amp;snd[],const double fst_value,
              const double snd_value,const int start,const int count)</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1268
</p>
<pre><code class="language-mql5">
  {
//--- verificar
   if(count!=0)
     {
      //--- preencher o buffer do indicador com valores
      ArrayFill(fst,start,count,fst_value);
      ArrayFill(snd,start,count,snd_value);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Gerar o fim do candlestick¬†                                      |
//+------------------------------------------------------------------+
void FormEnd(double &amp;fst[],double &amp;snd[],const double fst_value,
             const double snd_value,const int last)
  {
//--- preencher o buffer do indicador com valores
   ArrayFill(fst,last-1,2,fst_value);
   ArrayFill(snd,last-1,2,snd_value);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preencher i elemento dos buffers do indicador por valores vazios¬†|
//+------------------------------------------------------------------+
void FillIndicatorBuffers(const int i)
  {
//--- definir um valor vazio na c√©lula dos buffers do indicador
   ExtBearBodyFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearBodySecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBearBodyEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearBodyEndSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBearShadowEndSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodyFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodySecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodyEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullBodyEndSecond[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowEndFirst[i]=INDICATOR_EMPTY_VALUE;
   ExtBullShadowEndSecond[i]=INDICATOR_EMPTY_VALUE;
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1269
<h3>ArrayPrint</h3>
No log, exibe uma matriz de tipo ou estrutura simples.
</p>
<pre><code class="language-mql5">
void¬† ArrayPrint(
   const void&amp;¬†  array[],¬†            // matriz de sa√≠da
   uint¬†         digits=_Digits,¬†     // n√∫mero de casas decimais
   const string¬† separator=NULL,¬†     // separador entre os valores dos campos de estr
   ulong¬†        start=0,¬†            // √≠ndice do primeiro elemento de sa√≠da
   ulong ¬†       count=WHOLE_ARRAY,   // n√∫mero de elementos exibidos
   ulong ¬†       flags=ARRAYPRINT_HEADER|ARRAYPRINT_INDEX|ARRAYPRINT_LIMIT|ARRAYPRINT_
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Matriz de tipo ou estrutura simples..
digits=_Digits
[in]  N√∫mero de casas decimais para tipos reais. Por padr√£o igual a _Digits.
separator=NULL
[in]  Separador entre os valores dos campos do elemento de estrutura. O valor padr√£o NULL indica
que existe uma cadeia de caracteres vazia, neste caso, o separador √© um espa√ßo.
start=0
[in]  √çndice da primeira sa√≠da do elemento da matriz.  Por padr√£o, exibe-se a partir do √≠ndice zero.
count=WHOLE_ARRAY
[in]  N√∫mero de elementos de matriz que voc√™ deseja exibir. Por padr√£o, ele exibe toda a matriz
(count=WHOLE_ARRAY).
flags=ARRAYPRINT_HEADER|ARRAYPRINT_INDEX|ARRAYPRINT_LIMIT|ARRAYPRINT_ALIGN
[in]  A combina√ß√£o de sinalizadores especificada pelo modo de sa√≠da. Por padr√£o, todas os
sinalizadores:
¬∑ ARRAYPRINT_HEADER ‚Äì exibi√ß√£o dos cabe√ßalhos para a matriz das estruturas
¬∑ ARRAYPRINT_INDEX ‚Äì exibi√ß√£o √† esquerda do n√∫mero de √≠ndice
¬∑ ARRAYPRINT_LIMIT ‚Äì exibi√ß√£o somente dos 100 primeiros e os √∫ltimos 100 elementos da matriz. √â
usado quando voc√™ deseja exibir apenas parte de uma matriz maior.
¬∑ ARRAYPRINT_ALIGN ‚Äì permitir o alinhamento dos valores de sa√≠da, quer dizer, os n√∫meros ser√£o
alinhados √† direita, enquanto as cadeias de caracteres √† esquerda.
¬∑ ARRAYPRINT_DATE ‚Äì ao exibir datetime, mostra a data no formato dd.mm.yyyy
¬∑ ARRAYPRINT_MINUTES ‚Äì ao exibir datetime, mostra a data no formato HH:MM
¬∑ ARRAYPRINT_SECONDS ‚Äì ao exibir datetime, mostra a data no formato HH:MM:SS
<h3>Valor de retorno</h3>
<h3>N√£o</h3>
<h3>Observa√ß√£o</h3>
ArrayPrint() n√£o exibe, no log, todos os campos da matriz de estruturas, uma vez que os campos
tanto de matriz como de indicadores de objetos s√£o omitidos. Estas colunas simplesmente n√£o ser√£o</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1270
exibidas para impress√£o, com o prop√≥sito de obter uma apresenta√ß√£o simples e conveniente. Se
voc√™ precisar da exibi√ß√£o de todos os campos dessa estrutura, necessitar√° escrever sua pr√≥pria
fun√ß√£o de sa√≠da em massa com a formata√ß√£o desejada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- exibir os valores das √∫ltimas 10 barras
   MqlRates rates[];
   if(CopyRates(_Symbol,_Period,1,10,rates))
     {
      ArrayPrint(rates);
      Print(&quot;Verifica√ß√£o\n[time]\t[open]\t[high]\t[low]\t[close]\t[tick_volume]\t[spre
      for(int i=0;i&lt;10;i++)
        {
         PrintFormat(&quot;[%d]\t%s\t%G\t%G\t%G\t%G\t%G\t%G\t%I64d\t&quot;,i,
         TimeToString(rates[i].time,TIME_DATE|TIME_MINUTES|TIME_SECONDS),
         rates[i].open,rates[i].high,rates[i].low,rates[i].close,
         rates[i].tick_volume,rates[i].spread,rates[i].real_volume);
        }
     }
   else
      PrintFormat(&quot;CopyRates failed, error code=%d&quot;,GetLastError());
//--- exemplo de sa√≠da
/*
                    [time]  [open]  [high]   [low] [close] [tick_volume] [spread] [rea
   [0] 2016.11.09 04:00:00 1.11242 1.12314 1.11187 1.12295         18110       10   17
   [1] 2016.11.09 05:00:00 1.12296 1.12825 1.11930 1.12747         17829        9   15
   [2] 2016.11.09 06:00:00 1.12747 1.12991 1.12586 1.12744         13458       10    9
   [3] 2016.11.09 07:00:00 1.12743 1.12763 1.11988 1.12194         15362        9   12
   [4] 2016.11.09 08:00:00 1.12194 1.12262 1.11058 1.11172         16833        9   12
   [5] 2016.11.09 09:00:00 1.11173 1.11348 1.10803 1.11052         15933        8   10
   [6] 2016.11.09 10:00:00 1.11052 1.11065 1.10289 1.10528         11888        9    8
   [7] 2016.11.09 11:00:00 1.10512 1.11041 1.10472 1.10915          7284       10    5
   [8] 2016.11.09 12:00:00 1.10915 1.11079 1.10892 1.10904          8710        9    6
   [9] 2016.11.09 13:00:00 1.10904 1.10913 1.10223 1.10263          8956        7    7
   Verifica√ß√£o
   [time] [open] [high] [low] [close] [tick_volume] [spread] [real_volume]
   [0] 2016.11.09 04:00:00 1.11242 1.12314 1.11187 1.12295 18110 10 17300175000 
   [1] 2016.11.09 05:00:00 1.12296 1.12825 1.1193 1.12747 17829 9 15632176000 
   [2] 2016.11.09 06:00:00 1.12747 1.12991 1.12586 1.12744 13458 10 9593492000 
   [3] 2016.11.09 07:00:00 1.12743 1.12763 1.11988 1.12194 15362 9 12352245000 
   [4] 2016.11.09 08:00:00 1.12194 1.12262 1.11058 1.11172 16833 9 12961333000 
   [5] 2016.11.09 09:00:00 1.11173 1.11348 1.10803 1.11052 15933 8 10720384000 
   [6] 2016.11.09 10:00:00 1.11052 1.11065 1.10289 1.10528 11888 9 8084811000 
   [7] 2016.11.09 11:00:00 1.10512 1.11041 1.10472 1.10915 7284 10 5087113000 
   [8] 2016.11.09 12:00:00 1.10915 1.11079 1.10892 1.10904 8710 9 6769629000 
   [9] 2016.11.09 13:00:00 1.10904 1.10913 1.10223 1.10263 8956 7 7192138000 
</code></pre>
<p>
*/
<h3>Veja tamb√©m</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1271
<h3>FileSave, FileLoad</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1272
<h3>ArrayRange</h3>
A fun√ß√£o retorna o n√∫mero de elementos na dimens√£o selecionada do array.
</p>
<pre><code class="language-mql5">
int¬† ArrayRange(
   const void&amp; ¬† array[],¬†     // array para verifica√ß√£o
   int¬†          rank_index¬†   // √≠ndice da dimens√£o
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Array verificado.
rank_index
[in]  √çndice da dimens√£o.
<h3>Valor do Retorno</h3>
N√∫mero de elementos na dimens√£o selecionada do array.
<h3>Observa√ß√£o</h3>
Uma vez que os √≠ndices come√ßam em zero, o n√∫mero de dimens√µes de um array √© uma unidade
maior que o √≠ndice da √∫ltima dimens√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- cria um array de quatro dimens√µes
   double array[][5][2][4];
//--- definir o tamanho da dimens√£o de zero
   ArrayResize(array,10,10);
//--- imprimir as dimens√µes
   int temp;
   for(int i=0;i&lt;4;i++)
     {
      //--- receber o tamanho de i dimens√£o
      temp=ArrayRange(array,i);
      //--- imprimir
      PrintFormat(&quot;dim = %d, range = %d&quot;,i,temp);
     }
//--- Resultado
// dim = 0, range = 10
// dim = 1, range = 5
// dim = 2, range = 2
// dim = 3, range = 4
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1273
<h3>ArrayResize</h3>
A fun√ß√£o define um tamanho novo para a primeira dimens√£o
</p>
<pre><code class="language-mql5">
int¬† ArrayResize(
   void&amp;¬† array[],¬†             // array passado por refer√™ncia
   int¬†   new_size,¬†            // novo tamanho de array
   int¬†   reserve_size=0¬†       // valor do tamanho de reserva (excesso)
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[out] Array para altera√ß√£o de tamanho.
new_size
[in]  Novo tamanho para a primeira dimens√£o.
reserve_size=0
[in]  Tamanho alocado para obter reserva.
<h3>Valor do Retorno</h3>
Se executado com sucesso, a fun√ß√£o retorna a quantidade de todos os elementos contidos no array
ap√≥s a altera√ß√£o do tamanho, caso contr√°rio, retorna -1, e o tamanho do array n√£o √© alterado.
–ï—Å–ª–∏ ArrayResize() –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ –∫ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–º—É –º–∞—Å—Å–∏–≤—É, —Ç–∞–π–º—Å–µ—Ä–∏–∏ –∏–ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–Ω–æ–º—É –±—É—Ñ–µ—Ä—É, —Ç–æ
—Ä–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞ –æ—Å—Ç–∞–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–∏–º ‚Äì —Ç–∞–∫–∏–µ –º–∞—Å—Å–∏–≤—ã –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω—ã. –í —ç—Ç–æ–º
—Å–ª—É—á–∞–µ –µ—Å–ª–∏ new_size&lt;=ArraySize(array), —Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω–µ—Ç new_size; –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ
–±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ -1.
<h3>Observa√ß√£o</h3>
A fun√ß√£o pode ser aplicada somente para arrays din√¢micos. Deve ser notado que n√£o se pode alterar
o tamanho de arrays din√¢micos atribu√≠dos como buffers de indicadores atrav√©s da fun√ß√£o
SetIndexBuffer(). Para buffers de indicadores, todas a opera√ß√µes de redimensionamento de tamanho
s√£o realizadas pelo subsistema de tempo de execu√ß√£o do terminal.
Total amount of elements in the array cannot exceed 2147483647.
Com uma aloca√ß√£o de mem√≥ria freq√ºente, √© recomendado usar o terceiro par√¢metro que defini um
reserva para reduzir o n√∫mero de aloca√ß√µes f√≠sicas de mem√≥ria. Todas as subseq√ºentes chamadas
de ArrayResize n√£o levam uma realoca√ß√£o f√≠sica de mem√≥ria, mas somente altera√ß√£o do tamanho da
primeira dimens√£o do array dentro da mem√≥ria reservada. Deve ser lembrado que o terceiro
par√¢metro ser√° usado somente durante a aloca√ß√£o f√≠sica de mem√≥ria. Por exemplo:
<h3>ArrayResize(arr,1000,1000);</h3>
for(int i=1;i&lt;3000;i++)
</p>
<pre><code class="language-mql5">
   ArrayResize(arr,i,1000);
</code></pre>
<p>
Neste caso a mem√≥ria ser√° realocada duas vezes, a primeira vez antes de entrar no loop de
elemento 3000 (o tamanho do array ser√° definido para 1000), e a segunda vez com i igual a 2000.
Se omitisse o terceiro par√¢metro, haveria 2000 realoca√ß√µes f√≠sicas de mem√≥ria, que desaceleraria o
programa.</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1274
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Contadores
   ulong start=GetTickCount();
   ulong now;
   int   count=0;
//--- Um array para demonstra√ß√£o de uma vers√£o r√°pida
   double arr[];
   ArrayResize(arr,100000,100000);
//--- Verifique qu√£o r√°pida a variante com a reserva de mem√≥ria trabalha
   Print(&quot;--- Test Fast: ArrayResize(arr,100000,100000)&quot;);
   for(int i=1;i&lt;=300000;i++)
     {
      //--- Define um novo tamanho de array especificando a reserva de 100 000 element
      ArrayResize(arr,i,100000);
      //--- Quando alcan√ßar um n√∫mero redondo, exibe o tamanho do array e tempo gasto
      if(ArraySize(arr)%100000==0)
        {
         now=GetTickCount();
         count++;
         PrintFormat(&quot;%d. ArraySize(arr)=%d Time=%d ms&quot;,count,ArraySize(arr),(now-star
         start=now; 
        }
     }
//--- Agora mostra qu√£o lento a vers√£o sem reserva de mem√≥ria √©
   double slow[];
   ArrayResize(slow,100000,100000);
//--- 
   count=0;
   start=GetTickCount();
   Print(&quot;---- Teste lenta: ArrayResize(slow,100000)&quot;);
//---
   for(int i=1;i&lt;=300000;i++)
     {
      //--- Define um novo tamanho de array, mas sem a reserva adicional
      ArrayResize(slow,i);
      //--- Quando alcan√ßar um n√∫mero redondo, exibe o tamanho do array e tempo gasto
      if(ArraySize(slow)%100000==0)
        {
         now=GetTickCount();
         count++;
         PrintFormat(&quot;%d. ArraySize(slow)=%d Time=%d ms&quot;,count,ArraySize(slow),(now-st
         start=now;
        }</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1275
</p>
<pre><code class="language-mql5">
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//--- O resultado do script
/*
   Test_ArrayResize (EURUSD,H1)   --- Test Fast: ArrayResize(arr,100000,100000)
   Test_ArrayResize (EURUSD,H1)   1. ArraySize(arr)=100000 Time=0 ms
   Test_ArrayResize (EURUSD,H1)   2. ArraySize(arr)=200000 Time=0 ms
   Test_ArrayResize (EURUSD,H1)   3. ArraySize(arr)=300000 Time=0 ms
   Test_ArrayResize (EURUSD,H1)   ---- Test Slow: ArrayResize(slow,100000)
   Test_ArrayResize (EURUSD,H1)   1. ArraySize(slow)=100000 Time=0 ms
   Test_ArrayResize (EURUSD,H1)   2. ArraySize(slow)=200000 Time=0 ms
   Test_ArrayResize (EURUSD,H1)   3. ArraySize(slow)=300000 Time=228511 ms
</code></pre>
<p>
*/
<h3>Tamb√©m Veja</h3>
<h3>ArrayInitialize</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1276
<h3>ArrayInsert</h3>
Insere na matriz de destino o n√∫mero especificado de elementos da matriz de origem, iniciando no
√≠ndice especificado.
</p>
<pre><code class="language-mql5">
bool¬† ArrayInsert(
   void&amp;¬†       dst_array[],¬†         // matriz de destino
   const void&amp;¬† src_array[],¬†         // matriz de origem
   uint¬†        dst_start,¬†           // √≠ndice na matriz de destino para inserir
   uint¬†        src_start=0,          // √≠ndice na matriz de origem para copiar
   uint¬†        count=WHOLE_ARRAY     // n√∫mero de elementos a serem inseridos
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
dst_array[]
[in][out] Matriz receptor √† qual voc√™ deseja adicionar elementos.
src_array[]
[in] Matriz de origem a partir da qual voc√™ deseja adicionar elementos
dst_start
[in] √çndice na matriz de destino para inserir elementos da matriz de origem.
src_start=0
[in] √çndice na matriz de origem a partir do qual s√£o tomados os elementos da matriz de origem
para serem inseridos.
count=WHOLE_ARRAY
[in]  N√∫mero de elementos adicionados a partir da matriz de origem. O valor WHOLE_ARRAY
significa que ser√£o inseridos todos os elementos do √≠ndice especificado at√© o final da matriz.
<h3>Valor retornado</h3>
Retorna true em caso de sucesso, caso contr√°rio, false. Para obter informa√ß√µes de erro, chame a
fun√ß√£o GetLastError(). Poss√≠veis erros:
¬∑ 5052 ‚Äì ERR_SMALL_ARRAY (par√¢metros start e/ou count inv√°lidos ou matriz de origem src_array[]
est√° vazia),
¬∑ 5056 ‚Äì ERR_SERIES_ARRAY (a matriz n√£o pode ser alterada, buffer de indicador),
¬∑ 4006 ‚Äì ERR_INVALID_ARRAY (a c√≥pia para si pr√≥prio √© inv√°lida, ou as matrizes t√™m um tipo
diferente ou possuem uma matriz de tamanho fixo, que cont√©m objetos de uma classe ou de uma
estrutura com um destruidor),
¬∑ 4005 - ERR_STRUCT_WITHOBJECTS_ORCLASS (a matriz n√£o cont√©m estruturas POD, isto √©, √©
imposs√≠vel copiar),
¬∑ erros de redimensionamento da matriz de destino dst_array[] ‚Äì eles s√£o dados na descri√ß√£o da
fun√ß√£o ArrayRemove().
<h3>Observa√ß√£o</h3>
Se a fun√ß√£o √© usada para uma matriz de tamanho fixo, o tamanho da pr√≥pria matriz de destino
dst_array[] n√£o muda, a partir da posi√ß√£o dst_start os elementos da matriz de destino s√£o</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1277
deslocados para a direita (o √∫ltimo count dos elementos cai), e os elementos s√£o copiados da matriz
de origem para o local liberado.
Voc√™ n√£o pode inserir elementos em matrizes din√¢micas, que s√£o designadas como buffers de
indicador, atrav√©s da fun√ß√£o SetIndexBuffer(). Para buffers de indicador, todas as opera√ß√µes de
redimensionamento s√£o executadas pelo subsistema em execu√ß√£o do terminal.
Na matriz de origem, os elementos s√£o copiados a partir do √≠ndice src_start. O tamanho da matriz
de origem n√£o √© alterado. Os elementos adicionados √† matriz de destino n√£o s√£o refer√™ncias aos
elementos da matriz de origem, o que significa que altera√ß√µes subsequentes nos elementos em
qualquer uma das matrizes n√£o s√£o refletidas na seguinte.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- declara uma matriz de tamanho fixo e preenche com valores
   int array_dest[10];
   for(int i=0;i&lt;10;i++)
     {
      array_dest[i]=i;
     }
   //--- matriz de origem   
   int array_source[10];
   for(int i=0;i&lt;10;i++)
     {
      array_source[i]=10+i;
     }
//--- mostra matrizes antes de inserir elementos
   Print(&quot;Antes de chamar a ArrayInsert()&quot;);
   ArrayPrint(array_dest);
   ArrayPrint(array_source);
//--- insere 3 elementos da matriz de origem e mostra a nova composi√ß√£o da matriz de d
   ArrayInsert(array_dest,array_source,4,0,3);
   Print(&quot;Depois de chamar a ArrayInsert()&quot;);
   ArrayPrint(array_dest);
/*
</code></pre>
<p>
<h3>Resultado de execu√ß√£o</h3>
</p>
<pre><code class="language-mql5">
   Antes de chamar a ArrayInsert()
   0 1 2 3 4 5 6 7 8 9
   Depois de chamar aArrayInsert()
   0 1 2 3 10 11 12 7 8 9
</code></pre>
<p>
*/
<h3>Veja tamb√©m</h3>
<h3>ArrayRemove, ArrayCopy, ArrayResize, ArrayFree</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1278</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1279
<h3>ArrayRemove</h3>
Remove o n√∫mero especificado de elementos da matriz, iniciando no √≠ndice especificado.
</p>
<pre><code class="language-mql5">
bool¬† ArrayRemove(
   void&amp;¬†       array[],¬†           // matriz de qualquer tipo
   uint¬†        start,¬†             // √≠ndice a partir do qual √© iniciada a remo√ß√£o
   uint¬†        count=WHOLE_ARRAY¬†  // n√∫mero de elementos
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in][out]  Matriz.
start
[in]  √çndice a partir do qual s√£o exclu√≠dos os elementos da matriz.
count=WHOLE_ARRAY
[in]  N√∫mero de elementos para excluir. O valor WHOLE_ARRAY indica a remo√ß√£o de todos os
elemento, do √≠ndice especificado at√© o final da matriz.
<h3>Valor retornado</h3>
Retorna true em caso de sucesso, caso contr√°rio, false. Para obter informa√ß√µes de erro, chame a
fun√ß√£o GetLastError(). Poss√≠veis erros:
¬∑ 5052 ‚Äì ERR_SMALL_ARRAY (o valor start √© muito grande),
¬∑ 5056 ‚Äì ERR_SERIES_ARRAY (a matriz n√£o pode ser alterada, buffer de indicador),
¬∑ 4003 ‚Äì ERR_INVALID_PARAMETER (o valor count √© muito grande),
¬∑ 4005 - ERR_STRUCT_WITHOBJECTS_ORCLASS (matriz de tamanho fixo que cont√©m objetos
complexos com um destruidor),
¬∑ 4006 - ERR_INVALID_ARRAY  (matriz de tamanho fixo que cont√©m objetos de estruturas ou de
classes com destruidores).
<h3>Observa√ß√£o</h3>
Se a fun√ß√£o √© usada para uma matriz de tamanho fixo, o tamanho da matriz em si n√£o muda: neste
caso, a ‚Äúcauda‚Äù remanescente √© fisicamente copiada para a posi√ß√£o start. Para um entendimento
preciso de como funciona a fun√ß√£o, veja o exemplo abaixo. C√≥pia ‚Äúf√≠sica‚Äù significa que os objetos
copiados n√£o s√£o criados chamando o construtor ou o operador de c√≥pia, mas, sim, simplesmente
copiando a representa√ß√£o bin√°ria do objeto. √â por esse motivo que √© proibido aplicar a fun√ß√£o
ArrayRemove() √† uma matriz de tamanho fixo contendo objetos com um destruidor (√© ativado
ERR_INVALID_ARRAY ou ERR_STRUCT_WITHOBJECTS_ORCLASS) Como ao remover tal objeto, o
destruidor deve ser chamado duas vezes - para o objeto inicial e para sua c√≥pia.
√â imposs√≠vel excluir elementos de matrizes din√¢micas, atribu√≠das como buffers de indicador,
atrav√©s da fun√ß√£o SetIndexBuffer(), isso resultar√° no erro ERR_SERIES_ARRAY. Para buffers de
indicador, todas as opera√ß√µes de redimensionamento s√£o executadas pelo subsistema em execu√ß√£o
do terminal.
<h3>Exemplo:</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1280
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- declara uma matriz de tamanho fixo e preenche com valores
   int array[10];
   for(int i=0;i&lt;10;i++)
     {
      array[i]=i;
     }
//--- mostra uma matriz antes de remover elementos
   Print(&quot;Antes de chamar a ArrayRemove()&quot;);
   ArrayPrint(array);
//--- remove 2 elementos da matriz e mostra a nova composi√ß√£o
   ArrayRemove(array,4,2);
   Print(&quot;Depois de chamar a ArrayRemove()&quot;);
   ArrayPrint(array);
/*
</code></pre>
<p>
<h3>Resultado da execu√ß√£o:</h3>
<h3>Antes de chamar a ArrayRemove()</h3>
</p>
<pre><code class="language-mql5">
   0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>
<h3>Depois de chamar a ArrayRemove()</h3>
</p>
<pre><code class="language-mql5">
   0 1 2 3 6 7 8 9 8 9
</code></pre>
<p>
*/
<h3>Veja tamb√©m</h3>
<h3>ArrayInsert, ArrayCopy, ArrayResize, ArrayFree</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1281
<h3>ArrayReverse</h3>
Expande o n√∫mero de elementos especificado na matriz, iniciando no √≠ndice especificado.
</p>
<pre><code class="language-mql5">
bool¬† ArrayReverse(
   void&amp;¬†       array[],¬†           // matriz de qualquer tipo
   uint¬†        start=0,            // √≠ndice a partir do qual √© expandida a matriz
   uint¬†        count=WHOLE_ARRAY¬†  // n√∫mero de elementos
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in][out]  Matriz.
start=0
[in]  O √≠ndice a partir do qual a matriz √© invertida.
count=WHOLE_ARRAY
[in]  N√∫mero de elementos para expandir. Se for especificado WHOLE_ARRAY, todos os elementos
da matriz ser√£o colocados de maneira invertida entre eles, come√ßando com o √≠ndice especificado
start at√© o final da matriz.
<h3>Valor retornado</h3>
Retorna true em caso de sucesso, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
A fun√ß√£o ArraySetAsSeries() apenas altera a dire√ß√£o de indexa√ß√£o de tr√°s para frente, a fim de
organizar o acesso aos elementos como em timeseries. A fun√ß√£o ArrayReverse() move fisicamente
os elementos de uma matriz de tal forma que a matriz √© &quot;invertida&quot;.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- declara uma matriz de tamanho fixo e preenche com valores
   int array[10];
   for(int i=0;i&lt;10;i++)
     {
      array[i]=i;
     }
//--- mostra uma matriz antes de invers√£o de elementos
   Print(&quot;Antes de chamar a ArrayReverse()&quot;);
   ArrayPrint(array);
//--- inverte 3 elementos na matriz e exibe a nova composi√ß√£o
   ArrayReverse(array,4,3);
   Print(&quot;Depois de chamar a ArrayReverse()&quot;);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1282
</p>
<pre><code class="language-mql5">
   ArrayPrint(array);
/*
</code></pre>
<p>
<h3>Resultado da execu√ß√£o:</h3>
<h3>Antes de chamar a ArrayReverse()</h3>
</p>
<pre><code class="language-mql5">
   0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>
<h3>Depois de chamar a ArrayReverse()</h3>
</p>
<pre><code class="language-mql5">
   0 1 2 3 6 5 4 7 8 9
</code></pre>
<p>
*/
<h3>Veja tamb√©m</h3>
ArrayInsert, ArrayRemove, ArrayCopy, ArrayResize, ArrayFree, ArrayGetAsSeries, ArraySetAsSeries</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1283
<h3>ArraySetAsSeries</h3>
A fun√ß√£o define o flag AS_SERIES para um objeto de um array din√¢mico, e os elementos ser√£o
indexados como em timeseries.
</p>
<pre><code class="language-mql5">
bool¬† ArraySetAsSeries(
   const void&amp;¬† array[],    // array passado por refer√™ncia
   bool¬†        flag¬†       // true significa ordem reversa de indexa√ß√£o
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in][out]  Array num√©rico para definir.
flag
[in]  Dire√ß√£o de indexa√ß√£o do array.
<h3>Valor do Retorno</h3>
A fun√ß√£o retorna true para sucesso, caso contr√°rio - false.
<h3>Observa√ß√£o</h3>
O flag AS_SERIES n√£o pode ser definido para arrays multi-dimensionais ou arrays est√°ticos (arrays
cujo tamanho nos colchetes j√° √© predefinido na etapa de compila√ß√£o). A indexa√ß√£o em s√©ries de
tempo difere da indexa√ß√£o de um array comum, na medida que os elementos de s√©ries de tempo s√£o
indexados do fim para o come√ßo (dos dados mais novos para os mais antigos).
Exemplo: Indicador que mostra n√∫mero de barra
</p>
<pre><code class="language-mql5">
#property indicator_chart_window
#property indicator_buffers 1
#property indicator_plots   1
//---- plota Numeration</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1284
</p>
<pre><code class="language-mql5">
#property indicator_label1  &quot;Numeration&quot;
#property indicator_type1   DRAW_LINE
#property indicator_color1  CLR_NONE
//--- buffers do indicador
double         NumerationBuffer[];
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,NumerationBuffer,INDICATOR_DATA);
//--- definir a indexa√ß√£o do buffer como numa timeseries
   ArraySetAsSeries(NumerationBuffer,true);
//--- define a precis√£o de exibi√ß√£o na Janela de Dados
   IndicatorSetInteger(INDICATOR_DIGITS,0);
//--- como o nome do array do indicador √© exibido na Janela de Dados
   PlotIndexSetString(0,PLOT_LABEL,&quot;Bar #&quot;); 
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])
  {
//--- n√≥s armazenaremos a hora de abertura da barra zero corrente
   static datetime currentBarTimeOpen=0;
//--- acesso reverso ao array time[] - fazemos isso como em s√©ries temporais
   ArraySetAsSeries(time,true);
//--- se a hora da barra zero difere da hora armazenada
   if(currentBarTimeOpen!=time[0])
     {
     //--- enumera todas as barras a partir do corrento para a profundidade do gr√°fico
      for(int i=rates_total-1;i&gt;=0;i--) NumerationBuffer[i]=i;
      currentBarTimeOpen=time[0];
     }
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1285
<h3>Tamb√©m Veja</h3>
<h3>Acesso √† s√©ries de tempo, ArrayGetAsSeries</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1286
<h3>ArraySize</h3>
A fun√ß√£o retorna o n√∫mero de elementos de um array selecionado.
</p>
<pre><code class="language-mql5">
int¬† ArraySize(
   const void&amp; ¬†array[]    // array verificado
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in]  Array de qualquer tipo.
<h3>Valor do Retorno</h3>
Valor do tipo int.
<h3>Observa√ß√£o</h3>
Para um array de uma dimens√£o, o valor a ser retornado pela fun√ß√£o ArraySize √© igual ao de
ArrayRange(array,0).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- criar arrays
   double one_dim[];
   double four_dim[][10][5][2];
//--- tamanhos
   int one_dim_size=25;
   int reserve=20;
   int four_dim_size=5;
//--- vari√°veis auxiliares
   int size;
//--- alocar mem√≥ria sem fazer backup
   ArrayResize(one_dim,one_dim_size);
   ArrayResize(four_dim,four_dim_size);
//--- 1. array unidimensional
   Print(&quot;+==========================================================+&quot;);
   Print(&quot;Tamanhos de arrays:&quot;);
   Print(&quot;1. Array unidimensional&quot;);
   size=ArraySize(one_dim);
   PrintFormat(&quot;Tamanho dimens√£o zero = %d, Tamanho array = %d&quot;,one_dim_size,size);
//--- 2. array multidimensional
   Print(&quot;2. Array multidimensional&quot;);
   size=ArraySize(four_dim);
   PrintFormat(&quot;Tamanho dimens√£o zero = %d, Tamanho array = %d&quot;,four_dim_size,size);
//--- tamanhos de dimens√µes
   int d_1=ArrayRange(four_dim,1);
   int d_2=ArrayRange(four_dim,2);
   int d_3=ArrayRange(four_dim,3);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1287
</p>
<pre><code class="language-mql5">
   Print(&quot;Verificar:&quot;);
   Print(&quot;Dimens√£o zero = Tamanho de array / (Primeira dimens√£o * Segunda dimens√£o * T
   PrintFormat(&quot;%d = %d / (%d * %d * %d)&quot;,size/(d_1*d_2*d_3),size,d_1,d_2,d_3);
//--- 3. array unidimensional com backup de mem√≥ria
   Print(&quot;3. Array unidimensional com backup de mem√≥ria&quot;);
//--- dobro do valor
   one_dim_size*=2;
//--- alocar mem√≥ria com o backup
   ArrayResize(one_dim,one_dim_size,reserve);
//--- imprimir o tamanho
   size=ArraySize(one_dim);
   PrintFormat(&quot;Tamanho com o backup = %d, Atual tamanho do array = %d&quot;,one_dim_size+r
</code></pre>
<p>
  }</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1288
<h3>ArraySort</h3>
Classifica os valores na primeira dimens√£o de um array num√©rico multidimensional na ordem
crescente.
</p>
<pre><code class="language-mql5">
bool¬† ArraySort(
   void&amp;¬† array[]¬†     // array para ordena√ß√£o
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array[]
[in][out]  Array num√©rico para ordena√ß√£o.
<h3>Valor do Retorno</h3>
A fun√ß√£o retorna true para sucesso, caso contr√°rio - false.
<h3>Observa√ß√£o</h3>
Um array √© sempre classificado em ordem crescente, independentemente do valor da
flag¬†AS_SERIES.
Fun√ß√µes ArraySort e ArrayBSearch aceitam arrays de qualquer dimens√£o como um par√¢metro. No
entanto, a pesquisa e a classifica√ß√£o s√£o sempre aplicadas √† primeira dimens√£o (zero).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property description &quot;O indicador analisa os dados para o √∫ltimo m√™s e pinta todos os
#property description &quot;e grandes volumes de tick. A volume de tick do array √© ordenado
#property description &quot;para definir estes candlesticks. Os candlesticks que tem os vol
#property description &quot;por cento do array, s√£o consideradas pequenos. Os candlesticks 
#property description &quot;por cento do array, s√£o consideradas grandes.&quot;
//--- configura√ß√µes do indicador
#property indicator_chart_window
#property indicator_buffers 5
#property indicator_plots   1
//--- plotar
#property indicator_label1  &quot;VolumeFactor&quot;
#property indicator_type1   DRAW_COLOR_CANDLES
#property indicator_color1  clrDodgerBlue,clrOrange
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2
//--- constante pr√©-definida
#define INDICATOR_EMPTY_VALUE 0.0
//--- par√¢metros de entrada
input int InpSmallVolume=15; // Valor percentual de pequenos volumes (&lt;50)
input int InpBigVolume=20;   // Valor percentual de grandes volumes (&lt;50)
//--- in√≠cio do tempo para an√°lise (ser√° deslocado)
</code></pre>
<p>
datetime ExtStartTime;
</p>
<pre><code class="language-mql5">
//--- buffers do indicador
double   ExtOpenBuff[];</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1289
</p>
<pre><code class="language-mql5">
double   ExtHighBuff[];
double   ExtLowBuff[];
double   ExtCloseBuff[];
double   ExtColorBuff[];
//--- valores de limite do volume para exibir os candlesticks
</code></pre>
<p>
long     ExtLeftBorder=0;
long     ExtRightBorder=0;
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Receber valores das bordas para volumes de tick¬†                 |
//+------------------------------------------------------------------+
bool GetVolumeBorders(void)
  {
//--- vari√°veis
   datetime stop_time;  // copiar tempo final
   long     buff[];     // buffer para copiar
//--- tempo final √© o atual
   stop_time=TimeCurrent();
//--- tempo de in√≠cio √© de um m√™s antes do atual
   ExtStartTime=GetStartTime(stop_time);
//--- receber os valores de volume do tick
   ResetLastError();
   if(CopyTickVolume(Symbol(),Period(),ExtStartTime,stop_time,buff)==-1)
     {
      //--- falhou para receber os dados, retornar falso para lan√ßar o comando de rec√°
      PrintFormat(&quot;Falha ao receber os valores de volume do tick. C√≥digo de erro = %d&quot;
      return(false);
     }
//--- calcule tamanho de array
   int size=ArraySize(buff);
//--- classificar o array
   ArraySort(buff);
//--- definir os valores das bordas esquerda e direita para volumes do tick
   ExtLeftBorder=buff[size*InpSmallVolume/100];
   ExtRightBorder=buff[(size-1)*(100-InpBigVolume)/100];
//--- sucesso na execu√ß√£o
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Receber os dados do m√™s menor do que o m√™s anterior¬†             |
//+------------------------------------------------------------------+
</code></pre>
<p>
datetime GetStartTime(const datetime stop_time)
</p>
<pre><code class="language-mql5">
  {
//--- converter o tempo final da vari√°vel de estrutura do tipo MqlDateTime
   MqlDateTime temp;
   TimeToStruct(stop_time,temp);
//--- receber os dados que √© do m√™s menor
   if(temp.mon&gt;1)
      temp.mon-=1;  // o m√™s corrente n√£o √© o primeiro no ano, por conseguinte, o n√∫me
   else</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1290
</p>
<pre><code class="language-mql5">
     {
      temp.mon=12;  // o m√™s corrente √© o primeiro no ano, por conseguinte, o n√∫mero d
      temp.year-=1; // enquanto o n√∫mero do ano √© um a menos
     }
//--- n√∫mero do dia n√£o ser√° superior a 28
   if(temp.day&gt;28)
      temp.day=28;
//--- retornar a data obtida
   return(StructToTime(temp));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- verificar se os par√¢metros de entrada satisfazem as condi√ß√µes
   if(InpSmallVolume&lt;0 || InpSmallVolume&gt;=50 || InpBigVolume&lt;0 || InpBigVolume&gt;=50)
     {
      Print(&quot;Par√¢metros de entrada incorreto&quot;);
      return(INIT_PARAMETERS_INCORRECT);
     }
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,ExtOpenBuff);
   SetIndexBuffer(1,ExtHighBuff);
   SetIndexBuffer(2,ExtLowBuff);
   SetIndexBuffer(3,ExtCloseBuff);
   SetIndexBuffer(4,ExtColorBuff,INDICATOR_COLOR_INDEX);
//--- definir o valor que n√£o ser√° exibido
   PlotIndexSetDouble(0,PLOT_EMPTY_VALUE,INDICATOR_EMPTY_VALUE);
//--- definir etiquetas para buffers do indicador
   PlotIndexSetString(0,PLOT_LABEL,&quot;Open;High;Low;Close&quot;);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])
  {
//--- verificar se barras n√£o manipuladas ainda est√£o presentes</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1291
</p>
<pre><code class="language-mql5">
   if(prev_calculated&lt;rates_total)
     {
      //--- receber novos valores das bordas direita e esquerda para volumes
      if(!GetVolumeBorders())
         return(0);
     }
//--- iniciar vari√°vel para c√°lculo da barra
   int start=prev_calculated;
//--- trabalho na √∫ltima barra se os valores do indicador j√° foram calculados no tick 
   if(start&gt;0)
      start--;
//--- definir indexa√ß√£o direta em s√©ries temporais
   ArraySetAsSeries(time,false);
   ArraySetAsSeries(open,false);
   ArraySetAsSeries(high,false);
   ArraySetAsSeries(low,false);
   ArraySetAsSeries(close,false);
   ArraySetAsSeries(tick_volume,false);
//--- o loop de c√°lculo dos valores do indicador
   for(int i=start;i&lt;rates_total;i++)
     {
      //--- preencher os candlesticks a partir da data inicial
      if(ExtStartTime&lt;=time[i])
        {
         //--- se o valor n√£o √© inferior a borda direita, preencher clandlestick
         if(tick_volume[i]&gt;=ExtRightBorder)
           {
            //--- receber dados para desenhar o candlestick
            ExtOpenBuff[i]=open[i];
            ExtHighBuff[i]=high[i];
            ExtLowBuff[i]=low[i];
            ExtCloseBuff[i]=close[i];
            //--- cor de DodgerBlue
            ExtColorBuff[i]=0;
            //--- continuar o loop
            continue;
           }
         //--- preencher o candlestick, se o valor n√£o exceder o limite esquerdo
         if(tick_volume[i]&lt;=ExtLeftBorder)
           {
            //--- receber dados para desenhar o candlestick
            ExtOpenBuff[i]=open[i];
            ExtHighBuff[i]=high[i];
            ExtLowBuff[i]=low[i];
            ExtCloseBuff[i]=close[i];
            //--- Cor laranja
            ExtColorBuff[i]=1;
            //--- continuar o loop
            continue;</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1292
</p>
<pre><code class="language-mql5">
           }
        }
      //--- definir valores vazios para as barras que n√£o foram inclu√≠das no c√°lculo
      ExtOpenBuff[i]=INDICATOR_EMPTY_VALUE;
      ExtHighBuff[i]=INDICATOR_EMPTY_VALUE;
      ExtLowBuff[i]=INDICATOR_EMPTY_VALUE;
      ExtCloseBuff[i]=INDICATOR_EMPTY_VALUE;
     }
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
<h3>ArrayBsearch</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1293
<h3>ArraySwap</h3>
Troca entre si o conte√∫do de duas matrizes do tipo din√¢mico. Para matrizes multidimensionais, o
n√∫mero de elementos em todas as dimens√µes, excepto o primeiro, tem de ser o mesmo.
</p>
<pre><code class="language-mql5">
bool¬† ArraySwap(
   void&amp;¬† array1[],¬†     // primeira matriz
   void&amp;¬† array2[] ¬†     // segunda matriz
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
array1[]
[in][out]  Matriz num√©rica.
array2[]
[in][out]  Matriz num√©rica.
<h3>Valor de retorno</h3>
Retorna true em caso de sucesso, caso contr√°rio, false. Neste caso, GetLastError() retorna o c√≥digo
de erro ERR_INVALID_ARRAY.
<h3>Observa√ß√£o</h3>
A fun√ß√£o implementa matrizes din√¢micas do mesmo tipo e as mesmas dimens√µes, exceto a
primeira. Para tipos inteiros, o sinal √© ignorado, ou seja, char==uchar)
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- matrizes para armazenar cota√ß√µes
   double source_array[][8];
   double   dest_array[][8];
   MqlRates rates[];
//--- obtemos dados dos √∫ltimos 20 candles no timeframe atual
   int copied=CopyRates(NULL,0,0,20,rates);
   if(copied&lt;=0)
     {
      PrintFormat(&quot;CopyRates(%s,0,0,20,rates) failed, error=%d&quot;,
                  Symbol(),GetLastError());
      return;
     }
//--- definimos o tamanho da matriz pelo n√∫mero de dados copiados
   ArrayResize(source_array,copied);
//--- preenchemos a matriz rate_array_1[] com dados a partir de rates[]
   for(int i=0;i&lt;copied;i++)
     {</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1294
</p>
<pre><code class="language-mql5">
      source_array[i][0]=(double)rates[i].time;
      source_array[i][1]=rates[i].open;
      source_array[i][2]=rates[i].high;
      source_array[i][3]=rates[i].low;
      source_array[i][4]=rates[i].close;
      source_array[i][5]=(double)rates[i].tick_volume;
      source_array[i][6]=(double)rates[i].spread;
      source_array[i][7]=(double)rates[i].real_volume;
     }
//--- realizamos o interc√¢mbio de dados entre source_array[] e dest_array[]
   if(!ArraySwap(source_array,dest_array))
     {
      PrintFormat(&quot;ArraySwap(source_array,rate_array_2) failed, error code=%d&quot;,GetLast
      return;
     }
//--- verificamos que, depois do interc√¢mbio, o tamanho da fonte-matriz se tornou zero
   PrintFormat(&quot;ArraySwap() done: ArraySize(source_array)=%d&quot;,ArraySize(source_array))
//--- exibimos os dados do receptor de matriz dest_array[]
   ArrayPrint(dest_array);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>ArrayCopy, ArrayFill, ArrayRange, ArrayIsDynamic</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1295
<h3>ArrayToFP16</h3>
Realiza a c√≥pia de um array do tipo float ou double para um array do tipo ushort com o formato
especificado.
</p>
<pre><code class="language-mql5">
bool   ArrayToFP16(
   const ushort&amp;        dst_array[],¬†       // para onde copiamos
   const float&amp;¬†        src_array[],¬†       // de onde copiamos
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Sobrecarga para o tipo double</h3>
</p>
<pre><code class="language-mql5">
bool   ArrayToFP16(
   const ushort&amp;        dst_array[],¬†       // para onde copiamos
   const double&amp;        src_array[],¬†       // de onde copiamos
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
dst_array[]
[out]  Array receptor do tipo ushort.
src_array[]
[in]  Array receptor do tipo float ou double.
fmt
[in]  Formato de c√≥pia a partir da enumera√ß√£o ENUM_FLOAT16_FORMAT.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Os formatos FLOAT16 e BFLOAT16 s√£o definidos no enum ENUM_FLOAT16_FORMAT e s√£o usados no
MQL5 exclusivamente para trabalhar com modelos ONNX.
A fun√ß√£o √© utilizada para a convers√£o de par√¢metros de entrada do tipo float ou double para o tipo
FLOAT16 e BFLOAT16. Posteriormente, esses par√¢metros de entrada s√£o usados na fun√ß√£o
OnnxRun.
FLOAT16, tamb√©m conhecido como precis√£o m√©dia ou formato &quot;half-precision float&quot;, utiliza 16 bits
para representar um n√∫mero de ponto flutuante. Este formato oferece um equil√≠brio entre precis√£o e
efici√™ncia de c√°lculo. FLOAT16 √© amplamente usado em aprendizado profundo e redes neurais, onde
a alta performance no processamento de grandes volumes de dados √© requerida. Este formato
permite acelerar os c√°lculos por meio da redu√ß√£o do tamanho dos n√∫meros, o que √© especialmente
importante no treinamento de redes neurais profundas em unidades de processamento gr√°fico
(GPUs).</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1296
BFLOAT16 (ou Brain Floating Point 16) tamb√©m usa 16 bits, mas difere do FLOAT16 na forma como
os n√∫meros s√£o representados. Neste formato, 8 bits s√£o alocados para a representa√ß√£o do
expoente, e os 7 bits restantes s√£o usados para a mantissa. Este formato foi desenvolvido para uso
em aprendizado profundo e intelig√™ncia artificial, especialmente em unidades de processamento
Tensor do Google (TPUs). BFLOAT16 tem bom desempenho no treinamento de redes neurais e pode
ser efetivamente usado para acelerar os c√°lculos.
Exemplo: fun√ß√£o do artigo Trabalhando com modelos ONNX nos formatos float16 e float8
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| RunCastFloat16ToDouble                                           |
//+------------------------------------------------------------------+
bool RunCastFloat16ToDouble(long model_handle)
  {
   PrintFormat(&quot;test=%s&quot;,__FUNCTION__);
   double test_data[12]= {1,2,3,4,5,6,7,8,9,10,11,12};
   ushort data_uint16[12];
   if(!ArrayToFP16(data_uint16,test_data,FLOAT_FP16))
     {
      Print(&quot;error in ArrayToFP16. error code=&quot;,GetLastError());
      return(false);
     }
   Print(&quot;test array:&quot;);
   ArrayPrint(test_data);
   Print(&quot;ArrayToFP16:&quot;);
   ArrayPrint(data_uint16);
   U&lt;ushort&gt; input_float16_values[3*4];
   U&lt;double&gt; output_double_values[3*4];
   float test_data_float[];
   if(!ArrayFromFP16(test_data_float,data_uint16,FLOAT_FP16))
     {
      Print(&quot;error in ArrayFromFP16. error code=&quot;,GetLastError());
      return(false);
     }
   for(int i=0; i&lt;12; i++)
     {
      input_float16_values[i].value=data_uint16[i];
      PrintFormat(&quot;%d input value =%f  Hex float16 = %s  ushort value=%d&quot;,i,test_data_
     }
   Print(&quot;ONNX input array:&quot;);
   ArrayPrint(input_float16_values);
   bool res=OnnxRun(model_handle,ONNX_NO_CONVERSION,input_float16_values,output_double
   if(!res)
     {
      PrintFormat(&quot;error in OnnxRun. error code=%d&quot;,GetLastError());
      return(false);
     }
   Print(&quot;ONNX output array:&quot;);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1297
</p>
<pre><code class="language-mql5">
   ArrayPrint(output_double_values);
//---
   double sum_error=0.0;
   for(int i=0; i&lt;12; i++)
     {
      double delta=test_data[i]-output_double_values[i].value;
      sum_error+=MathAbs(delta);
      PrintFormat(&quot;%d output double %f = %s  difference=%f&quot;,i,output_double_values[i].
     }
//---
   PrintFormat(&quot;test=%s   sum_error=%f&quot;,__FUNCTION__,sum_error);
//---
   return(true);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>ArrayFromFP16, ArrayCopy</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1298
<h3>ArrayToFP8</h3>
Realiza a c√≥pia de um array do tipo float ou double para um array do tipo uchar com o formato
especificado.
</p>
<pre><code class="language-mql5">
bool   ArrayToFP8(
   const uchar&amp;         dst_array[],¬†       // para onde copiamos
   const float&amp;¬†        src_array[],¬†       // de onde copiamos
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Sobrecarga para o tipo double</h3>
</p>
<pre><code class="language-mql5">
bool   ArrayToFP8(
   const uchar&amp;         dst_array[],¬†       // para onde copiamos
   const double&amp;        src_array[],¬†       // de onde copiamos
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
dst_array[]
[out]  Array receptor do tipo uchar.
src_array[]
[in]  Array receptor do tipo float ou double.
fmt
[in] Formato de c√≥pia do enum ENUM_FLOAT8_FORMAT.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Todos os tipos de formato FP8 s√£o definidos no enum ENUM_FLOAT8_FORMAT e s√£o usados no
MQL5 exclusivamente para trabalhar com modelos ONNX.
A fun√ß√£o √© utilizada para a convers√£o de par√¢metros de entrada do tipo float ou double para um dos
tipos FP8. Posteriormente, esses par√¢metros de entrada s√£o usados na fun√ß√£o OnnxRun.
O formato FP8 (n√∫mero de ponto flutuante de 8 bits) √© um dos tipos de dados usados para
representar n√∫meros de ponto flutuante. No FP8, cada n√∫mero √© representado por 8 bits de dados,
que geralmente s√£o divididos em tr√™s componentes: sinal, expoente e mantissa. Este formato
oferece um compromisso entre precis√£o e efici√™ncia de armazenamento de dados, tornando-o
atraente para uso em aplicativos onde a economia de mem√≥ria e recursos computacionais √©
necess√°ria.</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1299
Gra√ßas √† representa√ß√£o compacta de n√∫meros, FP8 permite reduzir os requisitos de mem√≥ria e
acelerar os c√°lculos. Al√©m disso, FP8 pode ser √∫til para a implementa√ß√£o de opera√ß√µes de baixo
n√≠vel, como c√°lculos aritm√©ticos e processamento de sinais.
Exemplo: fun√ß√£o do artigo Trabalhando com modelos ONNX nos formatos float16 e float8
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| RunCastFloat8Float                                               |
//+------------------------------------------------------------------+
bool RunCastFloat8ToFloat(long model_handle,const ENUM_FLOAT8_FORMAT fmt)
  {
   PrintFormat(&quot;TEST: %s(%s)&quot;,__FUNCTION__,EnumToString(fmt));
//---
   float test_data[15]   = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
   uchar data_float8[15] = {};
   if(!ArrayToFP8(data_float8,test_data,fmt))
     {
      Print(&quot;error in ArrayToFP8. error code=&quot;,GetLastError());
      OnnxRelease(model_handle);
      return(false);
     }
   U&lt;uchar&gt; input_float8_values[3*5];
   U&lt;float&gt; output_float_values[3*5];
   float    test_data_float[];
//--- convert float8 to float
   if(!ArrayFromFP8(test_data_float,data_float8,fmt))
     {
      Print(&quot;error in ArrayFromFP8. error code=&quot;,GetLastError());
      OnnxRelease(model_handle);
      return(false);
     }
   for(uint i=0; i&lt;data_float8.Size(); i++)
     {
      input_float8_values[i].value=data_float8[i];
      PrintFormat(&quot;%d input value =%f  Hex float8 = %s  ushort value=%d&quot;,i,test_data_f
     }
   Print(&quot;ONNX input array: &quot;,ArrayToString(input_float8_values));
//--- execute model (convert float8 to float using ONNX)
   if(!OnnxRun(model_handle,ONNX_NO_CONVERSION,input_float8_values,output_float_values
     {
      PrintFormat(&quot;error in OnnxRun. error code=%d&quot;,GetLastError());
      OnnxRelease(model_handle);
      return(false);
     }
   Print(&quot;ONNX output array: &quot;,ArrayToString(output_float_values));
//--- calculate error (compare ONNX and ArrayFromFP8 results)
   double sum_error=0.0;
   for(uint i=0; i&lt;test_data.Size(); i++)</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1300
</p>
<pre><code class="language-mql5">
     {
      double delta=test_data_float[i]-(double)output_float_values[i].value;
      sum_error+=MathAbs(delta);
      PrintFormat(&quot;%d output float %f = %s difference=%f&quot;,i,output_float_values[i].val
     }
//---
   PrintFormat(&quot;%s(%s): sum_error=%f\n&quot;,__FUNCTION__,EnumToString(fmt),sum_error);
   return(true);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>ArrayFromFP8, ArrayCopy</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1301
<h3>ArrayFromFP16</h3>
Realiza a c√≥pia de um array do tipo ushort para um array do tipo float ou double com um formato
especificado.
</p>
<pre><code class="language-mql5">
bool   ArrayFromFP16(
   const float&amp;         dst_array[],¬†       // para onde copiamos
   const ushort&amp;¬†       src_array[],¬†       // de onde copiamos
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Sobrecarga para o tipo double</h3>
</p>
<pre><code class="language-mql5">
bool   ArrayFromFP16(
   const double&amp;        dst_array[],¬†       // para onde copiamos
   const ushort&amp;¬†       src_array[],¬†       // de onde copiamos
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
dst_array[]
[out]  Array receptor do tipo float ou double.
src_array[]
[in]  Array fonte do tipo ushort.
fmt
[in]  Formato de c√≥pia a partir da enumera√ß√£o ENUM_FLOAT16_FORMAT.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Os formatos FLOAT16 e BFLOAT16 s√£o definidos no enum ENUM_FLOAT16_FORMAT e s√£o usados no
MQL5 exclusivamente para trabalhar com modelos ONNX.
Se os par√¢metros de sa√≠da obtidos ao executar a fun√ß√£o OnnxRun s√£o do tipo FLOAT16 e BFLOAT16,
ent√£o esta fun√ß√£o permite converter o resultado em arrays do tipo float ou double.
FLOAT16, tamb√©m conhecido como precis√£o m√©dia ou formato &quot;half-precision float&quot;, utiliza 16 bits
para representar um n√∫mero de ponto flutuante. Este formato oferece um equil√≠brio entre precis√£o e
efici√™ncia de c√°lculo. FLOAT16 √© amplamente usado em aprendizado profundo e redes neurais, onde
a alta performance no processamento de grandes volumes de dados √© requerida. Este formato
permite acelerar os c√°lculos por meio da redu√ß√£o do tamanho dos n√∫meros, o que √© especialmente
importante no treinamento de redes neurais profundas em unidades de processamento gr√°fico
(GPUs).</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1302
BFLOAT16 (ou Brain Floating Point 16) tamb√©m usa 16 bits, mas difere do FLOAT16 na forma como
os n√∫meros s√£o representados. Neste formato, 8 bits s√£o alocados para a representa√ß√£o do
expoente, e os 7 bits restantes s√£o usados para a mantissa. Este formato foi desenvolvido para uso
em aprendizado profundo e intelig√™ncia artificial, especialmente em unidades de processamento
Tensor do Google (TPUs). BFLOAT16 tem bom desempenho no treinamento de redes neurais e pode
ser efetivamente usado para acelerar os c√°lculos.
Exemplo: fun√ß√£o do artigo Trabalhando com modelos ONNX nos formatos float16 e float8
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| RunCastFloat16ToDouble                                           |
//+------------------------------------------------------------------+
bool RunCastFloat16ToDouble(long model_handle)
  {
   PrintFormat(&quot;test=%s&quot;,__FUNCTION__);
   double test_data[12]= {1,2,3,4,5,6,7,8,9,10,11,12};
   ushort data_uint16[12];
   if(!ArrayToFP16(data_uint16,test_data,FLOAT_FP16))
     {
      Print(&quot;error in ArrayToFP16. error code=&quot;,GetLastError());
      return(false);
     }
   Print(&quot;test array:&quot;);
   ArrayPrint(test_data);
   Print(&quot;ArrayToFP16:&quot;);
   ArrayPrint(data_uint16);
   U&lt;ushort&gt; input_float16_values[3*4];
   U&lt;double&gt; output_double_values[3*4];
   float test_data_float[];
   if(!ArrayFromFP16(test_data_float,data_uint16,FLOAT_FP16))
     {
      Print(&quot;error in ArrayFromFP16. error code=&quot;,GetLastError());
      return(false);
     }
   for(int i=0; i&lt;12; i++)
     {
      input_float16_values[i].value=data_uint16[i];
      PrintFormat(&quot;%d input value =%f  Hex float16 = %s  ushort value=%d&quot;,i,test_data_
     }
   Print(&quot;ONNX input array:&quot;);
   ArrayPrint(input_float16_values);
   bool res=OnnxRun(model_handle,ONNX_NO_CONVERSION,input_float16_values,output_double
   if(!res)
     {
      PrintFormat(&quot;error in OnnxRun. error code=%d&quot;,GetLastError());
      return(false);
     }
   Print(&quot;ONNX output array:&quot;);</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1303
</p>
<pre><code class="language-mql5">
   ArrayPrint(output_double_values);
//---
   double sum_error=0.0;
   for(int i=0; i&lt;12; i++)
     {
      double delta=test_data[i]-output_double_values[i].value;
      sum_error+=MathAbs(delta);
      PrintFormat(&quot;%d output double %f = %s  difference=%f&quot;,i,output_double_values[i].
     }
//---
   PrintFormat(&quot;test=%s   sum_error=%f&quot;,__FUNCTION__,sum_error);
//---
   return(true);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>ArrayToFP16, ArrayCopy</h3></p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1304
<h3>ArrayFromFP8</h3>
Realiza a c√≥pia de um array do tipo uchar para um array do tipo float ou double com um formato
especificado.
</p>
<pre><code class="language-mql5">
bool   ArrayFromFP8(
   const float&amp;         dst_array[],¬†       // para onde copiamos
</code></pre>
<p>
 const uchar&amp;  src_array[], // de onde copiamos
</p>
<pre><code class="language-mql5">
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Sobrecarga para o tipo double</h3>
</p>
<pre><code class="language-mql5">
bool   ArrayFromFP8(
   const double&amp;        dst_array[],¬†       // para onde copiamos
</code></pre>
<p>
 const uchar&amp;  src_array[], // de onde copiamos
</p>
<pre><code class="language-mql5">
   ENUM_FLOAT16_FORMAT  fmt ¬†               // formato
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
dst_array[]
[out]  Array receptor do tipo float ou double.
src_array[]
[in] Array fonte do tipo uchar.
fmt
[in] Formato de c√≥pia do enum ENUM_FLOAT8_FORMAT.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false.
<h3>Observa√ß√£o</h3>
Todos os tipos de formato FP8 s√£o definidos no enum ENUM_FLOAT8_FORMAT e s√£o usados no
MQL5 exclusivamente para trabalhar com modelos ONNX.
Se os par√¢metros de sa√≠da obtidos ao executar a fun√ß√£o OnnxRun s√£o do tipo FP8 do enum
ENUM_FLOAT8_FORMAT, ent√£o esta fun√ß√£o permite converter o resultado em arrays do tipo float ou
double.
O formato FP8 (n√∫mero de ponto flutuante de 8 bits) √© um dos tipos de dados usados para
representar n√∫meros de ponto flutuante. No FP8, cada n√∫mero √© representado por 8 bits de dados,
que geralmente s√£o divididos em tr√™s componentes: sinal, expoente e mantissa. Este formato
oferece um compromisso entre precis√£o e efici√™ncia de armazenamento de dados, tornando-o
atraente para uso em aplicativos onde a economia de mem√≥ria e recursos computacionais √©
necess√°ria.</p>
<p><h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1305
Gra√ßas √† representa√ß√£o compacta de n√∫meros, FP8 permite reduzir os requisitos de mem√≥ria e
acelerar os c√°lculos. Al√©m disso, FP8 pode ser √∫til para a implementa√ß√£o de opera√ß√µes de baixo
n√≠vel, como c√°lculos aritm√©ticos e processamento de sinais.
Exemplo: fun√ß√£o do artigo Trabalhando com modelos ONNX nos formatos float16 e float8
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| RunCastFloat8Float                                               |
//+------------------------------------------------------------------+
bool RunCastFloat8ToFloat(long model_handle,const ENUM_FLOAT8_FORMAT fmt)
  {
   PrintFormat(&quot;TEST: %s(%s)&quot;,__FUNCTION__,EnumToString(fmt));
//---
   float test_data[15]   = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
   uchar data_float8[15] = {};
   if(!ArrayToFP8(data_float8,test_data,fmt))
     {
      Print(&quot;error in ArrayToFP8. error code=&quot;,GetLastError());
      OnnxRelease(model_handle);
      return(false);
     }
   U&lt;uchar&gt; input_float8_values[3*5];
   U&lt;float&gt; output_float_values[3*5];
   float    test_data_float[];
//--- convert float8 to float
   if(!ArrayFromFP8(test_data_float,data_float8,fmt))
     {
      Print(&quot;error in ArrayFromFP8. error code=&quot;,GetLastError());
      OnnxRelease(model_handle);
      return(false);
     }
   for(uint i=0; i&lt;data_float8.Size(); i++)
     {
      input_float8_values[i].value=data_float8[i];
      PrintFormat(&quot;%d input value =%f  Hex float8 = %s  ushort value=%d&quot;,i,test_data_f
     }
   Print(&quot;ONNX input array: &quot;,ArrayToString(input_float8_values));
//--- execute model (convert float8 to float using ONNX)
   if(!OnnxRun(model_handle,ONNX_NO_CONVERSION,input_float8_values,output_float_values
     {
      PrintFormat(&quot;error in OnnxRun. error code=%d&quot;,GetLastError());
      OnnxRelease(model_handle);
      return(false);
     }
   Print(&quot;ONNX output array: &quot;,ArrayToString(output_float_values));
//--- calculate error (compare ONNX and ArrayFromFP8 results)
   double sum_error=0.0;
   for(uint i=0; i&lt;test_data.Size(); i++)</p>
<p></code></pre>
<p>
<h3>Fun√ß√µes para Array</h3>
¬© 2000-2025, MetaQuotes Ltd.
1306
</p>
<pre><code class="language-mql5">
     {
      double delta=test_data_float[i]-(double)output_float_values[i].value;
      sum_error+=MathAbs(delta);
      PrintFormat(&quot;%d output float %f = %s difference=%f&quot;,i,output_float_values[i].val
     }
//---
   PrintFormat(&quot;%s(%s): sum_error=%f\n&quot;,__FUNCTION__,EnumToString(fmt),sum_error);
   return(true);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>ArrayToFP8, ArrayCopy</h3>
</p>
        </article>
        
        <footer>
            <p>Documenta√ß√£o MQL5 - Fonte: MetaQuotes Ltd.</p>
        </footer>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function toggleSidebar() {
            document.querySelector('.sidebar').classList.toggle('open');
        }
        
        function filterNav() {
            const filter = document.getElementById('search').value.toLowerCase();
            const items = document.querySelectorAll('.nav-list li');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }
    </script>
</body>
</html>