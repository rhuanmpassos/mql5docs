<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elementos B√°sicos da Linguagem - MQL5 Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>MQL5 Docs</h1>
            <p>Documenta√ß√£o Completa</p>
        </div>
        <div class="search-box">
            <input type="text" id="search" placeholder="Buscar..." onkeyup="filterNav()">
        </div>
        <ul class="nav-list" id="nav-list">
            <li class=""><a href="index.html">üìö √çndice</a></li>
            <li class=""><a href="introducao.html">Introducao</a></li>
<li class=""><a href="refer√™ncia_mql5.html">Refer√™ncia MQL5</a></li>
<li class="active"><a href="elementos_b√°sicos_da_linguagem.html">Elementos B√°sicos da Linguagem</a></li>
<li class=""><a href="constantes,_enumeradores_e_estruturas.html">Constantes, Enumeradores e Estruturas</a></li>
<li class=""><a href="programas_mql5.html">Programas MQL5</a></li>
<li class=""><a href="vari√°veis_predefinidas.html">Vari√°veis Predefinidas</a></li>
<li class=""><a href="fun√ß√µes_comuns.html">Fun√ß√µes Comuns</a></li>
<li class=""><a href="fun√ß√µes_para_array.html">Fun√ß√µes para Array</a></li>
<li class=""><a href="m√©todos_matriciais_e_vetoriais.html">M√©todos matriciais e vetoriais</a></li>
<li class=""><a href="fun√ß√µes_de_convers√£o.html">Fun√ß√µes de Convers√£o</a></li>
<li class=""><a href="fun√ß√µes_matem√°ticas.html">Fun√ß√µes Matem√°ticas</a></li>
<li class=""><a href="fun√ß√µes_de_string.html">Fun√ß√µes de String</a></li>
<li class=""><a href="data_e_hora.html">Data e Hora</a></li>
<li class=""><a href="informa√ß√µes_de_conta.html">Informa√ß√µes de Conta</a></li>
<li class=""><a href="verificando_estado.html">Verificando Estado</a></li>
<li class=""><a href="manipula√ß√£o_de_eventos.html">Manipula√ß√£o de eventos</a></li>
<li class=""><a href="informa√ß√µes_de_mercado.html">Informa√ß√µes de Mercado</a></li>
<li class=""><a href="calend√°rio_econ√¥mico.html">Calend√°rio econ√¥mico</a></li>
<li class=""><a href="s√©ries_temporais_e_acesso_a_indicadores.html">S√©ries Temporais e Acesso a Indicadores</a></li>
<li class=""><a href="s√≠mbolos_personalizados.html">S√≠mbolos personalizados</a></li>
<li class=""><a href="opera√ß√µes_de_gr√°ficos.html">Opera√ß√µes de Gr√°ficos</a></li>
<li class=""><a href="fun√ß√µes_de_negocia√ß√£o.html">Fun√ß√µes de Negocia√ß√£o</a></li>
<li class=""><a href="gerenciamento_de_sinais.html">Gerenciamento de sinais</a></li>
<li class=""><a href="fun√ß√µes_de_rede.html">Fun√ß√µes de rede</a></li>
<li class=""><a href="vari√°veis_globais_do_terminal.html">Vari√°veis Globais do Terminal</a></li>
<li class=""><a href="fun√ß√µes_de_arquivo.html">Fun√ß√µes de Arquivo</a></li>
<li class=""><a href="indicadores_customizados.html">Indicadores Customizados</a></li>
<li class=""><a href="fun√ß√µes_de_objeto.html">Fun√ß√µes de Objeto</a></li>
<li class=""><a href="indicadores_t√©cnicos.html">Indicadores T√©cnicos</a></li>
<li class=""><a href="trabalhando_com_resultados_de_otimiza√ß√£o.html">Trabalhando com Resultados de Otimiza√ß√£o</a></li>
<li class=""><a href="trabalhando_com_eventos.html">Trabalhando com Eventos</a></li>
<li class=""><a href="trabalhando_com_opencl.html">Trabalhando com OpenCL</a></li>
<li class=""><a href="trabalhar_com_bancos_de_dados.html">Trabalhar com bancos de dados</a></li>
<li class=""><a href="trabalho_com_directx.html">Trabalho com DirectX</a></li>
<li class=""><a href="metatrader_para_python.html">MetaTrader para Python</a></li>
<li class=""><a href="modelos_onnx.html">Modelos ONNX</a></li>
<li class=""><a href="biblioteca_padr√£o.html">Biblioteca Padr√£o</a></li>
<li class=""><a href="migrando_do_mql4.html">Migrando do MQL4</a></li>
<li class=""><a href="lista_de_fun√ß√µes_mql5.html">Lista de Fun√ß√µes MQL5</a></li>
<li class=""><a href="lista_de_constantes_mql5.html">Lista de Constantes MQL5</a></li>

        </ul>
    </nav>
    
    <main class="content">
        <header>
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1>Elementos B√°sicos da Linguagem</h1>
        </header>
        
        <article>
            <p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
75
<h3>Elementos B√°sicos da Linguagem</h3>
A Linguagem MetaQuotes 5 (MQL5) √© uma linguagem orientado a objetos de alto n√≠vel destinado para
escrever estrat√©gias de negocia√ß√£o automatizadas, e indicadores t√©cnicos customizados para a a
an√°lise de v√°rios mercados financeiros. Ele permite n√£o somente escrever uma variedade de sistemas
especialistas, concebidos para operar em tempo real, mas tamb√©m criar suas pr√≥prias ferramentas
gr√°ficas para ajudar voc√™ a tomar decis√µes de negocia√ß√£o (trade).
MQL5 √© baseado no conceito da popular linguagem de programa√ß√£o C++. Em compara√ß√£o com MQL4, a
nova linguagem tem agora enumeradores, estruturas, classes e manipula√ß√£o de evento. Ao aumentar
o n√∫mero de tipos principais incorporados, a intera√ß√£o dos programas execut√°veis em MQL5 com
outros aplicativos atrav√©s de dll √© agora t√£o f√°cil quanto poss√≠vel. A sintaxe do MQL5 √© similar √†
sintaxe do C++, e isso faz com que seja f√°cil traduzir para ele programas de linguagens modernas de
programa√ß√£o.
Para ajudar voc√™ a estudar a linguagem MQL5, todos os t√≥picos est√£o agrupados nas seguintes se√ß√µes:
¬∑ Sintaxe
¬∑ Tipos de Dados
¬∑ Opera√ß√µes e Express√µes
¬∑ Operadores
¬∑ Fun√ß√µes
¬∑ Vari√°veis
¬∑ Preprocessador
¬∑ Programa√ß√£o Orientada a Objetos
¬∑ Espa√ßos de nomes</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
76
<h3>Sintaxe</h3>
Quanto √† sintaxe, a linguagem MQL5 para programa√ß√£o de estrat√©gias de negocia√ß√£o √© muito similar √†
linguagem de programa√ß√£o C++, com exce√ß√£o de alguns recursos:
¬∑ aus√™ncia de aritm√©tica com endere√ßo
¬∑ aus√™ncia do operador goto
¬∑ um enumerador an√¥nimo n√£o pode ser declarado
¬∑ aus√™ncia de heran√ßa m√∫ltipla
<h3>Tamb√©m Veja</h3>
<h3>Enumeradores, Estruturas e Classes, Heran√ßa</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
77
<h3>Coment√°rios</h3>
Coment√°rios de m√∫ltiplas linhas come√ßam com o par de s√≠mbolos /* e terminam com o par */. Este
tipo de coment√°rio n√£o pode ser aninhado. Coment√°rios de linha √∫nica come√ßam com o par de
s√≠mbolos // e terminam com o caractere newline, eles podem ser aninhados em outros coment√°rios de
m√∫ltiplas linhas. Coment√°rios s√£o permitidos em todos os lugares onde os espa√ßos s√£o permitidos,
eles podem conter qualquer n√∫mero de espa√ßos.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
//--- Coment√°rio de linha √∫nica
/*  Coment√°rio
¬†  de m√∫ltiplas         // Coment√°rio de linha √∫nica aninhada
¬†  linhas
</code></pre>
<p>
*/</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
78
<h3>Identificadores</h3>
Identificadores s√£o usados como nomes de vari√°veis e fun√ß√µes. O comprimento de um identificador
n√£o pode exceder 63 caracteres.
Caracteres permitidos na forma√ß√£o de um identificador: n√∫meros 0-9, as letras mai√∫sculas e
min√∫sculas latinas a-z e A-Z, reconhecidos como caracteres diferentes, o caractere sublinhado (_). O
primeiro caractere n√£o pode ser um d√≠gito. 
O identificador n√£o deve coincidir com uma palavra reservada.
<h3>Exemplos:</h3>
<h3>NAME1 namel Total_5 Paper</h3>
<h3>Tamb√©m Veja</h3>
<h3>Vari√°veis, Fun√ß√µes</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
79
<h3>Palavras Reservadas</h3>
Os seguintes identificadores s√£o registrados como palavras reservadas, cada uma delas corresponde a
uma certa a√ß√£o, e n√£o pode ser usada com outro significado:
<h3>Tipos de Dados</h3>
bool
float
uint
char
int
ulong
class
long
union
color
short
ushort
datetime
string
void
double
struct
enum
uchar
<h3>Especificadores de Acesso</h3>
const
private
virtual
delete
protected
override
public
<h3>Classes de Mem√≥ria</h3>
extern
input
static
<h3>Operadores</h3>
break
dynamic_cast
operator
case
else
pack
continue
for
return
default
if
sizeof
delete
new
switch
do
offsetof
while
<h3>Outros</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
80
this
</p>
<pre><code class="language-mql5">
#define
</code></pre>
<p>
#import
true
#ifdef
</p>
<pre><code class="language-mql5">
#include
</code></pre>
<p>
false
#ifndef
</p>
<pre><code class="language-mql5">
#property
</code></pre>
<p>
template
#else 
group
typename
#endif
namespace</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
81
<h3>Tipos de Dados</h3>
Qualquer programa funciona com dados. Os dados podem ser de diferentes tipos dependendo da sua
finalidade. Por exemplo, dados inteiros s√£o usados para acessar componentes de arrays. Dados de
pre√ßo pertencem ao tipo de dupla precis√£o com ponto flutuante. Isso est√° relacionado ao fato de que
nenhum tipo de dados especial para detalhes de pre√ßo √© fornecido pelo MQL5.
Dados de diferentes tipos s√£o processados com diferentes taxas. Dados inteiros s√£o os de
processamento mais r√°pido. Para processar dados de dupla precis√£o, um co-processador especial √©
utilizado. No entanto, por causa da complexidade da representa√ß√£o interna de dados com ponto
flutuante, eles s√£o processados mais devagar que os dados inteiros.
Dados do tipo string s√£o os de processamento mais lento por causa da aloca√ß√£o/realoca√ß√£o din√¢mica
de mem√≥ria de computador.
<h3>Os tipos b√°sicos de dado s√£o:</h3>
¬∑ inteiros (char, short, int, long, uchar, ushort, uint, ulong);
¬∑ l√≥gico (bool);
¬∑ literais (ushort);
¬∑ strings (string);
¬∑ n√∫meros com ponto flutuante (double, float);
¬∑ cor (color);
¬∑ data e hora(datetime);
¬∑ enumeradores (enum).
<h3>Os tipos complexos de dado s√£o:</h3>
¬∑ estruturas;
¬∑ classes.
Em termos de OOP tipos de dados complexos s√£o chamados de tipos de dados abstratos.
Os tipos color e datetime fazem sentido apenas para facilitar a entrada e visualiza√ß√£o de par√¢metros
definidos do lado de fora - a partir da tabela de um Expert Advisor ou propriedades de um indicador
customizado (o guia Entradas). Dados de cor (color) e data e hora (datetime) s√£o representados como
inteiros. Tipos inteiros e tipos de ponto flutuante s√£o chamados tipos aritm√©ticos (num√©ricos).
Apenas convers√µes de tipo (type casting) impl√≠citas s√£o usadas em express√µes, a menos que uma
convers√£o (casting) expl√≠cita seja especificado.
<h3>Tamb√©m Veja</h3>
<h3>Convers√£o de Tipo (Typecasting)</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
82
<h3>Tipos Inteiros</h3>
Em MQL5, os inteiros s√£o representados por onze tipos. Alguns tipos podem ser utilizados em conjunto
com outros tipos, se exigido pela l√≥gica do programa, mas neste caso √© necess√°rio lembrar as regras
de convers√£o de tipos. 
A tabela abaixo lista as caracter√≠sticas de cada tipo. Al√©m disso, a √∫ltima coluna apresenta o tipo
correspondente em C++ para cada tipo.
<h3>Tipo</h3>
<h3>Tamanho</h3>
em
<h3>Bytes</h3>
<h3>Valor M√≠nimo</h3>
<h3>Valor M√°ximo</h3>
<h3>C++ An√°logo</h3>
char
1
-128
127
char
uchar
1
0
255
unsigned 
char,
<h3>BYTE</h3>
bool
1
0(false)
1(true)
bool
short
2
-32 768
32 767
short, wchar_t
ushort
2
0
65 535
unsigned 
short,
<h3>WORD</h3>
int
4
- 2 147 483 648
2 147 483 647
int
uint
4
0
4 294 967 295
unsigned 
int,
<h3>DWORD</h3>
color
4
-1
16 777 215
int, COLORREF
long
8
-9 223 372 036
854 775 808
9 223 372 036
854 775 807
__int64
ulong
8
0
18 446 744 073
709 551 615
unsigned __int64
datetime
8
0 
(1970.01.01
0:00:00)
32 535 244 799
(3000.12.31
23:59:59)
__time64_t
Valores do tipo integer podem ser apresentados como constantes num√©ricas, literais de cor, literais de
data-hora, constantes de caractere e enumeradores.
Pseud√¥nimos adicionais para tipos inteiros (para compatibilidade com C/C++)
Para facilitar a portabilidade de c√≥digo de outras linguagens, como C e C++, para a linguagem MQL5,
foram adicionados pseud√¥nimos (aliases) para os tipos inteiros padr√£o. Esses aliases n√£o criam novos
tipos, apenas s√£o nomes alternativos para os tipos j√° existentes em MQL5. Eles podem ser usados em
todos os contextos onde os tipos b√°sicos s√£o aplic√°veis.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
83
<h3>Tipo</h3>
<h3>Em</h3>
conformidad
e com o tipo
<h3>MQL5</h3>
<h3>Tamanho</h3>
(bits)
<h3>–ó–Ω–∞–∫</h3>
<h3>Valor m√≠nimo</h3>
<h3>Valor</h3>
m√°ximo
int8_t
char
8
com sinal
-128
127
uint8_t
uchar
8
sem sinal
0
255
int16_t
short
16
com sinal
-32 768
32 767
uint16_t
ushort
16
sem sinal
0
65 535
int32_t
int
32
com sinal
- 2 147 483
648
2 147 483 647
uint32_t
uint
32
sem sinal
0
4 294 967 295
int64_t
long
64
com sinal
-9 223 372
036 854 775
808
9 223 372 036
854 775 807
uint64_t
ulong
64
sem sinal
0
18 446 744
073 709 551
615
O uso desses pseud√¥nimos √© √∫til ao portar bibliotecas e algoritmos existentes de C/C++ para MQL5,
especialmente em projetos com alto n√≠vel de compatibilidade entre plataformas. Todos os novos
nomes est√£o dispon√≠veis tanto em scripts quanto em EAs e indicadores.
<h3>Tamb√©m Veja</h3>
Convers√£o de Dados, Constantes de Tipos Num√©ricos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
84
<h3>Tipos char, short, int e long</h3>
char
O tipo char usa 1 byte de mem√≥ria (8 bits) e permite expressar em nota√ß√£o bin√°ria 2^8=256 valores. O
tipo char pode conter tanto valores positivos quanto negativos. A faixa de valores √© de -128 a 127.
uchar
O tipo inteiro uchar tamb√©m ocupa 1 byte de mem√≥ria, assim como o tipo char , mas diferente dele
uchar √© destinado apenas para valores positivos. O valor m√≠nimo √© zero, o valor m√°ximo √© 255. A
primeira letra u no nome do tipo uchar √© abreviatura de unsigned (sem sinal).
short
O tamanho do tipo short √© de 2 bytes (16 bits) e, conseq√ºentemente, ele permite expressar a faixa de
valores igual a 2 elevado a 16: 2^16 = 65 536. Como o tipo short √© um tipo com sinal, e cont√©m tanto
valores positivos quanto negativos, a faixa de valores √© entre -32 768 e 32 767.
ushort
O tipo short sem sinal √© o tipo ushort, que tamb√©m tem 2 bytes de tamanho. O valor m√≠nimo √© 0, o
valor m√°ximo √© 65 535.
int
O tamanho do tipo int √© de 4 bytes (32 bits). O valor m√≠nimo √© -2 147 483 648, o valor m√°ximo √© 2 147
483 647.
uint
O tipo integer sem sinal √© uint. Ele usa 4 bytes de mem√≥ria e permite expressar inteiros de 0 a 4 294
967 295.
long
O tamanho do tipo long √© de 8 bytes (64 bits). O valor m√≠nimo √© -9 223 372 036 854 775 808, o valor
m√°ximo √© 9 223 372 036 854 775 807.
ulong
O tipo ulong tamb√©m ocupa 8 bytes e pode armazenar valores de 0 a 18 446 744 073 709 551 615.
<h3>Exemplos:</h3>
char  ch=12;
short sh=-5000;
</p>
<pre><code class="language-mql5">
int   in=2445777;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
85
Como os tipo inteiros sem sinal n√£o s√£o concebidos para armazenar valores negativos, a tentativa de
atribuir um valor negativo pode levar a conseq√º√™ncias inesperadas. Este simples script levar√° a um
loop infinito:
</p>
<pre><code class="language-mql5">
//--- Loop infinito
void OnStart()
  {
   uchar  u_ch;
   for(char ch=-128;ch&lt;128;ch++)
     {
      u_ch=ch;
      Print(&quot;ch = &quot;,ch,&quot; u_ch = &quot;,u_ch);
     }
</code></pre>
<p>
  }
<h3>A variante correta √©:</h3>
</p>
<pre><code class="language-mql5">
//--- Variante correta
void OnStart()
  {
   uchar  u_ch;
   for(char ch=-128;ch&lt;=127;ch++)
     {
      u_ch=ch;
      Print(&quot;ch = &quot;,ch,&quot; u_ch = &quot;,u_ch);
      if(ch==127) break;
     }
</code></pre>
<p>
  }
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   ch= -128  u_ch= 128
   ch= -127  u_ch= 129
   ch= -126  u_ch= 130
   ch= -125  u_ch= 131
   ch= -124  u_ch= 132
   ch= -123  u_ch= 133
   ch= -122  u_ch= 134
   ch= -121  u_ch= 135
   ch= -120  u_ch= 136
   ch= -119  u_ch= 137
   ch= -118  u_ch= 138
   ch= -117  u_ch= 139
   ch= -116  u_ch= 140
   ch= -115  u_ch= 141
   ch= -114  u_ch= 142
   ch= -113  u_ch= 143
   ch= -112  u_ch= 144</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
86
</p>
<pre><code class="language-mql5">
   ch= -111  u_ch= 145
    ... 
</code></pre>
<p>
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
//--- Valores negativos n√£o podem ser armazenados em tipos sem sinal
</code></pre>
<p>
uchar  u_ch=-120;
ushort u_sh=-5000;
uint   u_in=-401280;
Hexadecimal: n√∫meros 0-9, as letras a-f ou A-F para os valores de 10-15; come√ßam com 0x ou 0X.
<h3>Exemplos:</h3>
0x0A, 0x12, 0X12, 0x2f, 0xA3, 0Xa3, 0X7C7
For integer variables, the values can be set in binary form using B prefix. For example, you can encode
the working hours of a trading session into int type variable and use information about them according
to the required algorithm: 
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- set 1 for working hours and 0 for nonworking ones
   int AsianSession   =B&#x27;111111111&#x27;; // Asian session from 0:00 to 9:00
   int EuropeanSession=B&#x27;111111111000000000&#x27;; // European session 9:00 - 18:00
   int AmericanSession =B&#x27;111111110000000000000011&#x27;; // American session 16:00 - 02:00
//--- derive numerical values of the sessions
   PrintFormat(&quot;Asian session hours as value =%d&quot;,AsianSession);
   PrintFormat(&quot;European session hours as value is %d&quot;,EuropeanSession);
   PrintFormat(&quot;American session hours as value is %d&quot;,AmericanSession);
//--- and now let&#x27;s display string representations of the sessions&#x27; working hours
   Print(&quot;Asian session &quot;,GetHoursForSession(AsianSession));
   Print(&quot;European session &quot;,GetHoursForSession(EuropeanSession));
   Print(&quot;American session &quot;,GetHoursForSession(AmericanSession));   
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| return the session&#x27;s working hours as a string                   |
//+------------------------------------------------------------------+
string GetHoursForSession(int session)
  {
//--- in order to check, use AND bit operations and left shift by 1 bit &lt;&lt;=1
//--- start checking from the lowest bit
   int bit=1;
   string out=&quot;working hours: &quot;;
//--- check all 24 bits starting from the zero one and up to 23 inclusively  
   for(int i=0;i&lt;24;i++)</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
87
</p>
<pre><code class="language-mql5">
     {
      //--- receive bit state in number
      bool workinghour=(session&amp;bit)==bit;
      //--- add the hour&#x27;s number to the message
      if(workinghour )out=out+StringFormat(&quot;%d &quot;,i); 
      //--- shift by one bit to the left to check the value of the next one
      bit&lt;&lt;=1;
     }
//--- result string
   return out;
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
<h3>Convers√£o de Tipo (Typecasting)</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
88
<h3>Constantes de Caracteres</h3>
Os caracteres como elementos de uma string,em MQL5, s√£o √≠ndices do conjunto de caracteres
Unicode. Eles s√£o valores hexadecimais que podem ser convertidos para inteiros, e que podem ser
manipulados por opera√ß√µes com inteiros como adi√ß√£o e subtra√ß√£o.
Qualquer caractere √∫nico entre aspas simples ou um c√≥digo hexadecimal ASCII de um caractere como
&#x27;\x10&#x27; √© um caractere constante e √© do tipo ushort. Por exemplo, uma anota√ß√£o do tipo &#x27;0&#x27; representa o
valor num√©rico 30, que corresponde ao √≠ndice do zero na tabela de caracteres.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- define constantes de caracteres
   int symbol_0=&#x27;0&#x27;;
   int symbol_9=symbol_0+9; // obt√©m o s√≠mbolo &#x27;9&#x27;
//--- valores de sa√≠da de constantes
   printf(&quot;Num formato decimal: symbol_0 = %d,  symbol_9 = %d&quot;,symbol_0,symbol_9);
   printf(&quot;Num formato hexadecimal: symbol_0 = 0x%x,  symbol_9 = 0x%x&quot;,symbol_0,symbol
//--- entrada de constantes em uma string
   string test=&quot;&quot;; 
   StringSetCharacter(test,0,symbol_0);
   StringSetCharacter(test,1,symbol_9);
//--- isso √© como eles se apresentam em uma string
   Print(test);
</code></pre>
<p>
  }
Uma barra invertida (\) √© um caractere de controle para o compilador ao lidar com strings constantes e
constantes caracteres no texto fonte de um programa. Alguns s√≠mbolos, por exemplo uma aspas
simples (&#x27;), aspas duplas (&quot;), barra invertida (\) e caracteres de controle podem ser representados
como combina√ß√£o de s√≠mbolos que come√ßam com uma barra invertida (\), de acordo com a tabela
abaixo:
<h3>Nome do Caractere</h3>
<h3>C√≥digo Mnem√¥nico ou</h3>
imagem
<h3>Anota√ß√£o em MQL5</h3>
<h3>Valor Num√©rico</h3>
linha nova (line feed)
<h3>LF</h3>
&#x27;\n&#x27;
10
tab horizontal  
<h3>HT</h3>
&#x27;\t&#x27;
9
retorno de carro
<h3>CR</h3>
&#x27;\r&#x27;
13
barra invertida
\
&#x27;\\&#x27;
92
aspas simples  
&#x27;
&#x27;\&#x27;&#x27;
39
aspas duplas  
&quot;
&#x27;\&quot;&#x27;
34
c√≥digo hexadecimal
hhhh
&#x27;\xhhhh&#x27;
1 
a 
4 
caracteres
hexadecimais</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
89
<h3>Nome do Caractere</h3>
<h3>C√≥digo Mnem√¥nico ou</h3>
imagem
<h3>Anota√ß√£o em MQL5</h3>
<h3>Valor Num√©rico</h3>
c√≥digo decimal
d
&#x27;\d&#x27;
n√∫mero decimal de 0
a 65535
Caso uma barra invertida seja seguida por outro caractere n√£o descrito acima, o resultado √©
indefinido.
<h3>Exemplo</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- declara constantes de caracteres
   int a=&#x27;A&#x27;;
   int b=&#x27;$&#x27;;
   int c=&#x27;¬©&#x27;;      // c√≥digo 0xA9
   int d=&#x27;\xAE&#x27;;   // c√≥digo do s√≠mbolo ¬Æ
//--- sa√≠da imprime constantes
   Print(a,b,c,d);
//--- acrescenta um caractere na string
   string test=&quot;&quot;;
   StringSetCharacter(test,0,a);
   Print(test);
//--- substitui um caractere na string
   StringSetCharacter(test,0,b);
   Print(test);
//--- substitui um caractere na string
   StringSetCharacter(test,0,c);
   Print(test);
//--- substitui um caractere na string
   StringSetCharacter(test,0,d);
   Print(test);
//--- representa caracteres como n√∫mero
   int a1=65;
   int b1=36;
   int c1=169;
   int d1=174;
//--- acrescenta um caractere na string
   StringSetCharacter(test,1,a1);
   Print(test);
//--- acrescenta um caractere na string
   StringSetCharacter(test,1,b1);
   Print(test);
//--- acrescenta um caractere na string
   StringSetCharacter(test,1,c1);
   Print(test);
//--- acrescenta um caractere na string
   StringSetCharacter(test,1,d1);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
90
</p>
<pre><code class="language-mql5">
   Print(test);
</code></pre>
<p>
  }
Como foi mencionado acima, o valor de uma constante caractere (ou vari√°vel) √© o valor do √≠ndice na
tabela de caracteres. Sendo o √≠ndice um inteiro, pode ser escrito de diferentes maneiras.
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- 
   int a=0xAE;     // o c√≥digo de ¬Æ corresponde ao literal &#x27;\xAE&#x27; 
   int b=0x24;     // o c√≥digo de $ corresponde ao literal &#x27;\x24&#x27; 
   int c=0xA9;     // o c√≥digo de ¬© corresponde ao literal &#x27;\xA9&#x27; 
   int d=0x263A;   // o c√≥digo de ‚ò∫ corresponde ao literal &#x27;\x263A&#x27; 
//--- mostrar valores
   Print(a,b,c,d);
//--- acrescenta um caractere na string
   string test=&quot;&quot;;
   StringSetCharacter(test,0,a);
   Print(test);
//--- substitui um caractere na string
   StringSetCharacter(test,0,b);
   Print(test);
//--- substitui um caractere na string
   StringSetCharacter(test,0,c);
   Print(test);
//--- substitui um caractere na string
   StringSetCharacter(test,0,d);
   Print(test);
//--- c√≥digo de terno cart√£o
   int a1=0x2660;
   int b1=0x2661;
   int c1=0x2662;
   int d1=0x2663;
//--- acrescenta um caractere de espadas
   StringSetCharacter(test,1,a1);
   Print(test);
//--- acrescenta um caractere de copas
   StringSetCharacter(test,2,b1);
   Print(test);
//--- acrescenta um caractere de ouros
   StringSetCharacter(test,3,c1);
   Print(test);
//--- acrescenta um caractere de paus
   StringSetCharacter(test,4,d1);
   Print(test);
//--- Exemplo de literais de caractere em uma string
   test=&quot;Rainha\x2660√Ås\x2662&quot;;
   printf(&quot;%s&quot;,test);
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
91
A representa√ß√£o internal de um literal de caractere √© do tipo ushort. Constantes de caracteres podem
aceitar valores de 0 a 65535.
<h3>Tamb√©m Veja</h3>
StringSetCharacter(),  StringGetCharacter(), ShortToString(), ShortArrayToString(),
<h3>StringToShortArray()</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
92
<h3>Tipo datetime</h3>
O tipo datetime √© destinado a armazenar data e hora como o n√∫mero de segundos decorridos desde 01
de Janeiro de 1970. Este tipo ocupa 8 bytes de mem√≥ria.
Constantes de data e hora podem ser representados como string literal, que consiste de 6 partes
mostrando o valor num√©rico do ano, m√™s, dia (ou dia, m√™s, ano), horas, minutos e segundos. A
constante √© colocado entre aspas simples e come√ßa com o caractere D.
Os valores variam de 1 de Janeiro de 1970 a 31 de Dezembro de 3000. Tanto a data (ano, m√™s, dia)
quanto a hora (horas, minutos, segundos), ou ambos podem ser omitidos.
Na especifica√ß√£o da data literal , √© desej√°vel que voc√™ especifique ano, m√™s e dia. Caso contr√°rio, o
compilador retorna um aviso sobre entrada incompleta.  
<h3>Exemplos:</h3>
datetime NY=D&#x27;2015.01.01 00:00&#x27;;     // Data Hora de come√ßo do ano 2015
datetime d1=D&#x27;1980.07.19 12:30:27&#x27;;  // Ano M√™s Dia Horas Minutos Segundos
datetime d2=D&#x27;19.07.1980 12:30:27&#x27;;  // Igual a D&#x27;1980.07.19 12:30:27&#x27;;
datetime d3=D&#x27;19.07.1980 12&#x27;;        // Igual a D&#x27;1980.07.19 12:00:00&#x27;
datetime d4=D&#x27;01.01.2004&#x27;;           // Igual a D&#x27;01.01.2004 00:00:00&#x27;
datetime compilation_date=__DATE__;             // Data de Compila√ß√£o
datetime compilation_date_time=__DATETIME__;    // Data e Hora de Compila√ß√£o
datetime compilation_time=__DATETIME__-__DATE__;// Hora de Compila√ß√£o
</p>
<pre><code class="language-mql5">
//--- Exemplos de declara√ß√µes ap√≥s o qual avisos do compilador ser√£o retornados
</code></pre>
<p>
datetime warning1=D&#x27;12:30:27&#x27;;       // Igual a D&#x27;[data de compila√ß√£o] 12:30:27&#x27;
datetime warning2=D&#x27;&#x27;;               // Igual a __DATETIME__
<h3>Tamb√©m Veja</h3>
Estrutura do Tipo Data, Data e Hora, TimeToString, StringToTime</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
93
<h3>Tipo color</h3>
O tipo color √© destinado para armazenar informa√ß√µes sobre cor e ocupa 4 bytes na mem√≥ria. O
primeiro byte √© ignorado, os restantes 3 bytes cont√©m os componentes RGB.
As constantes de cor podem ser representadas de tr√™s formas: literalmente, por inteiros, ou por nome
(somente por Web-colors nomeados).
A representa√ß√£o literal consiste de tr√™s partes representando os valores num√©ricos das taxas dos tr√™s
principais componentes de cor: vermelho, verde e azul. A constante come√ßa com C e colocada entre
aspas simples. Os valores num√©ricos da taxa de um componente de cor ficam entre 0 e 255.
A representa√ß√£o dos valores inteiros √© escrito na forma de um n√∫mero hexadecimal ou decimal. Um
n√∫mero hexadecimal tem a forma 0x00BBGGRR, onde RR √© a taxa do componente da cor vermelha
(Red), GG - da cor verde (Green), e BB - da cor azul (Blue). As constantes decimais n√£o s√£o
diretamente refletidos no RGB. Eles representam um valor decimal da representa√ß√£o hexadecimal de
inteiros.
Cores espec√≠ficas refletem o chamado conjunto de Web-colors.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
//--- Literais
</code></pre>
<p>
<h3>C&#x27;128,128,128&#x27;    // Cinza</h3>
<h3>C&#x27;0x00,0x00,0xFF&#x27; // Azul</h3>
</p>
<pre><code class="language-mql5">
//nomes de cores
</code></pre>
<p>
clrRed               // Vermelho
clrYellow            // Amarelo
clrBlack             // Preto
</p>
<pre><code class="language-mql5">
//--- Representa√ß√µes integrais
</code></pre>
<p>
0xFFFFFF          // Branco
16777215          // Branco
0x008000          // Verde
32768             // Verde
<h3>Tamb√©m Veja</h3>
Web Colors,  ColorToString, StringToColor, Convers√£o de Tipo (Typecasting)</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
94
<h3>Tipo bool</h3>
O tipo bool √© destinado para armazenar os valores l√≥gicos true ou false, a representa√ß√£o num√©rica
deles √© 1 ou 0, respectivamente. 
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
bool a = true;
bool b = false;
bool c = 1;
</code></pre>
<p>
A representa√ß√£o internal √© um n√∫mero inteiro de 1 byte de tamanho. Deve-se notar que em express√µes
l√≥gicas √© poss√≠vel usar outros tipos reais ou inteiros ou express√µes desses tipos - o compilador n√£o ir√°
gerar qualquer erro. Neste caso, o valor zero ser√° interpretado como false (falso), e todos os outros
valores - como true (verdadeiro).
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
   int i=5;
   double d=-2.5;
   if(i) Print(&quot;i = &quot;,i,&quot; e tem valor true&quot;);
   else Print(&quot;i = &quot;,i,&quot; e tem valor false&quot;);
   if(d) Print(&quot;d = &quot;,d,&quot; e tem o valor true&quot;);
   else Print(&quot;d = &quot;,d,&quot; e tem o valor false&quot;);
   i=0;
   if(i) Print(&quot;i = &quot;,i,&quot; e tem o valor true&quot;);
   else Print(&quot;i = &quot;,i,&quot;e tem o valor false&quot;);
   d=0.0;
   if(d) Print(&quot;d = &quot;,d,&quot; e tem o valor true&quot;);
   else Print(&quot;d = &quot;,d,&quot; e tem o valor false&quot;);
//--- Resultados da execu√ß√£o
//   i= 5 e tem o valor true
//   d= -2.5 e tem o valor true
//   i= 0 e tem o valor false
//   d= 0 e tem o valor false
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
<h3>Opera√ß√µes Booleanas, Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
95
<h3>Enumeradores</h3>
Dados do tipo enum pertencem a um determinado conjunto limitado de dados. Definindo o tipo
enumerador:
</p>
<pre><code class="language-mql5">
enum nome do tipo enumer√°vel
  {
</code></pre>
<p>
¬† lista de valores
  };
A lista de valores √© uma lista de identificadores de constantes nomeados separados por v√≠rgulas.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
enum months  // enumera√ß√£o de constantes nomeados
   {
    January,
    February,
    March,
    April,
    May,
    June,
    July,
    August,
    September,
    October,
    November,
    December
   };
</code></pre>
<p>
Ap√≥s a enumera√ß√£o ser declarada, um novo tipo de dados de inteiro de 4 bytes aparece. A declara√ß√£o
do novo tipo de dados permite ao compilador controlar rigidamente os tipos de par√¢metros passados,
porque a enumera√ß√£o introduz novas constantes nomeadas. No exemplo acima, a constante nomeada
January tem valor igual a 0, February - 1, December - 11.
Rule: Se um certo valor n√£o estiver atribu√≠do a uma constante nomeada que √© membro da
enumera√ß√£o, seu novo valor ser√° formado automaticamente. Se ele √© o primeiro membro da
enumera√ß√£o, o valor 0 ser√° atribu√≠do a ele. Para todos os subseq√ºentes membros, os valores ser√£o
calculados baseados no valor dos membros anteriores adicionando um.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
enum intervals  // Enumera√ß√£o de constantes nomeadas
   {
    month=1,     // Intervalo de um m√™s
    two_months,  // Dois meses
    quarter,     // Tr√™s meses - trimestre
    halfyear=6,  // Semestre
    year=12,     // Ano - 12 meses
   };</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
96
<h3>Observa√ß√µes</h3>
¬∑ Diferente do C++, o tamanho da representa√ß√£o interna do tipo enumerado no MQL5 √© sempre igual a
4 bytes. Ou seja, sizeof(months) retorna o valor 4.
¬∑ Diferente do C++, uma enumera√ß√£o an√¥nima n√£o pode ser declarada no MQL5. Ou seja, um nome
√∫nico deve ser sempre especificado ap√≥s a palavra-chave enum.
<h3>Tamb√©m Veja</h3>
<h3>Convers√£o de Tipo (Typecasting)</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
97
<h3>Tipos Reais (double, float)</h3>
Tipos Reais (ou tipos de ponto flutuante) representam valores com um parte fracion√°ria. Na linguagem
MQL5 existem dois tipos para n√∫meros de ponto flutuante. O m√©todo de representa√ß√£o dos n√∫meros
reais na mem√≥ria do computador √© definido pelo padr√£o IEEE 754 e √© independente de plataformas,
sistemas operacionais ou linguagens de programa√ß√£o.
<h3>Tipo</h3>
<h3>Tamanho</h3>
em
bytes
<h3>Valor</h3>
<h3>Positivo</h3>
<h3>M√≠nimo</h3>
<h3>Valor M√°ximo</h3>
<h3>C++ An√°logo</h3>
float
4
1.175494351e-38
3.402823466e+3
8
float
double
8
2.225073858507
2014e-308
1.797693134862
3158e+308
double
double
Tipo de n√∫mero real double ocupa 64 bits (1 bit de sinal, 11 bits de expoente e 52 bits de mantissa). 
float
Tipo de n√∫mero real float ocupa 32 bits (1 bit de sinal, 8 bits de expoente e 23 bits de mantissa). 
vector
Array unidimensional de n√∫meros do tipo double. A mem√≥ria de dados √© alocada dinamicamente. As
propriedades vetoriais podem ser obtidas por m√©todos, e o tamanho do vetor pode ser alterado. Nas
fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o vector&lt;double&gt;. 
vectorf
Array unidimensional de n√∫meros do tipo float, pode ser usado em vez de vector, se a perda de
precis√£o n√£o for importante. Nas fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o vector&lt;float&gt;. 
vectorc
Array unidimensional de n√∫meros do tipo complex, √© projetado para trabalhar com n√∫meros
complexos. Nas fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o vector&lt;complex&gt;. No momento, as
opera√ß√µes sobre vetores do tipo vectorc ainda n√£o foram implementadas.
matrix
Uma matriz √© um array bidimensional de n√∫meros do tipo double. A mem√≥ria para os elementos da
matriz √© alocada de forma din√¢mica. As propriedades da matriz podem ser obtidas por m√©todos, e o
tamanho do vetor pode ser alterado. Nas fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o
matrix&lt;double&gt;. </p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
98
matrixf
Array de n√∫meros bidimensional do tipo float, pode ser usado no lugar de matrix, se a perda de
precis√£o n√£o for importante. Nas fun√ß√µes de modelo, √© poss√≠vel usar a nota√ß√£o matrix&lt;float&gt;. 
matrixc
Array de n√∫meros bidimensional do tipo complex, √© projetado para trabalhar com n√∫meros complexos.
Nas fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o matrix&lt;complex&gt;. No momento, as opera√ß√µes sobre
matrizes do tipo matrixc ainda n√£o foram implementadas.
O nome double significa que a precis√£o destes n√∫meros √© duas vezes a precis√£o dos n√∫meros do tipo
float. Na maioria dos casos, o tipo double √© o tipo mais conveniente. Em muitos casos a precis√£o
limitada de n√∫meros float n√£o √© suficiente. O motivo do tipo float ser ainda utilizado √© a economia de
mem√≥ria (isto √© importante para arrays grandes de n√∫meros reais).
Constantes de ponto flutuante consistem de um parte inteira, um ponto (.) e a parte fracion√°ria. As
partes inteira e fracion√°ria s√£o seq√º√™ncias de algarismos decimais.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
   double a=12.111;
   double b=-956.1007;
   float  c =0.0001;
   float  d =16;
</code></pre>
<p>
Existe uma forma cient√≠fica de escrever constantes reais, frequentemente este m√©todo de nota√ß√£o √©
mais compacta que a forma tradicional.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   double c1=1.12123515e-25;
   double c2=0.000000000000000000000000112123515; // 24 zeros ap√≥s o ponto decimal
   
   Print(&quot;1. c1 =&quot;,DoubleToString(c1,16));
   // Resultado: 1. c1 = 0.0000000000000000
   
   Print(&quot;2. c1 =&quot;,DoubleToString(c1,-16));
   // Resultado: 2. c1 = 1.1212351499999999e-025
   Print(&quot;3. c2 =&quot;,DoubleToString(c2,-16));
   // Resultado: 3. c2 = 1.1212351499999999e-025
</code></pre>
<p>
Deve-se lembrar que n√∫meros reais s√£o armazenados em mem√≥ria com precis√£o limitada no sistema
bin√°rio, apesar da nota√ß√£o decimal ser geralmente usada. √â por isso que muitos n√∫meros que s√£o
precisamente representados no sistema decimal s√≥ podem ser escritos como fra√ß√£o infinita no sistema
bin√°rio.
Por exemplo, os n√∫meros 0.3 e 0.7 s√£o representados no computador como fra√ß√µes infinitas, enquanto
o n√∫mero 0.25 √© armazenado de forma exata, porque ele representa uma pot√™ncia de dois.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
99
Neste sentido, recomenda-se fortemente n√£o comparar dois n√∫meros com igualdade, porque tal
compara√ß√£o n√£o √© correta.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   double three=3.0;
   double x,y,z;
   x=1/three;
   y=4/three;
   z=5/three;
   if(x+y==z) 
      Print(&quot;1/3 + 4/3 == 5/3&quot;);
   else 
      Print(&quot;1/3 + 4/3 != 5/3&quot;);
// Resultado: 1/3 + 4/3 != 5/3
</code></pre>
<p>
  }
Se voc√™ ainda precisa comparar com igualdade dois n√∫meros reais, ent√£o voc√™ pode fazer isso de duas
maneiras diferentes. A primeira maneira √© comparar a diferen√ßa entre dois n√∫meros com alguma
quantidade pequena que especifica a precis√£o da compara√ß√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
bool EqualDoubles(double d1,double d2,double epsilon)
  {
   if(epsilon&lt;0) 
      epsilon=-epsilon;
//---
   if(d1-d2&gt;epsilon) 
      return false;
   if(d1-d2&lt;-epsilon) 
      return false;
//---
   return true;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   double d_val=0.7;
   float  f_val=0.7;
   if(EqualDoubles(d_val,f_val,0.000000000000001)) 
      Print(d_val,&quot; equals &quot;,f_val);
   else 
      Print(&quot;Diferente: d_val = &quot;,DoubleToString(d_val,16),&quot;  f_val = &quot;,DoubleToString
// Resultado: Diferente: d_val= 0.7000000000000000   f_val= 0.6999999880790710
</code></pre>
<p>
  }
Note que o valor de epsilon no exemplo acima pode ser menor que a constante predefinida
DBL_EPSILON. O valor desta constante √© 2.2204460492503131e-016. A constante correspondente ao</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
100
tipo float √© FLT_EPSILON = 1.192092896e-07. O significado destes valores √© o seguinte: √© o menor
valor que satisfaz a condi√ß√£o¬†1.0 + DBL_EPSILON! = 1.0 (para n√∫meros do tipo float 1.0 +
FLT_EPSILON! = 1.0).
A segunda maneira compara a diferen√ßa normalizada de dois n√∫meros reais com zero. N√£o faz sentido
comparar a diferen√ßa de n√∫meros normalizados com zero, porque qualquer opera√ß√£o matem√°tica com
n√∫meros normalizados d√° um resultado n√£o normalizado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
bool CompareDoubles(double number1,double number2)
  {
   if(NormalizeDouble(number1-number2,8)==0) 
      return(true);
   else 
      return(false);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   double d_val=0.3;
   float  f_val=0.3;
   if(CompareDoubles(d_val,f_val)) 
      Print(d_val,&quot; iguais &quot;,f_val);
   else 
      Print(&quot;Diferente: d_val = &quot;,DoubleToString(d_val,16),&quot;  f_val = &quot;,DoubleToString
// Resultado: Diferente: d_val= 0.3000000000000000   f_val= 0.3000000119209290
</code></pre>
<p>
  }
Algumas opera√ß√µes do co-processador matem√°tico podem resultar em um n√∫mero real inv√°lido, o qual
n√£o pode ser usado em opera√ß√µes matem√°ticas e opera√ß√µes de compara√ß√£o, porque o resultado de
opera√ß√µes com n√∫meros reais inv√°lidos √© indefinido. Por exemplo, quando tentar calcular o arco-seno
de 2, o resultado √© infinito negativo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   double abnormal = MathArcsin(2.0);
   Print(&quot;MathArcsin(2.0) =&quot;,abnormal);
// Resulto:  MathArcsin(2.0) = -1.#IND
</code></pre>
<p>
Al√©m do menos infinito, existe o mais infinito e o NaN (not a number). Para determinar se um n√∫mero
√© inv√°lido, voc√™ pode usar MathIsValidNumber(). De acordo com o padr√£o IEEE, eles tem uma
representa√ß√£o de m√°quina especial. Por exemplo, mais infinito para o tipo double tem a representa√ß√£o
bin√°ria de 0x7FF0 0000 0000 0000.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
struct str1
  {
   double d;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
struct str2
  {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
101
</p>
<pre><code class="language-mql5">
   long l;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- Come√ßo
   str1 s1;
   str2 s2;
//---
   s1.d=MathArcsin(2.0);        // Obt√©m o n√∫mero inv√°lido -1.#IND
   s2=s1;
   printf(&quot;1.  %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0xFFFF000000000000;     // n√∫mero inv√°lido -1.#QNAN
   s1=s2;
   printf(&quot;2.  %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x7FF7000000000000;     // maior sem-n√∫mero SNaN
   s1=s2;
   printf(&quot;3.   %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x7FF8000000000000;     // menor sem-n√∫mero QNaN
   s1=s2;
   printf(&quot;4.   %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x7FFF000000000000;     // maior sem-n√∫mero QNaN
   s1=s2;
   printf(&quot;5.   %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x7FF0000000000000;     // // Infinito positivo 1.#INF e menor sem-n√∫mero SNaN
   s1=s2;
   printf(&quot;6.   %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0xFFF0000000000000;     // Infinito negativo -1.#INF
   s1=s2;
   printf(&quot;7.  %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x8000000000000000;     // Zero negativo -0.0
   s1=s2;
   printf(&quot;8.  %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x3FE0000000000000;     // 0.5
   s1=s2;
   printf(&quot;9.   %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x3FF0000000000000;     // 1.0
   s1=s2;
   printf(&quot;10.  %f %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x7FEFFFFFFFFFFFFF;     // Maior n√∫mero normalizado (MAX_DBL)
   s1=s2;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
102
</p>
<pre><code class="language-mql5">
   printf(&quot;11.  %.16e %I64X&quot;,s1.d,s2.l);
//---
   s2.l=0x0010000000000000;     // Menor normalizado positivo (MIN_DBL)
   s1=s2;
   printf(&quot;12.  %.16e %.16I64X&quot;,s1.d,s2.l);
//---
   s1.d=0.7;                    // Mostra que o n√∫mero 0.7 √© uma fra√ß√£o sem fim
   s2=s1;
   printf(&quot;13.  %.16e %.16I64X&quot;,s1.d,s2.l);
/*
</code></pre>
<p>
1.  -1.#IND00 FFF8000000000000
2.  -1.#QNAN0 FFFF000000000000
3.   1.#SNAN0 7FF7000000000000
4.   1.#QNAN0 7FF8000000000000
5.   1.#QNAN0 7FFF000000000000
6.   1.#INF00 7FF0000000000000
7.  -1.#INF00 FFF0000000000000
8.  -0.000000 8000000000000000
9.   0.500000 3FE0000000000000
10.  1.000000 3FF0000000000000
11.  1.7976931348623157e+308 7FEFFFFFFFFFFFFF
12.  2.2250738585072014e-308 0010000000000000
13.  6.9999999999999996e-001 3FE6666666666666 
*/
<h3>Tamb√©m Veja</h3>
DoubleToString, NormalizeDouble, Constantes de Tipos Num√©ricos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
103
<h3>N√∫meros complexos (complex)</h3>
O tipo complex embutido √© uma estrutura com dois campos double:
</p>
<pre><code class="language-mql5">
struct complex
  {
   double             real;   // parte real
   double             imag;   // parte imagin√°ria
</code></pre>
<p>
  };
O tipo &quot;complex&quot; pode ser passado por valor como um par√¢metro para fun√ß√µes MQL5 (ao contr√°rio de
estruturas comuns, que s√£o passadas apenas por refer√™ncia). Para fun√ß√µes importadas a partir de
DLLs, o tipo &quot;complex&quot; deve ser passado apenas por refer√™ncia.
O sufixo &#x27;i&#x27; √© usado para descrever constantes complexas:
complex square(complex c)
</p>
<pre><code class="language-mql5">
  {
   return(c*c);
</code></pre>
<p>
  }
 
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   Print(square(1+2i));  // como par√¢metro √© passada a constante
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
// ser√° exibido &quot;(-3,4)&quot;, que √© uma representa√ß√£o de string para um n√∫mero complexo
</code></pre>
<p>
Para n√∫meros complexos, atualmente est√£o dispon√≠veis apenas opera√ß√µes simples: =, +, -, *, /, +=, -
=, *=, /=, ==, !=.
No futuro, fun√ß√µes matem√°ticas adicionais ser√£o adicionadas: obten√ß√£o do valor absoluto, seno,
cosseno e muitos outros. 
vectorc
Array unidimensional de n√∫meros do tipo complex, √© projetado para trabalhar com n√∫meros
complexos. Nas fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o vector&lt;complex&gt;. No momento, as
opera√ß√µes sobre vetores do tipo vectorc ainda n√£o foram implementadas.
matrix
Uma matriz √© um array bidimensional de n√∫meros do tipo double. A mem√≥ria para os elementos da
matriz √© alocada de forma din√¢mica. As propriedades da matriz podem ser obtidas por m√©todos, e o
tamanho do vetor pode ser alterado. Nas fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o
matrix&lt;double&gt;. 
matrixf
Array de n√∫meros bidimensional do tipo float, pode ser usado no lugar de matrix, se a perda de
precis√£o n√£o for importante. Nas fun√ß√µes de modelo, √© poss√≠vel usar a nota√ß√£o matrix&lt;float&gt;. </p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
104
matrixc
Array de n√∫meros bidimensional do tipo complex, √© projetado para trabalhar com n√∫meros complexos.
Nas fun√ß√µes de modelo √© poss√≠vel usar a nota√ß√£o matrix&lt;complex&gt;. No momento, as opera√ß√µes sobre
matrizes do tipo matrixc ainda n√£o foram implementadas.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
105
<h3>Tipo string</h3>
O tipo string √© usado para armazenar cadeias de texto. Uma cadeia de texto √© uma seq√º√™ncia de
caracteres no formato Unicode com zero no final do mesmo. Uma constante string pode ser atribu√≠da a
uma vari√°vel string. Uma constante string √© uma seq√º√™ncia de caracteres entre aspas duplas: &quot;This is
a string constant&quot;.
Se for preciso incluir um aspas duplo (&quot;) em uma string, a barra invertida (\) deve ser colocada antes
dele. Quaisquer constantes de caractere especial podem ser escritos em uma string, se a barra
invertida (\) for digitada antes deles.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
string svar=&quot;Esta √© uma string&quot;;
string svar2=StringSubstr(svar,0,4);
</code></pre>
<p>
<h3>Print(&quot;S√≠mbolo de direitos autorais\t\x00A9&quot;);</h3>
FileWrite(handle,&quot;Esta string cont√©m uma nova linha de caracteres \n&quot;);
</p>
<pre><code class="language-mql5">
string MT5path=&quot;C:\\Program Files\\MetaTrader 5&quot;;
</code></pre>
<p>
Para tornar o c√≥digo fonte leg√≠vel, longas strings de constantes podem ser divididas em partes sem a
opera√ß√£o de adi√ß√£o. Durante a compila√ß√£o, estas partes ser√£o combinadas em uma string longa:
</p>
<pre><code class="language-mql5">
//--- Declara uma string constante longa
   string HTML_head=&quot;&lt;!DOCTYPE html PUBLIC \&quot;-//W3C//DTD XHTML 1.0 Transitional//EN\&quot;&quot;
                    &quot; \&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\&quot;&gt;\n&quot;
                    &quot;&lt;html xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\n&quot;
                    &quot;&lt;head&gt;\n&quot;
                    &quot;&lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=ut
                    &quot;&lt;title&gt;Trade Operations Report&lt;/title&gt;\n&quot;
                    &quot;&lt;/head&gt;&quot;;
//---Sa√≠da da string constante no log
   Print(HTML_head);
</code></pre>
<p>
  }
<h3>M√©todos incorporados do tipo string</h3>
Para manusear strings, voc√™ pode usar as fun√ß√µes de strings, as fun√ß√µes de convers√£o e os m√©todos
intr√≠nsecos do tipo string mostrados na tabela a seguir:
<h3>M√©todo string</h3>
<h3>An√°logo</h3>
<h3>Descri√ß√£o</h3>
<h3>Construtor string(const int len)</h3>
<h3>Constr√≥i uma string do comprimento</h3>
especificado
string[] tanto para leitura como para
escrita. O √≠ndice deve estar dentro
dos limites de BufferSize()
<h3>Fornece acesso ao elemento da</h3>
</p>
<pre><code class="language-mql5">
string pelo √≠ndice especificado</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
106
<h3>M√©todo string</h3>
<h3>An√°logo</h3>
<h3>Descri√ß√£o</h3>
static string string.Init(const int len,
const ushort character);
<h3>StringInit</h3>
<h3>Inicializa</h3>
uma 
</p>
<pre><code class="language-mql5">
string 
</code></pre>
<p>
com 
os
caracteres 
especificados 
e 
o
tamanho especificado
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
string.Fill(const 
ushort
character);
<h3>StringFill</h3>
<h3>Preenche</h3>
uma 
</p>
<pre><code class="language-mql5">
string 
</code></pre>
<p>
com 
o
caractere especificado
</p>
<pre><code class="language-mql5">
int string.Len();
</code></pre>
<p>
<h3>StringLen</h3>
<h3>Retorna o n√∫mero de caracteres na</h3>
string
</p>
<pre><code class="language-mql5">
int string.BufferSize();
</code></pre>
<p>
<h3>StringBufferLen</h3>
<h3>Retorna</h3>
o 
tamanho 
do 
buffer
alocado para a string
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
string.SetLen(const 
int
new_len);
<h3>StringSetLength</h3>
<h3>Define o comprimento especificado</h3>
em caracteres da string
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
string.Reserve(const 
int
buffer_len);
<h3>StringReserve</h3>
<h3>Reserva</h3>
o 
buffer 
do 
tamanho
especificado na mem√≥ria para a
</p>
<pre><code class="language-mql5">
string 
bool 
</code></pre>
<p>
string.Add(const 
string
substring);
<h3>StringAdd</h3>
<h3>Junta a substring especificada desde</h3>
o final
</p>
<pre><code class="language-mql5">
int string.Concatenate(const scalar
</code></pre>
<p>
val1, const scalar val2...);
<h3>StringConcatenate</h3>
<h3>Forma uma string a partir dos</h3>
par√¢metros passados
array 
string.Split(const 
ushort
separator, 
const 
bool
long_separator); 
<h3>StringSplit</h3>
<h3>Retorna uma matriz de strings pelo</h3>
separador dado
</p>
<pre><code class="language-mql5">
int string.Compare(const string str,
</code></pre>
<p>
const bool case_sensivity);
<h3>StringCompare</h3>
<h3>Compara com a string especificada e</h3>
retorna 1, caso a primeira string
seja maior que a segunda; 0, caso
as strings sejam iguais; -1 (menos
um), caso a primeira string seja
menor que a segunda
</p>
<pre><code class="language-mql5">
string 
</code></pre>
<p>
string.Substr(const 
int
start_pos, const int len);
<h3>StringSubstr</h3>
<h3>Extrai uma substring de uma posi√ß√£o</h3>
especificada
</p>
<pre><code class="language-mql5">
int string.Find(const string substr,
</code></pre>
<p>
const int pos); 
<h3>StringFind</h3>
<h3>Retorna o n√∫mero da posi√ß√£o em</h3>
que a substring come√ßa
</p>
<pre><code class="language-mql5">
void string.ToLower();
</code></pre>
<p>
<h3>StringToLower</h3>
<h3>Converte todos os caracteres em</h3>
min√∫sculas (pequenas)
</p>
<pre><code class="language-mql5">
void string.ToUpper();
</code></pre>
<p>
<h3>StringToUpper</h3>
<h3>Converte todos os caracteres em</h3>
mai√∫sculas (grandes)
</p>
<pre><code class="language-mql5">
int string.TrimLeft();
</code></pre>
<p>
<h3>StringTrimLeft</h3>
<h3>Elimina caracteres de retorno de</h3>
carro, 
espa√ßos 
e 
tabula√ß√µes 
√†
esquerda</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
107
<h3>M√©todo string</h3>
<h3>An√°logo</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
int string.TrimRight()
</code></pre>
<p>
<h3>StringTrimRight</h3>
<h3>Elimina caracteres de retorno de</h3>
carro, espa√ßos e tabula√ß√µes √† direita
</p>
<pre><code class="language-mql5">
void string.Double(const double var,
</code></pre>
<p>
const int digits=8); 
<h3>DoubleToString</h3>
<h3>Converte</h3>
uma 
</p>
<pre><code class="language-mql5">
string 
</code></pre>
<p>
para 
um
n√∫mero do tipo double
</p>
<pre><code class="language-mql5">
void string.Enum(const enum value);
</code></pre>
<p>
<h3>EnumToString</h3>
<h3>Converter um valor de enumera√ß√£o</h3>
de qualquer tipo em uma string
</p>
<pre><code class="language-mql5">
void string.Integer(const int value,
</code></pre>
<p>
const int str_len=0, const ushort
fill=&#x27; &#x27;);
<h3>IntegerToString</h3>
<h3>Converte</h3>
uma 
</p>
<pre><code class="language-mql5">
string 
</code></pre>
<p>
para 
um
n√∫mero do tipo long
</p>
<pre><code class="language-mql5">
void string.CharArray(const uchar
</code></pre>
<p>
array[], const int start_pos=0, const
</p>
<pre><code class="language-mql5">
int len=-1, const uint cp=CP_ACP); 
</code></pre>
<p>
<h3>CharArrayToString</h3>
<h3>Converte parte de uma matriz do</h3>
tipo uchar –≤ —Å—Ç—Ä–æ–∫—É
</p>
<pre><code class="language-mql5">
void string.ShortArray(const ushort
</code></pre>
<p>
array[], const int start_pos=0, const
</p>
<pre><code class="language-mql5">
int len=-1);
</code></pre>
<p>
<h3>ShortArrayToString</h3>
Copia parte de uma matriz do tipo
ushort –≤ —Å—Ç—Ä–æ–∫—É
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
string.Time(const 
datetime
dt,const 
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
mode=TIME_DATE|
<h3>TIME_MINUTES);</h3>
<h3>TimeToString</h3>
<h3>Convers√£o do valor datetime em</h3>
uma 
</p>
<pre><code class="language-mql5">
string 
</code></pre>
<p>
com 
formato
&quot;yyyy.mm.dd hh:mi&quot;.
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
string.Format(const 
string
format_str);
<h3>StringFormat</h3>
<h3>Formata os par√¢metros recebidos</h3>
em uma string
<h3>Veja tamb√©m</h3>
Fun√ß√µes de Convers√£o, Fun√ß√µes de String,  FileOpen, FileReadString, FileWriteString</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
108
<h3>Estruturas, Classes e Interfaces</h3>
<h3>Estruturas</h3>
Uma estrutura √© um conjunto de elementos de qualquer tipo (exceto o tipo void). Portanto, a estrutura
combina dados logicamente relacionados de diferentes tipos.
<h3>Declara√ß√£o da Estrutura</h3>
O tipo de dados estrutura √© determinado pela seguinte descri√ß√£o:
</p>
<pre><code class="language-mql5">
struct structure_name
  {
   elements_description
</code></pre>
<p>
  };
O nome da estrutura n√£o pode ser usado como um identificador (nome de uma vari√°vel ou fun√ß√£o).
Deve-se notar que em estruturas MQL5, os elementos seguem um ao outro diretamente, sem
alinhamento. Em C++ tal ordem √© feita pelo compilador usando a seguinte instru√ß√£o:
#pragma pack(1)
Se voc√™ quiser ter outro alinhamento na estrutura, use membros auxiliares, &quot;fillers&quot; (preenchedores)
para o tamanho certo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
struct trade_settings
  {
   uchar  slippage;     // valor do tamanho do slippage admiss√≠vel - 1 byte
   char   reserved1;    // pula 1 byte
   short  reserved2;    // pula 2 bytes
   int    reserved4;    // outros 4 bytes s√£o pulados. garantir um alinhamento de 8 by
   double take;         // valores do pre√ßo de fixa√ß√£o de lucro
   double stop;         // valor do pre√ßo de stop de prote√ß√£o
</code></pre>
<p>
  };
Tal descri√ß√£o de estruturas alinhadas √© necess√°rio somente para transfer√™ncia de dados para fun√ß√µes
de dll importadas.
Aten√ß√£o: Este exemplo ilustra dados incorretamente esquematizados. Seria melhor primeiro declarar o
take e stop de grandes volumes de dados do tipo double, e ent√£o declarar o membro slippage do tipo
uchar. Neste caso, a representa√ß√£o interna de dados ser√° sempre a mesma, independentemente do
valor especificado no #pragma pack().
Se a estrutura cont√©m vari√°veis do tipo string e/ou objeto de um array din√¢mico, o compilador atribui
um construtor impl√≠cito para tal estrutura. Este construtor redefine todos os membros de tipo string
da estrutura e corretamente inicializa objetos do array din√¢mico.
<h3>Estruturas Simples</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
109
As estruturas contendo cadeias de caracteres, objetos de classe, ponteiros e objetos de matrizes
din√¢micas s√£o chamadas de estruturas simples. As vari√°veis ‚Äãde estruturas simples e suas matrizes
podem ser transferidas ‚Äãcomo par√¢metros para as fun√ß√µes importadas a partir de DLL.
Copiar e colar estruturas simples √© permitido apenas em dois casos:
¬∑ se os objetos pertencem ao mesmo tipo de estrutura
¬∑ se os objetos s√£o ligados por uma linha heran√ßa, isto √©, uma estrutura √© um descendente de uma
outra estrutura.
Mostraremos isso com ajuda de exemplos, criamos uma estrutura personalizada CustomMqlTick
id√™ntica em composi√ß√£o √† estrutura constru√≠da MqlTick. O compilador n√£o permitir√° tentativas de
copiar e colar os valores do objeto MqlTick no objeto de tipo CustomMqlTick. A convers√£o direta para
o tipo desejado tamb√©m causar√° um erro de compila√ß√£o:
</p>
<pre><code class="language-mql5">
      //--- copiar estruturas simples de diferentes tipos √© restrito
      my_tick1=last_tick;               // aqui o compilador gerar√° um erro
     
      //--- combinar estruturas de diferente tipo tamb√©m √© restrito
      my_tick1=(CustomMqlTick)last_tick;// aqui o compilador gerar√° um erro
</code></pre>
<p>
Portanto, resta s√≥ uma op√ß√£o, isto √©, copiar e colar os valores dos membros da estrutura elemento por
elemento. Mas, ao fazer isto, √© permitido copiar e colar os valores dos objetos do mesmo
tipo¬†CustomMqlTick.
</p>
<pre><code class="language-mql5">
      CustomMqlTick my_tick1,my_tick2;
      //--- tamb√©m √© poss√≠vel copiar e colar objetos da mesma estrutura CustomMqlTick
      my_tick2=my_tick1;
     
      //--- criamos uma matriz a partir de objetos da estrutura simples CustomMqlTick 
      CustomMqlTick arr[2];
      arr[0]=my_tick1;
      arr[1]=my_tick2;
</code></pre>
<p>
Como um teste √© chamada a fun√ß√£o ArrayPrint() para exibir os valores da matriz arr[], no di√°rio.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- criamos a mesma estrutura como a constru√≠da por MqlTick
   struct CustomMqlTick
     {
      datetime          time;          // Tempo da √∫ltima atualiza√ß√£o dos pre√ßos
      double            bid;           // Pre√ßo atual Bid
      double            ask;           // Pre√ßo atual Ask
      double            last;          // Pre√ßo atual da √∫ltima transa√ß√£o (Last)
      ulong             volume;        // Volume para o pre√ßo atual Last
      long              time_msc;      // Hora da √∫ltima atualiza√ß√£o dos pre√ßos em mil
      uint              flags;         // Sinalizadores de ticks     
     };</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
110
</p>
<pre><code class="language-mql5">
   //--- obtemos os valores do √∫ltimo ticks
   MqlTick last_tick;
   CustomMqlTick my_tick1,my_tick2;
//--- tentamos colar e copiar os dados a partir do MqlTick no CustomMqlTick
   if(SymbolInfoTick(Symbol(),last_tick))
     {
      //--- copiar e colar estruturas simples n√£o aparentadas √© restrito
      //1. my_tick1=last_tick;               // aqui o compilador gerar√° um erro
     
      //--- combinar estruturas n√£o aparentadas tamb√©m √© restrito
      //2. my_tick1=(CustomMqlTick)last_tick;// aqui o compilador gerar√° um erro
     
      //--- por isso copiamos e colamos os membros da estrutura elemento por elemento 
      my_tick1.time=last_tick.time;
      my_tick1.bid=last_tick.bid;
      my_tick1.ask=last_tick.ask;
      my_tick1.volume=last_tick.volume;
      my_tick1.time_msc=last_tick.time_msc;
      my_tick1.flags=last_tick.flags;
     
      //--- tamb√©m √© poss√≠vel copiar e colar objetos da mesma estrutura CustomMqlTick
      my_tick2=my_tick1;
     
      //--- criamos uma matriz a partir de objetos da estrutura simples CustomMqlTick 
      CustomMqlTick arr[2];
      arr[0]=my_tick1;
      arr[1]=my_tick2;
      ArrayPrint(arr);
//--- exemplo de exibi√ß√£o de valores de matriz contendo objetos do tipo CustomMqlTick
      /*
                       [time]   [bid]   [ask]   [last] [volume]    [time_msc] [flags]
      [0] 2017.05.29 15:04:37 1.11854 1.11863 +0.00000  1450000 1496070277157       2
      [1] 2017.05.29 15:04:37 1.11854 1.11863 +0.00000  1450000 1496070277157       2 
      */
     }
   else
      Print(&quot;SymbolInfoTick() failed, error = &quot;,GetLastError());
</code></pre>
<p>
  }
O segundo exemplo mostra a possibilidade de copiar e colar estruturas simples segundo linha de
heran√ßa. Assumamos que temos uma estrutura b√°sica Animal, da qual s√£o geradas - para heran√ßa - as
estruturas Cat e Dog. N√≥s podemos copiar e colar entre si mesmos os objetos Animal e Cat (ou Animal
e Dog), no entanto n√£o podemos copiar e colar entre sim mesmos Cat e Dog, embora ambos sejam
descendentes da estrutura Animal.
</p>
<pre><code class="language-mql5">
//--- estrutura para descrever c√£es
struct Dog: Animal
  {
   bool              hunting;       // ra√ßa de ca√ßa</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
111
  };
</p>
<pre><code class="language-mql5">
//--- estrutura para descri√ß√£o de gatos
struct Cat: Animal
  {
   bool              home;          // ra√ßa domestica
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- criamos os objetos das subclasses
   Dog dog;
   Cat cat;
//--- √© poss√≠vel copiar no ancestral e colar no descendente (Animal ==&gt; Dog)
   dog=some_animal;
   dog.swim=true;    // c√£es sabem nadar
//--- √© imposs√≠vel copiar e colar objetos de subestruturas (Dog != Cat)
   cat=dog;        // aqui o compilador gerar√° um erro
</code></pre>
<p>
<h3>C√≥digo completo de exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- estrutura b√°sica para descrever animais
struct Animal
  {
   int               head;          // n√∫mero de cabe√ßas
   int               legs;          // n√∫mero de patas
   int               wings;         // n√∫mero de assas
   bool              tail;          // presen√ßa de cauda
   bool              fly;           // voa
   bool              swim;          // nada
   bool              run;           // corre
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- estrutura para descrever c√£es
struct Dog: Animal
  {
   bool              hunting;       // ra√ßa de ca√ßa
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- estrutura para descri√ß√£o de gatos
struct Cat: Animal
  {
   bool              home;          // ra√ßa domestica
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- criamos um objeto do tipo b√°sico Animal e descrevemo-lo
   Animal some_animal;
   some_animal.head=1;
   some_animal.legs=4;
   some_animal.wings=0;
   some_animal.tail=true;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
112
</p>
<pre><code class="language-mql5">
   some_animal.fly=false;
   some_animal.swim=false;
   some_animal.run=true;
//--- criamos os objetos dos subtipos
   Dog dog;
   Cat cat;
//--- √© poss√≠vel copiar no ancestral e colar no descendente (Animal ==&gt; Dog)
   dog=some_animal;
   dog.swim=true;    // c√£es sabem nadar
//--- √© imposs√≠vel copiar e colar objetos de subestruturas (Dog != Cat)
   //cat=dog;        // aqui o compilador gerar√° um erro
//--- por isso √© poss√≠vel copiar e colar apenas elemento por elemento
   cat.head=dog.head;
   cat.legs=dog.legs;
   cat.wings=dog.wings;
   cat.tail=dog.tail;
   cat.fly=dog.fly;
   cat.swim=false;   // gatos n√£o sabem nadar
//--- √© poss√≠vel copiar valores no descendente e col√°-los no ancestral
   Animal elephant;
   elephant=cat;
   elephant.run=false;// elefantes n√£o sabem correr
   elephant.swim=true;// elefantes nadam
//--- criamos uma matriz
   Animal animals[4];
   animals[0]=some_animal;
   animals[1]=dog;  
   animals[2]=cat;
   animals[3]=elephant;
//--- imprimimos
   ArrayPrint(animals);
//--- resultado da execu√ß√£o
/*
       [head] [legs] [wings] [tail] [fly] [swim] [run]
   [0]      1      4       0   true false  false  true
   [1]      1      4       0   true false   true  true
   [2]      1      4       0   true false  false false
   [3]      1      4       0   true false   true false
</code></pre>
<p>
*/  
  }
Outro m√©todo para copiar e colar tipos simples consiste em utilizar associa√ß√µes, para fazer isto, os
objetos destas estruturas devem ser membros da mesma associa√ß√£o ‚Äì veja o exemplo em union. 
<h3>Acesso a Membros de Estrutura</h3>
A estrutura √© um novo tipo de dados permitindo declarar vari√°veis deste tipo. A estrutura pode ser
declarado somente um vez dentro de um projeto. Os membros de estrutura s√£o acessados usando a
opera√ß√£o ponto (.).</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
113
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
struct trade_settings
  {
   double take;         // valor do pre√ßo de fixa√ß√£o do lucro
   double stop;         // valor do pre√ßo stop de prote√ß√£o
   uchar  slippage;     // valor do slippage admiss√≠vel
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- cria e inicializa uma vari√°vel do tipo trade_settings
</code></pre>
<p>
trade_settings my_set={0.0,0.0,5};  
</p>
<pre><code class="language-mql5">
if (input_TP&gt;0) my_set.take=input_TP;
</code></pre>
<p>
pack para alinhamento de campos de estruturas e classes
O atributo especial pack permite definir o alinhamento dos campos de estrutura ou classe.
 pack([n])
onde n  √© um dos seguintes valores 1,2,4,8 ou 16. Pode estar ausente.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   struct pack(sizeof(long)) MyStruct
     {
      // membros da estrutura ser√£o alinhados a 8 bytes
     };
</code></pre>
<p>
ou
</p>
<pre><code class="language-mql5">
   struct MyStruct pack(sizeof(long))
     {
      // membros da estrutura ser√£o alinhados a 8 bytes
     };
</code></pre>
<p>
Por padr√£o, pack(1) √© usado para estruturas. Isso significa que na mem√≥ria os membros da estrutura
est√£o localizados um ap√≥s o outro e o tamanho da estrutura √© igual √† soma dos tamanhos de seus
membros.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- estrutura simples sem alinhamento
   struct Simple_Structure
     {
      char              c; // sizeof(char)=1
      short             s; // sizeof(short)=2
      int               i; // sizeof(int)=4
      double            d; // sizeof(double)=8
     };
   //--- declaramos uma inst√¢ncia de uma estrutura simples   </p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
114
</p>
<pre><code class="language-mql5">
   Simple_Structure s;  
//--- exibimos o tamanho de cada membro da estrutura  
   Print(&quot;sizeof(s.c)=&quot;,sizeof(s.c));
   Print(&quot;sizeof(s.s)=&quot;,sizeof(s.s));
   Print(&quot;sizeof(s.i)=&quot;,sizeof(s.i));
   Print(&quot;sizeof(s.d)=&quot;,sizeof(s.d));
//--- verificamos de que o tamanho da estrutura POD √© igual √† soma dos tamanhos de seu
   Print(&quot;sizeof(simple_structure)=&quot;,sizeof(simple_structure));
/*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   sizeof(s.c)=1
   sizeof(s.s)=2
   sizeof(s.i)=4
   sizeof(s.d)=8
   sizeof(simple_structure)=15 
</code></pre>
<p>
*/    
  }
O alinhamento dos campos da estrutura pode ser necess√°rio ao trocar dados com bibliotecas de
terceiros (*.DLL), nas quais √© aplicado tal alinhamento.
Vamos exemplificar como funciona o alinhamento. Peguemos a estrutura de quatro membros sem
alinhamento.
</p>
<pre><code class="language-mql5">
//--- estrutura simples sem alinhamento
   struct Simple_Structure pack() // tamanho n√£o especificado, ele ser√° alinhado a 1 b
     {
      char              c; // sizeof(char)=1
      short             s; // sizeof(short)=2
      int               i; // sizeof(int)=4
      double            d; // sizeof(double)=8
     };
//--- declaramos uma inst√¢ncia de uma estrutura simples  
   Simple_Structure s;
</code></pre>
<p>
Os campos da estrutura ser√£o localizados na mem√≥ria um ap√≥s o outro, de acordo com a ordem de
declara√ß√£o e o tamanho do tipo. Tamanho da estrutura igual 15, nos arrays ser√° indefinido o
deslocamento para os campos da estrutura.
Agora declaramos a mesma estrutura com um alinhamento de 4 bytes e executamos o c√≥digo.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
115
</p>
<pre><code class="language-mql5">
//--- estrutura simples com alinhamento de 4 bytes
   struct Simple_Structure pack(4)
     {
      char              c; // sizeof(char)=1
      short             s; // sizeof(short)=2
      int               i; // sizeof(int)=4
      double            d; // sizeof(double)=8
     };
   //--- declaramos uma inst√¢ncia de uma estrutura simples   
   Simple_Structure s;  
//--- exibimos o tamanho de cada membro da estrutura  
   Print(&quot;sizeof(s.c)=&quot;,sizeof(s.c));
   Print(&quot;sizeof(s.s)=&quot;,sizeof(s.s));
   Print(&quot;sizeof(s.i)=&quot;,sizeof(s.i));
   Print(&quot;sizeof(s.d)=&quot;,sizeof(s.d));
//--- verificamos de que o tamanho da estrutura POD agora n√£o seja igual √† soma dos ta
   Print(&quot;sizeof(simple_structure)=&quot;,sizeof(simple_structure));
/*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   sizeof(s.c)=1
   sizeof(s.s)=2
   sizeof(s.i)=4
   sizeof(s.d)=8
   sizeof(simple_structure)=16 // tamanho da estrutura alterado
</code></pre>
<p>
*/    
  }
O tamanho da estrutura foi alterado para que todos os membros de 4 bytes ou mais tivessem um
deslocamento m√∫ltiplo de 4 bytes a partir do in√≠cio da estrutura. Membros menores ser√£o alinhados ao
seu pr√≥prio tamanho (por exemplo, 2 para short). Veja que o byte adicionado √© mostrado em cinza.
Neste caso, ap√≥s o membro s.c √© adicionado 1 byte, para que o campo s.s (sizeof(short)==2) tenha um
limite de 2 byte (alinhamento para o tipo short). 
O deslocamento para o in√≠cio da estrutura no array tamb√©m ser√° alinhado a 4 bytes, ou seja, para
Simple_Structure arr[], os endere√ßos dos elementos a[0], a[1], a[n] ser√£o m√∫ltiplos de 4 bytes.
Consideremos mais duas estruturas que consistem no mesmo tipo com alinhamento a 4 bytes, mas
cuja ordem de membros √© diferente. Na primeira estrutura, os membros s√£o organizados em ordem
ascendente segundo o tamanho do tipo.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
116
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- estrutura simples com alinhamento a 4 bytes
   struct CharShortInt pack(4)
     {
      char              c; // sizeof(char)=1
      short             s; // sizeof(short)=2
      int               i; // sizeof(double)=4
     };
//--- declaramos uma inst√¢ncia de uma estrutura simples  
   CharShortInt ch_sh_in;
//--- exibimos o tamanho de cada membro da estrutura  
   Print(&quot;sizeof(ch_sh_in.c)=&quot;,sizeof(ch_sh_in.c));
   Print(&quot;sizeof(ch_sh_in.s)=&quot;,sizeof(ch_sh_in.s));
   Print(&quot;sizeof(ch_sh_in.i)=&quot;,sizeof(ch_sh_in.i));
//--- verificamos de que o tamanho da estrutura POD √© igual √† soma dos tamanhos de seu
   Print(&quot;sizeof(CharShortInt)=&quot;,sizeof(CharShortInt));
/*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   sizeof(ch_sh_in.c)=1
   sizeof(ch_sh_in.s)=2
   sizeof(ch_sh_in.i)=4
   sizeof(CharShortInt)=8
</code></pre>
<p>
*/   
  }
Como se pode ver, o tamanho da estrutura √© 8 e consiste em dois blocos de 4 bytes cada. No primeiro
bloco, s√£o colocados os campos com tipos char e short, no segundo - o campo com tipo int.
Agora, a partir da primeira estrutura, vamos fazer a segunda, que difere apenas na ordem dos
campos: reorganizamos o tipo de membro short no final.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- estrutura simples com alinhamento a 4 bytes
   struct CharIntShort pack(4)
     {
      char              c; // sizeof(char)=1
      int               i; // sizeof(double)=4
      short             s; // sizeof(short)=2
     };
//--- declaramos uma inst√¢ncia de uma estrutura simples  </p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
117
</p>
<pre><code class="language-mql5">
   CharIntShort ch_in_sh;
//--- exibimos o tamanho de cada membro da estrutura  
   Print(&quot;sizeof(ch_in_sh.c)=&quot;,sizeof(ch_in_sh.c));
   Print(&quot;sizeof(ch_in_sh.i)=&quot;,sizeof(ch_in_sh.i));
   Print(&quot;sizeof(ch_in_sh.s)=&quot;,sizeof(ch_in_sh.s));
//--- verificamos de que o tamanho da estrutura POD √© igual √† soma dos tamanhos de seu
   Print(&quot;sizeof(CharIntShort)=&quot;,sizeof(CharIntShort));
/*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   sizeof(ch_in_sh.c)=1
   sizeof(ch_in_sh.i)=4
   sizeof(ch_in_sh.s)=2
   sizeof(CharIntShort)=12
</code></pre>
<p>
*/   
  }
Embora a estrutura em si n√£o tenha mudado, a altera√ß√£o na ordem dos membros levou a um aumento
no tamanho da pr√≥pria estrutura.
Durante a heran√ßa, tamb√©m √© preciso levar em conta o alinhamento. Exemplificamos uma estrutura
Parent simples, que possui apenas um membro do tipo char. O tamanho dessa estrutura sem
alinhamento √© 1.
</p>
<pre><code class="language-mql5">
   struct Parent
     {
      char              c;    // sizeof(char)=1
     };
</code></pre>
<p>
Crie uma classe filha Children com adi√ß√£o de um membro do tipo short (sizeof(short)=2).
</p>
<pre><code class="language-mql5">
   struct Children pack(2) : Parent
     {
      short             s;   // sizeof(short)=2
     };
</code></pre>
<p>
Como resultado, ao definir o alinhamento como 2 bytes, o tamanho da estrutura ser√° 4, embora o
tamanho dos pr√≥prios membros seja 3. J√° que sob a classe pai, para Parent ser√£o alocados 2 bytes, de
forma que o acesso ao campo short da classe filha seja alinhado a 2 bytes.
O conhecimento de como a mem√≥ria √© alocada para membros de uma estrutura √© necess√°rio se o
programa MQL5 interage com dados de terceiros escrevendo/lendo no n√≠vel do arquivo ou da thread.
A Biblioteca padr√£o cont√©m fun√ß√µes para trabalhar com fun√ß√µes WinAPI, no 
cat√°logo
MQL5\Include\WinAPI. Estas fun√ß√µes usam estruturas com um determinado alinhamento para os casos
em que s√£o necess√°rias para trabalhar com WinAPI.  
offsetof √© um comando especial que est√° diretamente relacionado ao atributo pack. Ele permite obter
o deslocamento do membro a partir do in√≠cio da estrutura.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
118
</p>
<pre><code class="language-mql5">
//--- declaramos uma vari√°vel do tipo Children
   Children child;  
//--- encontramos o deslocamento a partir do in√≠cio da estrutura
   Print(&quot;offsetof(Children,c)=&quot;,offsetof(Children,c));
   Print(&quot;offsetof(Children,s)=&quot;,offsetof(Children,s));  
/*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   offsetof(Children,c)=0
</code></pre>
<p>
¬† offsetof(child.s)=2
*/   
<h3>Especificador final</h3>
A presen√ßa do especificador final, ao declarar a estrutura, pro√≠be a heran√ßa a partir dela. Se a
estrutura n√£o precisar de altera√ß√µes futuras ou se essas altera√ß√µes n√£o se puderem levar a cabo por
causa de quest√µes de seguran√ßa, declare-a usando o especificador final. Al√©m disso, todos os
membros da estrutura tamb√©m ser√£o implicitamente considerados como final.
</p>
<pre><code class="language-mql5">
struct settings final
  {
  //--- corpo da estrutura
</code></pre>
<p>
  };
 
</p>
<pre><code class="language-mql5">
struct trade_settings : public settings
  {
  //--- corpo da estrutura
</code></pre>
<p>
  };
Como no exemplo acima, ao tentar herdar a partir da estrutura, usando o modificador final, o
compilador ir√° emitir um erro:
cannot inherit from &#x27;settings&#x27; as it has been declared as &#x27;final&#x27;
see declaration of &#x27;settings&#x27;
<h3>Classes</h3>
As classes diferem das estruturas no seguinte:
¬∑ a palavra-chave class √© usado na declara√ß√£o;
¬∑ por default (padr√£o), todos os membros da classe t√™m especificador de acesso private, a menos que
seja indicado o contr√°rio. Dados-membros da estrutura t√™m o tipo default de acesso como public, a
menos que seja indicado o contr√°rio;
¬∑ objetos de classe sempre tem uma tabela de fun√ß√µes virtuais, mesmo que n√£o existam fun√ß√µes
virtuais declaradas na classe. Estruturas n√£o podem ter fun√ß√µes virtuais;
¬∑ o operador new pode ser aplicado a objetos de classe; o operador this n√£o pode ser aplicado a
estruturas;
¬∑ classes pode ser herdados somente de classes, estruturas pode ser herdados somente de estruturas.
Classes e estruturas podem ter um construtor e destrutor expl√≠citos. Se seu construtor for definido
explicitamente, a inicializa√ß√£o de uma vari√°vel de estrutura ou classe usando a seq√º√™ncia de
inicializa√ß√£o √© imposs√≠vel.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
119
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
struct trade_settings
  {
   double take;         // valor do pre√ßo de fixa√ß√£o do lucro
   double stop;         // valor do pre√ßo stop de prote√ß√£o
   uchar  slippage;     // valor do slippage admiss√≠vel
   //--- Construtor
          trade_settings() { take=0.0; stop=0.0; slippage=5; }
   //--- Destrutor
         ~trade_settings() { Print(&quot;Este √© o final&quot;); } 
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- Compilador gerar√° uma mensagem de erro de que a inicializa√ß√£o √© imposs√≠vel
</code></pre>
<p>
trade_settings my_set={0.0,0.0,5};  
<h3>Construtores e Destrutores</h3>
Um construtor √© uma fun√ß√£o especial, que √© chamada automaticamente ao se criar um objeto de uma
estrutura ou classe e normalmente √© usado para inicializar membros da classe. Mais adiante,
falaremos sobre classes, tudo que for dito se aplica tamb√©m a estruturas, a menos que seja indicado o
contr√°rio. O nome de um construtor deve corresponder ao nome da classe. O construtor n√£o tem tipo
de retorno (voc√™ pode especificar o tipo void).
Membros de classe definidos ‚Äì strings, arrays din√¢micos e objetos que exigem inicializa√ß√£o ‚Äì ser√£o
inicializados em qualquer caso,independentemente de haver ou n√£o um construtor.
Cada classe pode ter m√∫ltiplos construtores, diferindo pelo n√∫mero de par√¢metros e a lista de
inicializa√ß√£o. Um construtor que exige especifica√ß√£o de par√¢metros √© chamado um construtor
param√©trico.
Um construtor sem par√¢metros √© chamado um construtor default. Se nenhum construtor for
declarado em uma classe, o compilador cria um construtor default durante a compila√ß√£o.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma classe para trabalhar com uma data¬†                          |
//+------------------------------------------------------------------+
class MyDateClass
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   int               m_year;          // Ano
   int               m_month;         // M√™s
   int               m_day;           // Dia do m√™s
   int               m_hour;          // Hora no dia
   int               m_minute;        // Minutos
   int               m_second;        // Segundos
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Construtor default
                     MyDateClass(void);
   //--- Construtor param√©trico
                     MyDateClass(int h,int m,int s);
</code></pre>
<p>
  };</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
120
Um construtor pode ser declarado na descri√ß√£o da classe e ent√£o seu corpo pode ser definido. Por
exemplo, dois construtores de MyDateClasse podem ser definidos da seguinte maneira:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Construtor default¬†                                              |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>MyDateClass::MyDateClass(void)</h3>
</p>
<pre><code class="language-mql5">
  {
//---
   MqlDateTime mdt;
   datetime t=TimeCurrent(mdt);
   m_year=mdt.year;
   m_month=mdt.mon;
   m_day=mdt.day;
   m_hour=mdt.hour;
   m_minute=mdt.min;
   m_second=mdt.sec;
   Print(__FUNCTION__);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Construtor param√©trico¬†                                          |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>MyDateClass::MyDateClass(int h,int m,int s)</h3>
</p>
<pre><code class="language-mql5">
  {
   MqlDateTime mdt;
   datetime t=TimeCurrent(mdt);
   m_year=mdt.year;
   m_month=mdt.mon;
   m_day=mdt.day;
   m_hour=h;
   m_minute=m;
   m_second=s;
   Print(__FUNCTION__);
</code></pre>
<p>
  }
No construtor default, todos os membros da classes s√£o preenchidos usando a fun√ß√£o TimeCurrent(),
no construtor param√©trico somente os valores de hora s√£o preenchidos. Outros membros da classe
(m_year, m_month and m_day) ser√£o inicializados automaticamente com a data corrente.
O construtor default tem um prop√≥sito especial ao inicializar um array de objetos de sua classe. Um
construtor, o qual todos o par√¢metros t√™m valores default, n√£o √© um construtor default. Aqui est√° um
exemplo:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma classe com um construtor default¬†                            |
//+------------------------------------------------------------------+
class CFoo
  {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
121
</p>
<pre><code class="language-mql5">
   datetime          m_call_time;     // Hora da √∫ltima chamada ao objeto
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Um construtor com um par√¢metro que tem um valor default n√£o √© um construtor d
                     CFoo(const datetime t=0){m_call_time=t;};
   //--- Um construtor copiador
                     CFoo(const CFoo &amp;foo){m_call_time=foo.m_call_time;};
   string ToString(){return(TimeToString(m_call_time,TIME_DATE|TIME_SECONDS));};
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
// CFoo foo; // Esta varia√ß√£o n√£o pode ser utilizada - um construtor default n√£o foi d
//--- Poss√≠veis op√ß√µes para criar o objeto CFoo
   CFoo foo1(TimeCurrent());     // Uma explicita chamada de um construtor param√©trico
   CFoo foo2();                  // Uma expl√≠cita chamada de um construtor param√©trico
   CFoo foo3=D&#x27;2009.09.09&#x27;;      // Uma impl√≠cita chamada de um construtor param√©trico
   CFoo foo40(foo1);             // Uma explicita chamada de um construtor copiador
   CFoo foo41=foo1;              // Uma impl√≠cita chamada de um construtor copiador
   CFoo foo5;                    // Uma expl√≠cita chamada de um construtor default (se
                                 // ent√£o um construtor param√©trico com um valor defau
//--- Poss√≠veis op√ß√µes para criar o objeto CFoo
   CFoo *pfoo6=new CFoo();       // Cria√ß√£o din√¢mica de um objeto e recep√ß√£o de um pon
   CFoo *pfoo7=new CFoo(TimeCurrent());// Outra op√ß√µes de cria√ß√£o din√¢mica de objeto
   CFoo *pfoo8=GetPointer(foo1); // Agora pfoo8 aponta para o objeto foo1
   CFoo *pfoo9=pfoo7;            // pfoo9 e pfoo7 apontam para o mesmo objeto
   // CFoo foo_array[3];         // Esta op√ß√£o n√£o pode ser usado - um construtor defa
//--- Mostra os valores de m_call_time
   Print(&quot;foo1.m_call_time=&quot;,foo1.ToString());
   Print(&quot;foo2.m_call_time=&quot;,foo2.ToString());
   Print(&quot;foo3.m_call_time=&quot;,foo3.ToString());
   Print(&quot;foo4.m_call_time=&quot;,foo4.ToString());
   Print(&quot;foo5.m_call_time=&quot;,foo5.ToString());
   Print(&quot;pfoo6.m_call_time=&quot;,pfoo6.ToString());
   Print(&quot;pfoo7.m_call_time=&quot;,pfoo7.ToString());
   Print(&quot;pfoo8.m_call_time=&quot;,pfoo8.ToString());
   Print(&quot;pfoo9.m_call_time=&quot;,pfoo9.ToString());
//--- Exclui dinamicamente arrays criados
   delete pfoo6;
   delete pfoo7;
   //delete pfoo8;  // Voc√™ n√£o precisa excluir pfoo8 explicitamente, j√° que ele apont
   //delete pfoo9;  // Voc√™ n√£o precisa excluir pfoo9 explicitamente, j√° que ele apont
</code></pre>
<p>
  }
<h3>Se voc√™ descomentar estas strings</h3>
</p>
<pre><code class="language-mql5">
¬† //CFoo foo_array[3];     // Esta variante n√£o pode ser usada - um construtor default</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
122
ou
</p>
<pre><code class="language-mql5">
¬† //CFoo foo_dyn_array[];  // Esta variante n√£o pode ser usada - um construtor default
</code></pre>
<p>
ent√£o o compilar retorn√° um erro para eles &quot;default constructor is not defined&quot; (construtor default n√£o
definido).
Se uma classe tiver um construtor definido pelo usu√°rio, o construtor padr√£o n√£o √© gerado pelo
compilador. Isso significa que se um construtor param√©trico √© declarado em uma classe, mas um
construtor default n√£o √© declarado, voc√™ n√£o pode declarar arrays de objetos desta classe. O
compilador retorn√° um erro para este script:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma classe sem um construtor default¬†                            |
//+------------------------------------------------------------------+
class CFoo
  {
   string            m_name;
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CFoo(string name) { m_name=name;}
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Obt√©m o erro &quot;default constructor is not defined&quot; durante compila√ß√£o
   CFoo badFoo[5];
</code></pre>
<p>
  }
Neste exemplo, a classe CFoo tem um construtor param√©trico declarado - em tais casos, o compilador
n√£o cria um construtor default automaticamente durante compila√ß√£o. Ao mesmo tempo quando voc√™
declara um array de objetos, presume-se que todos os objetos devam se criados e inicializados
automaticamente. Durante a auto-inicializa√ß√£o de um objeto, √© necess√°rio chamar um construtor
default, mas j√° que o construtor default n√£o foi explicitamente declarado e nem automaticamente
gerado pelo compilador, √© imposs√≠vel criar tal objeto. Por esta raz√£o, o compilador gerou um error na
etapa de compila√ß√£o.
Existe uma sintaxe especial para inicializar um objeto usando um construtor. Inicializadores de
membros de uma estrutura ou classe (constru√ß√µes especiais para inicializa√ß√£o) podem ser
especificados na lista de inicializa√ß√£o.
Uma lista de inicializa√ß√£o √© uma lista de inicializadores separados por v√≠rgulas, que seguem depois do
dois pontos (:), depois da lista de par√¢metros de um construtor e precede o corpo (antes da abertura
de chave). H√° v√°rios requisitos:
¬∑ Listas de inicializa√ß√£o podem ser usados somente em construtores;
¬∑ Membros paternos n√£o podem ser inicializados na lista de inicializa√ß√£o;
¬∑ A lista de inicializa√ß√£o deve ser seguida por uma defini√ß√£o (implementa√ß√£o) de uma fun√ß√£o.
Aqui est√° um exemplo de v√°rios construtores para inicializa√ß√µes de membros de uma classe.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
123
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma classe para armazenar o nome de um caractere¬†                |
//+------------------------------------------------------------------+
class CPerson
  {
   string            m_first_name;     // Primeiro nome
   string            m_second_name;    // Segundo nome
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Um construtor default vazio
                     CPerson() {Print(__FUNCTION__);};
   //--- Um construtor param√©trico
                     CPerson(string full_name);
   //--- Um construtor com uma lista de inicializa√ß√£o
                     CPerson(string surname,string name): m_second_name(surname), m_fi
   void PrintName(){PrintFormat(&quot;Name=%s Surname=%s&quot;,m_first_name,m_second_name);};
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CPerson::CPerson(string full_name)</h3>
</p>
<pre><code class="language-mql5">
  {
   int pos=StringFind(full_name,&quot; &quot;);
   if(pos&gt;=0)
     {
      m_first_name=StringSubstr(full_name,0,pos);
      m_second_name=StringSubstr(full_name,pos+1);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Obt√©m o erro &quot;default constructor is not defined&quot;
   CPerson people[5];
   CPerson Tom=&quot;Tom Sawyer&quot;;                       // Tom Sawyer
   CPerson Huck(&quot;Huckleberry&quot;,&quot;Finn&quot;);             // Huckleberry Finn
   CPerson *Pooh = new CPerson(&quot;Winnie&quot;,&quot;Pooh&quot;);  // Winnie the Pooh
   //--- Valores de s√°ida
   Tom.PrintName();
   Huck.PrintName();
   Pooh.PrintName();
   
   //--- Apaga um objeto criado dinamicamente
   delete Pooh;
</code></pre>
<p>
  }
Neste caso, a classe CPerson tem tr√™s construtores:
1. Um construtor default expl√≠cito, que permite a cria√ß√£o de um array de objetos desta classe;</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
124
2. Um construtor com um par√¢metro, que recebe um nome completo como um par√¢metro e divide
com o nome e segundo nome de acordo com o espa√ßo encontrado;
3. Um construtor com dois par√¢metros que contem uma lista de inicializa√ß√£o. Inicializadores -
m_second_name(surname) e m_first_name(name).
Note que a inicializa√ß√£o usando uma lista substitui uma atribui√ß√£o. Membros individuais devem ser
inicializados como:
¬†class_member (uma lista de express√µes)
Na lista de inicializa√ß√£o, membros podem aparecer em qualquer ordem, mas todos os membros da
classe ser√£o inicializados de acordo com a ordem de sua apari√ß√£o. Isso significa que no terceiro
construtor, primeiro o membro m_first_name ser√° inicializado, j√° que ele aparece primeiro, e
somente depois m_second_name ser√° inicializado. Isto ser√° tomado em conta nos casos onde a
inicializa√ß√£o de alguns membros da classe depende dos valores em outros membros da classe.
Se um construtor default n√£o for declarado na base base, e ao mesmo tempo um ou mais construtores
com par√¢metros forem declarados, voc√™ deve sempre chamar um dos construtores da classe base na
lista de inicializa√ß√£o. Ele √© passado com v√≠rgula da mesma forma que membros comuns da lista e ser√°
chamado primeiro durante a inicializa√ß√£o do objeto, n√£o importando onde ele √© colocado na lista de
inicializa√ß√£o.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| A classe base¬†                                                   |
//+------------------------------------------------------------------+
class CFoo
  {
   string            m_name;
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Um construtor com uma lista de inicializa√ß√£o
                     CFoo(string name) : m_name(name) { Print(m_name);}
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma classe derivada a partir de CFoo¬†                            |
//+------------------------------------------------------------------+
class CBar : CFoo
  {
   CFoo              m_member;      // Um membro de classe √© um objeto do pai
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- O construtor default na lista de inicializa√ß√£o chama o construtor do pai
                     CBar(): m_member(_Symbol), CFoo(&quot;CBAR&quot;) {Print(__FUNCTION__);}
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
   CBar bar;
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
125
Neste exemplo, ao criar o objeto bar, um construtor default CBar() ser√° chamado, no qual primeiro um
construtor do pai de CFoo √© chamado, e ent√£o vem um construtor para o membro de classe
m_member.
Um destrutor √© uma fun√ß√£o especial que √© chamado automaticamente quando um objeto de classe √©
destru√≠do. O nome do destrutor √© escrito como nome de classe precedido de (~). Strings, arrays
din√¢micos e objetos, exigindo desinicializa√ß√£o, ser√£o desinicializados de qualquer forma, n√£o
importando se o destrutor estiver presente ou ausente. Se existir um destrutor, essas a√ß√µes ser√£o
executadas ap√≥s chamar o destrutor.
Destrutores s√£o sempre virtuais, n√£o importando se eles s√£o declarados com a palavra-chave virtual
ou n√£o.
<h3>Definindo M√©todos de Classe</h3>
M√©todos de fun√ß√µes de classe podem ser definidos tanto dentro quanto fora da declara√ß√£o de classe.
Se o m√©todo √© definido dentro de uma classe, ent√£o seu corpo vem logo ap√≥s a declara√ß√£o do m√©todo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
class CTetrisShape
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   int               m_type;
   int               m_xpos;
   int               m_ypos;
   int               m_xsize;
   int               m_ysize;
   int               m_prev_turn;
   int               m_turn;
   int               m_right_border;
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              CTetrisShape();
   void              SetRightBorder(int border) { m_right_border=border; }
   void              SetYPos(int ypos)          { m_ypos=ypos;           }
   void              SetXPos(int xpos)          { m_xpos=xpos;           }
   int               GetYPos()                  { return(m_ypos);        }
   int               GetXPos()                  { return(m_xpos);        }
   int               GetYSize()                 { return(m_ysize);       }
   int               GetXSize()                 { return(m_xsize);       }
   int               GetType()                  { return(m_type);        }
   void              Left()                     { m_xpos-=SHAPE_SIZE;    }
   void              Right()                    { m_xpos+=SHAPE_SIZE;    }
   void              Rotate()                   { m_prev_turn=m_turn; if(++m_turn&gt;3) m
   virtual void      Draw()                     { return;                }
   virtual bool      CheckDown(int&amp; pad_array[]);
   virtual bool      CheckLeft(int&amp; side_row[]);
   virtual bool      CheckRight(int&amp; side_row[]);
</code></pre>
<p>
  }; </p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
126
Fun√ß√µes a partir de SetRightBorder(int border) at√© Draw() s√£o declarados e definidos diretamente
dentro da classe CTetrisShape.
O construtor CTetrisShape() e os m√©todos CheckDown(int&amp; pad_array[]), CheckLeft(int&amp; side_row[]) e
CheckRight(int&amp; side_row[]) s√£o declarados somente dentro da classe, mas ainda n√£o definidos. As
defini√ß√µes destas fun√ß√µes ser√£o feitas mais adiante no c√≥digo. A fim de definir o m√©todo do lado de
fora da classe, o operador de resolu√ß√£o de scope √© usado, o nome da classe √© usado como o escopo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Construtor da classe b√°sica¬†                                     |
//+------------------------------------------------------------------+
void CTetrisShape::CTetrisShape()
  {
   m_type=0;
   m_ypos=0;
   m_xpos=0;
   m_xsize=SHAPE_SIZE;
   m_ysize=SHAPE_SIZE;
   m_prev_turn=0;
   m_turn=0;
   m_right_border=0;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+--------------------------------------------------------------------+
//| Verifica√ß√£o da capacidade de move para baixo (para a varra e cubo) |
//+--------------------------------------------------------------------+
bool CTetrisShape::CheckDown(int&amp; pad_array[])
  {
   int i,xsize=m_xsize/SHAPE_SIZE;
//---
   for(i=0; i&lt;xsize; i++)
     {
      if(m_ypos+m_ysize&gt;=pad_array[i]) return(false);
     }
//---
   return(true);
</code></pre>
<p>
  }
Especificadores de Acesso Public, Protected e Private
Quando desenvolver um nova classe, √© recomend√°vel restringir o acesso do lado de fora aos membros
da classe. S√£o usadas palavras-chave private ou protected para esta finalidade. Neste caso, dados
escondidos podem ser acessados somente a partir de m√©todos-fun√ß√µes da mesma classe. Se a palavra-
chave protected √© usada, dados escondidos podem ser acessados tamb√©m a partir de m√©todos de
classes herdeiras desta classe. O mesmo m√©todo pode ser usado para restringir o acesso de m√©todos-
fun√ß√µes de uma classe. 
Se voc√™ precisar de acesso com abertura completa aos membros e/ou m√©todos de uma classe, use a
palavra-chave public.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
127
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
class CTetrisField
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   int               m_score;                            // Contagem
   int               m_ypos;                             // Posi√ß√£o corrente das figur
   int               m_field[FIELD_HEIGHT][FIELD_WIDTH]; // Boa matriz
   int               m_rows[FIELD_HEIGHT];               // Numera√ß√£o das linhas boas
   int               m_last_row;                         // √öltima linha livre
   CTetrisShape     *m_shape;                            // Figura Tetris
   bool              m_bover;                            // Fim de jogo
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              CTetrisField() { m_shape=NULL; m_bover=false; }
   void              Init();
   void              Deinit();
   void              Down();
   void              Left();
   void              Right();
   void              Rotate();
   void              Drop();
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   void              NewShape();
   void              CheckAndDeleteRows();
   void              LabelOver();
</code></pre>
<p>
  }; 
Quaisquer membros de classe e m√©todos declarados ap√≥s o especificador public: (e antes do pr√≥ximo
especificador de acesso) ficam dispon√≠veis para qualquer refer√™ncia ao objeto da classe pelo
programa. Neste exemplo, existem os seguintes membros: fun√ß√µes CTetrisField(), Init(), Deinit(),
Down(), Left(), Right(), Rotate() e Drop().
Quaisquer membros de classe e m√©todos declarados ap√≥s o especificador private: (e antes do pr√≥ximo
especificador de acesso) ficam dispon√≠veis somente para as fun√ß√µes-membros desta classe.
Especificadores de acesso a elementos sempre terminam com um dois pontos (:) e podem aparecer na
defini√ß√£o da classe v√°rias vezes.
Qualquer membro da classe declarado ap√≥s o especificador de acesso protected: (e antes do pr√≥ximo
especificador de acesso) est√° dispon√≠vel apenas para fun√ß√µes-membro dessa classe e fun√ß√µes-membro
dos herdeiros desta classe. Ao tentar usar membros com especificadores private e protected um erro
ser√° recebido de fora no est√°gio de compila√ß√£o. Exemplo:
</p>
<pre><code class="language-mql5">
class A
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   //--- operador de c√≥pia est√° dispon√≠vel apenas na classe A e seus herdeiros
   void operator=(const A &amp;)
     {
     }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
class B</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
128
</p>
<pre><code class="language-mql5">
  {
   //--- declarado objeto de classe A
   A                 a;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   //--- declaradas duas vari√°veis do tipo B
   B b1, b2;
   //--- tentativa de copiar um objeto para outro
   b2=b1;
</code></pre>
<p>
  }
Ao compilar esse c√≥digo, aparecer√° uma mensagem de erro ‚Äî tentativa de chamar o operador de
c√≥pia remoto:
attempting to reference deleted function &#x27;void B::operator=(const B&amp;)&#x27;   trash3.mq5   
A segunda linha abaixo fornece uma descri√ß√£o mais detalhada ‚Äî o operador de c√≥pia na classe B foi
exclu√≠do explicitamente, pois foi chamado o operador de c√≥pia indispon√≠vel da classe A:
</p>
<pre><code class="language-mql5">
   function &#x27;void B::operator=(const B&amp;)&#x27; was implicitly deleted because it invokes in
</code></pre>
<p>
O acesso aos membros de uma classe base pode ser redefinido durante a heran√ßa nas classes
derivadas.
<h3>Especificador delete</h3>
O especificador delete marca fun√ß√µes-membro da classe que n√£o podem ser usadas. Isso significa que
se o programa se referir expl√≠cita ou implicitamente a essa fun√ß√£o, aparecer√° um erro no est√°gio de
compila√ß√£o. Por exemplo, esse especificador permite tornar indispon√≠veis os m√©todos pai em uma
classe filho. Voc√™ pode obter o mesmo resultado se declarar na classe pai uma fun√ß√£o na √°rea privada
(declara√ß√µes na se√ß√£o private) Use delete, nesse caso, torna o c√≥digo mais leg√≠vel e gerenci√°vel no
n√≠vel dos herdeiros.
</p>
<pre><code class="language-mql5">
class A
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     A(void) {value=5;};
   double            GetValue(void) {return(value);}
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double            value;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
class B: public A
  {
   double            GetValue(void)=delete;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
129
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
void OnStart()
  {
//--- declaramos uma vari√°vel do tipo A
   A a;
   Print(&quot;a.GetValue()=&quot;, a.GetValue());
//--- tentativa de obter um valor de uma vari√°vel do tipo B
   B b;
   Print(&quot;b.GetValue()=&quot;, b.GetValue()); // o compilador d√° um erro nessa linha
</code></pre>
<p>
  }
<h3>Mensagem do compilador:</h3>
attempting to reference deleted function &#x27;double B::GetValue()&#x27;   
</p>
<pre><code class="language-mql5">
   function &#x27;double B::GetValue()&#x27; was explicitly deleted here   
</code></pre>
<p>
Com a ajuda do especificador delete, √© poss√≠vel desativar a convers√£o autom√°tica ou o construtor de
c√≥pia, que, caso contr√°rio, teria que estar oculto nas se√ß√µes private. Exemplo:
</p>
<pre><code class="language-mql5">
class A
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              SetValue(double v) {value=v;}
   //--- proibimos a chamado com o tipo int
   void              SetValue(int) = delete;
   //--- proibimos o operador de c√≥pia
   void              operator=(const A&amp;) = delete;
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double            value;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- declaramos duas vari√°veis do tipo A
   A a1, a2;
   a1.SetValue(3);      // erro!
   a1.SetValue(3.14);   // OK
   a2=a1;               // erro!
</code></pre>
<p>
  }
Ao tentar compilar, obtemos as mensagens de erro:
attempting to reference deleted function &#x27;void A::SetValue(int)&#x27; 
</p>
<pre><code class="language-mql5">
   function &#x27;void A::SetValue(int)&#x27; was explicitly deleted here 
</code></pre>
<p>
attempting to reference deleted function &#x27;void A::operator=(const A&amp;)&#x27;  
</p>
<pre><code class="language-mql5">
   function &#x27;void A::operator=(const A&amp;)&#x27; was explicitly deleted here  
</code></pre>
<p>
<h3>Especificador final</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
130
A presen√ßa do especificador final, ao declarar a classe, pro√≠be a heran√ßa a partir dela. Se a interface
da classe n√£o precisar de altera√ß√µes futuras ou se essas altera√ß√µes n√£o se puderem levar a cabo por
causa de quest√µes de seguran√ßa, declare-a usando o modificador final. Al√©m disso, todos os m√©todos
da classe tamb√©m ser√£o implicitamente considerados como final.
</p>
<pre><code class="language-mql5">
class CFoo final
  {
  //--- corpo da classe
</code></pre>
<p>
  };
 
</p>
<pre><code class="language-mql5">
class CBar : public CFoo
  {
  //--- corpo da classe
</code></pre>
<p>
  };
Como no exemplo acima, ao tentar herdar a partir da classe, usando o especificador final, o
compilador ir√° emitir um erro:
cannot inherit from &#x27;CFoo&#x27; as it has been declared as &#x27;final&#x27;
see declaration of &#x27;CFoo&#x27;
<h3>Uni√£es (union)</h3>
A uni√£o √© um tipo de dados especial que compreende uma s√©rie de vari√°veis que compartilham o
mesmo espa√ßo de mem√≥ria. Assim, a uni√£o permite interpretar a mesma sequ√™ncia de bit de dois (ou
mais) formas diferentes. A declara√ß√£o de uni√£o √© semelhante a declarar estruturas e come√ßa com a
palavra-chave union.
union LongDouble
</p>
<pre><code class="language-mql5">
{
</code></pre>
<p>
  long   long_value;
  double double_value;
</p>
<pre><code class="language-mql5">
};
</code></pre>
<p>
Mas ao contr√°rio das estruturas, diferentes membros de uni√£o pertencem ao mesmo local de mem√≥ria.
Neste exemplo, √© declarada a uni√£o LongDouble, nela o tipo long e o valor do tipo double compartilham
a mesma regi√£o mem√≥ria. √â importante entender que √© imposs√≠vel fazer com que esta associa√ß√£o
armazene ao mesmo tempo um valor inteiro long e um verdadeiro double (como acontecia na
estrutura), porque as vari√°veis long_value e double_value s√£o sobrepostas (na mem√≥ria). Mas o
programa MQL5 a qualquer momento pode processar a informa√ß√£o contida nesta uni√£o, como um valor
inteiro (long) ou real (double). Assim, a uni√£o faz com que seja poss√≠vel obter duas (ou mais)
variantes de representa√ß√£o da mesma s√©rie de dados.
Ao declarar a uni√£o, o compilador automaticamente aloca uma √°rea de mem√≥ria suficiente para
armazenar na uni√£o as maiores vari√°veis de acordo com o volume do tipo. Para acessar o elemento de
uni√£o, usa-se a mesma sintaxe como para as estruturas, isto √©, operador ponto.
union LongDouble
</p>
<pre><code class="language-mql5">
{
</code></pre>
<p>
  long   long_value;
  double double_value;
</p>
<pre><code class="language-mql5">
};
//+------------------------------------------------------------------+
//| Script program start function                                    |</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
131
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   LongDouble lb;
//--- obtemos o n√∫mero inv√°lido -nan(ind) e exibimo-lo
   lb.double_value=MathArcsin(2.0);
   printf(&quot;1.  double=%f                integer=%I64X&quot;,lb.double_value,lb.long_value);
//--- maior n√∫mero normalizado (DBL_MAX)
   lb.long_value=0x7FEFFFFFFFFFFFFF;
   printf(&quot;2.  double=%.16e  integer=%I64X&quot;,lb.double_value,lb.long_value);
//--- menor n√∫mero positivo normalizado (DBL_MIN)
   lb.long_value=0x0010000000000000;    
   printf(&quot;3.  double=%.16e  integer=%.16I64X&quot;,lb.double_value,lb.long_value);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
/*  Resultado da execu√ß√£o
    1.  double=-nan(ind)                integer=FFF8000000000000
    2.  double=1.7976931348623157e+308  integer=7FEFFFFFFFFFFFFF
    3.  double=2.2250738585072014e-308  integer=0010000000000000
</code></pre>
<p>
*/
Como as uni√µes permitem que o programa interprete os mesmos dados na mem√≥ria de diferentes
maneiras, elas s√£o frequentemente utilizadas em aplica√ß√µes que requerem uma convers√£o de tipos
pouco comum.
As uni√µes n√£o podem participar na heran√ßa, al√©m disso, n√£o podem ter membros est√°ticos por
defini√ß√£o. De resto union comporta-se como uma estrutura, em que todos os membros t√™m
deslocamento zero. Ao mesmo tempo, os membros de uni√£o n√£o podem ser dos seguintes tipos:
¬∑ arrays din√¢micas
¬∑ strings
¬∑ ponteiros de objetos e fun√ß√µes
¬∑ classes de objetos
¬∑ estruturas de objeto que t√™m construtores ou destruidores
¬∑ estruturas de objeto com um membro a partir dos pontos 1-5
Como as classes, a uni√£o pode ter construtores e destruidores, bem como m√©todos. Por padr√£o, os
membros da uni√£o t√™m o tipo de acesso public&lt;t2, para criar um elementos fechados necess√°rias para
usar a palavra-chave private. Todos esses recursos s√£o mostrados no exemplo que mostra como
converter a cor do tipo color, no formato ARGB, como o faz a fun√ß√£o ColorToARGB().
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uni√£o para convers√£o de color(BGR) no formato ARGB      |
//+------------------------------------------------------------------+
</code></pre>
<p>
union ARGB
</p>
<pre><code class="language-mql5">
  {
   uchar             argb[4];
   color             clr;
   //--- construtores
                     ARGB(color col,uchar a=0){Color(col,a);};</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
132
</p>
<pre><code class="language-mql5">
                    ~ARGB(){};
   //--- m√©todos p√∫blicos
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   uchar   Alpha(){return(argb[3]);};
   void    Alpha(const uchar alpha){argb[3]=alpha;};
   color   Color(){ return(color(clr));};
   //--- m√©todos fechados
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   //+------------------------------------------------------------------+
   //| defini√ß√£o de cor e valor do canal-alfa                          |
   //+------------------------------------------------------------------+
   void    Color(color col,uchar alpha)
     {
      //--- definimos a cor no membro clr
      clr=col;
      //--- definimos o valor do componente Alpha, isto √©, o n√≠vel de opacidade
      argb[3]=alpha;
      //--- mudamos de lugar os bytes do componente R e B (Red e Blue)     
      uchar t=argb[0];argb[0]=argb[2];argb[2]=t;
     };
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- o valor 0x55 significa 55/255=21.6 % (0% - totalmente transparente)
   uchar alpha=0x55; 
//--- o tipo color t√™m o formato 0x00BBGGRR
   color test_color=clrDarkOrange;
//--- aqui entrar√£o os valores de bytes a partir da uni√£o ARGB
   uchar argb[]; 
   PrintFormat(&quot;0x%.8X - assim se v√™ o tipo color para %s, BGR=(%s)&quot;,
               test_color,ColorToString(test_color,true),ColorToString(test_color));
//--- o tipo ARGB √© apresentado como 0x00RRGGBB, mudados de lugar os componentes RR e 
   ARGB argb_color(test_color);
//--- copiamos o array de bytes
   ArrayCopy(argb,argb_color.argb);
//--- vemos como fica no formato ARGB  
   PrintFormat(&quot;0x%.8X - presenta√ß√£o ARGB com alfa-canal=0x%.2x, ARGB=(%d,%d,%d,%d)&quot;,
               argb_color.clr,argb_color.Alpha(),argb[3],argb[2],argb[1],argb[0]);
//--- adicionamos o valor de opacidade
   argb_color.Alpha(alpha);
//--- tentamos imprimir ARGB como tipo color
   Print(&quot;ARGB como color=(&quot;,argb_color.clr,&quot;)  alfa-canal=&quot;,argb_color.Alpha());
//--- copiamos o array de bytes
   ArrayCopy(argb,argb_color.argb);
//--- assim fica no formato ARGB
   PrintFormat(&quot;0x%.8X - presenta√ß√£o ARGB com alfa-canal=0x%.2x, ARGB=(%d,%d,%d,%d)&quot;,</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
133
</p>
<pre><code class="language-mql5">
               argb_color.clr,argb_color.Alpha(),argb[3],argb[2],argb[1],argb[0]);
//--- verificamos se √© gerada a fun√ß√£o ColorToARGB()
   PrintFormat(&quot;0x%.8X - resultado ColorToARGB(%s,0x%.2x)&quot;,ColorToARGB(test_color,alph
               ColorToString(test_color,true),alpha);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
/* Resultado da execu√ß√£o
   0x00008CFF - assim se v√™ o tipocolor para clrDarkOrange, BGR=(255,140,0)
</code></pre>
<p>
¬† 0x00FF8C00 - presenta√ß√£o ARGB com alfa-canal=0x00, ARGB=(0,255,140,0)
</p>
<pre><code class="language-mql5">
   ARGB como color=(0,140,255)  alfa-canal=85
</code></pre>
<p>
¬† 0x55FF8C00 - presenta√ß√£o ARGB com alfa-canal=0x55, ARGB=(85,255,140,0)
</p>
<pre><code class="language-mql5">
   0x55FF8C00 - resultado ColorToARGB(clrDarkOrange,0x55)
</code></pre>
<p>
*/ 
<h3>Interfaces</h3>
A interface √© projetada para determinar a funcionalidade espec√≠fica que a classe pode implementar.
Na verdade, essa √© uma classe que n√£o pode conter nenhum membro e n√£o pode ter um construtor
e/ou destrutor. Todos os m√©todos declarados na interface s√£o normalmente virtuais, mesmo sem uma
defini√ß√£o expl√≠cita.
A interface √© definida usando a palavra-chave interface, como √© mostrado no exemplo a seguir:
</p>
<pre><code class="language-mql5">
//--- interface b√°sica para descrever animais
</code></pre>
<p>
interface IAnimal
</p>
<pre><code class="language-mql5">
  {
//--- m√©todos da interface padr√£o t√™m acesso p√∫blico
   void Sound();  // som que produz o animal
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  a classe CCat √© herdada da interface IAnimal                    |
//+------------------------------------------------------------------+
class CCat : public IAnimal
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CCat() { Print(&quot;Cat was born&quot;); }
                    ~CCat() { Print(&quot;Cat is dead&quot;);  }
   //--- implementamos o m√©todo Sound da interface IAnimal
   void Sound(){ Print(&quot;meou&quot;); }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  a classe CDog √© herdada da interface IAnimal                    |
//+------------------------------------------------------------------+
class CDog : public IAnimal
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CDog() { Print(&quot;Dog was born&quot;); }
                    ~CDog() { Print(&quot;Dog is dead&quot;);  }
   //--- implementamos o m√©todo Sound da interface IAnimal
   void Sound(){ Print(&quot;guaf&quot;); }</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
134
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- matriz do ponteiro para o objeto do tipo IAnimal
   IAnimal *animals[2];
//--- geramos descendente IAnimal e salvamos os ponteiros para eles nas suas matrizes 
   animals[0]=new CCat;
   animals[1]=new CDog;
//--- chamamos o m√©todo Sound() da interface base IAnimal para cada descendente  
   for(int i=0;i&lt;ArraySize(animals);++i)
      animals[i].Sound();
//--- removemos objetos
   for(int i=0;i&lt;ArraySize(animals);++i)
      delete animals[i];
//--- resultado da execu√ß√£o
/*
   Cat was born
   Dog was born
   meou
   guaf
   Cat is dead
   Dog is dead
</code></pre>
<p>
*/
  }
Como as classes abstratas, n√£o se deve criar o objeto da interface sem descendente. A interface pode
ser herdada apenas a partir de outras interfaces e pode se tornar descendente para a classe. Al√©m
disso, a interface sempre tem visibilidade p√∫blica. 
√â imposs√≠vel declarar a interface dentro da declara√ß√£o da classe ou estrutura, por√©m √© poss√≠vel
armazenar o ponteiro para a interface na vari√°vel do tipo void *. De um modo geral, √© poss√≠vel
armazenar os ponteiros para objetos de qualquer classe na vari√°vel do tipo void *. Para converter um
ponteiro void * para outro ponteiro para um objeto de uma classe espec√≠fica, √© indispens√°vel utilizar o
operador dynamic_cast. Quando a convers√£o √© imposs√≠vel, o resultado da opera√ß√£o dynamic_cast ser√°
NULL.
<h3>Veja Tamb√©m</h3>
<h3>Programa√ß√£o Orientada a Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
135
<h3>Objeto Array Din√¢mico</h3>
<h3>Arrays Din√¢micos</h3>
No m√°ximo pode-se declarar arrays de 4 dimens√µes. Quando declarar um array din√¢mico (um array
sem valor especificado no primeiro par de colchetes), o compilador automaticamente cria uma
vari√°vel da estrutura acima (um objeto array din√¢mico) e fornece um c√≥digo para a correta
inicializa√ß√£o.
Arrays din√¢micos s√£o automaticamente liberados quando ficam al√©m da √°rea de visibilidade do bloco
em que eles foram declarados.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
double matrix[][10][20]; // array din√¢mico de 3 dimens√µes
</code></pre>
<p>
ArrayResize(matrix,5);   // define o tamanha da primeira dimens√£o
<h3>Arrays Est√°ticos</h3>
Quando todas as dimens√µes significantes do array s√£o explicitamente especificadas, o compilador pr√©-
aloca o tamanho de mem√≥ria necess√°rio. Tal array √© chamado est√°tico. Contudo, o compilador aloca
mem√≥ria adicional para o array din√¢mico, que √© associado ao buffer est√°tico pr√©-alocado (parte da
mem√≥ria para armazenar o array).
A cria√ß√£o de um objeto array din√¢mico √© devido a poss√≠vel necessidade de passar este array est√°tico
como par√¢metro para alguma fun√ß√£o.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
double stat_array[5]; // array est√°tico de uma dimens√£o
</code></pre>
<p>
some_function(stat_array);
...
</p>
<pre><code class="language-mql5">
bool some_function(double&amp; array[])
  {
   if(ArrayResize(array,100)&lt;0) return(false);
   ...
   return(true);
</code></pre>
<p>
  }
<h3>Arrays em Estruturas</h3>
Quando um array est√°tico √© declarado como membro de uma estrutura, um objeto array din√¢mico n√£o
√© criado. Isso √© assim para assegurar compatibilidade com estruturas de dados usados em API&#x27;s do
Windows.
Contudo, arrays est√°ticos que s√£o declarados como membros de estruturas, podem tamb√©m serem
passados para fun√ß√µes em MQL5. Neste caso, quando passar o par√¢metro um objeto tempor√°rio de um
array din√¢mico, conectado com o array est√°tico - membro da estrutura, ser√° criado.
<h3>Tamb√©m Veja</h3>
Fun√ß√µes com Arrays, Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis,
<h3>Criando e Excluindo Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
136
<h3>Matrizes e vetores</h3>
Um vector √© um tipo de dados especial em MQL5 para trabalhar com vetores, que √© uma matriz
unidimensional do tipo double. O vetor √© um dos conceitos fundamentais da √°lgebra linear e √© usado
ativamente em muitos campos da ci√™ncia, incluindo f√≠sica, geometria e outros. Os vetores s√£o usados
para resolver sistemas de equa√ß√µes lineares, em gr√°ficos 3D, etc. Com base nos vetores, s√£o
definidas opera√ß√µes de adi√ß√£o e multiplica√ß√£o, e √© introduzido o conceito de &quot;Norma&quot; para obter o
comprimento ou dist√¢ncia entre vetores. Na programa√ß√£o, os vetores s√£o normalmente representados
por matrizes de elementos homog√™neos sobre os quais n√£o podem ser realizadas opera√ß√µes vetoriais
convencionais, ou seja, as matrizes n√£o podem ser adicionadas umas √†s outras, multiplicadas umas
pelas outras, e n√£o existe o conceito de norma.
Os vetores podem ser representados como um vetor de coluna ou como um vetor de linha quando se
trabalha com matrizes. Al√©m disso, em √°lgebra linear os vetores usam conceitos como covari√¢ncia e
contravari√¢ncia. Para fins de escrita de c√≥digo em MQL5, essas diferen√ßas n√£o importam, pois apenas
o programador decide qual √© cada objeto do tipo vector. Por exemplo, pode ser um vetor de rota√ß√£o,
deslocamento, compress√£o e assim por diante quando se trata de gr√°ficos 3D.
De um modo geral, do ponto de vista da √°lgebra linear, um n√∫mero tamb√©m √© um vetor, s√≥ que em um
espa√ßo unidimensional. Al√©m disso, um vetor pode ser considerado um caso especial de matriz.
Um matrix √© outro tipo de dados especial em MQL5 para representar matrizes, que na verdade √© uma
matriz bidimensional do tipo double. Vetores e matrizes foram introduzidos na linguagem MQL5 para
facilitar o trabalho com certos tipos de conjuntos de dados. Eles permitem que os programadores
tirem total proveito da √°lgebra linear da forma mais simples e pr√≥xima da matem√°tica poss√≠vel. As
matrizes s√£o amplamente utilizadas para escrever sistemas compactos de equa√ß√µes alg√©bricas lineares
ou diferenciais. Nesse caso, o n√∫mero de linhas da matriz corresponde ao n√∫mero de equa√ß√µes e o
n√∫mero de colunas corresponde ao n√∫mero de inc√≥gnitas. Como resultado, a solu√ß√£o de sistemas de
equa√ß√µes lineares √© reduzida a opera√ß√µes em matrizes. 
<h3>Existem os seguintes tipos de dados:</h3>
¬∑ matrix ‚Äî matriz contendo elementos do tipo double
¬∑ matrixf ‚Äî matriz contendo elementos do tipo float
¬∑ matrixc ‚Äî matriz contendo elementos do tipo complex.
¬∑ vector ‚Äî vetor contendo elementos do tipo double
¬∑ vectorf ‚Äî vetor contendo elementos do tipo float
¬∑ vectorc ‚Äî vetor contendo elementos do tipo complex
Para uso em fun√ß√µes de modelo, √© poss√≠vel usar a entrada matrix&lt;double&gt;, matrix&lt;float&gt;,
matrix&lt;complex&gt;, vector&lt;double&gt;, vector&lt;float&gt;, vector&lt;complex&gt; em vez dos tipos correspondentes.
Para uma matriz, s√£o definidas as seguintes opera√ß√µes alg√©bricas:
¬∑ adi√ß√£o de matrizes do mesmo tamanho;
¬∑ multiplica√ß√£o de matrizes de tamanho adequado, com o n√∫mero de colunas da matriz √† esquerda
correspondendo ao n√∫mero de filas da matriz √† direita;
¬∑ multiplica√ß√£o de matrizes por um vetor de coluna e multiplica√ß√£o de um vetor de linha por uma
matriz de acordo com a regra de multiplica√ß√£o de matrizes. Ou seja, o vetor √©, nesse sentido, um
caso especial da matriz;
¬∑ multiplica√ß√£o de matriz por um n√∫mero, ou seja, por um escalar.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
137
No campo da matem√°tica, s√£o considerados muitos tipos e tipos diferentes de matrizes. Por exemplo,
identidade, sim√©trica, assim√©trica, triangular superior (triangular inferior) e outras matrizes. De
particular import√¢ncia na teoria da matriz s√£o todos os tipos de formas normais, ou seja, a forma
can√¥nica √† qual uma matriz pode ser reduzida atrav√©s da substitui√ß√£o de coordenadas. Na pr√°tica, s√£o
utilizadas formas normais que possuem propriedades adicionais, tais como estabilidade.
O uso de vetores e matrizes, ou melhor, de m√©todos especiais que estes tipos de dados possuem,
permite escrever um c√≥digo mais simples, mais curto e mais claro que se aproxima da nota√ß√£o
matem√°tica. Isto poupa ao programador o trabalho de criar la√ßos aninhados e de lembrar de indexar
corretamente as matrizes que est√£o envolvidas no c√°lculo. Isto aumenta a confiabilidade e a
velocidade de desenvolvimento de programas complexos.
Lista de m√©todos implementados em matrix e vector
Os tipos matrix e vector t√™m m√©todos incorporados que correspondem √†s contrapartidas da biblioteca
NumPy. Desta forma, voc√™ pode migrar algoritmos e c√≥digos de Python para MQL5 com um esfor√ßo
m√≠nimo. Assim, muitos problemas de processamento de dados, resolu√ß√£o de equa√ß√µes matem√°ticas,
redes neurais e aprendizagem de m√°quinas podem ser resolvidos usando bibliotecas de linguagem
Python prontas para uso.
<h3>M√©todo matrix/vector</h3>
<h3>Contraparte</h3>
em
<h3>NumPy</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
void matrix.Eye(const 
int 
</code></pre>
<p>
rows,
const int cols, const int ndiag=0)
eye
<h3>Cria uma matriz com</h3>
uns 
na
diagonal e zeros nos outros lugares
</p>
<pre><code class="language-mql5">
void matrix.Identity(const int rows)
</code></pre>
<p>
identity
<h3>Cria uma matriz quadrada com uns</h3>
na diagonal principal
</p>
<pre><code class="language-mql5">
void matrix.Ones(const int rows,
</code></pre>
<p>
const int cols)
ones
Cria uma nova matriz por n√∫mero de
filas e colunas, preenchida com
unidades
</p>
<pre><code class="language-mql5">
void matrix.Zeros(const int rows,
</code></pre>
<p>
const int cols)
zeros
Cria uma nova matriz por n√∫mero de
filas e colunas, preenchida com
zeros
</p>
<pre><code class="language-mql5">
void matrix.Full(const 
int 
</code></pre>
<p>
rows,
const int cols, const scalar value)
full
<h3>Cria uma nova matriz pelo n√∫mero</h3>
de filas e colunas, preenchidas com
um valor escalar
</p>
<pre><code class="language-mql5">
void matrix.Copy(const matrix a)
</code></pre>
<p>
copy
<h3>Cria uma c√≥pia de dada matriz</h3>
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
matrix.FromBuffer(const 
int
rows, const int cols, const scalar
array[], const int count=-1, const int
offset=0)
frombuffer
Cria uma matriz a partir de uma
matriz unidimensional
</p>
<pre><code class="language-mql5">
void matrix.FromFile(const int rows,
</code></pre>
<p>
condt int cols, const int file_handle,
const 
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
count=-1, 
const 
int
offset=0)
fromfile
Cria uma matriz a partir de dados
em um arquivo de texto ou bin√°rio</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
138
<h3>M√©todo matrix/vector</h3>
<h3>Contraparte</h3>
em
<h3>NumPy</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
void vector.FromString(const string
</code></pre>
<p>
source, const string sep=&quot; &quot;)
fromstring
Cria um vetor baseado em dados de
texto a partir de uma string
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
vector.Arange(const 
scalar
start, const scalar stop, const scalar
step=1)
arange
<h3>Cria</h3>
um 
vetor 
com 
valores
uniformemente distribu√≠dos em um
dado intervalo
</p>
<pre><code class="language-mql5">
void matrix.Diag(const vector v,
</code></pre>
<p>
const int ndiag=0)
diag
<h3>Extrai uma diagonal ou cria uma</h3>
matriz diagonal
</p>
<pre><code class="language-mql5">
void matrix.Tri(const int rows, const
int cols, const int ndiag=0)
</code></pre>
<p>
tri
<h3>Cria uma matriz com</h3>
uns 
na
diagonal indicada e abaixo e zeros
nos outros lugares
</p>
<pre><code class="language-mql5">
void matrix.Tril(const 
int 
</code></pre>
<p>
rows,
const int cols, const scalar array[],
const int ndiag=0)
tril
<h3>Retorna uma c√≥pia da matriz com</h3>
elementos zerados sobre a diagonal
k
</p>
<pre><code class="language-mql5">
void matrix.Triu(const int rows,
</code></pre>
<p>
const int cols, const scalar array[],
const int ndiag=0)
triu
<h3>Retorna uma c√≥pia da matriz com</h3>
elementos 
zerados 
abaixo 
da
diagonal k
</p>
<pre><code class="language-mql5">
void matrix.Vander(const vector v,
</code></pre>
<p>
const 
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
cols=-1, 
const 
bool
increasing=false)
vander
<h3>Cria uma matriz de Vandermonde</h3>
vector matrix.Row(const unsigned
nrow)
 
<h3>Retorna um vetor de linha</h3>
vector 
matrix.Col(const 
unsigned
ncol)
 
<h3>Retorna um vetor de coluna</h3>
unsigned matrix.Rows()
 
Retorna o n√∫mero de linhas em uma
matriz
unsigned matrix.Cols()
 
<h3>Retorna o n√∫mero de colunas em</h3>
uma matriz
</p>
<pre><code class="language-mql5">
void matrix.Init()
 
</code></pre>
<p>
<h3>Inicializa uma matriz</h3>
matrix matrix.Transpose()
transpose
<h3>Troca os eixos de uma matriz,</h3>
retorna a matriz modificada
matrix matrix.Dot(const matrix b)
dot
<h3>Produto de duas matrizes</h3>
matrix matrix.Inner(const matrix b)
inner
<h3>Produto interno de duas matrizes</h3>
matrix matrix.Outer(const matrix b)
outer
<h3>Produto externo de duas matrizes</h3>
matrix matrix.MatMul(const matrix
b)
matmul
<h3>Produto de matriz de duas matrizes</h3>
matrix matrix.MatrixPower(const int
power)
matrix_power
<h3>Eleva uma matriz quadrada para a</h3>
pot√™ncia (inteira) n</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
139
<h3>M√©todo matrix/vector</h3>
<h3>Contraparte</h3>
em
<h3>NumPy</h3>
<h3>Descri√ß√£o</h3>
matrix matrix.Kron(const matrix b)
kron
<h3>Retorna o produto de Kronecker de</h3>
duas matrizes
</p>
<pre><code class="language-mql5">
bool matrix.Cholesky(matrix&amp; L)
</code></pre>
<p>
cholesky
<h3>Retorna a decomposi√ß√£o de Cholesky</h3>
</p>
<pre><code class="language-mql5">
bool matrix.QR(matrix&amp; Q, matrix&amp;
</code></pre>
<p>
<h3>R)</h3>
qr
Calcula a fatora√ß√£o qr de uma matriz
</p>
<pre><code class="language-mql5">
bool matrix.SVD(matrix&amp; U, matrix&amp;
</code></pre>
<p>
<h3>V, vector&amp; singular_values)</h3>
svd
<h3>Calcula a decomposi√ß√£o SVD</h3>
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
matrix.Eig(matrix&amp;
eigen_vectors, 
vector&amp;
eigen_values)
eig
<h3>Calcula os valores pr√≥prios e os</h3>
vetores pr√≥prios direitos de uma
matriz quadrada
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
matrix.EigH(matrix&amp;
eigen_vectors, 
vector&amp;
eigen_values)
eigh
<h3>Retorna</h3>
os 
autovalores 
e
autovetores 
de 
uma 
matriz
<h3>Hermitiana</h3>
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
matrix.EigVals(vector&amp;
eigen_values)
eigvals
<h3>Calcula os valores pr√≥prios de uma</h3>
matriz comum
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
matrix.EigValsH(vector&amp;
eigen_values)
eigvalsh
<h3>Calcula os valores pr√≥prios de uma</h3>
matriz Hermitiana
</p>
<pre><code class="language-mql5">
bool matrix.LU(matrix&amp; L, matrix&amp;
</code></pre>
<p>
<h3>U)</h3>
 
<h3>Executa a decomposi√ß√£o LU de uma</h3>
matriz como o produto de uma
matriz triangular inferior e uma
matriz triangular superior
</p>
<pre><code class="language-mql5">
bool matrix.LUP(matrix&amp; L, matrix&amp;
</code></pre>
<p>
<h3>U, matrix&amp; P)</h3>
 
<h3>Executa a decomposi√ß√£o LUP de</h3>
rota√ß√£o parcial, que √© fatora√ß√£o LU
com permuta√ß√µes de linha: PA = LU
</p>
<pre><code class="language-mql5">
double matrix.Norm(const norm)
</code></pre>
<p>
norm
Retorna a norma de uma matriz ou
vetor
</p>
<pre><code class="language-mql5">
double matrix.Norm(const norm)
</code></pre>
<p>
cond
<h3>Calcula o n√∫mero da condi√ß√£o de</h3>
uma matriz
vector matrix.Spectrum()
<h3>Calcula o espectro de uma matriz</h3>
como 
um 
conjunto 
de 
seus
autovalores a partir do produto AT*A
</p>
<pre><code class="language-mql5">
double matrix.Det()
</code></pre>
<p>
det
<h3>Calcula o determinante de uma</h3>
matriz
</p>
<pre><code class="language-mql5">
int matrix.Rank()
</code></pre>
<p>
matrix_rank
Retorna a posto de matriz usando o
m√©todo Gaussiano
</p>
<pre><code class="language-mql5">
int matrix.SLogDet(int&amp; sign)
</code></pre>
<p>
slogdet
Calcula o sinal e o logaritmo de um
determinante de matriz</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
140
<h3>M√©todo matrix/vector</h3>
<h3>Contraparte</h3>
em
<h3>NumPy</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
double matrix.Trace()
</code></pre>
<p>
trace
<h3>Retorna a soma das diagonais de</h3>
uma matriz
vector matrix.Solve(const vector b)
solve
<h3>Resolve uma equa√ß√£o de matriz</h3>
linear ou um sistema de equa√ß√µes
alg√©bricas lineares
vector matrix.LstSq(const vector b)
lstsq
<h3>Resolve um sistema de equa√ß√µes</h3>
alg√©bricas 
lineares
aproximadamente (para 
matrizes
n√£o quadradas ou degeneradas)
matrix matrix.Inv()
inv
<h3>Calcula o inverso (multiplicativo) de</h3>
uma matriz
matrix matrix.PInv()
pinv
<h3>Calcula o pseudoinverso pelo m√©todo</h3>
<h3>Moore-Penrose</h3>
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
matrix.Compare(const 
matrix
matrix_c, const double epsilon)
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
matrix.Compare(const 
matrix
matrix_c, const int digits)
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
vector.Compare(const 
vector
vector_c, const double epsilon)
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
vector.Compare(const 
vector
vector_c, const int digits)
 
<h3>Compara os elementos de duas</h3>
matrizes/vetores com a precis√£o
especificada
</p>
<pre><code class="language-mql5">
double 
</code></pre>
<p>
matrix.Flat(const 
ulong
index)
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
matrix.Flat(const 
ulong
index,const double value)
flat
<h3>Permite endere√ßar um elemento da</h3>
matriz por meio de um √≠ndice, e n√£o
por meio de dois
</p>
<pre><code class="language-mql5">
double vector.ArgMax()
double matrix.ArgMax()
</code></pre>
<p>
vector 
matrix.ArgMax(const 
int
axis)
argmax
<h3>Retorna o √≠ndice do valor m√°ximo</h3>
</p>
<pre><code class="language-mql5">
double vector.ArgMin()
double matrix.ArgMin()
</code></pre>
<p>
vector matrix.ArgMin(const int axis)
argmin
<h3>Retorna o √≠ndice do valor m√≠nimo</h3>
</p>
<pre><code class="language-mql5">
double vector.Max()
double matrix.Max()
</code></pre>
<p>
vector matrix.Max(const int axis)
max
<h3>Retorna o valor m√°ximo em uma</h3>
matriz/vetor
</p>
<pre><code class="language-mql5">
double vector.Mean()
double matrix.Mean()
</code></pre>
<p>
vector matrix.Mean(const int axis)
mean
<h3>Calcula a m√©dia aritm√©tica dos</h3>
valores dos elementos
</p>
<pre><code class="language-mql5">
double vector.Min()
double matrix.Min()
</code></pre>
<p>
vector matrix.Min(const int axis)
min
<h3>Retorna o valor m√≠nimo em uma</h3>
matriz/vetor</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
141
<h3>M√©todo matrix/vector</h3>
<h3>Contraparte</h3>
em
<h3>NumPy</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
double vector.Sum()
double matrix.Sum()
</code></pre>
<p>
vector matrix.Sum(const int axis)
sum
<h3>Executa uma soma de elementos de</h3>
matriz/vetor, que tamb√©m pode ser
realizada ao longo do(s) eixo(s)
especificado(s).
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
vector.Clip(const 
double
min_value,const double max_value)
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
matrix.Clip(const 
double
min_value,const double max_value)
clip
<h3>Limita</h3>
os 
elementos 
de 
uma
matriz/vetor 
a 
um 
intervalo
especificado de valores v√°lidos
vector vector.CumProd()
vector matrix.CumProd()
matrix 
matrix.CumProd(const 
int
axis)
cumprod
<h3>Retorna</h3>
o 
produto 
cumulativo
(cumulativo) 
dos 
elementos 
da
matriz/vetor, incluindo aqueles ao
longo do eixo fornecido
vector vector.CumSum()
vector matrix.CumSum()
matrix 
matrix.CumSum(const 
int
axis)
cumsum
<h3>Retorna</h3>
a 
soma 
cumulativa
(cumulativa) 
de 
elementos 
de
matriz/vetor, incluindo aqueles ao
longo do eixo fornecido
</p>
<pre><code class="language-mql5">
double 
</code></pre>
<p>
vector.Prod(const 
double
initial=1)
</p>
<pre><code class="language-mql5">
double 
</code></pre>
<p>
matrix.Prod(const 
double
initial=1)
vector 
matrix.Prod(const 
int
axis,const double initial=1)
prod
<h3>Calcula o produto de elementos de</h3>
matriz/vetor, que tamb√©m podem
ser executados ao longo do eixo
especificado
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
matrix.Reshape(const 
ulong
rows, const ulong cols)
reshape
Altera a forma de uma matriz sem
mudar seus dados
</p>
<pre><code class="language-mql5">
void 
</code></pre>
<p>
matrix.Resize(const 
ulong
rows,const ulong cols)
resize
<h3>Retorna uma nova matriz com a</h3>
forma especificada
</p>
<pre><code class="language-mql5">
bool matrix.SwapRows(const ulong
</code></pre>
<p>
row1, const ulong row2)
<h3>Troca de linhas na matriz</h3>
</p>
<pre><code class="language-mql5">
bool matrix.SwapCols(const ulong
</code></pre>
<p>
col1, const ulong col2)
<h3>Troca colunas na matriz</h3>
</p>
<pre><code class="language-mql5">
double vector.Ptp()
double matrix.Ptp()
</code></pre>
<p>
vector matrix.Ptp(const int axis)
ptp
<h3>Retorna a faixa de valores de</h3>
matriz/vetor ou o eixo de matriz
especificado 
e 
equivalente 
ao
resultado Max() - Min()
</p>
<pre><code class="language-mql5">
double vector.Percentile(const int
</code></pre>
<p>
percent)
</p>
<pre><code class="language-mql5">
double matrix.Percentile(const int
</code></pre>
<p>
percent)
vector matrix.Percentile(const int
percent,const int axis)
percentile
<h3>Calcula</h3>
o 
percentil 
especificado
(percentil) 
dos 
valores 
dos
elementos 
de 
matriz/vetor 
ou
elementos 
ao 
longo 
do 
eixo
especificado. Os valores v√°lidos do
par√¢metro de porcentagem est√£o no
intervalo [0, 100]</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
142
<h3>M√©todo matrix/vector</h3>
<h3>Contraparte</h3>
em
<h3>NumPy</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
double 
</code></pre>
<p>
vector.Quantile(const 
int
percent)
</p>
<pre><code class="language-mql5">
double 
</code></pre>
<p>
matrix.Quantile(const 
int
percent)
vector 
matrix.Quantile(const 
int
percent,const int axis)
quantile
<h3>Calcula o quantil especificado dos</h3>
valores 
dos 
elementos 
da
matriz/vetor ou dos elementos ao
longo 
do 
eixo 
especificado. 
<h3>O</h3>
intervalo do par√¢metro percentual
assume valores no intervalo [0, 1]
</p>
<pre><code class="language-mql5">
double vector.Median()
double matrix.Median()
</code></pre>
<p>
vector matrix.Median(const int axis)
median
<h3>Calcula a mediana dos elementos de</h3>
uma matriz/vetor. A mediana √© um
valor tal que exatamente metade
dos elementos da matriz/vetor ser√°
menor que ela, e a outra ser√° maior.
</p>
<pre><code class="language-mql5">
double vector.Average()
double matrix.Average()
</code></pre>
<p>
vector 
matrix.Average(const 
int
axis)
average
<h3>Calcula</h3>
a 
m√©dia 
ponderada
aritm√©tica 
dos 
valores 
dos
elementos da matriz/vetor. A soma
dos pesos no denominador n√£o pode
ser 0, mas alguns pesos podem ser 0
</p>
<pre><code class="language-mql5">
double vector.Std()
double matrix.Std()
</code></pre>
<p>
vector matrix.Std(const int axis)
std
<h3>Calcula o desvio quadr√°tico m√©dio</h3>
(padr√£o) dos valores dos elementos
de uma matriz/vetor ou um eixo
especificado
</p>
<pre><code class="language-mql5">
double vector.Var()
double matrix.Var()
</code></pre>
<p>
vector matrix.Var(const int axis)
var
<h3>Calcula a vari√¢ncia dos valores dos</h3>
elementos de uma matriz/vetor
</p>
<pre><code class="language-mql5">
double 
</code></pre>
<p>
vector.CorrCoef(const
vector&amp; v)
matrix matrix.CorrCoef()
corrcoef
<h3>Calcula o coeficiente de correla√ß√£o</h3>
de 
<h3>Pearson</h3>
(coeficiente 
de
correla√ß√£o linear). O coeficiente de
correla√ß√£o est√° no intervalo [-1, 1]
vector 
vector.Correlate(const
vector&amp; v,enum mode)
correlate
<h3>Calcula os valores da fun√ß√£o de</h3>
correla√ß√£o 
cruzada 
(correla√ß√£o
cruzada) 
de 
dois 
vetores. 
<h3>O</h3>
par√¢metro mode determina o modo
de c√°lculo de convolu√ß√£o linear
vector 
vector.Convolve(const
vector&amp; v, enum mode)
convolve
<h3>Retorna</h3>
uma 
convolu√ß√£o 
linear
discreta de dois vetores de uma
sequ√™ncia. 
<h3>O</h3>
par√¢metro 
mode
determina o modo de c√°lculo de
convolu√ß√£o linear
matrix matrix.Cov()
matrix vector.Cov(const vector&amp; v);
(matriz final 2 x 2)
cov
<h3>Calcula a matriz de covari√¢ncia. A</h3>
covari√¢ncia de duas amostras (de
duas vari√°veis aleat√≥rias) √© uma
medida de sua depend√™ncia linear</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
143
<h3>Convers√£o de Tipo (Typecasting)</h3>
<h3>Convers√£o de Tipos Num√©ricos</h3>
Frequentemente surge a necessidade de converter um tipo num√©rico em outro. Nem todos os tipos
num√©ricos podem ser convertidos em outro. Aqui est√° o esquema de convers√£o permitida:
Linhas s√≥lidas com setas indicam mudan√ßas que s√£o realizadas quase sem nenhuma perda de
informa√ß√£o. Ao inv√©s do tipo char, o tipo bool pode ser usado (ambos ocupam 1 byte de mem√≥ria), ao
inv√©s do tipo int, o tipo color pode ser usado (4 bytes), ao inv√©s do tipo long, datetime pode ser usado
(ocupa 8 bytes). As quatro linhas cinzentas tracejadas, tamb√©m com setas, denotam convers√£o em
que a perda de precis√£o pode ocorrer. Por exemplo, o n√∫mero de algarismos em um inteiro igual a
123456789 (int) √© maior que o n√∫mero de algarismos que podem ser representados por um float. 
</p>
<pre><code class="language-mql5">
   int n=123456789;
   float f=n;    // o conte√∫do de f √© igual a 1.234567892E8
   Print(&quot;n = &quot;,n,&quot;   f = &quot;,f);
   // resultado n= 123456789    f= 123456792.00000
</code></pre>
<p>
O n√∫mero convertido em float tem a mesma ordem de grandeza, mas √© menos preciso. Convers√µes,
no sentido contr√°rio das setas pretas, podem ser realizadas com poss√≠vel perda de dados. Convers√µes
entre char e uchar, short e ushort, int e uint, long e ulong (convers√µes para ambos os lados), podem
levar a perda de dados.
Como resultado da convers√£o de valores de ponto flutuante para o tipo inteiro, a parte fracion√°ria √©
sempre exclu√≠da. Se voc√™ quiser arredondar um float para o inteiro mais pr√≥ximo (que em muitos
casos √© mais √∫til), voc√™ deve usar MathRound().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- Acelera√ß√£o gravitacional
   double g=9.8;
   double round_g=(int)g;
   double math_round_g=MathRound(g);
   Print(&quot;round_g = &quot;,round_g);
   Print(&quot;math_round_g = &quot;,math_round_g);
/*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   round_g = 9
   math_round_g = 10
</code></pre>
<p>
*/</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
144
Se dois valores s√£o combinados por um operador bin√°rio, antes da execu√ß√£o da opera√ß√£o, o operando
do tipo mais baixo √© convertido para o do tipo mais alto, em concord√¢ncia com a prioridade dada no
esquema abaixo:
Os tipos de dados char, uchar, short, e ushort incondicionalmente s√£o convertido para o tipo int.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
   char   c1=3;
//--- Primeiro exemplo
   double d2=c1/2+0.3;
   Print(&quot;c1/2 + 0.3 = &quot;,d2);
// Resultado:   c1/2+0.3 = 1.3
//--- Segundo exemplo
   d2=c1/2.0+0.3;
   Print(&quot;c1/2.0 + 0.3 = &quot;,d2);
// Resultado:   c1/2.0+0.3 = 1.8
</code></pre>
<p>
A express√£o calculada consiste de duas opera√ß√µes. No primeiro exemplo, a vari√°vel c1 do tipo char √©
convertida para uma vari√°vel tempor√°ria do tipo int, porque o segundo operando da opera√ß√£o de
divis√£o, a constante 2, √© do tipo mais alto, int. Como resultado da divis√£o de inteiros, 3/2, n√≥s
obtemos o valor 1, que √© do tipo inteiro.
Na segunda opera√ß√£o do primeiro exemplo, o segundo operando √© a constante 0.3, que √© do tipo
double, ent√£o o resultado da primeira opera√ß√£o √© convertido em uma vari√°vel tempor√°ria para o tipo
</p>
<pre><code class="language-mql5">
double com o valor 1.0.
</code></pre>
<p>
No segundo exemplo, a vari√°vel c1 do tipo char √© convertida para uma vari√°vel tempor√°ria do tipo
double, porque o segundo operando da opera√ß√£o de divis√£o, a constante 2.0, √© do tipo double;
nenhuma convers√£o adicional √© feita.
<h3>Convers√£o de Tipos Num√©ricos</h3>
Nas express√µes da linguagem MQL5 tanto convers√£o explicita quanto impl√≠cita podem ser usadas. A
convers√£o expl√≠cita √© escrita da seguinte forma:
var_1 = (type)var_2;
Uma express√£o ou resultado de execu√ß√£o de uma fun√ß√£o podem ficar no lugar da vari√°vel var_2. A
nota√ß√£o funcional de uma convers√£o expl√≠cita √© tamb√©m poss√≠vel:
var_1 = type(var_2);
Vamos considerar uma convers√£o expl√≠cita com base no primeiro exemplo.
</p>
<pre><code class="language-mql5">
//--- Terceiro exemplo</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
145
</p>
<pre><code class="language-mql5">
   double d2=(double)c1/2+0.3;
   Print(&quot;(double)c1/2 + 0.3 = &quot;,d2);
// Resultado:   (double)c1/2+0.3 = 1.80000000
</code></pre>
<p>
Antes da opera√ß√£o de divis√£o ser realizada, a vari√°vel c1 √© explicitamente convertida para o tipo
double. Agora a constante inteira 2 √© convertida no valor 2.0 do tipo double, pois o resultado da
convers√£o do primeiro operando assumiu o tipo double. De fato, a convers√£o expl√≠cita √© uma opera√ß√£o
un√°ria.
Al√©m disso, quanto tentar converter tipos, o resultado pode ir al√©m da faixa permitida. Neste caso, o
truncamento ocorre. Por exemplo:
</p>
<pre><code class="language-mql5">
   char c;
   uchar u;
   c=400;
   u=400;
   Print(&quot;c = &quot;,c); // Resultado c=-112
   Print(&quot;u = &quot;,u); // Resultado u=144
</code></pre>
<p>
Antes de opera√ß√µes (exceto opera√ß√µes de atribui√ß√£o) serem realizadas, os dados s√£o convertidos para
o tipo de m√°xima prioridade. Antes de opera√ß√µes de atribui√ß√£o serem realizadas, os dados s√£o
convertidos para o tipo destino.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
   int    i=1/2;        // nenhuma convers√£o, o resultado √© 0
   Print(&quot;i = 1/2  &quot;,i);
   int k=1/2.0;         // a express√£o √© convertida para o tipo double,
   Print(&quot;k = 1/2  &quot;,k);  // ent√£o √© convertido para o tipo destino, o resultado √© 0
   double d=1.0/2.0;    // nenhuma convers√£o de tipos, o resultado √© 0.5
   Print(&quot;d = 1/2.0; &quot;,d);
   double e=1/2.0;      // a express√£o √© convertida para o tipo double,
   Print(&quot;e = 1/2.0; &quot;,e);// que √© o mesmo do tipo destino, o resultado √© 0.5
   double x=1/2;        // a express√£o do tipo inteiro √© convertido para o tipo destin
   Print(&quot;x = 1/2; &quot;,x);  // o resultado √© 0.0
</code></pre>
<p>
Ao converter o tipo long/ulong em double, a precis√£o pode ser perdida caso o valor inteiro seja maior
do que 223372036854774784 ou menor do que -9223372036854774784.
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   long l_max=LONG_MAX;
   long l_min=LONG_MIN+1;
//--- definir o valor inteiro maior, que n√£o perde a precis√£o ao ser lan√ßado para doub
   while(l_max!=long((double)l_max))
      l_max--;
//--- definir o valor inteiro menor, que n√£o perde a precis√£o ao ser lan√ßado para doub
   while(l_min!=long((double)l_min))</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
146
</p>
<pre><code class="language-mql5">
      l_min++;
//--- resulta no intervalo encontrado para valores inteiro  
   PrintFormat(&quot;Ao converter um valor inteiro para double, ele deve ser &quot;
               &quot;dentro [%I64d, %I64d] do intervalo&quot;,l_min,l_max);
//--- agora, vamos ver o que acontece se o valor fica fora deste intervalo
   PrintFormat(&quot;l_max+1=%I64d, double(l_max+1)=%.f, ulong(double(l_max+1))=%I64d&quot;,
               l_max+1,double(l_max+1),long(double(l_max+1)));
   PrintFormat(&quot;l_min-1=%I64d, double(l_min-1)=%.f, ulong(double(l_min-1))=%I64d&quot;,
               l_min-1,double(l_min-1),long(double(l_min-1)));
//--- receber o seguinte resultado
// Ao converter um valor integer para double, ele deve estar dentro do intervalo [-922
// l_max+1=9223372036854774785, double(l_max+1)=9223372036854774800, ulong(double(l_ma
// l_min-1=-9223372036854774785, double(l_min-1)=-9223372036854774800, ulong(double(l_
</code></pre>
<p>
  }
<h3>Convers√£o para o tipo String</h3>
O tipo string tem a mais alta prioridade entre os tipos simples. Portanto, se um dos operandos de uma
opera√ß√£o √© do tipo string, o segundo operando ser√° convertido para uma string automaticamente.
Observe que para uma string, uma √∫nica opera√ß√£o de dois-lugares di√°dicos de adi√ß√£o √© poss√≠vel. A
convers√£o explicita de string para qualquer tipo num√©rico √© permitida.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
   string s1=1.0/8;            // a express√£o √© convertida para o tipo double,
   Print(&quot;s1 = 1.0/8; &quot;,s1);     //  da√≠ √© convertida para o tipo string,
// resultado √© &quot;0.12500000&quot; (uma string cont√©m 10 caracteres)
   string s2=NULL;             // string desinicializa√ß√£o
   Print(&quot;s2 = NULL; &quot;,s2);      // o resultado √© uma string vazia
   string s3=&quot;Ticket N&quot;+12345; // a express√£o √© convertida para o tipo string
   Print(&quot;s3 = \&quot;Ticket N\&quot;+12345&quot;,s3);
   string str1=&quot;true&quot;;
   string str2=&quot;0,255,0&quot;;
   string str3=&quot;2009.06.01&quot;;
   string str4=&quot;1.2345e2&quot;;
   Print(bool(str1));
   Print(color(str2));
   Print(datetime(str3));
   Print(double(str4));
</code></pre>
<p>
Convers√£o de Ponteiros de Classe Base para Ponteiros de Classes Derivadas
Objetos de classe derivada podem ser vistos como objetos da correspondente classe base. Isso leva a
algumas conseq√º√™ncias interessantes. Por exemplo, apesar do fato que objetos de diferentes classes,</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
147
gerados a partir de uma √∫nica classe base, poderem diferir significativamente um do outro, podemos
criar uma lista ligada (List) com eles, j√° que vemos eles como objetos do tipo base. Mas o inverso n√£o
√© verdade: objetos da classe base n√£o s√£o automaticamente objetos da classe derivada.
Voc√™ pode usar a convers√£o explicita para converter ponteiros da classe base para ponteiros da classe
derivada. Mas voc√™ deve estar totalmente confiante na admissibilidade de tal transforma√ß√£o, porque
sen√£o um erro cr√≠tico de execu√ß√£o ocorrer√° e o programa MQL5 ser√° interrompido.
Convers√£o din√¢mica de tipos  usando o operador dynamic_cast
Existe a possibilidade de realizar uma convers√£o din√¢mica de tipos usando o operador dynamic_cast,
ele pode ser aplicado apenas para ponteiros de classes. Al√©m disso, a revis√£o dos tipos √© realizada
quando o programa est√° em execu√ß√£o. Isto significa que, ao usar operador compilador dynamic_cast
n√£o se verifica o tipo de dados usado para a convers√£o. Se for levada a cabo convers√£o do apontador
para o tipo de dados que n√£o √© um tipo real de objeto, o resultado  ser√°  o valor NULL.
dynamic_cast &lt;type-id&gt; ( expression )
O par√¢metro type-id  em colchetes angulares deve ser o ponteiro um tipo de classe definido
anteriormente. O tipo de operando expression (ao contr√°rio de C++) pode ser qualquer um, exceto
void.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
class CBar { };
class CFoo : public CBar { };
void OnStart()
  {
   CBar bar;    
//--- permitida a convers√£o din√¢mica do tipo de ponteiro *bar para o ponteiro *foo
   CFoo *foo = dynamic_cast&lt;CFoo *&gt;(&amp;bar); // n√£o acontecer√£o erros cr√≠ticos de execu√ß
   Print(foo);                             // foo=NULL      
//--- restringida a tentativa de clara convers√£o dos enlaces do objeto do tipo Bar par
   foo=(CFoo *)&amp;bar;                       // acontecer√° um erro cr√≠tico de execu√ß√£o
   Print(foo);                             // esta linha n√£o ser√° executada
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
<h3>Tipos de Dados</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
148
<h3>Tipo void e constante NULL</h3>
Sintaticamente o tipo void √© um tipo fundamental, juntamente com os tipos char, uchar, bool, short,
ushort, int, uint, color, long, ulong, datetime, float, double e string. Este tipo √© usado tanto para
indicar que a fun√ß√£o n√£o retorna nenhum valor ou, como um par√¢metro de fun√ß√£o, para indicar
aus√™ncia de par√¢metros.
A predefinida vari√°vel constante NULL √© do tipo void. Ele pode ser atribu√≠do a vari√°veis de qualquer
outro tipo fundamental sem convers√£o. A compara√ß√£o de vari√°veis de tipo fundamental com o valor
NULL √© permitida..
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- Se a string n√£o √© inicializada, ent√£o atribua nosso valor predefinido a ela
</code></pre>
<p>
if(some_string==NULL) some_string=&quot;empty&quot;;
Tamb√©m NULL pode ser comparado com ponteiros de objetos criados com o operador new.
<h3>Tamb√©m Veja</h3>
<h3>Vari√°veis, Fun√ß√µes</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
149
<h3>Tipos personalizados</h3>
A palavra-chave typedef em linguagem C++ permite criar tipos personalizados de dados, basta definir
o nome do tipo de dados para um tipo de dados existente. Ao fazer isto, n√£o √© criado um novo tipo de
dados, mas sim √© definido um novo nome para o tipo existente. Gra√ßas ao uso de tipos
personalizados, voc√™ pode tornar o programa mais flex√≠vel, basta suficiente alterar as instru√ß√µes
typedef usando os macros de substitui√ß√£o (#define). Usar os tipos personalizados tamb√©m pode
melhorar a legibilidade do c√≥digo, uma vez que, para os tipos de dados padr√£o, voc√™ pode usar seus
pr√≥prios nomes descritivos com ajuda de typedef. Formato geral para escrever instru√ß√µes a fim de
criar um tipo personalizado:
</p>
<pre><code class="language-mql5">
   typedef tipo novo_nome;
</code></pre>
<p>
Aqui o elemento tipo representa qualquer tipo de dados v√°lido, enquanto o elemento novo_nome √© o
nome novo para este tipo. √â importante notar que o novo nome √© definido apenas como um
complemento para o nome existente do tipo e n√£o para substitu√≠-lo. Na linguagem MQL5, voc√™ pode
criar um ponteiro para a fun√ß√£o, usando typedef.
<h3>Ponteiro para a fun√ß√£o</h3>
Ponteiro para a fun√ß√£o geralmente √© determinado pelo formato de registro
</p>
<pre><code class="language-mql5">
   typedef tipo_de_resultado_de_fun√ß√£o (*Nome_de_tipo_de_fun√ß√£o)(lista_de_tipos_de_par
</code></pre>
<p>
onde, ap√≥s a palavra typedef, √© definida a assinatura da fun√ß√£o, isto √©, o n√∫mero e tipo de
par√¢metros de entrada, bem como o tipo de resultado a ser retornado pela fun√ß√£o. Aqui est√° uma
explica√ß√£o de como criar e usar um ponteiro para uma fun√ß√£o:
</p>
<pre><code class="language-mql5">
// --- declaramos o ponteiro para uma fun√ß√£o que aceita dois par√¢metros do tipo int
   typedef int (*TFunc)(int,int);
//--- TFunc √© o tipo, e n√≥s podemos declarar o ponteiro-vari√°vel para a fun√ß√£o
   TFunc func_ptr; // ponteiro para a fun√ß√£o
//--- declaramos as fun√ß√µes que correspondem √† descri√ß√£o TFunc
   int sub(int x,int y) { return(x-y); }  // / subtra√ß√£o de um n√∫mero a partir de outr
   int add(int x,int y) { return(x+y); }  // adi√ß√£o de dois n√∫meros
   int neg(int x)       { return(~x);  }  // invers√£o de bits na vari√°vel
//--- voc√™ pode armazenas o endere√ßo da fun√ß√£o na vari√°vel func_ptr, para cham√°-la no 
   func_ptr=sub;
   Print(func_ptr(10,5));
   func_ptr=add;
   Print(func_ptr(10,5));
   func_ptr=neg;           // erro: neg n√£o tem o tipo¬†int (int,int)
   Print(func_ptr(10));    // erro: deve haver dois par√¢metros
</code></pre>
<p>
Neste exemplo, √† vari√°vel func_ptr podem ser atribu√≠das as fun√ß√µes sub e add, uma vez que cada uma
delas tem dois par√¢metros de entrada do tipo int, conforme especificado na defini√ß√£o do ponteiro para
a fun√ß√£o TFunc. Aqui √† fun√ß√£o neg n√£o pode ser atribu√≠do o ponteiro func_ptr, uma vez que sua
assinatura √© diferente.
Organiza√ß√£o dos modelos de eventos na interface personalizada</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
150
Usando os ponteiros para a fun√ß√£o voc√™ pode facilmente construir a manipula√ß√£o de eventos ao criar a
interface personalizada. Mostraremos um exemplo a partir da se√ß√£o CButton sobre como criar bot√µes e
adicionar neles uma fun√ß√£o para processamento do carregamento do bot√£o. Em primeiro lugar,
definimos o ponteiro para a fun√ß√£o TAction, ela ser√° chamada pressionando um bot√£o, e criaremos
tr√™s fun√ß√µes em conformidade com a descri√ß√£o TAction.
</p>
<pre><code class="language-mql5">
//--- criamos o tipo personalizado de fun√ß√£o
</code></pre>
<p>
typedef int(*TAction)(string,int);
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Abre o arquivo                                                  |
//+------------------------------------------------------------------+
int Open(string name,int id)
  {
   PrintFormat(&quot;Fun√ß√£o chamada %s (name=%s id=%d)&quot;,__FUNCTION__,name,id);
   return(1);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Salva o arquivo                                                  |
//+------------------------------------------------------------------+
int Save(string name,int id)
  {
   PrintFormat(&quot;Fun√ß√£o chamada %s (name=%s id=%d)&quot;,__FUNCTION__,name,id);
   return(2);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Fecha o arquivo                                                  |
//+------------------------------------------------------------------+
int Close(string name,int id)
  {
   PrintFormat(&quot;Fun√ß√£o chamada %s (name=%s id=%d)&quot;,__FUNCTION__,name,id);
   return(3);
</code></pre>
<p>
  }
Logo realizamos a classe MyButton a partir do CButton, em que adicionamos o membro TAction que,
por sua vez, √© o ponteiro para a fun√ß√£o. 
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Criamos nossa classe de bot√£o com a fun√ß√£o de manipulador de eventos          |
//+------------------------------------------------------------------+
class MyButton: public CButton
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   TAction           m_action;                    // manipulador de eventos para o gr√°
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     MyButton(void){}
                    ~MyButton(void){}
   //--- construtor com indica√ß√£o do texto do bot√£o e ponteiro para a fun√ß√£o a fim de 
                     MyButton(string text, TAction act)
     {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
151
</p>
<pre><code class="language-mql5">
      Text(text);
      m_action=act;
     }
   //--- defini√ß√£o de fun√ß√£o que ser√° chamada a partir do manipulador de eventos OnEve
   void              SetAction(TAction act){m_action=act;}
   //--- manipulador padr√£o de eventos de gr√°fico
   virtual bool      OnEvent(const int id,const long &amp;lparam,const double &amp;dparam,cons
     {      
      if(m_action!=NULL &amp; lparam==Id())
        { 
         //--- chamamos o manipulador pr√≥prio m_action() 
         m_action(sparam,(int)lparam);
         return(true);
        }
      else
      //--- retornamos o resultado da chamada do manipulador a partir da classe m√£o CB
         return(CButton::OnEvent(id,lparam,dparam,sparam));
     }
</code></pre>
<p>
  };
Em seguida, criamos a classe derivada CControlsDialog a partir da CAppDialog, √† qual adicionamos a
matriz m_buttons para armazenas os bot√µes do tipo MyButton,  bem como os m√©todos
AddButton(MyButton &amp;button) e CreateButtons().
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Classe CControlsDialog                                            |
//| Designa√ß√£o: painel gr√°fico para controle do aplicativo       |
//+------------------------------------------------------------------+
class CControlsDialog : public CAppDialog
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   CArrayObj         m_buttons;                     // matriz de bot√µes
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CControlsDialog(void){};
                    ~CControlsDialog(void){};
   //--- create
   virtual bool      Create(const long chart,const string name,const int subwin,const 
   //--- adi√ß√£o de bot√£o
   bool              AddButton(MyButton &amp;button){return(m_buttons.Add(GetPointer(butto
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   //--- cria√ß√£o de bot√µes 
   bool              CreateButtons(void);
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Cria√ß√£o do objeto CControlsDialog no gr√°fico                      |
//+------------------------------------------------------------------+
bool CControlsDialog::Create(const long chart,const string name,const int subwin,const
  {
   if(!CAppDialog::Create(chart,name,subwin,x1,y1,x2,y2))</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
152
</p>
<pre><code class="language-mql5">
      return(false);
   return(CreateButtons());
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| defines                                                          |
//+------------------------------------------------------------------+
//--- indents and gaps
#define INDENT_LEFT                         (11)      // indent from left (with allowa
#define INDENT_TOP                          (11)      // indent from top (with allowan
#define CONTROLS_GAP_X                      (5)       // gap by X coordinate
#define CONTROLS_GAP_Y                      (5)       // gap by Y coordinate
//--- for buttons
#define BUTTON_WIDTH                        (100)     // size by X coordinate
#define BUTTON_HEIGHT                       (20)      // size by Y coordinate
//--- for the indication area
#define EDIT_HEIGHT                         (20)      // size by Y coordinate
//+------------------------------------------------------------------+
//| Cria√ß√£o e adi√ß√£o de bot√µes para o painel CControlsDialog           |
//+------------------------------------------------------------------+
bool CControlsDialog::CreateButtons(void)
  {
//--- c√°lculo de coordenadas de bot√µes
   int x1=INDENT_LEFT;
   int y1=INDENT_TOP+(EDIT_HEIGHT+CONTROLS_GAP_Y);
   int x2;
   int y2=y1+BUTTON_HEIGHT;
//--- adicionamos os objetos dos bot√µes juntamente com os ponteiros para as fun√ß√µes
   AddButton(new MyButton(&quot;Open&quot;,Open));
   AddButton(new MyButton(&quot;Save&quot;,::Save));
   AddButton(new MyButton(&quot;Close&quot;,Close));
//--- criamos os bot√µes graficamente
   for(int i=0;i&lt;m_buttons.Total();i++)
     {
      MyButton *b=(MyButton*)m_buttons.At(i);
      x1=INDENT_LEFT+i*(BUTTON_WIDTH+CONTROLS_GAP_X);
      x2=x1+BUTTON_WIDTH;
      if(!b.Create(m_chart_id,m_name+&quot;bt&quot;+b.Text(),m_subwin,x1,y1,x2,y2))
        {
         PrintFormat(&quot;Failed to create button %s %d&quot;,b.Text(),i);
         return(false);
        }
      //--- adicionamos cada bot√£o no recipiente CControlsDialog
      if(!Add(b))
         return(false);
     }
//--- succeed
   return(true);
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
153
Agora podemos escrever o programa usando o painel de controle CControlsDialog, no qual s√£o criados
3 bot√µes &quot;Open&quot;, &quot;Save&quot; e &quot;Close&quot;. Ao pressionar o bot√£o, √© chamada a fun√ß√£o correspondente que
est√° escrita como um ponteiro para a fun√ß√£o TAction.
</p>
<pre><code class="language-mql5">
//--- declaramos o objeto no n√≠vel global para cri√°-lo automaticamente ao inciar o pro
</code></pre>
<p>
<h3>CControlsDialog MyDialog;</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- agora criamos o objeto no gr√°fico
   if(!MyDialog.Create(0,&quot;Controls&quot;,0,40,40,380,344))
      return(INIT_FAILED);
//--- executamos o aplicativo
   MyDialog.Run();
//--- inicializa√ß√£o bem-sucedida do aplicativo
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy dialog
   MyDialog.Destroy(reason);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert chart event function                                      |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,         // event ID  
                  const long&amp; lparam,   // event parameter of the long type
                  const double&amp; dparam, // event parameter of the double type
                  const string&amp; sparam) // event parameter of the string type
  {
//--- para os eventos do gr√°fico, chamamos o manipulador a partir da classe m√£e (neste
   MyDialog.ChartEvent(id,lparam,dparam,sparam);
</code></pre>
<p>
  }
A apar√™ncia do aplicativo em execu√ß√£o e os resultados dos bot√µes pressionados s√£o mostrados na
imagem.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
154
<h3>C√≥digo-fonte completo do programa</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                Panel_Buttons.mq5 |
//|                        Copyright 2017, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2017, MetaQuotes Software Corp.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;Painel com v√°rios bot√µes CButton&quot;
#include &lt;Controls\Dialog.mqh&gt;
#include &lt;Controls\Button.mqh&gt;
//+------------------------------------------------------------------+
//| defines                                                          |
//+------------------------------------------------------------------+
//--- indents and gaps
#define INDENT_LEFT                         (11)      // indent from left (with allowa
#define INDENT_TOP                          (11)      // indent from top (with allowan
#define CONTROLS_GAP_X                      (5)       // gap by X coordinate
#define CONTROLS_GAP_Y                      (5)       // gap by Y coordinate</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
155
</p>
<pre><code class="language-mql5">
//--- for buttons
#define BUTTON_WIDTH                        (100)     // size by X coordinate
#define BUTTON_HEIGHT                       (20)      // size by Y coordinate
//--- for the indication area
#define EDIT_HEIGHT                         (20)      // size by Y coordinate
//--- criamos o tipo personalizado de fun√ß√£o
</code></pre>
<p>
typedef int(*TAction)(string,int);
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Abre o arquivo                                                  |
//+------------------------------------------------------------------+
int Open(string name,int id)
  {
   PrintFormat(&quot;Fun√ß√£o chamada %s (name=%s id=%d)&quot;,__FUNCTION__,name,id);
   return(1);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Salva o arquivo                                                  |
//+------------------------------------------------------------------+
int Save(string name,int id)
  {
   PrintFormat(&quot;Fun√ß√£o chamada %s (name=%s id=%d)&quot;,__FUNCTION__,name,id);
   return(2);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Fecha o arquivo                                                  |
//+------------------------------------------------------------------+
int Close(string name,int id)
  {
   PrintFormat(&quot;Fun√ß√£o chamada %s (name=%s id=%d)&quot;,__FUNCTION__,name,id);
   return(3);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Criamos nossa classe de bot√£o com a fun√ß√£o de manipulador de eventos          |
//+------------------------------------------------------------------+
class MyButton: public CButton
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   TAction           m_action;                    // manipulador de eventos para o gr√°
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     MyButton(void){}
                    ~MyButton(void){}
   //--- construtor com indica√ß√£o do texto do bot√£o e ponteiro para a fun√ß√£o a fim de 
                     MyButton(string text,TAction act)
     {
      Text(text);
      m_action=act;
     }
   //--- defini√ß√£o de fun√ß√£o que ser√° chamada a partir do manipulador de eventos OnEve</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
156
</p>
<pre><code class="language-mql5">
   void              SetAction(TAction act){m_action=act;}
   //--- manipulador padr√£o de eventos de gr√°fico
   virtual bool      OnEvent(const int id,const long &amp;lparam,const double &amp;dparam,cons
     {
      if(m_action!=NULL &amp; lparam==Id())
        {
         //--- chamamos o manipulador pr√≥prio
         m_action(sparam,(int)lparam);
         return(true);
        }
      else
      //--- retornamos o resultado da chamada do manipulador a partir da classe m√£o CB
         return(CButton::OnEvent(id,lparam,dparam,sparam));
     }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Classe CControlsDialog                                            |
//| Designa√ß√£o: painel gr√°fico para controle do aplicativo       |
//+------------------------------------------------------------------+
class CControlsDialog : public CAppDialog
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   CArrayObj         m_buttons;                     // matriz de bot√µes
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CControlsDialog(void){};
                    ~CControlsDialog(void){};
   //--- create
   virtual bool      Create(const long chart,const string name,const int subwin,const 
   //--- adi√ß√£o de bot√£o
   bool              AddButton(MyButton &amp;button){return(m_buttons.Add(GetPointer(butto
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   //--- cria√ß√£o de bot√µes 
   bool              CreateButtons(void);
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Cria√ß√£o do objeto CControlsDialog no gr√°fico                      |
//+------------------------------------------------------------------+
bool CControlsDialog::Create(const long chart,const string name,const int subwin,const
  {
   if(!CAppDialog::Create(chart,name,subwin,x1,y1,x2,y2))
      return(false);
   return(CreateButtons());
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Cria√ß√£o e adi√ß√£o de bot√µes para o painel CControlsDialog           |
//+------------------------------------------------------------------+
bool CControlsDialog::CreateButtons(void)
  {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
157
</p>
<pre><code class="language-mql5">
//--- c√°lculo de coordenadas de bot√µes
   int x1=INDENT_LEFT;
   int y1=INDENT_TOP+(EDIT_HEIGHT+CONTROLS_GAP_Y);
   int x2;
   int y2=y1+BUTTON_HEIGHT;
//--- adicionamos os objetos dos bot√µes juntamente com os ponteiros para as fun√ß√µes
   AddButton(new MyButton(&quot;Open&quot;,Open));
   AddButton(new MyButton(&quot;Save&quot;,::Save));
   AddButton(new MyButton(&quot;Close&quot;,Close));
//--- criamos os bot√µes graficamente
   for(int i=0;i&lt;m_buttons.Total();i++)
     {
      MyButton *b=(MyButton*)m_buttons.At(i);
      x1=INDENT_LEFT+i*(BUTTON_WIDTH+CONTROLS_GAP_X);
      x2=x1+BUTTON_WIDTH;
      if(!b.Create(m_chart_id,m_name+&quot;bt&quot;+b.Text(),m_subwin,x1,y1,x2,y2))
        {
         PrintFormat(&quot;Failed to create button %s %d&quot;,b.Text(),i);
         return(false);
        }
      //--- adicionamos cada bot√£o no recipiente CControlsDialog
      if(!Add(b))
         return(false);
     }
//--- succeed
   return(true);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//--- declaramos o objeto no n√≠vel global para cri√°-lo automaticamente ao inciar o pro
</code></pre>
<p>
<h3>CControlsDialog MyDialog;</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- agora criamos o objeto no gr√°fico
   if(!MyDialog.Create(0,&quot;Controls&quot;,0,40,40,380,344))
      return(INIT_FAILED);
//--- executamos o aplicativo
   MyDialog.Run();
//--- inicializa√ß√£o bem-sucedida do aplicativo
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy dialog
   MyDialog.Destroy(reason);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
158
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert chart event function                                      |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,         // event ID  
                  const long&amp; lparam,   // event parameter of the long type
                  const double&amp; dparam, // event parameter of the double type
                  const string&amp; sparam) // event parameter of the string type
  {
//--- para os eventos do gr√°fico, chamamos o manipulador a partir da classe m√£e (neste
   MyDialog.ChartEvent(id,lparam,dparam,sparam);
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>Vari√°veis, Fun√ß√µes</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
159
<h3>Ponteiros de Objeto</h3>
Em MQL5, √© poss√≠vel criar dinamicamente objetos de tipo complexo. Isso √© feito usando o operador
new, que retorna um identificador para o objeto criado. O descritor tem um tamanho de 8 bytes.
Sintaticamente, os descritores de objetos em MQL5 s√£o semelhantes a ponteiros em C++.
<h3>Exemplo:</h3>
<h3>MyObject* hobject= new MyObject();</h3>
Ao contr√°rio do C++, a vari√°vel hobject do exemplo acima n√£o √© um ponteiro para a mem√≥ria, sen√£o
um descritor para um objeto. Al√©m disso, na linguagem MQL5, todos os objetos nos par√¢metros da
fun√ß√£o devem ser passados por refer√™ncia. Exemplos de passagem de objetos como par√¢metro de
fun√ß√£o:
</p>
<pre><code class="language-mql5">
class Foo
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   string            m_name;
   int               m_id;
   static int        s_counter;
   //--- construtores e destruidores
                     Foo(void){Setup(&quot;noname&quot;);};
                     Foo(string name){Setup(name);};
                    ~Foo(void){};
   //--- inicializamos o objeto Foo
   void              Setup(string name)
     {
      m_name=name;
      s_counter++;
      m_id=s_counter;
     }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
int Foo::s_counter=0;
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- declaramos o objeto como uma vari√°vel com cria√ß√£o autom√°tica
   Foo foo1;
//--- variante de passagem de objeto por refer√™ncia
   PrintObject(foo1);
//--- declaramos um ponteiro para um objeto e o criamos usando o operador &#x27;new&#x27;
   Foo *foo2=new Foo(&quot;foo2&quot;);
//--- variante de passagem de um ponteiro para um objeto por refer√™ncia
   PrintObject(foo2); // o ponteiro para o objeto √© convertido automaticamente pelo co
//--- declaramos um array de objetos Foo</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
160
</p>
<pre><code class="language-mql5">
   Foo foo_objects[5];
//--- variante de passagem de array de objetos
   PrintObjectsArray(foo_objects); // fun√ß√£o separada para passagem de array de objeto
//--- declaramos um array de ponteiros para objetos do tipo Foo
   Foo *foo_pointers[5];
   for(int i=0;i&lt;5;i++)
      foo_pointers[i]=new Foo(&quot;foo_pointer&quot;);
//--- variante de passagem de array de ponteiros
   PrintPointersArray(foo_pointers); // fun√ß√£o separada para passagem de array de pont
//--- antes de concluir o trabalho, sempre devemos excluir os objetos criados como pon
   delete(foo2);
//--- removemos o array de ponteiros
   int size=ArraySize(foo_pointers);
   for(int i=0;i&lt;5;i++)
      delete(foo_pointers[i]);
//---   
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Os objetos s√£o sempre passados por refer√™ncia                    |
//+------------------------------------------------------------------+
void PrintObject(Foo &amp;object)
  {
   Print(__FUNCTION__,&quot;: &quot;,object.m_id,&quot; Object name=&quot;,object.m_name);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Passagem de um array de objetos                                  |
//+------------------------------------------------------------------+
void PrintObjectsArray(Foo &amp;objects[])
  {
   int size=ArraySize(objects);
   for(int i=0;i&lt;size;i++)
      PrintObject(objects[i]);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Passagem de array de ponteiros para um objeto                    |
//+------------------------------------------------------------------+
void PrintPointersArray(Foo* &amp;objects[])
  {
   int size=ArraySize(objects);
   for(int i=0;i&lt;size;i++)
      PrintObject(objects[i]);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
</code></pre>
<p>
Verifica√ß√£o do ponteiro antes de seu uso</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
161
A tentativa de acesso a um ponteiro inv√°lido causa o encerramento cr√≠tico do programa. Para verificar
o ponteiro antes de us√°-lo, usamos a fun√ß√£o CheckPointer. O ponteiro pode ser inv√°lido quando:
¬∑ o ponteiro √© NULL;
¬∑ o objeto foi destru√≠do usando o operador delete.
Esta fun√ß√£o pode ser usada como verifica√ß√£o de ponteiro. Um valor diferente de zero garante que os
dados possam ser acessados com base nesse ponteiro.
</p>
<pre><code class="language-mql5">
class CMyObject
 {
</code></pre>
<p>
protected:
  double             m_value;
public:
</p>
<pre><code class="language-mql5">
                     CMyObject(void);
                     CMyObject(double value) {m_value=value;};
                    ~CMyObject(void){};
  //---
</code></pre>
<p>
  double             Value(void) {return(m_value);}
 };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
 {
//--- criamos um objeto n√£o inicializado
</code></pre>
<p>
<h3>CMyObject *pointer;</h3>
  if(CheckPointer(pointer)==POINTER_INVALID)
</p>
<pre><code class="language-mql5">
    Print(&quot;1. pointer is &quot;, EnumToString(CheckPointer(pointer)));
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;1. pointer.Value()=&quot;, pointer.Value());
//--- inicializamos o ponteiro
</code></pre>
<p>
  pointer=new CMyObject(M_PI);
  if(CheckPointer(pointer)==POINTER_INVALID)
</p>
<pre><code class="language-mql5">
    Print(&quot;2. pointer is &quot;, EnumToString(CheckPointer(pointer)));
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;2. pointer.Value()=&quot;, pointer.Value());
//--- excluimos o objeto
</code></pre>
<p>
  delete(pointer);
  if(CheckPointer(pointer)==POINTER_INVALID)
</p>
<pre><code class="language-mql5">
    Print(&quot;3. pointer is &quot;, EnumToString(CheckPointer(pointer)));
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;3. pointer.Value()=&quot;, pointer.Value());
</code></pre>
<p>
 }
</p>
<pre><code class="language-mql5">
/*
   1. pointer is POINTER_INVALID
   2. pointer.Value()=3.141592653589793
   3. pointer is POINTER_INVALID</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
162
*/
Para verifica√ß√£o r√°pida do ponteiro, voc√™ tamb√©m pode usar o operador &quot;!&quot; (LNOT) que testa sua
validade por meio de uma chamada de fun√ß√£o impl√≠cita CheckPointer. Isso permite que voc√™ escreva o
c√≥digo de forma mais concisa e clara. Veja como seriam as verifica√ß√µes do exemplo anterior:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
 {
//--- criamos um objeto n√£o inicializado
</code></pre>
<p>
<h3>CMyObject *pointer;</h3>
  if(!pointer)
</p>
<pre><code class="language-mql5">
    Print(&quot;1. pointer is &quot;, EnumToString(CheckPointer(pointer)));
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;1. pointer.Value()=&quot;, pointer.Value());
//--- inicializamos o ponteiro
</code></pre>
<p>
  pointer=new CMyObject(M_PI);
  if(!pointer)
</p>
<pre><code class="language-mql5">
    Print(&quot;2. pointer is &quot;, EnumToString(CheckPointer(pointer)));
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;2. pointer.Value()=&quot;, pointer.Value());
//--- excluimos o objeto
</code></pre>
<p>
  delete(pointer);
  if(!pointer)
</p>
<pre><code class="language-mql5">
    Print(&quot;3. pointer is &quot;, EnumToString(CheckPointer(pointer)));
</code></pre>
<p>
  else
</p>
<pre><code class="language-mql5">
    Print(&quot;3. pointer.Value()=&quot;, pointer.Value());
</code></pre>
<p>
 }
</p>
<pre><code class="language-mql5">
/*
   1. pointer is POINTER_INVALID
   2. pointer.Value()=3.141592653589793
   3. pointer is POINTER_INVALID
</code></pre>
<p>
*/
Para uma verifica√ß√£o r√°pida de NULL, use o operador &quot;==&quot;. Por exemplo: ptr==NULL ou ptr!=NULL. 
<h3>Tamb√©m Veja</h3>
Vari√°veis, Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e
<h3>Excluindo Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
163
<h3>Refer√™ncia, Modificador &amp; e Palavra-chave this</h3>
<h3>Passando Par√¢metros por Refer√™ncia</h3>
Em MQL5, par√¢metros de tipos simples podem ser passados tanto por valor como por refer√™ncia,
enquanto que par√¢metros de tipos compostos s√£o sempre passados por refer√™ncia. Para informar ao
compilador que um par√¢metro deve ser passado por refer√™ncia, o caractere &quot;e comercial&quot; &amp; √©
adicionado antes do nome do par√¢metro. 
Passar um par√¢metro por refer√™ncia significa passar o endere√ßo da vari√°vel, √© por isso que todas as
mudan√ßas no par√¢metro que √© passado por refer√™ncia ser√° imediatamente refletida na vari√°vel
origem. Usando par√¢metros passados por refer√™ncia, pode-se implementar o retorno de v√°rios
resultados de uma fun√ß√£o ao mesmo tempo. A fim de evitar altera√ß√£o de um par√¢metro passado por
refer√™ncia, use o modificador const.
Assim, se o par√¢metro de entrada de uma fun√ß√£o for um array, um objeto de classe ou estrutura, o
s√≠mbolo &#x27;&amp;&#x27; √© colocado no cabe√ßalho da fun√ß√£o ap√≥s o tipo da vari√°vel e antes de seu nome.
<h3>Exemplo</h3>
</p>
<pre><code class="language-mql5">
class CDemoClass
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double            m_array[];
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              setArray(double &amp;array[]);
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preenchendo o array¬†                                             |
//+------------------------------------------------------------------+
void  CDemoClass::setArray(double &amp;array[])
  {
   if(ArraySize(array)&gt;0)
     {
     ArrayResize(m_array,ArraySize(array));
     ArrayCopy(m_array, array);
     }
</code></pre>
<p>
  }
No exemplo acima, a classe CDemoClass √© declarada, e cont√©m o membro array private - m_array[] de
tipo double. A fun√ß√£o setArray() √© declarada, e o par√¢metro array[] √© passado por refer√™ncia. Se o
cabe√ßalho da fun√ß√£o n√£o cont√©m a indica√ß√£o de passar por refer√™ncia, isto √©, n√£o cont√©m o caractere
&quot;e comercial&quot; (&amp;), uma mensagem de erro ser√° gerada na tentativa de compilar tal c√≥digo.
Apesar do fato de que um array √© passado por refer√™ncia, n√£o se pode atribuir um array ao outro. N√≥s
precisamos realizar a c√≥pia elemento a elemento de conte√∫do do array origem para o array destino. A
presen√ßa de &amp; nas descri√ß√µes de fun√ß√£o √© uma condi√ß√£o obrigat√≥ria para array e estruturas quando
passado como par√¢metro de fun√ß√£o.
<h3>Palavra-chave this</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
164
Uma vari√°vel de tipo de classe (objeto) pode ser passado tanto por refer√™ncia como por ponteiro.
Assim como refer√™ncia, o ponteiro permite ter acesso a um objeto. Ap√≥s o ponteiro de objeto ser
declarado, o operador new deve ser aplicado nele para cri√°-lo e inicializ√°-lo.
A palavra reservada this √© destinado para obter a refer√™ncia do objeto para si mesmo, que fica
dispon√≠vel dentro de m√©todos de classe e estrutura. this sempre referencia o objeto, dentro do
m√©todo em que ele √© usado, e a express√£o GetPointer(this) retorna o ponteiro do objeto, cujo
membro √© a fun√ß√£o na qual a chamada ao GetPointer() √© realizado. Em fun√ß√µes MQL5 n√£o se pode
retornar objetos, mas eles podem retornar ponteiro de objeto. 
Assim, se precisamos de uma fun√ß√£o para retornar um objeto, n√≥s podemos retornar o ponteiro deste
objeto na forma de GetPointer(this). Vamos adicionar a fun√ß√£o getDemoClass() que retorna o ponteiro
do objeto para este classe, na descri√ß√£o de CDemoClass.
</p>
<pre><code class="language-mql5">
class CDemoClass
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double            m_array[];
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              setArray(double &amp;array[]);
   CDemoClass       *getDemoClass();
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Preenchendo o array¬†                                             |
//+------------------------------------------------------------------+
void  CDemoClass::setArray(double &amp;array[])
  {
   if(ArraySize(array)&gt;0)
     {
      ArrayResize(m_array,ArraySize(array));
      ArrayCopy(m_array,array);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna seu pr√≥prio ponteiro¬†                                    |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CDemoClass *CDemoClass::getDemoClass(void)</h3>
</p>
<pre><code class="language-mql5">
  {
   return(GetPointer(this));
</code></pre>
<p>
  }
Estruturas n√£o t√™m ponteiros, os operadores new e delete n√£o podem ser aplicados a eles,
GetPointer(this) n√£o pode ser usado. 
<h3>Tamb√©m Veja</h3>
Ponteiros de Objetos, Criando e Excluindo Objetos, Visibilidade Escopo e Tempo de Vida de
<h3>Vari√°veis</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
165
<h3>Opera√ß√µes e Express√µes</h3>
Alguns caracteres e seq√º√™ncias de caractere s√£o de uma import√¢ncia especial. Existem os chamados
s√≠mbolos de opera√ß√£o, por exemplo:
+ - * / %     S√≠mbolos de opera√ß√µes aritm√©ticas
&amp;&amp; ||         S√≠mbolos de opera√ß√µes l√≥gicas
= += *=       Caracteres de operador de atribui√ß√£o
Os s√≠mbolos de opera√ß√£o s√£o usados em express√µes e t√™m sentido quando operandos apropriados s√£o
dados a eles. Sinais de pontua√ß√£o s√£o enfatizados, da mesma forma. Existem par√™nteses, chaves,
v√≠rgula, dois pontos, e ponto e v√≠rgula.
S√≠mbolos de opera√ß√£o, sinais de pontua√ß√£o, e espa√ßos s√£o usados para separar elementos de
linguagem uns dos outros.
Esta se√ß√£o cont√©m a descri√ß√£o dos seguintes t√≥picos:
¬∑ Express√µes
¬∑ Opera√ß√µes Aritm√©ticas
¬∑ Opera√ß√µes de Atribui√ß√£o
¬∑ Opera√ß√µes de Rela√ß√£o
¬∑ Opera√ß√µes Booleanas
¬∑ Opera√ß√µes Bin√°rias
¬∑ Outras Opera√ß√µes
¬∑ Regras de Preced√™ncia</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
166
<h3>Express√µes</h3>
Uma express√£o consiste de um ou mais operandos e s√≠mbolos de opera√ß√£o. Uma express√£o pode ser
escrita em v√°rias linhas.
<h3>Exemplos:</h3>
a++; b = 10;         // v√°rias express√µes est√£o localizados em uma linha
</p>
<pre><code class="language-mql5">
//---  uma express√£o est√° dividida em v√°rias linhas
</code></pre>
<p>
x = (y * z) /
</p>
<pre><code class="language-mql5">
    (w + 2) + 127;
</code></pre>
<p>
Uma express√£o que termina com um ponto e v√≠rgula (;) √© um operador.
<h3>Tamb√©m Veja</h3>
<h3>Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
167
<h3>Opera√ß√µes Aritm√©ticas</h3>
Opera√ß√µes aritm√©ticas incluem opera√ß√µes aditivas e multiplicativas:
Soma de vari√°veis¬†                      i = j + 2;
Diferen√ßa de vari√°veis¬†                 i = j - 3;
Mudan√ßa de sinal¬†                       x = - x;
Produto de vari√°veis¬†                   z = 3 * x;
Quociente de divis√£o¬†                   i = j / 5;
Resto de divis√£o¬†                       minutes = time % 60;
Adicionando 1 ao valor da vari√°vel¬†     i++;
Adicionando 1 ao valor da vari√°vel¬†     ++i;
Subtraindo 1 ao valor da vari√°vel¬†      k--;
Subtraindo 1 do valor da vari√°vel¬†      --k;
Opera√ß√µes de incremento e decremento s√£o aplicadas somente a vari√°veis, elas n√£o podem ser
aplicadas a constantes. O prefixo de incremento (++i) e decremento (--k) s√£o aplicados √† vari√°vel
imediatamente antes desta vari√°vel ser usada em uma express√£o.
P√≥s-incremento (i++) e p√≥s-decremento (k--) s√£o aplicados √† vari√°vel imediatamente depois da
vari√°vel ser usado em uma express√£o.
<h3>Observa√ß√£o importante</h3>
</p>
<pre><code class="language-mql5">
int i=5;
int k = i++ + ++i;
</code></pre>
<p>
Problemas computacionais podem ocorrer na movimenta√ß√£o da express√£o acima de um ambiente de
programa√ß√£o para outro (por exemplo, do Borland C++ para MQL5). Geralmente, a ordem de
computa√ß√£o depende da implementa√ß√£o do compilador. Na pr√°tica, existem duas formas de
implementar o p√≥s-decremento (p√≥s-incremento):
1. O p√≥s-decremento (p√≥s-incremento) √© aplicado √† vari√°vel depois de se calcular a express√£o toda.
2. O p√≥s-decremento (p√≥s-incremento) √© aplicado √† vari√°vel imediatamente na opera√ß√£o.
Atualmente, a primeira forma de calcular o p√≥s-decremento (p√≥s-incremento) est√° implementado no
MQL5. Mas mesmo conhecendo esta peculiaridade, n√£o se recomenda experi√™ncias com seu uso.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
int a=3;
</code></pre>
<p>
a++;            // express√£o v√°lida
</p>
<pre><code class="language-mql5">
int b=(a++)*3;  // express√£o inv√°lida
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
<h3>Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
168
<h3>Opera√ß√µes de Atribui√ß√£o</h3>
O valor da express√£o que inclui uma dada opera√ß√£o √© o valor a esquerda do operando ap√≥s a
atribui√ß√£o:
Atribuindo o valor x para a vari√°vel y¬†                                y = x;
As seguintes opera√ß√µes unem opera√ß√µes arim√©ticas e bin√°rias com opera√ß√µes de atribui√ß√£o:
Adicionando x √† vari√°vel y¬†                                            y += x;
Subtraindo x da vari√°vel y¬†                                            y -= x;
Multiplicando a vari√°vel y por x¬†                                      y *= x;
Dividindo a vari√°vel y por x¬†                                          y /= x;
Resto da divis√£o da vari√°vel y por x¬†                                  y %= x;
Opera√ß√£o AND bit a bit de representa√ß√µes bin√°rias de y e x¬†            y &amp;= x;
Opera√ß√£o AND bit a bit de representa√ß√µes bin√°rias de y e x¬†            y &amp;= x;
Opera√ß√£o AND bit a bit de representa√ß√µes bin√°rias de y e x¬†            y &amp;= x;
Opera√ß√£o OR bit a bit de representa√ß√µes bin√°rias de y e x¬†             y |= x;
Opera√ß√£o OR Exclusivo bit a bit de representa√ß√µes bin√°rias de y e x¬†   y ^= x;
Opera√ß√µes bit a bit podem ser aplicados somente em inteiros. Ao realizar a opera√ß√£o de deslocamento
l√≥gico da representa√ß√£o de y para direita/esquerda em x bits, os 5 menores d√≠gitos bin√°rios do valor
de x s√£o usados, os bits maiores s√£o descartados, isto √©, o deslocamento √© feito para 0-31 bits.
Pela opera√ß√£o %= (resto da divis√£o de y por x), o sinal resultante √© igual ao sinal do n√∫mero dividido.
O operador de atribui√ß√£o pode ser usado v√°rias vezes em uma express√£o. Neste caso o processamento
da express√£o √© realizado da esquerda para direta:
 y=x=3;
Primeiro, a vari√°vel x ser√° atribu√≠da o valor 3, ent√£o a vari√°vel y ser√° atribu√≠da o valor de x, isto √©,
tamb√©m 3.
<h3>Tamb√©m Veja</h3>
<h3>Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
169
<h3>Opera√ß√µes de Rela√ß√£o</h3>
A booleana FALSE √© representada pelo valor zero inteiro, enquanto que a booleana TRUE √©
representada por qualquer valor n√£o inteiro.
O valor de express√µes contendo opera√ß√µes de rela√ß√£o ou opera√ß√µes l√≥gicas √© FALSE (0) ou TRUE (1).
True se a √© igual a b¬†                       a == b;
True se a n√£o igual a b¬†                     a != b;
True se a √© menor que b¬†                     a &lt; b;
True se a n√£o √© menor que b¬†                 a &gt; b;
True se a √© menor ou igual a b¬†              a &lt;= b;
True se a √© maior ou igual a b¬†              a &gt;= b;
A igualdade de dois n√∫meros reais n√£o pode ser comparada. Na maioria dos casos, dois n√∫meros
aparentemente id√™nticos podem ser desiguais por causa da diferen√ßa de valores na 15 casa decimal. A
fim de comparar corretamente dois n√∫meros reais, compare a diferen√ßa normalizada destes n√∫meros
com zero.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
bool CompareDoubles(double number1,double number2)
  {
   if(NormalizeDouble(number1-number2,8)==0) return(true);
   else return(false);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   double first=0.3;
   double second=3.0;
   double third=second-2.7;
   if(first!=third)
     {
      if(CompareDoubles(first,third))
         printf(&quot;%.16f e %.16f s√£o iguais&quot;,first,third);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
// Resultado: 0.3000000000000000  0.2999999999999998   s√£o iguais
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
<h3>Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
170
<h3>Opera√ß√µes Booleanas</h3>
<h3>Nega√ß√£o L√≥gica NOT (!)</h3>
Operando da nega√ß√£o l√≥gia (!) deve ser de tipo aritm√©tico. O resultado √© TRUE (1), se o valor do
operando √© FALSE (0); e √© igual a FALSE (0), se o operando difere de FALSE (0).
if(!a) Print(&quot;n√£o &#x27;a&#x27;&quot;);
<h3>Opera√ß√£o l√≥gica OR (||)</h3>
Opera√ß√£o OR l√≥gico (||) entre valores x e y. O valor da express√£o √© TRUE (1), se os valores x ou y s√£o
verdadeiros (not null). Sen√£o - FALSE (0).
if(x&lt;0 || x&gt;=max_bars) Print(&quot;fora da faixa&quot;);
<h3>Opera√ß√£o l√≥gica AND (&amp;&amp;)</h3>
Opera√ß√£o l√≥gica AND (&amp;&amp;) entre valores de x e y. O valor da express√£o √© TRUE (1), se os valores de x
e y s√£o verdadeiros (not null). Sen√£o - FALSE (0).
<h3>Estima√ß√£o breve de Opera√ß√µes Booleanas</h3>
O esquema do chamado &quot;brief estimate&quot; (estima√ß√£o breve) √© aplicado a opera√ß√µes booleanas, isto √©, o
c√°lculo da express√£o √© finalizado quando o resultado da express√£o pode ser precisamente estimado.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- o primeiro exemplo de estima√ß√£o breve
   if(func_false() &amp;&amp; func_true())
     {
      Print(&quot;Opera√ß√£o &amp;&amp;: Voc√™ nunca ver√° esta express√£o&quot;);
     }
   else
     {
      Print(&quot;Opera√ß√£o &amp;&amp;: Resultado da primeira express√£o √© falso, ent√£o a segunda n√£o
     }
//--- o segundo exemplo da estima√ß√£o breve
   if(!func_false() || !func_true())
     {
      Print(&quot;Opera√ß√£o ||: Resultado da primeira express√£o √© verdadeiro,ent√£o a segunda
     }
   else
     {
      Print(&quot;Opera√ß√£o ||: Voc√™ nunca ver√° esta express√£o&quot;);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
171
</p>
<pre><code class="language-mql5">
//| a fun√ß√£o sempre retorna false¬†                                   |
//+------------------------------------------------------------------+
bool func_false()
  {
   Print(&quot;Fun√ß√£o func_false()&quot;);
   return(false);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| a fun√ß√£o sempre retorna true¬†                                    |
//+------------------------------------------------------------------+
bool func_true()
  {
   Print(&quot;Fun√ß√£o func_true()&quot;);
   return(true);
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
<h3>Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
172
<h3>Opera√ß√µes Bin√°rias</h3>
<h3>Complementar de Um</h3>
Complementar do valor da vari√°vel at√© um. O valor da express√£o cont√©m 1 em todos os d√≠gitos onde o
valor da vari√°vel contem 0, e 0 em todos os demais d√≠gitos onde a vari√°vel contem 1.
b = ~n;
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   char a=&#x27;a&#x27;,b;
   b=~a;
   Print(&quot;a = &quot;,a, &quot;  b = &quot;,b);  
// O resultado ser√°:
// a = 97   b = -98
</code></pre>
<p>
<h3>Deslocamento para Direita</h3>
A representa√ß√£o bin√°ria de x √© deslocada para direita em y d√≠gitos. Se o valor a ser deslocado √© de um
tipo sem sinal (unsigned type), o deslocamento l√≥gico para a direita √© feito, isto √©, os bits do lado
esquerdo liberados ser√£o preenchido com zeros.
Se o valor a ser desloca √© de um tipo com sinal (signed type), o deslocamento aritm√©tico para direita √©
feito, isto √©, os d√≠gitos do lado esquerdo liberados ser√£o preenchidos com o valor do bit de sinal (sign
bit) (se o n√∫mero √© positivo, o valor do bit de sinal √© 0, se o n√∫mero √© negativo, o valor do bit de sinal
√© 1).
x = x &gt;&gt; y;
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   char a=&#x27;a&#x27;,b=&#x27;b&#x27;;
   Print(&quot;Antes:  a = &quot;,a, &quot;  b = &quot;,b); 
//--- deslocamento para direita
   b=a&gt;&gt;1;
   Print(&quot;Ap√≥s:   a = &quot;,a, &quot;  b = &quot;,b); 
// O resultado ser√°:
// Antes:  a = 97   b = 98
// Ap√≥s:   a = 97   b = 48
</code></pre>
<p>
<h3>Deslocamento para Esquerda</h3>
A representa√ß√£o bin√°ria de x √© deslocada para esquerda em y d√≠gitos, os d√≠gitos do lado direito
liberados s√£o preenchidos com zero.
x = x &lt;&lt; y;
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   char a=&#x27;a&#x27;,b=&#x27;b&#x27;;
   Print(&quot;Antes:  a = &quot;,a, &quot;  b = &quot;,b); 
//--- deslocamento para a esquerda</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
173
</p>
<pre><code class="language-mql5">
   b=a&lt;&lt;1;
   Print(&quot;Ap√≥s:   a = &quot;,a, &quot;  b = &quot;,b); 
// O resultado ser√°:
// Antes:  a = 97   b = 98
// Ap√≥s:   a = 97   b = -62
</code></pre>
<p>
N√£o √© recomend√°vel deslocar um n√∫mero maior ou igual de bits que o comprimento da vari√°vel
deslocada, porque o resultado de tal opera√ß√£o √© indefinido.
<h3>Opera√ß√£o AND bit a bit</h3>
A opera√ß√£o AND bit a bit em representa√ß√µes bin√°rias de x e y. O valor da express√£o contem 1 (TRUE)
em todos os d√≠gitos onde ambos x e y cont√©m n√£o-zero, e contem 0 (FALSE) em todos os demais
d√≠gitos.
b = ((x &amp; y) != 0);
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   char a=&#x27;a&#x27;,b=&#x27;b&#x27;;
//--- opera√ß√£o AND
   char c=a&amp;b;
   Print(&quot;a = &quot;,a,&quot;  b = &quot;,b);
   Print(&quot;a &amp; b = &quot;,c);
// O resultado ser√°:
// a = 97   b = 98
// a &amp; b = 96
</code></pre>
<p>
<h3>Opera√ß√£o OR bit a bit</h3>
A opera√ß√£o OR bit a bit de representa√ß√µes bin√°rias de x e y. O valor da express√£o contem 1 em todos
os d√≠gitos onde x ou y n√£o cont√©m 0, e cont√©m 0 em todos os demais d√≠gitos.
b = x | y;
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   char a=&#x27;a&#x27;,b=&#x27;b&#x27;;
//--- opera√ß√£o OR
   char c=a|b;
   Print(&quot;a = &quot;,a,&quot;  b = &quot;,b);
   Print(&quot;a | b = &quot;,c);
// O resultado ser√°:
// a = 97   b = 98
// a | b = 99
</code></pre>
<p>
<h3>Opera√ß√£o OR Exclusivo bit a bit</h3>
A opera√ß√£o OR exclusivo bit a bit (eXclusive OR) de representa√ß√µes bin√°rias de x e y. O valor da
express√£o contem 1 em todos os d√≠gitos onde x e y tem valores bin√°rios diferentes, e cont√©m 0 em
todos os demais d√≠gitos.
b = x ^ y;</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
174
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   char a=&#x27;a&#x27;, b=&#x27;b&#x27;;
//--- opera√ß√£o OR Exclusivo
   char c=a^b;
   Print(&quot;a = &quot;,a,&quot;  b = &quot;,b);
   Print(&quot;a ^ b = &quot;,c);
// O resultado ser√°:
// a = 97   b = 98
// a ^ b = 3
</code></pre>
<p>
Opera√ß√µes bit a bit s√£o realizadas somente com inteiros.
<h3>Tamb√©m Veja</h3>
<h3>Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
175
<h3>Outras Opera√ß√µes</h3>
<h3>Indexa√ß√£o ( [] )</h3>
Ao endere√ßar o i-√©simo elemento de um array, o valor da express√£o √© o valor da vari√°vel com o
n√∫mero serial i.
<h3>Exemplo:</h3>
array[i] = 3; // Atribui o valor de 3 ao i-√©simo elemento do array.
Somente um inteiro pode ser √≠ndice de um array. S√£o permitidos arrays com 4 dimens√µes ou menos.
Cada medida √© indexada de 0 ao tamanho da medida - 1. Em particular, para um array de uma
dimens√£o consistindo de 50 elementos, a refer√™ncia ao primeiro elemento se assemelhar√° a array[0],
e a refer√™ncia ao √∫ltimo elemento ser√° array[49].
Ao endere√ßar al√©m do array, o subsistema em execu√ß√£o gerar√° um erro cr√≠tico, e o programa ser√°
interrompido.
Chamando Fun√ß√£o com argumentos x1, x2 ,..., xn
Cada argumento pode representar uma constante, vari√°vel, ou express√£o do correspondente tipo. Os
argumentos passados s√£o separados por v√≠rgula e devem estar dentro dos par√™nteses, o par√™ntese de
abertura deve seguir o nome da fun√ß√£o chamada.
O valor da express√£o √© o valor retornado pela fun√ß√£o. Se o valor retornado √© do do tipo void, a
chamada da fun√ß√£o n√£o pode ser colocada a direita de um operador de atribui√ß√£o. Repare que a ordem
de execu√ß√£o x1, ..., xn √© garantida.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   int length=1000000;   
   string a=&quot;a&quot;,b=&quot;b&quot;,c;
//--- Outras Opera√ß√µes
   int start=GetTickCount(),stop;
   long i;
   for(i=0;i&lt;length;i++)
     {
      c=a+b;
     }
   stop=GetTickCount();
   Print(&quot;tempo para &#x27;c = a + b&#x27; = &quot;,(stop-start),&quot; milissegundos, i = &quot;,i);
</code></pre>
<p>
<h3>Opera√ß√£o V√≠rgula ( , )</h3>
Express√µes separadas por v√≠rgulas s√£o executadas da esquerda para direita. Todos os efeitos
colaterais do c√°lculo da express√£o a esquerda podem aparecer antes da express√£o a direita ser
calculada. O tipo do resultado e o valor coincidem com aqueles da express√£o a direita. A lista de
par√¢metros a ser passada (seja acima) pode ser considerada como um exemplo.
<h3>Exemplo:</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
176
for(i=0,j=99; i&lt;100; i++,j--) Print(array[i][j]);
<h3>Operador Ponto ( . )</h3>
Para o acesso direto a membros p√∫blicos de estruturas e classes, a opera√ß√£o ponto √© usada. Sintaxe:
<h3>Nome_da_vari√°vel_do_tipo_estrutura.Nome_do_membro</h3>
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   struct SessionTime
     {
      string sessionName;
      int    startHour;
      int    startMinutes;
      int    endHour;
      int    endMinutes;
     } st;
   st.sessionName=&quot;Asian&quot;;
   st.startHour=0;
   st.startMinutes=0;
   st.endHour=9;
   st.endMinutes=0;
</code></pre>
<p>
Opera√ß√£o de Resolu√ß√£o de Escopo ( :: )
Cada fun√ß√£o em um programa MQL5 tem seu pr√≥prio escopo de execu√ß√£o. Por exemplo, a fun√ß√£o de
sistema Print() √© realizada em um escopo global. Fun√ß√µes Importadas s√£o chamadas no escopo do
correspondente import. M√©todos de fun√ß√µes de classes t√™m o escopo da correspondente classe. A
sintaxe do operador de resolu√ß√£o de escopo √© o seguinte:
[Scope_name]::Function_name(parameters)
Se n√£o existir nenhum nome de escopo, isto √© uma orienta√ß√£o expl√≠cita para usar o escopo global. Se
n√£o existir nenhuma opera√ß√£o de resolu√ß√£o de escopo, a fun√ß√£o √© procurada no escopo mais pr√≥ximo.
Se n√£o existir nenhuma fun√ß√£o no escopo local, a procura √© conduzida no escopo global.
A resolu√ß√£o de escopo √© tamb√©m usada para definir fun√ß√µes membros de classe.
type Class_name::Function_name(parameters_description)
</p>
<pre><code class="language-mql5">
   {
// corpo da fun√ß√£o
   }
</code></pre>
<p>
O uso de v√°rias fun√ß√µes do mesmo nome a partir de contextos de execu√ß√£o diferentes em um
programa pode causar ambig√ºidade. A ordem de prioridade das chamadas da fun√ß√£o sem
especifica√ß√£o de escopo expl√≠cita √© a seguinte:
1. M√©todos de classe. Se nenhuma fun√ß√£o com o nome especificado for definida na classe, mova para
o pr√≥ximo n√≠vel.
2. Fun√ß√µes do MQL5. Se o idioma n√£o tiver essa fun√ß√£o, v√° para o pr√≥ximo n√≠vel.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
177
3. Fun√ß√µes globais definidas pelo usu√°rio. Se nenhuma fun√ß√£o com o nome especificado for
encontrada, mova para o pr√≥ximo n√≠vel.
4. Fun√ß√µes importadas. Se nenhuma fun√ß√£o com o nome especificado for encontrada, o compilador
retornar√° um erro.
Para evitar a ambig√ºidade de chamadas de fun√ß√£o, sempre explicitamente especificar o escopo de
fun√ß√£o usando a opera√ß√£o de resolu√ß√£o de escopo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property script_show_inputs
</code></pre>
<p>
#import &quot;kernel32.dll&quot;
</p>
<pre><code class="language-mql5">
   int GetLastError(void);
</code></pre>
<p>
#import
</p>
<pre><code class="language-mql5">
class CCheckContext
  {
   int         m_id;
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
               CCheckContext() { m_id=1234; }
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   int         GetLastError() { return(m_id); }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
class CCheckContext2 : public CCheckContext
  {
   int         m_id2;
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
               CCheckContext2() { m_id2=5678; }
   void        Print();
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   int         GetLastError() { return(m_id2); }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
void CCheckContext2::Print()
  {
   ::Print(&quot;Terminal GetLastError&quot;,::GetLastError());
   ::Print(&quot;kernel32 GetLastError&quot;,kernel32::GetLastError());
   ::Print(&quot;parent GetLastError&quot;,CCheckContext::GetLastError());
   ::Print(&quot;our GetLastError&quot;,GetLastError());
</code></pre>
<p>
  }  
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   CCheckContext2 test;
   test.Print();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
178
Opera√ß√£o de Obten√ß√£o do Tamanho do Tipo de Dados ou Tamanho
do Objeto de Qualquer Tipo de Dados ( sizeof )
Usando a opera√ß√£o sizeof o tamanho de mem√≥ria correspondente a um identificador ou tipo pode ser
definido. A opera√ß√£o sizeof √© do seguinte formato:
<h3>Exemplo:</h3>
sizeof(expression)
Qualquer identificador, ou nome de tipo entre colchetes pode ser usado como uma express√£o. Observe
que o nome tipo void n√£o pode ser usado, e o identificar n√£o pode pertencer ao campo de bits, ou ser
um nome de fun√ß√£o.
Se a express√£o for o nome de um array est√°tico (isto √©, a primeira dimens√£o √© dada), ent√£o o
resultado √© o tamanho do array inteiro (isto √©, o produto do n√∫mero de elementos e o comprimento do
tipo. Se a express√£o √© o nome de um array din√¢mico (a primeira dimens√£o n√£o √© especificada), o
resultado ser√° o tamanho do objeto do array din√¢mico.
Quando sizeof √© aplicado ao nome de um tipo de estrutura ou classe, ou ao identificador do tipo de
uma estrutura ou classe, o resultado √© tamanho real da estrutura ou classe.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   struct myStruct
     {
      char   h;
      int    b;
      double f;
     } str;
   Print(&quot;sizeof(str) = &quot;,sizeof(str));
   Print(&quot;sizeof(myStruct) = &quot;,sizeof(myStruct));   
</code></pre>
<p>
O tamanho √© calculado na etapa de compila√ß√£o.
<h3>Veja Tamb√©m</h3>
<h3>Regras de Preced√™ncia</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
179
<h3>Regras de Preced√™ncia</h3>
Cada grupo de opera√ß√µes na tabela tem a mesma prioridade. Quanto mais alta a prioridade de
opera√ß√µes, mais alta √© a posi√ß√£o do grupo na tabela. As regras de preced√™ncia determinar o
agrupamento de opera√ß√µes e operandos.
Aten√ß√£o: A preced√™ncia de opera√ß√µes na linguagem MQL5 corresponde √† prioridade adotada em C++, e
difere da prioridade dada na linguagem MQL4.
<h3>Opera√ß√£o</h3>
<h3>Descri√ß√£o</h3>
<h3>Ordem de Execu√ß√£o</h3>
()
[]
.
<h3>Chamada de Fun√ß√£o</h3>
<h3>Referenciando um elemento de array</h3>
<h3>Referenciando</h3>
um 
elemento 
de
estrutura
<h3>Da esquerda para direita</h3>
!
~
‚Äì
++
--
(tipo)
sizeof
<h3>Nega√ß√£o l√≥gica</h3>
<h3>Nega√ß√£o bit a bit (complemento)</h3>
<h3>Mudan√ßa de Sinal</h3>
<h3>Incremento por um</h3>
<h3>Decremento por um</h3>
<h3>Convers√£o de Tipo (Typecasting)</h3>
<h3>Determina√ß√£o de tamanho em bytes</h3>
<h3>Direita para esquerda</h3>
*
/
%
<h3>Multiplica√ß√£o</h3>
<h3>Divis√£o</h3>
<h3>Quociente de divis√£o</h3>
<h3>Da esquerda para direita</h3>
+
‚Äì
<h3>Adi√ß√£o</h3>
<h3>Subtra√ß√£o</h3>
<h3>Da esquerda para direita</h3>
&lt;&lt;
&gt;&gt;
<h3>Deslocamento para esquerda</h3>
<h3>Deslocamento para direita</h3>
<h3>Da esquerda para direita</h3>
&lt;
&lt;=
&gt;
&gt;=
<h3>Menor que</h3>
<h3>Menor ou igual a</h3>
<h3>Maior que</h3>
<h3>Maior ou igual a</h3>
<h3>Da esquerda para direita</h3>
==
!=
<h3>Igual</h3>
<h3>N√£o igual</h3>
<h3>Da esquerda para direita</h3>
&amp;
<h3>Opera√ß√£o AND bit a bit</h3>
<h3>Da esquerda para direita</h3>
^
<h3>OR exclusivo bit a bit</h3>
<h3>Da esquerda para direita</h3>
|
<h3>Opera√ß√£o OR bit a bit</h3>
<h3>Da esquerda para direita</h3>
&amp;&amp;
<h3>Opera√ß√£o l√≥gica AND</h3>
<h3>Da esquerda para direita</h3>
||
<h3>Opera√ß√£o l√≥gica OR</h3>
<h3>Da esquerda para direita</h3>
?:
<h3>Operador condicional</h3>
<h3>Direita para esquerda</h3>
=
*=
<h3>Atribui√ß√£o</h3>
<h3>Multiplica√ß√£o com atribui√ß√£o</h3>
<h3>Direita para esquerda</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
180
<h3>Opera√ß√£o</h3>
<h3>Descri√ß√£o</h3>
<h3>Ordem de Execu√ß√£o</h3>
/=
%=
+=
-=
&lt;&lt;=
&gt;&gt;=
&amp;=
^=
|=
<h3>Divis√£o com atribui√ß√£o</h3>
<h3>Quociente de divis√£o com atribui√ß√£o</h3>
<h3>Adi√ß√£o com atribui√ß√£o</h3>
<h3>Subtra√ß√£o com atribui√ß√£o</h3>
<h3>Deslocamento</h3>
para 
esquerda 
com
atribui√ß√£o
<h3>Deslocamento</h3>
para 
direita 
com
atribui√ß√£o
<h3>AND bit a bit com atribui√ß√£o</h3>
<h3>OR Exclusivo com atribui√ß√£o</h3>
<h3>OR bit a bit com atribui√ß√£o</h3>
,
<h3>V√≠rgula</h3>
<h3>Da esquerda para direita</h3>
Para mudar a ordem de execu√ß√£o de opera√ß√£o, s√£o usados par√™nteses, que s√£o de prioridade mais
alta.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
181
<h3>Operadores</h3>
Operadores de linguagem descrevem algumas opera√ß√µes algor√≠tmicas que devem ser executadas para
se realizar uma tarefa. O corpo do programa √© uma seq√º√™ncia de tais operadores. Operadores, um a
um, s√£o separados por ponto e v√≠rgula.
<h3>Operador</h3>
<h3>Descri√ß√£o</h3>
<h3>Operador Composto {}</h3>
Um ou mais operadores de qualquer tipo, entre chaves {}
<h3>Operador de Express√£o (;)</h3>
Qualquer express√£o que termina com ponto e v√≠rgula (;)
</p>
<pre><code class="language-mql5">
return operador
</code></pre>
<p>
Finaliza a fun√ß√£o corrente e retorna o controle para o programa
chamador
if-else operador condicional
√â usado quando √© necess√°rio fazer uma escolha
?: operador condicional
Um an√°logo simples do operador condicional if-else
switch operador de sele√ß√£o
Passa o controle para o operador que corresponde ao valor da
express√£o
</p>
<pre><code class="language-mql5">
while operador de loop
</code></pre>
<p>
Realiza uma opera√ß√£o at√© que a express√£o verificada se torne
falsa. A express√£o √© verificada antes de cada itera√ß√£o
</p>
<pre><code class="language-mql5">
for operador de loop
</code></pre>
<p>
Realiza uma opera√ß√£o at√© que a express√£o verificada se torne
falsa. A express√£o √© verificada antes de cada itera√ß√£o
do-while operador de loop
Realiza uma opera√ß√£o at√© que a express√£o verificada se torne
falsa. A condi√ß√£o de finaliza√ß√£o √© verificada, ap√≥s cada loop. O
corpo do loop √© executado pelo menos uma vez.
break operador
Finaliza a execu√ß√£o do operador externo adjunto mais pr√≥ximo:
switch, while, do-while ou for.
continue operador
Passa controle para o come√ßo do loop do operador externo mais
pr√≥ximo: while, do-while ou for
@ operator
Realiza a multiplica√ß√£o de matrizes de acordo com as regras da
√°lgebra linear. Permite realizar multiplica√ß√£o de matrizes, vetores
e produto escalar de vetores.
new operador
Cria um objeto de tamanho apropriado e retorna um descritor do
objeto criado.
delete operador
Exclui o objeto criado pelo operador new
Um operador pode ocupar uma ou mais linhas. Dois ou mais operadores podem ser colocados na
mesma linha. Operadores que controlam a ordem de execu√ß√£o (if, if-else, switch, while e for) podem
ser aninhados (encaixados) um no outro.
<h3>Exemplo:</h3>
if(Month() == 12)
  if(Day() == 31) Print(&quot;Feliz Ano Novo!&quot;);
<h3>Tamb√©m Veja</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
182
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
183
<h3>Operador Composto</h3>
Um operador composto (um bloco) consiste de um ou mais operadores de qualquer tipo, entre chaves
</p>
<pre><code class="language-mql5">
{}. A chave de fechamento deve ser seguida por dois pontos (;).
</code></pre>
<p>
<h3>Exemplo:</h3>
if(x==0)
</p>
<pre><code class="language-mql5">
  {
   Print(&quot;posi√ß√£o inv√°lida x = &quot;,x);
   return;
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
184
<h3>Operador de Express√£o</h3>
Qualquer express√£o seguida por ponto e v√≠rgula (;) √© o operador. Aqui est√£o alguns exemplos de
operadores de express√£o.
<h3>Operador de Atribui√ß√£o</h3>
<h3>Identificador = express√£o;</h3>
  x=3;
  y=x=3; 
  bool equal=(x==y);
Um operador de atribui√ß√£o pode ser usado muitas vezes em uma express√£o. Neste caso, o
processamento da express√£o √© realizado da direita para a esquerda.
<h3>Operador de Chamada de Fun√ß√£o</h3>
<h3>Function_name (argument1,..., argumentN);</h3>
<h3>FileClose(file);</h3>
<h3>Operador Empty</h3>
Consiste somente de um ponto e v√≠rgula (;) e √© usado para denotar um corpo vazio de um operador de
controle.
<h3>Veja Tamb√©m</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
185
<h3>Operador return</h3>
O operador return finaliza a execu√ß√£o da fun√ß√£o corrente e retorna o controle para o programa
chamador. O resultado do c√°lculo da express√£o √© retornado para a fun√ß√£o chamadora. A express√£o
pode conter um operador de atribui√ß√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int CalcSum(int x, int y)
  {
   return(x+y);
</code></pre>
<p>
  }
Em fun√ß√µes com o tipo de retorno void, o operador return sem express√£o deve ser usada:
</p>
<pre><code class="language-mql5">
void SomeFunction()
  {
   Print(&quot;Ol√°!&quot;);
   return;    // este operador pode ser removido
</code></pre>
<p>
  }
A chave direita da fun√ß√£o (&quot;}&quot;) significa execu√ß√£o impl√≠cita do operador return sem express√£o.
Pode ser retornado: tipos simples, estruturas simples, ponteiros de objetos. Com o operador return
n√£o se pode retornar arrays, objetos de classe, vari√°veis de tipo estrutura composta.
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
186
<h3>Operador Condicional If-Else</h3>
O operador IF - ELSE √© usado quando uma escolha deve ser feita. Formalmente, a sintaxe √© a
seguinte:
</p>
<pre><code class="language-mql5">
if (express√£o)
¬†   operador1
</code></pre>
<p>
else
</p>
<pre><code class="language-mql5">
¬†   operador2
</code></pre>
<p>
Se a express√£o √© verdadeira, o operador1 √© executado e o controle √© dado ao operador que segue o
operador2. Se a express√£o √© falsa, o operador2 √© executado.
A parte else do operador if pode ser omitida. Assim, uma diverg√™ncia pode aparecer em operadores
aninhados (encaixados) if com omiss√£o da parte else. Neste caso, o else se refere ao operador
anterior if mais pr√≥ximo no mesmo bloco que n√£o tem a parte else.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
//--- A parte else refere-se ao segundo operador if:
</code></pre>
<p>
if(x&gt;1)
</p>
<pre><code class="language-mql5">
   if(y==2) z=5;
</code></pre>
<p>
else     z=6;
</p>
<pre><code class="language-mql5">
//--- A parte else refere-se ao primeiro operador if:
</code></pre>
<p>
if(x&gt;l)
</p>
<pre><code class="language-mql5">
  {
   if(y==2) z=5;
</code></pre>
<p>
  }
else        z=6;
</p>
<pre><code class="language-mql5">
//--- Operadores aninhados
</code></pre>
<p>
if(x==&#x27;a&#x27;)
</p>
<pre><code class="language-mql5">
  {
   y=1;
</code></pre>
<p>
  }
else if(x==&#x27;b&#x27;)
</p>
<pre><code class="language-mql5">
  {
   y=2;
   z=3;
</code></pre>
<p>
  }
else if(x==&#x27;c&#x27;)
</p>
<pre><code class="language-mql5">
  {   
   y=4;
</code></pre>
<p>
  }
else Print(&quot;ERROR&quot;);
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
187
<h3>Operador Tern√°rio ?</h3>
A forma geral do operador tern√°rio √© a seguinte:
express√£o1 ? express√£o2 : express√£o3
Para o primeiro operando - &quot;express√£o1&quot; - qualquer express√£o que resulte em um valor do tipo bool
pode ser usado. Se o resultado √© true, ent√£o o operador definido pelo segundo operando, isto √©,
&quot;express√£o2&quot;, √© executado.
Se o primeiro operando √© false, o terceiro operando - &quot;express√£o3&quot; √© executado. Os segundo e terceiro
operandos, isto √©, &quot;express√£o2&quot; e &quot;express√£o3&quot; devem retornar valores de algum tipo e n√£o devem ser
do tipo void. O resultado da execu√ß√£o do operador condicional √© o resultado de express√£o2 ou o
resultado de express√£o3, dependendo do resultado de express√£o1.
</p>
<pre><code class="language-mql5">
//--- diferen√ßa normalizada entre pre√ßos de abertura e fechamento para intervalo de um
double true_range = (High==Low)?0:(Close-Open)/(High-Low);
</code></pre>
<p>
<h3>Esta entrada √© equivalente ao seguinte:</h3>
</p>
<pre><code class="language-mql5">
   double true_range;
   if(High==Low)true_range=0;               // se o M√°ximo e o M√≠nimo s√£o iguais
   else true_range=(Close-Open)/(High-Low); // se a faixa n√£o √© nula
</code></pre>
<p>
<h3>Restri√ß√µes ao Uso do Operador</h3>
Baseado no valor da &quot;express√£o1&quot;, o operador deve retornar um dentre dois valores - ou &quot;express√£o2&quot;
ou &quot;express√£o3&quot;. Existem v√°rias limita√ß√µes nessas express√µes:
1. N√£o confunda o tipo user-defined (definida pelo usu√°rio) com o tipo simples ou enumerador. NULL
pode ser usado para ponteiro.
2. Se os tipos dos valores s√£o simples, o operador ser√° do tipo m√°ximo (veja Convers√£o de Tipos
(type casting)).
3. Se algum dos valores √© uma enumera√ß√£o e o segundo valor √© de um tipo num√©rico, a enumera√ß√£o √©
substitu√≠da por int e a segunda regra √© aplicada.
4. Se ambos os valores s√£o enumera√ß√µes, seus tipos devem ser id√™nticos, e o operador ser√° do tipo
enumera√ß√£o.
Restri√ß√µes ao tipos user-defined (classes ou estruturas definidas pelo usu√°rio):
a) Os tipos devem ser id√™nticos ou um deve ser derivado do outro.
b) Se os tipo n√£o forem id√™nticos (heran√ßa), ent√£o a filha √© implicitamente convertida para o pai, isto
√©, o operador ser√° do tipo paterno.
c) N√£o confunda objetos com ponteiros - ambas as express√£o ou s√£o objetos ou s√£o ponteiros. NULL
pode ser usado para ponteiro.
<h3>Observa√ß√£o</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
188
Cuidado ao usar o operador condicional como um argumento de uma fun√ß√£o de sobrecarga, porque o
tipo do resultado de um operador condicional √© definido na durante a compila√ß√£o do programa. E este
tipo √© definido como a maior dos tipos &quot;expression2&quot; e &quot;expression3&quot;.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void func(double d) { Print(&quot;double argumento: &quot;,d); }
void func(string s) { Print(&quot;string argumento: &quot;,s); }
bool   Expression1=true;
double Expression2=M_PI;
string Expression3=&quot;3.1415926&quot;;
void OnStart()
  {
   func(Expression2);
   func(Expression3);
   func(Expression1?Expression2:Expression3);   // aviso sobre convers√£o impl√≠cita par
   func(!Expression1?Expression2:Expression3);  // aviso sobre convers√£o impl√≠cita par
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//   Resultado:
//   double argumento: 3.141592653589793
//   string argumento: 3.1415926
//   string argumento: 3.141592653589793
//   string argumento: 3.1415926
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
189
<h3>Operador switch</h3>
Compara o valor da express√£o com constantes em todas as variantes de case e passa o controle para o
operador, que corresponde ao valor da express√£o. Cada variante de case pode ser marcada com uma
constante inteira, uma constante literal ou uma express√£o constante. A express√£o constante n√£o pode
conter vari√°veis ou chamadas de fun√ß√£o. A express√£o do operador switch deve ser do tipo inteiro ‚Äì int
ou uint.
switch(express√£o)
</p>
<pre><code class="language-mql5">
  {
   case constantes: operadores
   case constantes: operadores
      ...
   default: operadores
</code></pre>
<p>
  }
Operadores marcados pelo r√≥tulo default s√£o executados se nenhuma das constantes nos operadores
case forem iguais ao valor da express√£o. A variante default n√£o precisa ser necessariamente
declarada e n√£o precisa ser necessariamente ser a √∫ltimo. Se nenhuma das constantes corresponder ao
valor da express√£o e a variante default n√£o estiver presente, nenhuma a√ß√£o ser√° executada.
A palavra-chave case com uma constante s√£o apenas r√≥tulos, e se operadores forem executados para
alguma variante case, o programa continuar√° a executar os operadores de todas as subseq√ºentes
variantes at√© que o operador break ocorra. Isso permite vincular uma seq√º√™ncia de operadores com
v√°rias variantes.
Uma express√£o constante √© calculada durante a compila√ß√£o. Duas constantes em um operador switch
n√£o podem ter o mesmo valor.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
//--- Primeiro exemplo
</code></pre>
<p>
switch(x)
</p>
<pre><code class="language-mql5">
  {
   case &#x27;A&#x27;:
      Print(&quot;CASE A&quot;);
      break;
   case &#x27;B&#x27;:
   case &#x27;C&#x27;:
      Print(&quot;CASE B ou C&quot;);
      break;
   default:
      Print(&quot;NOT A, B ou C&quot;);
      break;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//---  Segundo exemplo
   string res=&quot;&quot;;
   int i=0;
   switch(i)
     {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
190
</p>
<pre><code class="language-mql5">
      case 1:
         res=i;break;
      default:
         res=&quot;default&quot;;break;
      case 2:
         res=i;break;
      case 3:
         res=i;break;
     }
   Print(res);
/*
   Result
   default
</code></pre>
<p>
*/
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
191
<h3>Operador de Loop while</h3>
O operador while consiste de uma express√£o verificada e um operador:
while(expression)
¬†operador;
Se a express√£o √© verdadeira, o operador √© executado at√© que a express√£o se torne falsa. Se a
express√£o √© falsa, o controle √© passado para o pr√≥ximo operador. O valor da express√£o √© definido
antes do operador ser executado. Portanto se a express√£o √© falsa logo no come√ßo, o operador n√£o ser√°
executado.
<h3>Observa√ß√£o</h3>
Se √© esperado que um grande n√∫mero de itera√ß√µes seja tratado por um loop, √© recomend√°vel que se
verifique a ocorr√™ncia de uma finaliza√ß√£o de programa for√ßada usando a fun√ß√£o IsStopped().
<h3>Exemplo:</h3>
while(k&lt;n &amp;&amp; !IsStopped())
</p>
<pre><code class="language-mql5">
  {
   y=y*x;
   k++;
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
192
<h3>Operador de Loop For</h3>
O operador for consiste de tr√™s express√µes e um operador execut√°vel:
for(express√£o1; express√£o2; express√£o3)
¬† operador;
Express√£o1 descreve a inicializa√ß√£o do loop. Expression2 verifica as condi√ß√µes de finaliza√ß√£o do loop.
Se for verdadeira, o corpo do loop do for √© executado. Realiza uma opera√ß√£o at√© que a express√£o
verificada se torne falsa. Se a express√£o √© verdadeira, o operador1 √© executado e o controle √© dado ao
operador que segue o operador2. Expression3 √© calculado ap√≥s cada itera√ß√£o.
O operador for √© equivalente √† seguinte sucess√£o de operadores:
express√£o1;
while(express√£o2)
</p>
<pre><code class="language-mql5">
  {
</code></pre>
<p>
¬† operador;
¬† express√£o3;
  };
Quaisquer das tr√™s ou todas as tr√™s express√µes podem estar ausentes no operador for, mas o ponto e
v√≠rgula (;) que as separada n√£o pode ser omitido. Se express√£o2 √© omitida, ela √© considerada como
verdadeira. O operador for(;;) √© um loop cont√≠nuo, equivalente ao operador while(1). As express√µes 1
e 3 podem consistir de v√°rias express√µes combinadas por um operador v√≠rgula &#x27;,&#x27;.
<h3>Observa√ß√£o</h3>
Se √© esperado que um grande n√∫mero de itera√ß√µes seja tratado por um loop, √© recomend√°vel que se
verifique a ocorr√™ncia de uma finaliza√ß√£o de programa for√ßada usando a fun√ß√£o IsStopped().
<h3>Exemplos:</h3>
for(x=1;x&lt;=7000; x++)
</p>
<pre><code class="language-mql5">
  {
   if(IsStopped())
      break;
   Print(MathPower(x,2));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//--- Outro exemplo
</code></pre>
<p>
for(;!IsStopped();)
</p>
<pre><code class="language-mql5">
  {
   Print(MathPower(x,2));
   x++;
   if(x&gt;10) break;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//--- Terceiro exemplo
</code></pre>
<p>
for(i=0,j=n-l;i&lt;n &amp;&amp; !IsStopped();i++,j--) a[i]=a[j];
<h3>Tamb√©m Veja</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
193
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
194
<h3>Operador de loop do while</h3>
Os loops for e while verificam o t√©rmino no come√ßo, n√£o no fim de um loop. O terceiro operador de
loop do - while verifica a condi√ß√£o de t√©rmino no fim, ap√≥s cada intera√ß√£o do loop. O corpo do loop √©
sempre executado pelo menos uma vez.
do
¬† operador;
while(expression);
Primeiro o operador √© executado, ent√£o a express√£o √© calculada. Se a express√£o for verdadeira, ent√£o
o operador √© executado novamente, e assim por diante. Se a express√£o se tornar falsa, o loop
termina.
<h3>Observa√ß√£o</h3>
Se √© esperado que um grande n√∫mero de itera√ß√µes seja tratado por um loop, √© recomend√°vel que se
verifique a ocorr√™ncia de uma finaliza√ß√£o de programa for√ßada usando a fun√ß√£o IsStopped().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- Calcula a s√©rie de Fibonacci
   int counterFibonacci=15;
   int i=0,first=0,second=1;
   int currentFibonacciNumber;
   do
     {
      currentFibonacciNumber=first+second;
      Print(&quot;i = &quot;,i,&quot;  currentFibonacciNumber = &quot;,currentFibonacciNumber);
      first=second;
      second=currentFibonacciNumber;
      i++; // Sem este operador um loop infinito aparecer√°!
     }
   while(i&lt;counterFibonacci &amp;&amp; !IsStopped());
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
195
<h3>Operador break</h3>
O operador break finaliza a execu√ß√£o do operador aninhado (encaixado) switch, while, do-while ou for
mais pr√≥ximo. O controle √© passado ao operador que se segue a aquele finalizado. Um dos prop√≥sitos
deste operador √© finalizar a execu√ß√£o de loop quando um certo valor √© atribu√≠do a uma vari√°vel.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- buscando pelo primeiro elemento zero
</code></pre>
<p>
for(i=0;i&lt;array_size;i++)
  if(array[i]==0)
</p>
<pre><code class="language-mql5">
    break;
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
196
<h3>Operador continue</h3>
O operador continue passa o controle para o come√ßo do pr√≥ximo loop do operador while, do-while ou
</p>
<pre><code class="language-mql5">
for mais pr√≥ximo, executando a pr√≥xima itera√ß√£o. O prop√≥sito deste operador √© oposto ao do
</code></pre>
<p>
operador break.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- Soma de todos os elementos n√£o-zero
int func(int array[])
  {
   int array_size=ArraySize(array);
   int sum=0;
   for(int i=0;i&lt;array_size; i++)
     {
      if(a[i]==0) continue;
      sum+=a[i];
     }
   return(sum);
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
197
<h3>Operador de multiplica√ß√£o de matrizes @</h3>
O operador @ na linguagem MQL5 realiza a multiplica√ß√£o de matrizes de acordo com as regras da
√°lgebra linear. Permite realizar multiplica√ß√£o de matrizes, vetores e produto escalar de vetores.
<h3>Tipos de elementos suportados:</h3>
¬∑ float
¬∑ double
¬∑ complex&lt;float&gt;
¬∑ complex&lt;double&gt;
Importante: os tipos dos elementos nos operandos esquerdo e direito devem ser iguais.
<h3>Exemplos de uso</h3>
1. Multiplica√ß√£o de matrizes (matriz √ó matriz)
matrix A(2, 3);
matrix B(3, 2);
matrix C = A @ B; // Resultado: matriz C de tamanho [2,2]
2. Multiplica√ß√£o de matrizes (matriz √ó vetor)
matrix M(2, 3);
vector V(3);
vector R = M @ V; // Resultado: vetor R com 2 elementos
3. Multiplica√ß√£o de matrizes (vetor √ó matriz)
matrix M(2, 3);
vector V(1, 2);
vector R = V @ M; // Resultado: vetor R com 3 elementos
4. Produto escalar (vetor √ó vetor)
vector V1(1, 3), V2(1, 3);
</p>
<pre><code class="language-mql5">
double r = V1 @ V2; // Resultado: escalar
</code></pre>
<p>
<h3>Observa√ß√£o</h3>
As dimens√µes devem seguir as regras da multiplica√ß√£o: o n√∫mero de colunas no primeiro operando =
n√∫mero de linhas no segundo.
Se houver erro de dimens√£o, ser√° lan√ßada uma exce√ß√£o em tempo de execu√ß√£o.
Vetores √† esquerda s√£o considerados horizontais (1√ón).</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
198
Vetores √† direita s√£o considerados verticais (n√ó1).
A prioridade da opera√ß√£o @ corresponde √† prioridade da multiplica√ß√£o, ou seja, numa express√£o
como D=C+A@B, primeiro ser√° feita a multiplica√ß√£o de matrizes T=A@B, depois a soma elemento a
elemento D=C+T.
<h3>Veja tamb√©m</h3>
<h3>MatMul, GeMM, Kron, Dot,</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
199
<h3>Operador de Cria√ß√£o de Objeto new</h3>
O operador new automaticamente cria um objeto de tamanho correspondente, chama o construtor do
objeto e retorna um descritor do objeto criado. Em caso de falha, o operador retorna um descritor de
null que pode ser comparado com a constante NULL.
O operador new pode ser aplicado somente a objetos de classe. Ele n√£o pode ser aplicado a estruturas.
O operador n√£o deve ser usado para criar arrays de objetos. Para fazer isso, use a fun√ß√£o
ArrayResize().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Cria√ß√£o de Figura¬†                                               |
//+------------------------------------------------------------------+
void CTetrisField::NewShape()
  {
   m_ypos=HORZ_BORDER;
//--- cria aleatoriamente uma das 7 poss√≠veis formas
   int nshape=rand()%7;
   switch(nshape)
     {
      case 0: m_shape=new CTetrisShape1; break;
      case 1: m_shape=new CTetrisShape2; break;
      case 2: m_shape=new CTetrisShape3; break;
      case 3: m_shape=new CTetrisShape4; break;
      case 4: m_shape=new CTetrisShape5; break;
      case 5: m_shape=new CTetrisShape6; break;
      case 6: m_shape=new CTetrisShape7; break;
     }
//--- desenhar
   if(m_shape!=NULL)
     {
      //--- pr√©-configura√ß√µes
      m_shape.SetRightBorder(WIDTH_IN_PIXELS+VERT_BORDER);
      m_shape.SetYPos(m_ypos);
      m_shape.SetXPos(VERT_BORDER+SHAPE_SIZE*8);
      //--- draw
      m_shape.Draw();
     }
//---
</code></pre>
<p>
  }
Deve ser notado que um descritor do objeto n√£o √© um ponteiro para um endere√ßo de mem√≥ria.
Um objeto criado com o operador new deve ser explicitamente removido usando o operador delete.
<h3>Tamb√©m Veja</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
200
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
201
<h3>Opera√ß√£o de Exclus√£o de Objeto delete</h3>
O operador delete exclui um objeto criado pelo operador new, chama o destrutor da classe
correspondente e libera mem√≥ria ocupada pelo objeto. Um descritor real de um objeto existente √©
usado como um operando. Ap√≥s a opera√ß√£o de exclus√£o (delete) ser executada, o descritor do objeto
torna-se inv√°lido.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
      //--- exclui figura
      delete m_shape;
      m_shape=NULL;
      //--- criar uma nova figura
      NewShape();
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
Inicializa√ß√£o de Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo
<h3>Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
202
<h3>Fun√ß√µes</h3>
Toda tarefa pode ser dividida em sub-tarefas, cada qual podendo ser representada tanto na forma de
c√≥digo, como ser divida em sub-tarefas ainda menores. Este m√©todo √© chamado de refinamento passo
a passo.. Fun√ß√µes s√£o usadas para escrever o c√≥digo das sub-tarefas a serem resolvidas. O c√≥digo que
descreve o que uma fun√ß√£o faz √© chamado de defini√ß√£o de fun√ß√£o:
function_header
</p>
<pre><code class="language-mql5">
  {
</code></pre>
<p>
¬† instru√ß√µes
  }
Tudo que est√° antes da primeira chave √© o cabe√ßalho (header) da defini√ß√£o de fun√ß√£o, e o que est√°
entre as chaves √© o corpo (body) da defini√ß√£o de fun√ß√£o. O cabe√ßalho de fun√ß√£o (function header)
inclui a descri√ß√£o do tipo de valor de retorno, o nome (identificador) e os par√¢metros formais. O
n√∫mero de par√¢metros passados para a fun√ß√£o √© limitado e n√£o pode exceder 64.
A fun√ß√£o pode ser chamada de outras partes do programa quantas vezes forem necess√°rias. Na
verdade, o tipo de retorno, o identificador da fun√ß√£o e os tipos de par√¢metros constituem o prot√≥tipo
da fun√ß√£o.
Prot√≥tipo de fun√ß√£o √© a declara√ß√£o da fun√ß√£o, mas n√£o a sua defini√ß√£o. Devido a declara√ß√£o expl√≠cita
do tipo de retorno e da lista dos tipos de argumentos, a verifica√ß√£o estrita de tipo e a impl√≠cita
convers√£o de tipo (typecasting) s√£o poss√≠veis durante as chamadas de fun√ß√£o. Muito freq√ºentemente
declara√ß√µes de fun√ß√µes s√£o usadas em classes para melhorar a legibilidade do c√≥digo.
As defini√ß√µes de fun√ß√£o devem corresponder exatamente √† sua declara√ß√£o. Cada fun√ß√£o declarada
deve ser definida.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
double                       // tipo do valor de retorno
</code></pre>
<p>
linfunc (double a, double b) // nome da fun√ß√£o e lista de par√¢metros
</p>
<pre><code class="language-mql5">
  {
                             // operador composto
   return (a + b);           // valor do retorno
</code></pre>
<p>
  }
O operador return pode retornar o valor de uma express√£o localizada neste operador. Se necess√°rio, o
valor da express√£o √© convertido para o tipo do resultado da fun√ß√£o. Pode ser retornado: tipos simples,
estruturas simples, ponteiros de objetos. Com o operador return n√£o se pode retornar arrays, objetos
de classe, vari√°veis de tipo estrutura composta.
Uma fun√ß√£o que n√£o retorna nenhum valor deve ser descrita como do tipo void.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void errmesg(string s)
  {
   Print(&quot;erro: &quot;+s);
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
203
Par√¢metros passado para a fun√ß√£o podem ter valores default (padr√£o), que s√£o definidos por
constantes daquele tipo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int somefunc(double a,
             double d=0.0001,
             int n=5,
             bool b=true,
             string s=&quot;string transmitida&quot;)
  {
   Print(&quot;Par√¢metro obrigat√≥rio a = &quot;,a);
   Print(&quot;Transmitir os seguintes par√¢metros: d = &quot;,d,&quot; n = &quot;,n,&quot; b = &quot;,b,&quot; s = &quot;,s);
   return(0);
</code></pre>
<p>
  }
Se algum dos par√¢metros tem um valor default, todos os par√¢metros subseq√ºentes devem tamb√©m ter
valores default.
<h3>Exemplo de declara√ß√£o incorreta:</h3>
</p>
<pre><code class="language-mql5">
int somefunc(double a,
             double d=0.0001,    // valor padr√£o declarado 0.0001
             int n,              // n√£o √© determinado o valor padr√£o!
             bool b,             // n√£o √© determinado o valor padr√£o!
             string s=&quot;string transmitida&quot;)
  {                                          
</code></pre>
<p>
  }   
<h3>Tamb√©m Veja</h3>
<h3>Sobrecarga (Overload), Fun√ß√µes Virtuais, Polimorfismo</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
204
<h3>Chamada de Fun√ß√£o</h3>
Se um nome, que n√£o foi descrito antes, aparece em uma express√£o e √© seguido pelo par√™ntesis de
abertura, ele √© considerado contextualmente como o nome de uma fun√ß√£o.
function_name (x1, x2,..., xn)
Argumentos (par√¢metros formais) s√£o passados por valor, isto √©, cada express√£o x1,.., xn √©
calculada, e os valores s√£o passados para a fun√ß√£o. A ordem de c√°lculo das express√µes e a ordem de
carregamento dos valores n√£o s√£o garantidos. Durante a execu√ß√£o, o sistema verifica o n√∫mero e o
tipo dos argumentos passados para a fun√ß√£o. Tal forma de abordar uma fun√ß√£o √© chamada de uma
chamada de valor.
Chamada de fun√ß√£o √© uma express√£o, cujo valor √© o valor retornado pela fun√ß√£o. O tipo da fun√ß√£o
descrito acima deve corresponder com o tipo do valor de retorno. Uma fun√ß√£o pode ser declarada ou
descrita em qualquer parte do programa no escopo global, isto √©, fora de outras fun√ß√µes. Uma fun√ß√£o
n√£o pode ser declarada ou descrita dentro de outra fun√ß√£o.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
int start()
  {
   double some_array[4]={0.3, 1.4, 2.5, 3.6};
   double a=linfunc(some_array, 10.5, 8);
   //...
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
double linfunc(double x[], double a, double b)
  {
   return (a*x[0] + b);
</code></pre>
<p>
  }
Na chamada de uma fun√ß√£o com par√¢metros default, a lista de par√¢metros a serem passados pode ser
limitada, mas n√£o antes do primeiro par√¢metro default.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
void somefunc(double init,
              double sec=0.0001, //define valores default
              int level=10);  
//...
</code></pre>
<p>
somefunc();                      // Chamada errada. O primeiro par√¢metro deve estar pr
somefunc(3.14);                  // Chamada correta
somefunc(3.14,0.0002);           // Chamada correta
somefunc(3.14,0.0002,10);        // Chamada correta
Ao chamar uma fun√ß√£o, n√£o se pode pular par√¢metros, mesmo aqueles que t√™m valores default:
somefunc(3.14, , 10);           // Chamada errada -&gt; o segundo par√¢metros foi pulado.
<h3>Tamb√©m Veja</h3>
<h3>Sobrecarga (Overload), Fun√ß√µes Virtuais, Polimorfismo</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
205
<h3>Passando Par√¢metros</h3>
Existem pois m√©todos pelo qual a linguagem de m√°quina pode passar argumentos para um
subprograma (fun√ß√£o). O primeiro m√©todo √© enviar um par√¢metro por valor. Este m√©todo copia o valor
do argumento para um par√¢metro formal de fun√ß√£o. Portanto, quaisquer mudan√ßas neste par√¢metro
ocorridas dentro da fun√ß√£o n√£o t√™m influ√™ncia no correspondente argumento usado na chamada da
fun√ß√£o.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Passando par√¢metros por valor¬†                                   |
//+------------------------------------------------------------------+
double FirstMethod(int i,int j)
  {
   double res;
//---
   i*=2;
   j/=2;
   res=i+j;
//---
   return(res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   int a=14,b=8;
   Print(&quot;a e b antes chamada:&quot;,a,&quot; &quot;,b);
   double d=FirstMethod(a,b);
   Print(&quot;a e b ap√≥s chamada:&quot;,a,&quot; &quot;,b);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//--- Resultado da execu√ß√£o do script
//  a e b antes chamada: 14 8
//  a e b ap√≥s chamada: 14 8
</code></pre>
<p>
O segundo m√©todo √© passar por refer√™ncia. Neste caso, a refer√™ncia para um par√¢metro (n√£o seu
valor) √© passada para um par√¢metro de fun√ß√£o. Dentro da fun√ß√£o, ele √© usado para referenciar o
verdadeiro par√¢metro especificado na chamada. Isso significa que mudan√ßas no par√¢metro afetar√£o o
argumento usado na chamada da fun√ß√£o.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Passando par√¢metros por refer√™ncia¬†                              |
//+------------------------------------------------------------------+
double SecondMethod(int &amp;i,int &amp;j)
  {
   double res;
//---
   i*=2;
   j/=2;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
206
</p>
<pre><code class="language-mql5">
   res=i+j;
//---
   return(res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   int a=14,b=8;
   Print(&quot;a e b antes chamada:&quot;,a,&quot; &quot;,b);
   double d=SecondMethod(a,b);
   Print(&quot;a e b ap√≥s chamada:&quot;,a,&quot; &quot;,b);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//--- resultado da execu√ß√£o do script
//  a e b antes chamada: 14 8
//  a e b ap√≥s chamada: 28 4
</code></pre>
<p>
MQL5 usa ambos os m√©todos, com uma exce√ß√£o, arrays, vari√°veis tipo estrutura e objetos de classe
s√£o sempre passados por refer√™ncia. A fim de evitar modifica√ß√µes nos par√¢metros reais (argumentos
passados na chamada da fun√ß√£o) use o especificador de acesso const. Ao se tentar modificar o
conte√∫do de uma vari√°vel declarada com o especificador const, o compilador gerar√° um erro.
<h3>Observa√ß√£o</h3>
Deve se notar que os par√¢metros s√£o passados para uma fun√ß√£o em ordem inversa, ou seja, o √∫ltimo
par√¢metro √© calculado e passado primeiro, depois o √∫ltimo mas apenas um, etc. O √∫ltimo par√¢metro
calculado e passado √© aquele que est√° em primeiro lugar depois da abertura dos par√™nteses.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   int a[]={0,1,2};
   int i=0;
   func(a[i],a[i++],&quot;First call (i = &quot;+string(i)+&quot;)&quot;);
   func(a[i++],a[i],&quot;Second call (i = &quot;+string(i)+&quot;)&quot;);
// Result:
// First call (i = 0) : par1 = 1     par2 = 0
// Second call (i = 1) : par1 = 1     par2 = 1
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void func(int par1,int par2,string comment)</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
207
</p>
<pre><code class="language-mql5">
  {
   Print(comment,&quot;: par1 = &quot;,par1,&quot;    par2 = &quot;,par2);
</code></pre>
<p>
  }
Na primeira chamada (ver exemplo acima) a vari√°vel i √© usada pela primeira vez na concatena√ß√£o de
strings:
  &quot;Primeira chamada (i = &quot;+string(i)+&quot;)&quot;
Aqui o valor n√£o muda. Ent√£o a vari√°vel i √© usada no c√°lculo do elemento do array a[i++], ou seja,
quando o elemento do array com √≠ndice i √© acessado, a vari√°vel i √© incrementada. E s√≥ depois disso o
primeiro par√¢metro com valor alterado da vari√°vel i √© calculado.
Na segunda chamada o mesmo valor de i (calculado sobre a primeira fase da fun√ß√£o chamada) √©
utilizado no c√°lculo de todos os tr√™s par√¢metros. Somente depois de os primeiros par√¢metros serem
calculados, a vari√°vel i √© alterada novamente.
<h3>Tamb√©m Veja</h3>
Escopo de visibilidade e tempo de vida das vari√°veis, Sobrecarga, Fun√ß√µes Virtuais, Polimorfismo</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
208
<h3>Sobrecarga de Fun√ß√£o</h3>
Geralmente, o nome da fun√ß√£o tende a refletir seu prop√≥sito principal. Como regra, programas
leg√≠veis cont√©m v√°rios identificadores bem selecionados. √Äs vezes, fun√ß√µes diferentes s√£o usados
para os mesmos prop√≥sitos. Vamos considerar, por exemplo, uma fun√ß√£o que calcula o valor m√©dio de
um array de n√∫meros de dupla precis√£o e a mesma fun√ß√£o, mas operando com um array de inteiros.
<h3>Ambas s√£o convenientemente chamadas de AverageFromArray:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| O c√°lculo de m√©dia de um array de tipo double¬†                   |
//+------------------------------------------------------------------+
double AverageFromArray(const double &amp; array[],int size)
  {
   if(size&lt;=0) return 0.0;
   double sum=0.0;
   double aver;
//---
   for(int i=0;i&lt;size;i++)
     {
      sum+=array[i];    // Soma para o tipo double
     }
   aver=sum/size;       // Apenas divide a soma pelo n√∫mero
//---
   Print(&quot;C√°lculo da m√©dia para um array do tipo double&quot;);
   return aver;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| O c√°lculo de m√©dia para um array de tipo int¬†                    |
//+------------------------------------------------------------------+
double AverageFromArray(const int &amp; array[],int size)
  {
   if(size&lt;=0) return 0.0;
   double aver=0.0;
   int sum=0;
//---
   for(int i=0;i&lt;size;i++)
     {
      sum+=array[i];     // Soma para o tipo int
     }
   aver=(double)sum/size;// Fornece uma quantidade de tipo double, e divide
//---
   Print(&quot;C√°lculo da m√©dia para um array do tipo int&quot;);
   return aver;
</code></pre>
<p>
  }
Cada fun√ß√£o cont√©m a sa√≠da da mensagem via a fun√ß√£o Print();
</p>
<pre><code class="language-mql5">
   Print(&quot;C√°lculo da m√©dia para um array do tipo int&quot;);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
209
O compilador seleciona a fun√ß√£o necess√°ria de acordo com os tipos dos argumentos e suas
quantidades. A regra, que define a escolha a ser feita, √© chamada de algoritmo de correspond√™ncia de
assinatura. Um assinatura √© uma lista de tipos usados na declara√ß√£o da fun√ß√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   int    a[5]={1,2,3,4,5};
   double b[5]={1.1,2.2,3.3,4.4,5.5};
   double int_aver=AverageFromArray(a,5);
   double double_aver=AverageFromArray(b,5);
   Print(&quot;int_aver = &quot;,int_aver,&quot;   double_aver = &quot;,double_aver);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//--- Resultado do script
// Calcula a m√©dia para um array de tipo int
// Calcula a m√©dia para um array de tipo double
// int_aver= 3.00000000    double_aver= 3.30000000
</code></pre>
<p>
Sobrecarga de fun√ß√£o √© um processo de criar v√°rias fun√ß√µes com o mesmo nome, mas com diferentes
par√¢metros. Isso significa que em variantes sobrecarregadas de uma fun√ß√£o, o n√∫mero de argumentos
e/ou seus tipos devem ser diferentes. Um variante de fun√ß√£o espec√≠fica √© selecionada baseada na
correspond√™ncia entre lista de argumentos ao chamar a fun√ß√£o com a lista de par√¢metros na
declara√ß√£o da fun√ß√£o.
Quando uma fun√ß√£o sobrecarregada √© chamada, o compilador deve ter uma algoritmo para selecionar
a fun√ß√£o apropriada. O algoritmo que realiza esta escolha depende da convers√£o de quais tipos
estiverem presentes. A melhor correspond√™ncia deve ser √∫nica. Uma fun√ß√£o sobrecarregada deve ser a
melhor correspond√™ncia dentre todas as outras variantes para ao menos um argumento. Ao mesmo
tempo, ela n√£o deve ser pior que as outras variantes para todos os outros argumentos.
Abaixo est√° um algoritmo de correspond√™ncia para cada argumento.
Algoritmo de Escolha de uma Fun√ß√£o Sobrecarregada
1. Use estrita correspond√™ncia (se poss√≠vel).
2. Tente incremento de tipo padr√£o.
3. Tente convers√£o de tipo padr√£o.
O incremento de tipo padr√£o √© melhor que outras convers√µes padr√£o. Incremento √© a convers√£o de
float para double, de bool, char, short ou enum para int. Convers√£o de tipo de arrays de tipos inteiros
similares tamb√©m pertencem a convers√£o de tipo. Tipos similares s√£o: bool, char, uchar, j√° que todos
os tr√™s tipo s√£o inteiros de √∫nico bytes, inteiros de duplo byte short e ushort; inteiros de 4 bytes int,
uint, e color; long, ulong e datetime.
Claro que a estrita correspond√™ncia √© a melhor. Para alcan√ßar tal consist√™ncia convers√£o de tipo
(typecasting) pode ser usada. O compilador n√£o pode lidar com situa√ß√µes amb√≠guas. Portanto voc√™ n√£o</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
210
deve confiar em diferen√ßas sutis de tipos e convers√µes impl√≠citas que tornam a fun√ß√£o sobrecarregada
n√£o clara.
No caso de d√∫vida, use convers√£o expl√≠cita para assegurar estrita adequa√ß√£o.
Exemplos de fun√ß√µes sobrecarregadas no MQL5 podem ser vistas no exemplo de fun√ß√µes
ArrayInitialize().
Regras de sobrecarga de fun√ß√£o para sobrecarga de m√©todos de classe.
A sobrecarga de fun√ß√µes de sistema √© permitida, mas deve-se observar que o compilador √© capaz de
selecionar com precis√£o a fun√ß√£o necess√°ria. Por exemplo, podemos sobrecarregar o sistema da
fun√ß√£o MathMax() de 4 maneiras diferentes, mas apenas duas variantes s√£o corretas. 
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
// 1. sobrecarga √© permitida - fun√ß√£o difere da fun√ß√£o embutida MathMax() em n√∫mero de
double MathMax(double a,double b,double c);
// 2. sobrecarga n√£o √© permitida!
// n√∫mero de par√¢metros √© diferente, mas o √∫ltimo tem um valor default
// isso leva ao ocultamento da fun√ß√£o de sistema ao chamar-lo, o que √© inaceit√°vel
double MathMax(double a,double b,double c=DBL_MIN);
// 3. sobrecarga √© permitida - sobrecarga normal para tipos de par√¢metros &#x27;a&#x27; e &#x27;b&#x27;
double MathMax(int a,int b);
// 4. sobrecarga n√£o √© permitida!
// o n√∫mero e tipos de par√¢metros s√£o os mesmos que no original double MathMax (double
int MathMax(double a,double b);
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
<h3>Sobrecarga (Overload), Fun√ß√µes Virtuais, Polimorfismo</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
211
<h3>Sobrecarga de Opera√ß√£o</h3>
Para facilitar a leitura e escrita de c√≥digo, a sobrecarga de algumas opera√ß√µes √© permitida. O
operador de sobrecarga √© escrito usando a palavra-chave operator. Os seguintes operadores podem
ser sobrecarregados:
¬∑ bin√°rio +,-,/,*,%,&lt;&lt;,&gt;&gt;,==,!=,&lt;,&gt;,&lt;=,&gt;=,=,+=,-=,/=,*=,%=,&amp;=,|=,^=,&lt;&lt;=,&gt;&gt;=,&amp;&amp;,||,&amp;,|,^
¬∑ un√°rio +,-,++,--,!,~
¬∑ operador de atribui√ß√£o =
¬∑ operador de indexa√ß√£o []
Sobrecarga de opera√ß√£o permite o uso da nota√ß√£o de opera√ß√£o (escrita na forma de express√µes
simples) para objetos complexos - estruturas e classes. Escrevendo express√µes usando opera√ß√µes de
sobrecarga simplifica a visualiza√ß√£o do c√≥digo fonte, porque uma implementa√ß√£o mais complexa fica
escondida.
Por exemplo, considere n√∫meros complexos, que consistem de partes real e imagin√°ria. Eles s√£o
amplamente utilizados na matem√°tica. A linguagem MQL5 n√£o tem um tipo de dado que represente
n√∫meros complexos, mas √© poss√≠vel criar um novo tipo de dado na forma de uma estrutura ou classe.
Declare a estrutura complexa e defina quatro m√©todos que implementam as quatro opera√ß√µes
aritm√©ticas:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma estrutura para opera√ß√µes com n√∫meros complexos¬†              |
//+------------------------------------------------------------------+
struct complex
  {
   double            re; // Parte real
   double            im; // Parte imagin√°rio
   //--- Construtores
                     complex():re(0.0),im(0.0) {  }
                     complex(const double r):re(r),im(0.0) {  }
                     complex(const double r,const double i):re(r),im(i) {  }
                     complex(const complex &amp;o):re(o.re),im(o.im) { }
   //--- Opera√ß√µes Aritm√©ticas
   complex           Add(const complex &amp;l,const complex &amp;r) const;  // Adi√ß√£o
   complex           Sub(const complex &amp;l,const complex &amp;r) const;  // Subtra√ß√£o
   complex           Mul(const complex &amp;l,const complex &amp;r) const;  // Multiplica√ß√£o
   complex           Div(const complex &amp;l,const complex &amp;r) const;  // Divis√£o
</code></pre>
<p>
  };
Agora, em nosso c√≥digo n√≥s podemos declarar vari√°veis representando n√∫meros complexos, e
trabalhar com eles.
<h3>Por exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//--- Declara e inicialize vari√°veis de um tipo complexo
   complex a(2,4),b(-4,-2);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
212
</p>
<pre><code class="language-mql5">
   PrintFormat(&quot;a=%.2f+i*%.2f,   b=%.2f+i*%.2f&quot;,a.re,a.im,b.re,b.im);
//--- Soma dois n√∫meros
   complex z;
   z=a.Add(a,b);
   PrintFormat(&quot;a+b=%.2f+i*%.2f&quot;,z.re,z.im);
//--- Multiplica dois n√∫meros
   z=a.Mul(a,b);
   PrintFormat(&quot;a*b=%.2f+i*%.2f&quot;,z.re,z.im);
//--- Dividir dois n√∫meros
   z=a.Div(a,b);
   PrintFormat(&quot;a/b=%.2f+i*%.2f&quot;,z.re,z.im);
//---
</code></pre>
<p>
  }
Mas seria mais conveniente usar os operadores usuais &quot;+&quot;, &quot;-&quot;, &quot;*&quot; e &quot;/&quot; para opera√ß√µes aritm√©ticas
comuns com n√∫meros complexos.
A palavra-chave operator √© usado para definir uma fun√ß√£o membro que realiza convers√£o de tipo.
Opera√ß√µes un√°rias e bin√°rias para vari√°veis de objeto de classe podem ser sobrecarregadas como
fun√ß√µes membro n√£o est√°ticas. Elas implicitamente agem nos objetos de classe.
A maioria das opera√ß√µes bin√°rias podem ser sobrecarregadas como fun√ß√µes regulares que tomam uma
vari√°vel de classe e/ou um ponteiro de objeto desta classe como argumento. Para o nosso tipo
complexo, a sobrecarga na declara√ß√£o se parecer√° como:
</p>
<pre><code class="language-mql5">
   //--- Operadores
   complex operator+(const complex &amp;r) const { return(Add(this,r)); }
   complex operator-(const complex &amp;r) const { return(Sub(this,r)); }
   complex operator*(const complex &amp;r) const { return(Mul(this,r)); }
   complex operator/(const complex &amp;r) const { return(Div(this,r)); }
</code></pre>
<p>
<h3>O exemplo completo do script:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Declara e inicialize vari√°veis de um tipo complexo
   complex a(2,4),b(-4,-2);
   PrintFormat(&quot;a=%.2f+i*%.2f,   b=%.2f+i*%.2f&quot;,a.re,a.im,b.re,b.im);
   //a.re=5;
   //a.im=1;
   //b.re=-1;
   //b.im=-5;
//--- Soma dois n√∫meros
   complex z=a+b;
   PrintFormat(&quot;a+b=%.2f+i*%.2f&quot;,z.re,z.im);
//--- Multiplica dois n√∫meros
   z=a*b;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
213
</p>
<pre><code class="language-mql5">
   PrintFormat(&quot;a*b=%.2f+i*%.2f&quot;,z.re,z.im);
//--- Dividir dois n√∫meros
   z=a/b;
   PrintFormat(&quot;a/b=%.2f+i*%.2f&quot;,z.re,z.im);
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma estrutura para opera√ß√µes com n√∫meros complexos¬†              |
//+------------------------------------------------------------------+
struct complex
  {
   double            re; // Parte real
   double            im; // Parte imagin√°rio
   //--- Construtores
                     complex():re(0.0),im(0.0) {  }
                     complex(const double r):re(r),im(0.0) {  }
                     complex(const double r,const double i):re(r),im(i) {  }
                     complex(const complex &amp;o):re(o.re),im(o.im) { }
   //--- Opera√ß√µes Aritm√©ticas
   complex           Add(const complex &amp;l,const complex &amp;r) const;  // Adi√ß√£o
   complex           Sub(const complex &amp;l,const complex &amp;r) const;  // Subtra√ß√£o
   complex           Mul(const complex &amp;l,const complex &amp;r) const;  // Multiplica√ß√£o
   complex           Div(const complex &amp;l,const complex &amp;r) const;  // Divis√£o
   //--- Operadores bin√°rias
   complex operator+(const complex &amp;r) const { return(Add(this,r)); }
   complex operator-(const complex &amp;r) const { return(Sub(this,r)); }
   complex operator*(const complex &amp;r) const { return(Mul(this,r)); }
   complex operator/(const complex &amp;r) const { return(Div(this,r)); }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Adi√ß√£o¬†                                                          |
//+------------------------------------------------------------------+
</code></pre>
<p>
complex complex::Add(const complex &amp;l,const complex &amp;r) const
</p>
<pre><code class="language-mql5">
  {
   complex res;
//---
   res.re=l.re+r.re;
   res.im=l.im+r.im;
//--- Resultado
   return res;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Subtra√ß√£o¬†                                                       |
//+------------------------------------------------------------------+
</code></pre>
<p>
complex complex::Sub(const complex &amp;l,const complex &amp;r) const
</p>
<pre><code class="language-mql5">
  {
   complex res;
//---
   res.re=l.re-r.re;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
214
</p>
<pre><code class="language-mql5">
   res.im=l.im-r.im;
//--- Resultado
   return res;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Multiplica√ß√£o¬†                                                   |
//+------------------------------------------------------------------+
</code></pre>
<p>
complex complex::Mul(const complex &amp;l,const complex &amp;r) const
</p>
<pre><code class="language-mql5">
  {
   complex res;
//---
   res.re=l.re*r.re-l.im*r.im;
   res.im=l.re*r.im+l.im*r.re;
//--- Resultado
   return res;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Divis√£o¬†                                                         |
//+------------------------------------------------------------------+
</code></pre>
<p>
complex complex::Div(const complex &amp;l,const complex &amp;r) const
</p>
<pre><code class="language-mql5">
  {
//--- Numero complexo vazio
   complex res(EMPTY_VALUE,EMPTY_VALUE);
//--- Verificar se √© zero
   if(r.re==0 &amp;&amp; r.im==0)
     {
      Print(__FUNCTION__+&quot;: n√∫mero √© zero&quot;);
      return(res);
     }
//--- Vari√°veis auxiliares
   double e;
   double f;
//--- Selecionando a variante de c√°lculo
   if(MathAbs(r.im)&lt;MathAbs(r.re))
     {
      e = r.im/r.re;
      f = r.re+r.im*e;
      res.re=(l.re+l.im*e)/f;
      res.im=(l.im-l.re*e)/f;
     }
   else
     {
      e = r.re/r.im;
      f = r.im+r.re*e;
      res.re=(l.im+l.re*e)/f;
      res.im=(-l.re+l.im*e)/f;
     }
//--- Resultado
   return res;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
215
  }
A maioria das opera√ß√µes un√°rias para classes podem ser sobrecarregadas como fun√ß√µes comuns que
aceitam um √∫nico argumento de objeto de classe ou ponteiro dele. Adicione sobrecarga de opera√ß√µes
un√°rias &quot;-&quot; e &quot;!&quot;.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma estrutura para opera√ß√µes com n√∫meros complexos¬†              |
//+------------------------------------------------------------------+
struct complex
  {
   double            re;       // Parte real
   double            im;       // Parte imagin√°rio
</code></pre>
<p>
...
</p>
<pre><code class="language-mql5">
   //--- Operadores un√°rios
   complex operator-()  const; // Unary minus
   bool    operator!()  const; // Nega√ß√£o
</code></pre>
<p>
  };
...
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Sobrecarregar operador de &quot;menos un√°rio&quot;¬†                        |
//+------------------------------------------------------------------+
</code></pre>
<p>
complex complex::operator-() const
</p>
<pre><code class="language-mql5">
  {
   complex res;
//---
   res.re=-re;
   res.im=-im;
//--- Resultado
   return res;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Sobrecarregar operador de &quot;nega√ß√£o l√≥gica&quot;¬†                      |
//+------------------------------------------------------------------+
bool complex::operator!() const
  {
//--- S√£o as partes real e imagin√°ria do n√∫mero complexo igual a zero?
   return (re!=0 &amp;&amp; im!=0);
</code></pre>
<p>
  }
Agora n√≥s podemos verificar se valor de um n√∫mero complexo √© zero e obter um valor negativo:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Declara e inicialize vari√°veis de um tipo complexo</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
216
</p>
<pre><code class="language-mql5">
   complex a(2,4),b(-4,-2);
   PrintFormat(&quot;a=%.2f+i*%.2f,   b=%.2f+i*%.2f&quot;,a.re,a.im,b.re,b.im);
//--- Dividir dois n√∫meros
   complex z=a/b;
   PrintFormat(&quot;a/b=%.2f+i*%.2f&quot;,z.re,z.im);
//--- Um n√∫mero complexo √© igual a zero por padr√£o (no construtor padr√£o re==0 e im==0
   complex zero;
   Print(&quot;!zero=&quot;,!zero);
//--- Atribuir um valor negativo
   zero=-z;
   PrintFormat(&quot;z=%.2f+i*%.2f,  zero=%.2f+i*%.2f&quot;,z.re,z.im, zero.re,zero.im);
   PrintFormat(&quot;-zero=%.2f+i*%.2f&quot;,-zero.re,-zero.im);
//--- Verificar se √© zero mais uma vez  
   Print(&quot;!zero=&quot;,!zero);
//---
</code></pre>
<p>
  }
Note que n√≥s n√£o tivemos que sobrecarregar o operador de atribui√ß√£o &quot;=&quot;, j√° que estruturas de tipos
simples pode ser diretamente copiadas uma no outra. Assim, n√≥s agora podemos escrever um c√≥digo
para c√°lculos envolvendo n√∫meros complexos de maneira usual.
Sobrecarga de operador de indexa√ß√£o permite obter os valores dos arrays fechados em um objeto, de
uma maneira simples e familiar, e isso tamb√©m contribui para uma melhor legibilidade do c√≥digo
fonte. Por exemplo, n√≥s precisamos fornecer acesso a um s√≠mbolo dentro de uma string em uma
posi√ß√£o espec√≠fica. Uma string em MQL5 √© um tipo string separado, que n√£o √© um array de s√≠mbolos,
mas com a ajuda de uma opera√ß√£o de indexa√ß√£o sobrecarregada podemos fornecer um trabalho
simples e transparente na classe CString gerada:
</p>
<pre><code class="language-mql5">
//+----------------------------------------------------------------------+
//| Uma classe para acessar s√≠mbolos em string como na array de s√≠mbolos |
//+----------------------------------------------------------------------+
class CString
  {
   string            m_string;
  
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CString(string str=NULL):m_string(str) { }
   ushort operator[] (int x) { return(StringGetCharacter(m_string,x)); }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()  
  {
//--- Um array para receber os s√≠mbolos a partir de uma string
   int     x[]={ 19,4,18,19,27,14,15,4,17,0,19,14,17,27,26,28,27,5,14,
                 17,27,2,11,0,18,18,27,29,30,19,17,8,13,6 };
   CString str(&quot;abcdefghijklmnopqrstuvwxyz[ ]CS&quot;);
   string  res;
//--- Fazer um frase usando s√≠mbolos da vari√°vel str</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
217
</p>
<pre><code class="language-mql5">
   for(int i=0,n=ArraySize(x);i&lt;n;i++)
     {
      res+=ShortToString(str[x[i]]);
     }
//--- Mostrar o resultado
   Print(res);
</code></pre>
<p>
  }
Um outro exemplo de sobrecarga do operador de indexa√ß√£o s√£o opera√ß√µes com matrizes. A matriz
representa um array din√¢mico de duas dimens√µes, o tamanho do array n√£o √© definido com
anteced√™ncia. Portanto, voc√™ n√£o pode declarar um array da forma array[][] sem especificar o
tamanho da segunda dimens√£o, e ent√£o passar este array como um par√¢metro. Uma poss√≠vel solu√ß√£o √©
uma classe especial CMatrix, que cont√©m um array de objetos de classe CRow.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Opera√ß√µes de adi√ß√£o e multiplica√ß√£o de matrizes
   CMatrix A(3),B(3),C();
//--- Preparar um array para as linhas
   double a1[3]={1,2,3}, a2[3]={2,3,1}, a3[3]={3,1,2};
   double b1[3]={3,2,1}, b2[3]={1,3,2}, b3[3]={2,1,3};
//--- Preencher as matrizes
   A[0]=a1; A[1]=a2; A[2]=a3;
   B[0]=b1; B[1]=b2; B[2]=b3;
//--- Sa√≠da de matrizes no log Experts
   Print(&quot;---- Os elementos da matriz A&quot;);
   Print(A.String());
   Print(&quot;---- Os elementos da matriz B&quot;);
   Print(B.String());
//--- Adi√ß√£o de matrizes
   Print(&quot;---- Adi√ß√£o das matrizes A e B&quot;);
   C=A+B;
//--- Sa√≠da da representa√ß√£o da string formatada
   Print(C.String());
//--- Multiplica√ß√£o de matrizes
   Print(&quot;---- Multiplica√ß√£o das matrizes A e B&quot;);
   C=A*B;
   Print(C.String());
//--- Agora mostraremos como obter valores no estilo dos arrays din√¢micos matrix[i][j]
   Print(&quot;Sa√≠da de valores da matriz C elemento a elemento&quot;);
//--- Atravessar as linhas da matriz - objetos CRow - num loop
   for(int i=0;i&lt;3;i++)
     {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
218
</p>
<pre><code class="language-mql5">
      string com=&quot;| &quot;;
      //--- Formar linhas a partir da matriz para o valor
      for(int j=0;j&lt;3;j++)
        {
         //--- Obter o elemento da matriz pelo n√∫mero de linha e coluna
         double element=C[i][j];// [i] - Acesso para CRow no array m_rows[] ,
                                // [j] - Operador sobrecarregado da indexa√ß√£o em CRow
         com=com+StringFormat(&quot;a(%d,%d)=%G ; &quot;,i,j,element);
        }
      com+=&quot;|&quot;;
      //--- Sa√≠da dos valores da linha
      Print(com);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Class &quot;Row&quot;                                                      |
//+------------------------------------------------------------------+
class CRow
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double            m_array[];
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Construtores e um destrutor
                     CRow(void)          { ArrayResize(m_array,0);    }
                     CRow(const CRow &amp;r) { this=r;                    }
                     CRow(const double &amp;array[]);
                    ~CRow(void){};
   //--- N√∫mero de elementos na linha
   int               Size(void) const    { return(ArraySize(m_array));}
   //--- Retorna uma string com valores
   string            String(void) const;
   //--- Operador de indexa√ß√£o
   double            operator[](int i) const  { return(m_array[i]);   }
   //--- Operadores de atribui√ß√£o
   void              operator=(const double  &amp;array[]); // Uma array
   void              operator=(const CRow &amp; r);         // Outro objeto CRow
   double            operator*(const CRow &amp;o);          // Objeto CRow para multiplica
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Construtor para inicializar uma linha com um array¬†              |
//+------------------------------------------------------------------+
void  CRow::CRow(const double &amp;array[])
  {
   int size=ArraySize(array);
//--- Se o array n√£o est√° vazio
   if(size&gt;0)
     {
      ArrayResize(m_array,size);
      //--- Preencher com valores</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
219
</p>
<pre><code class="language-mql5">
      for(int i=0;i&lt;size;i++)
         m_array[i]=array[i];
     }
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Atribuir opera√ß√£o para o array¬†                                  |
//+------------------------------------------------------------------+
void CRow::operator=(const double &amp;array[])
  {
   int size=ArraySize(array);
   if(size==0) return;
//--- Preencher array com valores
   ArrayResize(m_array,size);
   for(int i=0;i&lt;size;i++) m_array[i]=array[i];
//--- 
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Opera√ß√£o de atribui√ß√£o para CRow¬†                                |
//+------------------------------------------------------------------+
void CRow::operator=(const CRow  &amp;r)
  {
   int size=r.Size();
   if(size==0) return;
//--- Preencher array com valores
   ArrayResize(m_array,size);
   for(int i=0;i&lt;size;i++) m_array[i]=r[i];
//--- 
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Operador de multiplica√ß√£o por outra linha¬†                       |
//+------------------------------------------------------------------+
double CRow::operator*(const CRow &amp;o)
  {
   double res=0;
//--- Verifica√ß√µes
   int size=Size();
   if(size!=o.Size() || size==0)
     {
      Print(__FUNCSIG__,&quot;: Falha ao multiplicar duas matrizes, elas s√£o de tamanhos di
      return(res);
     }
//--- Multiplicar arrays elemento a elemento e adicionar os produtos
   for(int i=0;i&lt;size;i++)
      res+=m_array[i]*o[i];
//--- Resultado
   return(res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
220
</p>
<pre><code class="language-mql5">
//| Retorno da representa√ß√£o da string formatada¬†                    |
//+------------------------------------------------------------------+
string CRow::String(void) const
  {
   string out=&quot;&quot;;
//--- Se o tamanho do array √© maior do que zero
   int size=ArraySize(m_array);
//--- Trabalhamos apenas com n√∫meros diferentes de zero dos elementos array
   if(size&gt;0)
     {
      out=&quot;{&quot;;
      for(int i=0;i&lt;size;i++)
        {
         //--- Recolher os valores para a string
         out+=StringFormat(&quot; %G;&quot;,m_array[i]);
        }
      out+=&quot; }&quot;;
     }
//--- Resultado
   return(out);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Class &quot;Matrix&quot;                                                   |
//+------------------------------------------------------------------+
class CMatrix
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   CRow              m_rows[];
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Construtores e um destrutor
                     CMatrix(void);
                     CMatrix(int rows)  { ArrayResize(m_rows,rows);             }
                    ~CMatrix(void){};
   //--- Obter os tamanhos de matriz
   int               Rows()       const { return(ArraySize(m_rows));            }
   int               Cols()       const { return(Rows()&gt;0? m_rows[0].Size():0); }
   //--- Retorna o valor da coluna na forma da linha Crow
   CRow              GetColumnAsRow(const int col_index) const;
   //--- Retorna uma string com valores de matriz
   string            String(void) const;
   //--- O operador de indexa√ß√£o retorna uma string pelo seu n√∫mero
   CRow *operator[](int i) const        { return(GetPointer(m_rows[i]));        }
   //--- Operador de adi√ß√£o
   CMatrix           operator+(const CMatrix &amp;m);
   //--- Operador de multiplica√ß√£o
   CMatrix           operator*(const CMatrix &amp;m);
   //--- Operador de atribui√ß√£o
   CMatrix          *operator=(const CMatrix &amp;m);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
221
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Um construtor padr√£o, cria um array de linhas de tamanho zero¬†   |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CMatrix::CMatrix(void)</h3>
</p>
<pre><code class="language-mql5">
  {
//--- O n√∫mero zero das linhas na matriz
   ArrayResize(m_rows,0);
//---  
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna o valor da coluna na forma de CRow¬†                      |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CRow  CMatrix::GetColumnAsRow(const int col_index) const</h3>
</p>
<pre><code class="language-mql5">
  {
//--- A vari√°vel para obter os valores a partir da coluna
   CRow row();
//--- O n√∫mero de linhas na matriz
   int rows=Rows();
//--- Se o n√∫mero de linhas maior do que zero, executar a opera√ß√£o
   if(rows&gt;0)
     {
      //--- Um array para receber os valores da coluna com √≠ndice col_indez
      double array[];
      ArrayResize(array,rows);
      //--- Preenchendo o array
      for(int i=0;i&lt;rows;i++)
        {
         //--- Verificar o n√∫mero da coluna para a linha i - que podem ultrapassar os 
         if(col_index&gt;=this[i].Size())
           {
            Print(__FUNCSIG__,&quot;: Erro! N√∫mero da coluna &quot;,col_index,&quot;&gt; tamanho da linh
            break; // linha n√£o inicializar√° o objeto
           }
         array[i]=this[i][col_index];
        }
      //--- Criar uma linha CRow baseada nos valores do array
      row=array;
     }
//--- Resultado
   return(row);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Adicionar duas matrizes¬†                                         |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CMatrix CMatrix::operator+(const CMatrix &amp;m)</h3>
</p>
<pre><code class="language-mql5">
  {
//--- O n√∫mero de linha e colunas na matriz passada
   int cols=m.Cols();</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
222
</p>
<pre><code class="language-mql5">
   int rows=m.Rows();
//--- A matriz recebe os resultados da adi√ß√£o
   CMatrix res(rows);
//--- Os tamanhos de matriz devem coincidir
   if(cols!=Cols() || rows!=Rows())
     {
      //--- Adi√ß√£o imposs√≠vel
      Print(__FUNCSIG__,&quot;: Falha para adicionar duas matrizes, seus tamanhos s√£o difer
      return(res);
     }
//--- Array auxiliar
   double arr[];
   ArrayResize(arr,cols);
//--- Atravessar as linhas para adicionar
   for(int i=0;i&lt;rows;i++)
     {
      //--- Escrever os resultados da adi√ß√£o das strings matriz no array
      for(int k=0;k&lt;cols;k++)
        {
         arr[k]=this[i][k]+m[i][k];
        }
      //--- Colocar o array para a linha matriz
      res[i]=arr;
     }
//--- retorna o resultado da adi√ß√£o de matrizes
   return(res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Multiplica√ß√£o de duas matrizes¬†                                  |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CMatrix CMatrix::operator*(const CMatrix &amp;m)</h3>
</p>
<pre><code class="language-mql5">
  {
//--- N√∫mero de colunas da primeira matriz, n√∫mero de linhas transmitidas na matriz
   int cols1=Cols();
   int rows2=m.Rows();
   int rows1=Rows();
   int cols2=m.Cols();
//--- Matriz para receber o resultado da adi√ß√£o
   CMatrix res(rows1);
//--- Matrizes devem ser coordenadas
   if(cols1!=rows2)
     {
      //--- Multiplica√ß√£o imposs√≠vel
      Print(__FUNCSIG__,&quot;: Falha para multiplicar duas matrizes, formato n√£o √© compat√≠
            &quot;- o n√∫mero de colunas no primeiro fator deveria ser igual ao n√∫mero de li
      return(res);
     }
//--- Array auxiliar
   double arr[];</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
223
</p>
<pre><code class="language-mql5">
   ArrayResize(arr,cols1);
//--- Preencher as linhas na multiplica√ß√£o da matriz
   for(int i=0;i&lt;rows1;i++)// Atravessar as linhas
     {
      //--- Restabelecer o array recebido
      ArrayInitialize(arr,0);
      //--- Atravessar elementos na linha
      for(int k=0;k&lt;cols1;k++)
        {
         //--- Levar valores da coluna k da matriz m para CRow
         CRow column=m.GetColumnAsRow(k);
         //--- Multiplicar duas linhas e escrever o resultado da multiplica√ß√£o escalar
         arr[k]=this[i]*column;
        }
      //--- colocar array arr[] na linha i-th da matriz
      res[i]=arr;
     }
//--- Retornar o produto das duas matrizes
   return(res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Opera√ß√£o de atribui√ß√£o¬†                                          |
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>CMatrix *CMatrix::operator=(const CMatrix &amp;m)</h3>
</p>
<pre><code class="language-mql5">
  {
//--- Preencher e defineir o n√∫mero de linhas
   int rows=m.Rows();
   ArrayResize(m_rows,rows);
//--- Preencher nossas linhas com valores das linhas da matriz anterior
   for(int i=0;i&lt;rows;i++) this[i]=m[i];
//---
   return(GetPointer(this));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Representa√ß√£o string da matriz¬†                                  |
//+------------------------------------------------------------------+
string CMatrix::String(void) const
  {
   string out=&quot;&quot;;
   int rows=Rows();
//--- Formar string por string
   for(int i=0;i&lt;rows;i++)
     {
      out=out+this[i].String()+&quot;\r\n&quot;;
     }
//--- Resultado
   return(out);
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
224
<h3>Tamb√©m Veja</h3>
Sobrecarga, Opera√ß√µes Aritm√©ticas, Sobrecarga de Fun√ß√£o, Regras de Preced√™ncia</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
225
<h3>Descri√ß√£o de Fun√ß√µes Externas</h3>
As fun√ß√µes externas definidas em outro m√≥dulo devem ser explicitamente descritas. A descri√ß√£o inclui
o tipo retornado, o nome da fun√ß√£o e uma s√©rie dos par√¢metros de entrada com os seus tipos. A
aus√™ncia de tal descri√ß√£o pode levar a erros ao compilar, construir e executar um programa. Ao
descrever um objeto externo, use a palavra-chave #import indicando o m√≥dulo.
<h3>Exemplos:</h3>
#import &quot;user32.dll&quot;
  int     MessageBoxW(int hWnd ,string szText,string szCaption,int nType);
  int     SendMessageW(int hWnd,int Msg,int wParam,int lParam);
#import &quot;lib.ex5&quot;
  double  round(double value);
#import
Com a ajuda do import, √© f√°cil descrever fun√ß√µes que s√£o chamadas de DLL externas ou de bibliotecas
(libraries) EX5 compiladas. Bibliotecas (libraries) EX5 s√£o arquivos ex5 compilados, que t√™m a
propriedade library. Somente fun√ß√µes descritas com o modificador export pode ser importadas de
bibliotecas (libraries) EX5.
Lembre-se de que as bibliotecas DLL e EX5 devem ter nomes diferentes (independentemente dos
diret√≥rios em que est√£o localizados) se forem importados juntos. Todas as fun√ß√µes importadas t√™m a
resolu√ß√£o de escopo correspondente √† biblioteca &quot;file name&quot;.
<h3>Exemplo:</h3>
#import &quot;kernel32.dll&quot;
</p>
<pre><code class="language-mql5">
   int GetLastError();
</code></pre>
<p>
#import &quot;lib.ex5&quot;
</p>
<pre><code class="language-mql5">
   int GetLastError();
</code></pre>
<p>
#import
</p>
<pre><code class="language-mql5">
class CFoo
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   int            GetLastError() { return(12345); }
   void           func()
     {
      Print(GetLastError());           // Chamada do m√©todo de classe
      Print(::GetLastError());         // chamar a fun√ß√£o MQL5
      Print(kernel32::GetLastError()); // Chamada da fun√ß√£o de biblioteca DLL a partir
      Print(lib::GetLastError());      // Chamada da fun√ß√£o da biblioteca EX5 lib.ex5
     }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   CFoo foo;
   foo.func();
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
226
<h3>Tamb√©m Veja</h3>
<h3>Sobrecarga (Overload), Fun√ß√µes Virtuais, Polimorfismo</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
227
<h3>Exporta√ß√£o de Fun√ß√µes</h3>
Uma fun√ß√£o declarada em um programa MQL5 com o p√≥s-modificador export pode ser usada em um
outro programa MQL5. Tal fun√ß√£o √© chamada export√°vel, e ela pode ser chamada de outros programas
ap√≥s compila√ß√£o.
</p>
<pre><code class="language-mql5">
int Function() export
  {
</code></pre>
<p>
  }
Este modificador ordena o compilador a adicionar a fun√ß√£o na tabela de fun√ß√µes EX5 exportada por
este arquivo ex5. Somente fun√ß√µes com tal modificador podem ser acess√≠veis (&quot;vis√≠veis&quot;) a partir de
outros programas MQL5.
A propriedade library diz ao compilador que o arquivo-EX5 ser√° uma biblioteca (library), e o compilador
o exibir√° no cabe√ßalho da EX5. 
Todas as fun√ß√£o que s√£o planejadas a serem export√°veis devem ser marcadas com o modificador
export.
<h3>Tamb√©m Veja</h3>
<h3>Sobrecarga (Overload), Fun√ß√µes Virtuais, Polimorfismo</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
228
<h3>Fun√ß√µes de Manipula√ß√£o de Evento</h3>
A linguagem MQL5 fornece processamento de alguns eventos pr√©-definidos. Fun√ß√µes para manipula√ß√£o
destes eventos devem ser definidas em um programa MQL5; nome da fun√ß√£o, tipo de retorno,
composi√ß√£o dos par√¢metros (se existir algum) e seus tipos devem estar rigorosamente em
conformidade com a descri√ß√£o da fun√ß√£o de handler (manipulador) de evento.
O handler (manipulador) de evento do terminal cliente identifica fun√ß√µes, manipulando este ou aquela
evento, pelo tipo de valor de retorno e tipo de par√¢metros. Se outros par√¢metros, que n√£o
correspondem √†s descri√ß√µes abaixo, s√£o especificadas para uma fun√ß√£o correspondente, ou outro tipo
de retorno √© indicado para ela, tal fun√ß√£o n√£o ser√° usada como um handler (manipulador) de evento.
<h3>OnStart</h3>
A fun√ß√£o OnStart() √© o handler (manipulador) do evento Start ,que √© automaticamente gerado
somente para execu√ß√µes de scripts. Ela dever ser do tipo void, sem par√¢metros:
</p>
<pre><code class="language-mql5">
void OnStart();
</code></pre>
<p>
Para a fun√ß√£o OnStart(), o tipo de retorno int pode ser especificado.
<h3>OnInit</h3>
A fun√ß√£o OnInit() √© o handler (manipulador) do evento Init. Ela deve ser do tipo void ou int, sem
par√¢metros:
</p>
<pre><code class="language-mql5">
void OnInit();
</code></pre>
<p>
O evento Init √© gerado imediatamente ap√≥s um Expert Advisor ou um indicador ser baixado; este
evento n√£o √© gerado para scripts. A fun√ß√£o OnInit() √© usada para inicializa√ß√£o. Se OnInit() tiver o tipo
</p>
<pre><code class="language-mql5">
int de valor de retorno, o c√≥digo de retorno n√£o-zero significa inicializa√ß√£o sem sucesso e √© gerado o
</code></pre>
<p>
evento Deinit com o c√≥digo do motivo da desinicializa√ß√£o REASON_INITFAILED. 
Ao retornar o valor INIT_FAILED o Expert Advisor ser√° retirado √† for√ßa do gr√°fico. 
Ao retornar o valor INIT_FAILED o indicador n√£o ser√° removido do gr√°fico. Nesse caso, o indicador
restante no gr√°fico estar√° inoperante ‚Äî os manipuladores de eventos n√£o s√£o chamados no indicador. 
Para otimizar os par√¢metros de entrada de um Expert Advisor, √© recomendado usar valores da
enumera√ß√£o ENUM_INIT_RETCODE como c√≥digo de retorno. Esses valores s√£o usados para organizar o
curso da otimiza√ß√£o, incluindo a sele√ß√£o dos mais apropriados agentes de teste. Durante a
inicializa√ß√£o de um Expert Advisor, antes do in√≠cio do teste, voc√™ pode solicitar informa√ß√£o sobre a
configura√ß√£o e recursos de um agente (o n√∫mero de cores, quantidade de mem√≥ria livre, etc) usando a
fun√ß√£o TerminalInfoInteger(). Baseado nestas informa√ß√µes obtidas, pode-se tanto permitir usar este
agente de teste, ou rejeitar us√°-lo durante a otimiza√ß√£o deste Expert Advisor.
<h3>ENUM_INIT_RETCODE</h3>
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>INIT_SUCCEEDED</h3>
Inicializa√ß√£o bem sucedida, teste do Expert Advisor pode
continuar.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
229
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
Este c√≥digo significa o mesmo que um valor null = o Expert
Advisor foi inicializado com sucesso no Provador de Estrat√©gia.
<h3>INIT_FAILED</h3>
Inicializa√ß√£o com falha; n√£o existe motivo para continuar
testando por cause de erros fatais. Por exemplo, falha em criar
um indicador que √© requerido para o funcionamento do Expert
Advisor.
Este valor de retorno significa o mesmo que um valor diferente
de zero - inicializa√ß√£o do Expert Advisor pelo Provador de
Estrat√©gia falhou.
<h3>INIT_PARAMETERS_INCORRECT</h3>
Este valor significa a incorreta defini√ß√£o da entrada de
par√¢metros. A seq√º√™ncia de resultado contendo o c√≥digo de
retorno √© destacado em vermelho na tabela de otimiza√ß√£o
geral.
O teste para o dado conjunto de par√¢metros do Expert Advisor
n√£o ser√° executado, o agente √© liberado para receber uma nova
tarefa.
Depois de receber este valor, o testador de estrat√©gia com
seguran√ßa n√£o vai passar essa tarefa para que outros agentes
tentem novamente.
<h3>INIT_AGENT_NOT_SUITABLE</h3>
Nenhum erro durante a inicializa√ß√£o, mas por alguma raz√£o o
agente n√£o √© adequado para o teste. Por exemplo, aus√™ncia de
mem√≥ria suficiente, sem support ao OpenCL, etc. 
Ap√≥s este c√≥digo de retorno, o agente n√£o receber√° tarefas at√©
o fim desta otimiza√ß√£o.
A fun√ß√£o OnInit() do tipo void sempre indica inicializa√ß√£o bem sucedida.
<h3>OnDeinit</h3>
A fun√ß√£o OnDeinit() √© chamada durante a desinicializa√ß√£o e √© o handler (manipulador) do evento
Deinit. Ela deve ser declarada com o tipo void e ter um par√¢metro do tipo const int, que cont√©m o
c√≥digo do motivo da desinicializa√ß√£o. Se um tipo diferente √© declarado, o compilador gerar√° um aviso
e a fun√ß√£o n√£o ser√° chamada. Para scripts o evento Deinit n√£o √© gerado e portanto a fun√ß√£o
OnDeInit() n√£o pode ser usada em scripts.
</p>
<pre><code class="language-mql5">
void OnDeinit(const int reason);
</code></pre>
<p>
O evento Deinit √© gerado para Expert Advisors e indicadores nos seguintes casos:
¬∑ antes de uma reinicializa√ß√£o devido √† mudan√ßa de ativo (symbol) ou per√≠odo do gr√°fico no qual o
programa MQL5 est√° anexado;
¬∑ antes de uma reinicializa√ß√£o devido √† mudan√ßa de par√¢metros de entrada;
¬∑ antes de descarregar o programa MQL5.
<h3>OnTick</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
230
O evento NewTick √© gerado para Expert Advisors somente quanto um novo pre√ßo (tick) para um ativo
√© recebido pelo gr√°fico no qual o Expert Advisor est√° anexado. √â in√∫til definir a fun√ß√£o OnTick() num
indicador personalizado ou script, porque o evento NewTick n√£o √© gerado para eles.
O evento Tick √© gerado apenas para Expert Advisors, mas isso n√£o significa que Expert Advisors
requer a fun√ß√£o OnTick(), uma vez que n√£o s√£o apenas os eventos NewTick gerados para Expert
Advisors, mas tamb√©m s√£o gerados os eventos de Timer, BookEvent e ChartEvent. Ela deve ser
declarada com o tipo void, sem par√¢metros:
</p>
<pre><code class="language-mql5">
void OnTick();
</code></pre>
<p>
<h3>OnTimer</h3>
A fun√ß√£o OnTimer() √© chamada quando o evento Timer ocorre, que √© gerado pelo timer do sistema
somente para Expert Advisors e indicadores - ela n√£o pode ser usada em scprits. A freq√º√™ncia de
ocorr√™ncia do evento √© definida na subscri√ß√£o de notifica√ß√µes deste evento atrav√©s da fun√ß√£o
EventSetTimer(). 
Voc√™ pode desfazer a subscri√ß√£o de receber eventos de timer para um Expert Advisor particular usando
a fun√ß√£o EventKillTimer(). A fun√ß√£o de ser definida com o tipo void, sem par√¢metros:
</p>
<pre><code class="language-mql5">
void OnTimer();
</code></pre>
<p>
√â recomend√°vel chamar a fun√ß√£o EventSetTimer() uma vez na fun√ß√£o OnInit(), e a fun√ß√£o
EventKillTimer() deve ser chamada uma vez em OnDeinit().
Todo Expert Advisor, assim como todo indicador funciona com seu pr√≥prio timer e recebe eventos
apenas a partir dele. T√£o logo um programa MQL5 para de funcionar, o timer √© destru√≠do de forma
for√ßada, se ele foi criado mas n√£o desabilitado pela fun√ß√£o EventKillTimer().
<h3>OnTrade</h3>
A fun√ß√£o √© chamada quando o evento Trade ocorre, que surge quando voc√™ muda a lista de ordens
postadas e posi√ß√µes abertas, o hist√≥rico de ordens e hist√≥rico de opera√ß√µes (deals). Quando uma
atividade de negocia√ß√£o (trade) √© realizada (abertura de ordem pendente, abertura/fechamento de
posi√ß√£o, defini√ß√£o de stop, disparo de ordem pendente, etc.) o hist√≥rico de ordens e opera√ß√µes (deals)
e/ou a lista de posi√ß√µes e ordens correntes s√£o por conseq√º√™ncia alterados.
</p>
<pre><code class="language-mql5">
void OnTrade();
</code></pre>
<p>
Os usu√°rios devem implementar de forma independente no c√≥digo a verifica√ß√£o do estado de uma
conta de negocia√ß√£o quanto tal evento √© recebido (se isto √© requerido pelas condi√ß√µes da estrat√©gia de
neg√≥cio). Se a chamada da fun√ß√£o OrderSend() foi conclu√≠da com sucesso e retornou um valor de true,
isso significa que o servidor de negocia√ß√£o postou a ordem na fila de execu√ß√£o e atribuiu um n√∫mero
de bilhetagem (ticket number) nele. T√£o logo o servidor processe esta ordem, o evento Trade ser√°
gerado. E se um usu√°rio lembrar valor da bilhetagem (ticket), ele/ela ser√° capaz de descobrir o que
aconteceu com a ordem usando este valor na fun√ß√£o OnTrade().
<h3>OnTradeTransaction</h3>
Ao realizar algumas a√ß√µes espec√≠ficas em uma conta de negocia√ß√£o, seu estado muda. Tais a√ß√µes
includem:</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
231
¬∑ Envio de uma solicita√ß√£o de negocia√ß√£o a partir de algum aplicativo MQL5 no terminal usando as
fun√ß√µes OrderSend e OrderSendAsync e sua posterior execu√ß√£o.
¬∑ Envio de uma solicita√ß√£o de negocia√ß√£o por meio da interface gr√°fica do terminal e sua posterior
execu√ß√£o.
¬∑ Ativa√ß√£o de ordens pendentes e ordens de stop no servidor.
¬∑ Realiza√ß√£o de opera√ß√µes no lado de um servidor de negocia√ß√£o.
As seguintes transa√ß√µes de negocia√ß√£o s√£o realizadas como resultado destas a√ß√µes:
¬∑ tratamento de uma solicita√ß√£o de negocia√ß√£o
¬∑ mudan√ßa de ordens de abertura
¬∑ mudan√ßa de hist√≥rico de ordens
¬∑ mudan√ßa de hist√≥rico de opera√ß√µes (deals)
¬∑ mudan√ßa de posi√ß√µes
Por exemplo, ao enviar uma ordem de compra de mercado, ela √© tratada, uma ordem de compra
apropriada √© criada para a conta, a ordem √© ent√£o executada e removida da lista de ordens em
aberto, e ent√£o ela √© adicionada ao hist√≥rico de ordens, uma apropriada opera√ß√£o (deal) √© adicionada
ao hist√≥rico e uma nova posi√ß√£o √© criada. Todas estas a√ß√µes s√£o transa√ß√µes de negocia√ß√£o. A chegada
de tal transa√ß√£o no terminal √© um evento TradeTransaction. Ele chama o handler (manipulador) de
evento OnTradeTransaction.
</p>
<pre><code class="language-mql5">
void¬† OnTradeTransaction(
   const MqlTradeTransaction&amp;¬†   trans,¬†       // estrutura das transa√ß√µes de neg√≥cios
   const MqlTradeRequest&amp;¬†       request,¬†     // estrutura solicitada
   const MqlTradeResult&amp; ¬†       result ¬†      // resultado da estrutura
   );
</code></pre>
<p>
<h3>O handler (manipulador) cont√©m tr√™s par√¢metros:</h3>
¬∑ trans - este par√¢metro obt√©m a estrutura MqlTradeTransaction descrevendo uma transa√ß√£o de
negocia√ß√£o aplicada a uma conta de neg√≥cio.
¬∑ request - este par√¢metro obt√©m a estrutura MqlTradeRequest descrevendo uma solicita√ß√£o de
neg√≥cio;
¬∑ result - este par√¢metro obt√©m a estrutura MqlTradeResult descrevendo o resultado da execu√ß√£o de
uma solicita√ß√£o de negocia√ß√£o.
Os √∫ltimos dois par√¢metros, request e result, s√£o preenchidos por valores somente para uma
transa√ß√£o de tipo TRADE_TRANSACTION_REQUEST, dados sobre uma transa√ß√£o podem ser recebidos a
partir do par√¢metro do tipo da vari√°vel trans. Note que neste caso, o campo request_id na vari√°vel
result cont√©m o ID da solicita√ß√£o  de neg√≥cio, ap√≥s a execu√ß√£o da transa√ß√£o de negocia√ß√£o, descrita
na vari√°vel trans, ter sido realizada. O identificador da solicita√ß√£o (Request ID) permite associar a
a√ß√£o realizada (chamada de fun√ß√µes OrderSend ou OrderSendAsync) com o resultado da a√ß√£o enviado
para OnTradeTransaction().
Uma solicita√ß√£o de negocia√ß√£o manualmente enviada a partir do terminal ou via fun√ß√µes
OrderSend()/OrderSendAsync() podem gerar v√°rias transa√ß√µes consecutivas no servidor de neg√≥cios. A
prioridade de chegada dessas transa√ß√µes no terminal n√£o √© garantida. Assim, voc√™ n√£o deve esperar
que um grupo de transa√ß√µes chegar√° ap√≥s um outro grupo ao desenvolver seu algoritmo de
negocia√ß√£o.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
232
¬∑ Todos 
os 
tipo 
de 
transa√ß√µes 
de 
negocia√ß√£o 
s√£o 
descritas 
na 
enumera√ß√£o
ENUM_TRADE_TRANSACTION_TYPE.
¬∑ A estrutura MqlTradeTransaction descrevendo um transa√ß√£o de negocia√ß√£o √© preenchida de
diferentes formas dependendo do tipo de transa√ß√£o. Por exemplo, somente o campo de tipo
(tipo de transa√ß√£o de negocia√ß√£o) deve ser analisado para 
transa√ß√µes 
do 
tipo
TRADE_TRANSACTION_REQUEST. O segundo e terceiro par√¢metros (request e result) da fun√ß√£o
OnTradeTransaction deve ser analisado para dados adicionais. Para informa√ß√µes adicionais,
veja Estrutura de uma Transa√ß√£o de Negocia√ß√£o.
¬∑ Uma descri√ß√£o de transa√ß√£o de negocia√ß√£o n√£o entrega todas as informa√ß√µes dispon√≠veis
relativas a ordens, opera√ß√µes (deals) e posi√ß√µes (por exemplo, coment√°rios). As fun√ß√µes
OrderGet*, HistoryOrderGet*, HistoryDealGet* e PositionGet* devem ser usadas para obter
informa√ß√µes adicionais.
Ap√≥s aplicar transa√ß√µes de negocia√ß√£o em uma conta de cliente, elas s√£o consistentemente postadas
na fila de transa√ß√µes de neg√≥cio do terminal, a partir da qual s√£o consistentemente enviados para o
ponto de entrada OnTradeTransaction na ordem de chegada no terminal.
Ao tratar transa√ß√µes de negocia√ß√£o por um Expert Advisor usando o handler OnTradeTransaction
(Manipulador sobre Transa√ß√£o de Com√©rcio), o terminal continua manipulando as transa√ß√µes de
negocia√ß√£o rec√©m chegadas. Portanto, o estado de uma conta de negocia√ß√£o pode mudar durante uma
opera√ß√£o OnTradeTransaction. Por exemplo, enquanto um programa MQL5 manipula um evento para
adicionar uma nova ordem, ela pode ser executada, deletada da lista das abertas e movida para o
hist√≥rico. Mais adiante, o aplicativo ser√° notificado destes eventos.
O comprimento da fila de transa√ß√µes compreende 1024 elementos. Se OnTradeTransaction tratar uma
nova transa√ß√£o por muito tempo, as transa√ß√µes mais antigas na fila podem ser substitu√≠das pelas
novas.
¬∑ De forma geral, n√£o existe um propor√ß√£o precisa entre o n√∫mero de chamadas de OnTrade e
OnTradeTransactions. Uma chamada OnTrade corresponde a uma ou v√°rias chamadas
OnTradeTransactions.
¬∑ OnTrade √© chamada ap√≥s apropriadas chamadas OnTradeTransaction.
<h3>OnTester</h3>
A fun√ß√£o OnTester() √© o handler (manipulador) do evento Tester que √© automaticamente gerado ap√≥s
um teste de hist√≥rico de um Expert Advisor no intervalo escolhido ter terminado. A fun√ß√£o deve estar
definida com o tipo double, sem par√¢metros:
</p>
<pre><code class="language-mql5">
double OnTester();
</code></pre>
<p>
A fun√ß√£o √© chamada logo antes da chamada de OnDeinit() e tem o mesmo tipo do valor de retorno -
double. OnTester() pode ser usado apenas no teste de Expert Advisors. Seu principal prop√≥sito √©
calcular um certo valor que √© usado como o crit√©rio max customizado na otimiza√ß√£o gen√©tica de
par√¢metros de entrada.
Na otimiza√ß√£o gen√©tica, a ordena√ß√£o descendente √© aplica aos resultados de uma gera√ß√£o. Isto √©, do
ponto de vista do crit√©rio de otimiza√ß√£o, os melhores resultados s√£o aqueles com o maiores valores
(os valores do crit√©rio de otimiza√ß√£o max customizado retornados pela fun√ß√£o OnTester s√£o levados</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
233
em considera√ß√£o). Em tal ordena√ß√£o, os piores valores s√£o posicionados no final e posteriormente
jogados fora e n√£o participam na forma√ß√£o da nova gera√ß√£o.
<h3>OnTesterInit</h3>
√â chamada em EAs quando ocorre o evento TesterInit para executar as a√ß√µes necess√°rias antes do
in√≠cio da otimiza√ß√£o no testador de estrat√©gia. Existem duas vers√µes da fun√ß√£o.
<h3>Vers√£o com retorno de resultado</h3>
</p>
<pre><code class="language-mql5">
int¬† OnTesterInit(void);
</code></pre>
<p>
<h3>Valor retornado</h3>
Valor do tipo int, zero significa inicializa√ß√£o bem-sucedida do EA em execu√ß√£o no gr√°fico antes do
in√≠cio da otimiza√ß√£o.
O uso da chamada da OnTesterInit() com o retorno de resultado √© prioridade, pois este m√©todo
permite n√£o apenas inicializar o programa, mas tamb√©m retornar o c√≥digo de erro em caso de t√©rmino
antecipado da otimiza√ß√£o. Retorno de qualquer valor diferente de INIT_SUCCEEDED (0) significa um
erro e n√£o ser√° inicializada a otimiza√ß√£o.
Vers√£o sem retorno do resultado √© deixada apenas para compatibilidade com c√≥digos antigos. N√£o √©
recomendada
</p>
<pre><code class="language-mql5">
void¬† OnTesterInit(void);
</code></pre>
<p>
Com o in√≠cio da otimiza√ß√£o, um Expert Advisor com o handler (manipulador) OnTesterInit() ou
OnTesterPass() √© automaticamente carregado em um gr√°fico separado do terminal com o ativo e
per√≠odo especificados no Provador de Estrat√©gia, e recebe o evento TesterInit. A fun√ß√£o √© usada para
inicializar o Expert Advisor antes de iniciar a otimiza√ß√£o para posterior processamento dos resultados
da otimiza√ß√£o.
<h3>OnTesterPass</h3>
A fun√ß√£o OnTesterPass() √© um handler (manipulador) do evento TesterPass, que √© automaticamente
gerado quanto um plano √© recebido durando a otimiza√ß√£o de um Expert Advisor no Provador de
Estrat√©gia. A fun√ß√£o deve ser definida com o tipo void. Ele n√£o tem par√¢metros:
</p>
<pre><code class="language-mql5">
void OnTesterPass();
</code></pre>
<p>
Um Expert Advisor com o handler (manipulador) OnTesterPass() √© automaticamente carregado em um
gr√°fico separado do terminal com o ativo/per√≠odo especificados para teste, e obt√©m eventos
TesterPass quando um plano √© recebido durante uma otimiza√ß√£o. A fun√ß√£o √© usada para tratamento
din√¢mico dos resultados de otimiza√ß√£o &quot;no local&quot; sem precisar esperar pela sua conclus√£o. Planos s√£o
adicionados usando a fun√ß√£o FrameAdd(), que pode ser chamada ap√≥s o fim de um passo √∫nico no
handler (manipulador) OnTester() .
<h3>OnTesterDeinit</h3>
OnTesterDeinit() √© um handler (manipulador) do TesterDeinit, que √© automaticamente gerada ap√≥s o
fim da optimiza√ß√£o de um Expert Advisor no Provador de Estrat√©gia. A fun√ß√£o deve ser definida com o
tipo void. Ele n√£o tem par√¢metros:</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
234
</p>
<pre><code class="language-mql5">
void OnTesterDeinit();
</code></pre>
<p>
Um Expert Advisor com o handler (manipulador) TesterDeinit() √© automaticamente carregada em um
gr√°fico no in√≠cio da otimiza√ß√£o, e recebe TesterDeinit ap√≥s sua conclus√£o. A fun√ß√£o √© usada para um
processamento final de todos os resultados da otimiza√ß√£o. 
<h3>OnBookEvent</h3>
A fun√ß√£o OnBookEvent() √© o handler (manipulador) do BookEvent. BookEvent √© gerado para Expert
Advisors e indicadores somente quando a Profundidade do Mercado muda. Ela deve do tipo void e ter
um par√¢metro do tipo string:
</p>
<pre><code class="language-mql5">
void OnBookEvent (const string&amp; symbol);
</code></pre>
<p>
Para receber eventos BookEvent para qualquer ativo (symbol), voc√™ apenas precisa fazer uma pr√©-
subscri√ß√£o pra receber eventos para este ativo usando a fun√ß√£o MarketBookAdd(). A fim de desfazer a
subscri√ß√£o 
de 
recebimento 
de 
eventos 
<h3>BookEvent</h3>
para 
um 
particular 
ativo, 
chame
MarketBookRelease(). 
Diferente de outros eventos, o evento BookEvent √© por difus√£o (broadcast). Isso significa que se um
Expert Advisor subscreve para receber eventos BookEvent usando MarketBookAdd, todos os outros
Experts Advisors que tem o handler (manipulador) OnBookEvent() receber√£o este evento. √â portanto
necess√°rio analisar o nome do ativo, que √© passado para o handler (manipulador) atrav√©s dos
par√¢metros const string&amp; symbol.
<h3>OnChartEvent</h3>
OnChartEvent() √© o handler (manipulador) de um grupo de eventos ChartEvent:
¬∑ CHARTEVENT_KEYDOWN ‚Äî evento de uma teclada, quando a janela do gr√°fico est√° com foco;
¬∑ CHARTEVENT_MOUSE_MOVE ‚Äî eventos de movimento de mouse e eventos de click de mouse (se
<h3>CHART_EVENT_MOUSE_MOVE=true √© definido para o gr√°fico);</h3>
¬∑ CHARTEVENT_OBJECT_CREATE 
‚Äî 
evento 
de 
cria√ß√£o 
de 
objeto 
gr√°fico 
(se
<h3>CHART_EVENT_OBJECT_CREATE=true √© definido para o gr√°fico);</h3>
¬∑ CHARTEVENT_OBJECT_CHANGE ‚Äî evento de mudan√ßa de um propriedade de objeto via janela
di√°logo de propriedades;
¬∑ CHARTEVENT_OBJECT_DELETE 
‚Äî 
evento 
de 
exclus√£o 
de 
objeto 
gr√°fico 
(se
<h3>CHART_EVENT_OBJECT_DELETE=true √© definido para o gr√°fico);</h3>
¬∑ CHARTEVENT_CLICK ‚Äî evento de um click de mouse no gr√°fico;
¬∑ CHARTEVENT_OBJECT_CLICK ‚Äî evento de um click de mouse em um objeto gr√°fico pertencente ao
gr√°fico;
¬∑ CHARTEVENT_OBJECT_DRAG ‚Äî evento de um movimento de objeto gr√°fico usando o mouse;
¬∑ CHARTEVENT_OBJECT_ENDEDIT ‚Äî evento da edi√ß√£o de texto finalizada na caixa de entrada do
objeto gr√°fico LabelEdit;
¬∑ CHARTEVENT_CHART_CHANGE ‚Äî evento de mudan√ßas de gr√°fico;
¬∑ CHARTEVENT_CUSTOM+n ‚Äî ID do evento do usu√°rio, onde n est√° na faixa de 0 a 65535.
¬∑ CHARTEVENT_CUSTOM_LAST 
‚Äî 
o 
√∫ltimo 
<h3>ID</h3>
aceit√°vel 
de 
um 
evento 
customizado
(CHARTEVENT_CUSTOM+65535).</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
235
A fun√ß√£o pode ser chamada somente em Expert Advisors e indicadores. A fun√ß√£o deve ser de tipo void
com 4 par√¢metros:
</p>
<pre><code class="language-mql5">
void OnChartEvent(const int id,         // Evento ID
                  const long&amp; lparam,   // Par√¢metro de evento de tipo long
                  const double&amp; dparam, // Par√¢metro de evento de tipo double
                  const string&amp; sparam  // Par√¢metro de evento de tipo string
</code></pre>
<p>
  );
Para cada tipo de evento, os par√¢metros de entrada da fun√ß√£o OnChartEvent() t√™m valores definidos
que s√£o requeridos para o processamento deste evento. Os eventos e valores passados atrav√©s destes
par√¢metros s√£o listados na tabela abaixo.
<h3>Evento</h3>
<h3>Valor</h3>
do
par√¢metro id
<h3>Valor</h3>
do
par√¢metro
lparam
<h3>Valor</h3>
do
par√¢metro
dparam
<h3>Valor</h3>
do
par√¢metro
sparam
<h3>Evento de uma</h3>
teclada
<h3>CHARTEVENT_KE</h3>
<h3>YDOWN</h3>
c√≥digo de uma
tecla pressionada
<h3>Repita</h3>
a
contagem 
(o
n√∫mero de vezes
que a tecla √©
repetida 
como
um resultado de
que 
o 
usu√°rio
pressiona 
a
tecla)
<h3>O valor da string</h3>
de uma pequena
m√°scara 
de
descrever 
o
estado de bot√µes
do teclado
<h3>Eventos</h3>
de
mouse 
(se 
a
propriedade
<h3>CHART_EVENT_</h3>
<h3>MOUSE_MOVE=tr</h3>
ue est√° definida
para o gr√°fico)
<h3>CHARTEVENT_MO</h3>
<h3>USE_MOVE</h3>
a coordenada X
a coordenada Y
<h3>O valor de string</h3>
de uma m√°scara
de 
bites
descrevendo 
o
estado de bot√µes
de mouse
<h3>Evento</h3>
de
cria√ß√£o 
de
objeto 
gr√°fico
(se
<h3>CHART_EVENT_O</h3>
<h3>BJECT_CREATE=t</h3>
rue, 
ent√£o 
√©
definido para o
gr√°fico)
<h3>CHARTEVENT_OB</h3>
<h3>JECT_CREATE</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico criado
<h3>Evento</h3>
de
mudan√ßa de uma
propriedade 
de
objeto via janela
de 
di√°logo 
de
propriedades
<h3>CHARTEVENT_OB</h3>
<h3>JECT_CHANGE</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico
modificado</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
236
<h3>Evento</h3>
<h3>Valor</h3>
do
par√¢metro id
<h3>Valor</h3>
do
par√¢metro
lparam
<h3>Valor</h3>
do
par√¢metro
dparam
<h3>Valor</h3>
do
par√¢metro
sparam
<h3>Evento</h3>
de
exclus√£o 
de
objeto 
gr√°fico
(se
<h3>CHART_EVENT_O</h3>
<h3>BJECT_DELETE=t</h3>
rue est√° definido
para o gr√°fico)
<h3>CHARTEVENT_OB</h3>
<h3>JECT_DELETE</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico exclu√≠do
<h3>Evento de</h3>
um
click de mouse
no gr√°fico
<h3>CHARTEVENT_C</h3>
<h3>LICK</h3>
a coordenada X
a coordenada Y
‚Äî
<h3>Evento de</h3>
um
click de mouse
num 
objeto
gr√°fico
pertencente 
ao
gr√°fico
<h3>CHARTEVENT_OB</h3>
<h3>JECT_CLICK</h3>
a coordenada X
a coordenada Y
<h3>Nome do objeto</h3>
gr√°fico, na qual
o evento ocorreu
<h3>Evento de</h3>
um
objeto 
gr√°fico
arrastado usando
o mouse
<h3>CHARTEVENT_OB</h3>
<h3>JECT_DRAG</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico movido
<h3>Evento da edi√ß√£o</h3>
de 
texto
finalizada 
na
caixa de entrada
do objeto gr√°fico
<h3>LabelEdit</h3>
<h3>CHARTEVENT_OB</h3>
<h3>JECT_ENDEDIT</h3>
‚Äî
‚Äî
<h3>Nome do objeto</h3>
gr√°fico
<h3>LabelEdit,</h3>
cuja
edi√ß√£o de texto
foi conclu√≠da
<h3>Evento</h3>
de
mudan√ßas 
de
gr√°fico
<h3>CHARTEVENT_C</h3>
<h3>HART_CHANGE</h3>
‚Äî
‚Äî
‚Äî
<h3>ID do evento de</h3>
usu√°rio 
sob 
<h3>N</h3>
n√∫mero
<h3>CHARTEVENT_CU</h3>
<h3>STOM+N</h3>
<h3>Valor</h3>
definido
pela 
fun√ß√£o
<h3>EventChartCusto</h3>
m()
<h3>Valor</h3>
definido
pela 
fun√ß√£o
<h3>EventChartCusto</h3>
m()
<h3>Valor</h3>
definido
pela 
fun√ß√£o
<h3>EventChartCusto</h3>
m()
<h3>OnCalculate</h3>
A fun√ß√£o OnCalculate() √© chamada somente em indicadores customizados quando √© necess√°rio calcular
os valores do indicador pelo evento Calculate. Isso geralmente acontece quando um novo pre√ßo (tick) √©
recebido para o ativo, de cujo indicador √© calculado. N√£o √© necess√°rio que este indicador esteja
anexado a qualquer gr√°fico de pre√ßo deste ativo.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
237
A fun√ß√£o OnCalculate() deve retornar um tipo int. Existem duas poss√≠veis defini√ß√µes. Dentro de um
indicador voc√™ n√£o pode usar ambas as vers√µes da fun√ß√£o.
A primeira forma √© destinado para aqueles indicadores que podem ser calculados com um √∫nico buffer
de dados. Um exemplo de tal indicador √© a M√©dia M√≥vel Customizada (Custom Moving Average).
</p>
<pre><code class="language-mql5">
int OnCalculate (const int rates_total,      // tamanho do array price[]
                 const int prev_calculated,  // barras tratadas na chamada anterior
                 const int begin,            // a partir de onde come√ßam os dados sign
                 const double&amp; price[]       // array a ser calculado
   );
</code></pre>
<p>
Assim como o array price[], uma das s√©rie de pre√ßo ou um buffer calculado de algum indicador pode
ser passado. Para determinar a dire√ß√£o da indexa√ß√£o no array price[], chame ArrayGetAsSeries(). A
fim de n√£o depender de valores default, voc√™ deve incondicionalmente chamar a fun√ß√£o
ArraySetAsSeries() para aqueles arrays que voc√™ espera utilizar.
Uma s√©rie de tempo necess√°ria ou um indicador, para ser usado como o array price[], deve ser
selecionado pelo usu√°rio na guia &quot;Par√¢metros&quot; ao iniciar o indicador. Para fazer isso, voc√™ deve
especificar o necess√°rio item no lista drop-down do campo &quot;Aplicar a&quot;.
Para receber valores de um indicador customizado a partir outros programas mql5, a fun√ß√£o iCustom()
√© usada, que retorna o manuseio do indicador para opera√ß√µes subseq√ºentes. Voc√™ pode tamb√©m
especificar o price[] array apropriado ou o manuseio de outro indicador. Este par√¢metro deve ser
transmitido por √∫ltimo na lista de vari√°veis de entrada do indicador customizado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   string terminal_path=TerminalInfoString(STATUS_TERMINAL_PATH);
   int handle_customMA=iCustom(Symbol(),PERIOD_CURRENT, &quot;Custom Moving Average&quot;,13,0, 
   if(handle_customMA&gt;0)
      Print(&quot;handle_customMA = &quot;,handle_customMA);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
238
</p>
<pre><code class="language-mql5">
   else
      Print(&quot;Pode abrir ou n√£o o arquivo EX5 &#x27;&quot;+terminal_path+&quot;\\MQL5\\Indicators\\&quot;+&quot;
</code></pre>
<p>
  }
Neste exemplo, o √∫ltimo par√¢metro passado √© o valor PRICE_TYPICAL (da enumera√ß√£o
ENUM_APPLIED_PRICE), que indica que o indicador customizado ser√° constru√≠do baseado em pre√ßos
t√≠picos obtidos como (High+Low+Close)/3. Se este par√¢metro n√£o for especificado, o indicador √©
constru√≠do baseado em valores de PRICE_CLOSE, isto √©, pre√ßos de fechamento de cada barra.
Outro exemplo que mostra a passagem de um handler (manipulador) de indicador como o √∫ltimo
par√¢metro para especificar o array price[], √© dado na descri√ß√£o da fun√ß√£o iCustom().
A segunda forma √© destinada para todos os outros indicadores, na qual mais de uma s√©rie de tempo √©
usada nos c√°lculos.
</p>
<pre><code class="language-mql5">
int OnCalculate (const int rates_total,      // tamanho da s√©rie de pre√ßos de entrada 
                 const int prev_calculated,  // barras tratadas na chamada anterior
                 const datetime&amp; time[],     // Hora
                 const double&amp; open[],       // Open (abertura)
                 const double&amp; high[],       // High (m√°ximo)
                 const double&amp; low[],        // Low (m√≠nimo)
                 const double&amp; close[],      // Close (fechamento)
                 const long&amp; tick_volume[],  // Volume de Tick
                 const long&amp; volume[],       // Volume Real
                 const int&amp; spread[]         // Spread
   );
</code></pre>
<p>
Os par√¢metros open[], high[], low[] and close[] cont√©m os arrays com pre√ßos de abertura, pre√ßos de
m√°ximo e m√≠nimo e pre√ßos de fechamento da janela de tempo corrente. O par√¢metro time[] cont√©m
um array com valores de hora de abertura, o par√¢metro spread[] tem um array contendo o hist√≥rico de
spreads (se algum spread √© fornecido para o ativo negociado). Os par√¢metros volume[] e
tick_volume[] cont√™m o hist√≥rico de volume de negocia√ß√£o e tick, respectivamente.
Par determinar a dire√ß√£o de indexa√ß√£o de time[], open[], high[], low[], close[], tick_volume[],
volume[] e spread[], chame ArrayGetAsSeries(). A fim de n√£o depender de valores default, voc√™ deve
incondicionalmente chamar a fun√ß√£o ArraySetAsSeries() para aqueles arrays que voc√™ esperar utilizar.
O primeiro par√¢metro rates_total cont√©m o n√∫mero de barras dispon√≠veis no indicador para c√°lculo, e
corresponde ao n√∫mero de barras dispon√≠veis no gr√°fico.
Devemos notat a conex√£o entre o valor de retorno de OnCalculate() e o segundo par√¢metro de entrada
prev_calculated. Durante a chamada da fun√ß√£o, o par√¢metro prev_calculated cont√©m um valor
retornado pelo OnCalculate() durante a chamada anterior. Isso permite que algoritmos eficientes
calculem o indicador customizado de forma a evitar c√°lculos repetidos naquelas barras que n√£o
tiveram mudan√ßa deste a execu√ß√£o anterior desta fun√ß√£o.
Para isso, √© geralmente suficiente retornar o valor do par√¢metro rates_total, que cont√©m o n√∫mero de
barras da chamada corrente da fun√ß√£o. Se desde a √∫ltima chamada da fun√ß√£o OnCalculate() os dados
de pre√ßo mudarem (um hist√≥rico mais antigo baixado ou brancos no hist√≥rico preenchidos), o valor do
par√¢metro de entrada prev_calculated ser√° definido para zero pelo terminal.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
239
Observa√ß√£o: se OnCalculate retornar zero, ent√£o os valores do indicador n√£o s√£o mostrados na Janela
de Dados do terminal cliente.
Para entender isso melhor, seria √∫til iniciar o indicador, cujo c√≥digo est√° anexado abaixo.
<h3>Exemplo indicador:</h3>
</p>
<pre><code class="language-mql5">
#property indicator_chart_window
#property indicator_buffers 1
#property indicator_plots   1
//---- plotar Linha
#property indicator_label1  &quot;Line&quot;
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDarkBlue
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- buffers do indicador
double         LineBuffer[];
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,LineBuffer,INDICATOR_DATA);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime&amp; time[],
                const double&amp; open[],
                const double&amp; high[],
                const double&amp; low[],
                const double&amp; close[],
                const long&amp; tick_volume[],
                const long&amp; volume[],
                const int&amp; spread[])
  {
//--- Obten√ß√£o do n√∫mero de barras dispon√≠veis para o ativo corrente e per√≠odo do gr√°f
   int bars=Bars(Symbol(),0);
   Print(&quot;Bars = &quot;,bars,&quot;, rates_total = &quot;,rates_total,&quot;,  prev_calculated = &quot;,prev_ca
   Print(&quot;time[0] = &quot;,time[0],&quot; time[rates_total-1] = &quot;,time[rates_total-1]);
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
240
<h3>Tamb√©m Veja</h3>
Programas em Execu√ß√£o, Eventos do Terminal Cliente, Trabalhando com Eventos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
241
<h3>Vari√°veis</h3>
<h3>Declarando Vari√°veis</h3>
Vari√°veis devem ser declaradas antes de serem usadas. Nomes √∫nicos s√£o usados para identificar
vari√°veis. Para declarar uma vari√°vel, voc√™ deve especificar o seu tipo e nome √∫nico. Declara√ß√£o de
vari√°vel n√£o √© um operador.
<h3>Os tipos simples s√£o:</h3>
¬∑ char, short, int, long, uchar, ushort, uint, ulong ‚Äì inteiros;
¬∑ color ‚Äì inteiro representando a cor-RGB (red, green, blue);
¬∑ datetime ‚Äì a data e hora, um inteiro sem sinal (unsigned) contendo o n√∫mero de segundos desde a 0
hora de 1 de Janeiro de 1970;
¬∑ bool ‚Äì valores booleanos true e false;
¬∑ double ‚Äì n√∫mero de ponto flutuante de dupla precis√£o;
¬∑ float ‚Äì n√∫mero de ponto flutuante de precis√£o simples;
¬∑ string ‚Äì cadeias de caracteres.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
string szInfoBox;
int    nOrders;
double dSymbolPrice;
bool   bLog;
</code></pre>
<p>
datetime tBegin_Data   = D&#x27;2004.01.01 00:00&#x27;;
color    cModify_Color = C&#x27;0x44,0xB9,0xE6&#x27;;
<h3>Tipos compostos ou complexos:</h3>
Estruturas s√£o tipos de dados compostos constru√≠das usando outros tipos.
</p>
<pre><code class="language-mql5">
struct MyTime
  {
   int hour;    // 0-23
   int minute;  // 0-59
   int second;  // 0-59
</code></pre>
<p>
  };
...
MyTime strTime; // Vari√°vel previamente declarada da estrutura MyTime
N√£o se pode declarar vari√°veis do tipo estrutura at√© que se declare a estrutura.
<h3>Arrays</h3>
Array (ou matriz) √© uma seq√º√™ncia indexada de dados de tipos id√™nticos:
</p>
<pre><code class="language-mql5">
int    a[50];       // Array de uma dimens√£o de 50 inteiros.
double m[7][50];    // Array de duas dimens√µes de sete arrays,
                    // cada um deles constitu√≠do de 50 n√∫meros.
</code></pre>
<p>
MyTime t[100];      // Array contendo elementos como MyTime</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
242
Somente um inteiro pode ser um √≠ndice de array. N√£o s√£o permitidos arrays com mais que quatro
dimens√µes. A numera√ß√£o de elementos de um array come√ßa com 0. O √∫ltimo elemento de um array de
uma dimens√£o tem o n√∫mero do √≠ndice que √© 1 a menos que o tamanho do array. Isso significa que
chamar pelo √∫ltimo elemento de um array constitu√≠do de 50 aparecer√° como a[49]. O mesmo acontece
a arrays multidimensionais: uma dimens√£o √© indexada de 0 ao tamanho da dimens√£o menos 1. O
√∫ltimo elemento de um array de duas dimens√µes aparecer√° como m[6][49].
<h3>Arrays</h3>
est√°ticos 
n√£o 
podem 
ser 
representados 
como 
s√©ries 
de 
tempo, 
isto 
√©, 
a
fun√ß√£oArraySetAsSeries() n√£o pode ser aplicada a eles, esta fun√ß√£o define o acesso aos elementos de
um array do fim para o come√ßo. Se voc√™ desejar ter acesso a um array da mesma forma que uma s√©rie
de tempo, use o objeto de array din√¢mico.
Se houver uma tentativa de acesso fora da faixa do array, a execu√ß√£o do subsistema gerar√° um erro
cr√≠tico e o programa ser√° interrompido.
<h3>M√©todos embutidos para trabalhar usando arrays</h3>
Para trabalhar com arrays, voc√™ pode usar as fun√ß√µes da se√ß√£o Opera√ß√µes de arrays, bem como
m√©todos embutidos:
<h3>M√©todo</h3>
<h3>An√°logo</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
void array.Fill(const scalar value,
</code></pre>
<p>
const int start_pos=0, const int
count=-1);
<h3>ArrayFill,</h3>
<h3>ArrayInitialize</h3>
<h3>Preenche o array com o valor</h3>
especificado
</p>
<pre><code class="language-mql5">
void array.Free();
</code></pre>
<p>
<h3>ArrayFree</h3>
Libera o buffer din√¢mico do array e
define o tamanho da dimens√£o zero
como 0 (zero)
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
array.Resize(const 
int
range0_size, const int reserve);
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
array.Resize(const 
int
range_sizes[], const int reserve);
<h3>ArrayResize</h3>
<h3>Estabelece um novo tamanho na</h3>
primeira dimens√£o do array
</p>
<pre><code class="language-mql5">
int array.Print();
</code></pre>
<p>
<h3>ArrayPrint</h3>
Imprime os valores de um array de
tipo simples no log
</p>
<pre><code class="language-mql5">
int array.Size(const int range=-1);
</code></pre>
<p>
<h3>ArraySize,</h3>
<h3>ArrayRange</h3>
<h3>Retorna o n√∫mero de elementos em</h3>
todo o array (range=-1) ou na
dimens√£o especificada do array
</p>
<pre><code class="language-mql5">
bool array.IsDynamic();
</code></pre>
<p>
<h3>ArrayIsDynamic</h3>
<h3>Verifica se o array √© din√¢mico</h3>
</p>
<pre><code class="language-mql5">
bool array.IsIndicatorBuffer();
</code></pre>
<p>
Verifica se o array √© um buffer
indicador
</p>
<pre><code class="language-mql5">
bool array.IsSeries(); 
</code></pre>
<p>
<h3>ArrayIsSeries</h3>
Verifica se o array √© uma s√©rie
temporal
</p>
<pre><code class="language-mql5">
bool array.AsSeries();
</code></pre>
<p>
<h3>ArrayGetAsSeries</h3>
<h3>Verifica a dire√ß√£o de indexa√ß√£o do</h3>
array
</p>
<pre><code class="language-mql5">
bool 
</code></pre>
<p>
array.AsSeries(const 
bool
as_series);
<h3>ArraySetAsSeries</h3>
<h3>Define a dire√ß√£o da indexa√ß√£o no</h3>
array</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
243
<h3>M√©todo</h3>
<h3>An√°logo</h3>
<h3>Descri√ß√£o</h3>
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
array.Copy(const 
src_array[],
const 
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
dst_start, 
const 
int
src_start, const int cnt);
<h3>ArrayCopy</h3>
Copia os valores de um array em
outro array
</p>
<pre><code class="language-mql5">
int array.Compare(const src_array[],
</code></pre>
<p>
const 
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
dst_start, 
const 
int
src_start, const int cnt);
<h3>ArrayCompare</h3>
<h3>Retorna</h3>
o 
resultado 
de 
uma
compara√ß√£o de dois arrays de tipos
simples 
ou 
de 
estruturas
personalizadas
</p>
<pre><code class="language-mql5">
int array.Insert(const src_array[],
</code></pre>
<p>
const 
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
dst_start, 
const 
int
src_start, const int cnt);
<h3>ArrayInsert</h3>
<h3>Insere na matriz de destino o</h3>
n√∫mero especificado de elementos
da matriz de origem, iniciando no
√≠ndice especificado
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
array.Remove(const 
int
start_pos, const int count);
<h3>ArrayRemove</h3>
<h3>Elimina o n√∫mero especificado de</h3>
elementos do array a partir do √≠ndice
especificado
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
array.Reverse(const 
int
start_pos, const int count);
<h3>ArrayReverse</h3>
<h3>Desdobra o n√∫mero especificado de</h3>
elementos do array, come√ßando pelo
√≠ndice especificado
</p>
<pre><code class="language-mql5">
bool array.Swap(array&amp; arr[]);
</code></pre>
<p>
<h3>ArraySwap</h3>
<h3>Troca de conte√∫do com outro array</h3>
din√¢mico do mesmo tipo
</p>
<pre><code class="language-mql5">
void array.Sort(sort_function);
</code></pre>
<p>
<h3>ArraySort</h3>
<h3>Classifica√ß√£o de arrays num√©ricos</h3>
por primeira dimens√£o
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
array.Search(scalar 
value,
search_function);
<h3>ArrayBsearch</h3>
<h3>Retorna</h3>
o 
√≠ndice 
do 
primeiro
elemento encontrado na primeira
dimens√£o do array
</p>
<pre><code class="language-mql5">
int 
</code></pre>
<p>
array.Find((scalar 
value,
search_function);
<h3>Procura o array usando a fun√ß√£o</h3>
passada e retorna o √≠ndice do
primeiro elemento encontrado
array 
array.Select(scalar 
value,
search_function);
<h3>Procura o array usando a fun√ß√£o</h3>
passada e retorna o array com todos
os elementos encontrados
<h3>Especificadores de Acesso</h3>
Especificadores de acesso definem como o compilador pode acessar vari√°veis, membros de estruturas
ou classes.
O especificador const declara uma vari√°vel como uma constante e n√£o permite modificar esta vari√°vel
durante o tempo de execu√ß√£o. Uma inicializa√ß√£o simples de uma vari√°vel √© permitida durante sua
declara√ß√£o.
<h3>Exemplo:</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
244
</p>
<pre><code class="language-mql5">
int OnCalculate (const int rates_total,      // tamanho do array price[]
                 const int prev_calculated,  // barras tratadas na chamada anterior
                 const int begin,            // a partir de onde come√ßam os dados sign
                 const double&amp; price[]       // array a ser calculado
   );
</code></pre>
<p>
Para acessar membros de estruturas e classes use os seguintes qualificadores:
¬∑ public ‚Äì permite acesso irrestrito √†s vari√°veis ou m√©todos da classe
¬∑ protected ‚Äì permite acesso a partir dos m√©todos desta classe, bem como a partir dos m√©todos de
classes publicamente herdadas. Outro acesso √© imposs√≠vel;
¬∑ private ‚Äì permite acesso √†s vari√°veis e m√©todos da classe somente a partir dos m√©todos da mesma
classe.
¬∑ virtual ‚Äì aplica-se apenas a m√©todos de classe (n√£o a m√©todos de estrutura) e diz ao compilador que
este m√©todo deve se colocado na tabela de fun√ß√µes virtuais da classe.
<h3>Classes de Armazenamento</h3>
Existem tr√™s classes de armazenamento: static, input e extern. Estes modificadores de classe de
armazenamento explicitamente indicam ao compilador que as vari√°veis correspondentes est√£o
distribu√≠das em uma √°rea pr√©-alocada de mem√≥ria, que √© chamada de global pool. Al√©m disso, estes
modificadores indicam um processamento especial dos dados da vari√°vel. Se uma vari√°vel declarada
em n√≠vel local n√£o for uma vari√°vel est√°tica, a mem√≥ria para tal vari√°vel √© alocada automaticamente
em uma pilha de programa. A libera√ß√£o de mem√≥ria alocada para um array n√£o est√°tico (non-static) √©
tamb√©m realizada automaticamente quando se passa al√©m da √°rea de visibilidade do bloco em que o
array est√° declarado.
<h3>Veja tamb√©m</h3>
Tipos de Dados, Encapsulamento e Extensibilidade de Tipos,Inicializa√ß√£o de Vari√°veis, Visibilidade
Escopo e Tempo de Vida de Vari√°veis, Cria√ß√£o e Exclus√£o de Objetos, Membros Est√°ticos de uma
<h3>Classe</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
245
<h3>Vari√°veis Locais</h3>
Uma vari√°vel declarada dentro de uma fun√ß√£o √© local. O escopo de uma vari√°vel local √© limitado a
regi√£o dentro da fun√ß√£o na qual a vari√°vel est√° declarada. Uma vari√°vel local pode ser inicializada pelo
resultado de qualquer express√£o. Toda chamada da fun√ß√£o inicializa uma vari√°vel local. Vari√°veis
locais s√£o armazenadas na √°rea de mem√≥ria da correspondente fun√ß√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int somefunc()
  {
   int ret_code=0;
   ...
   return(ret_code);
</code></pre>
<p>
  }
Escopo de uma vari√°vel √© uma parte de um programa, na qual uma vari√°vel pode ser referenciada.
Vari√°veis declaradas dentro de um bloco (a n√≠vel interno), possuem o bloco como seu escopo. O escopo
de bloco come√ßa com a declara√ß√£o da vari√°vel e termina com a chave direita final.
Vari√°veis locais declaradas no come√ßo de uma fun√ß√£o tamb√©m t√™m escopo de bloco, bem como
par√¢metros de fun√ß√£o, que s√£o vari√°veis locais. Qualquer bloco pode conter declara√ß√µes de vari√°veis.
Se blocos estiverem aninhados e um identificador no bloco externo tiver o mesmo nome que um
identificador no bloco interno, o identificador no bloco externo √© oculto, at√© que a opera√ß√£o do bloco
interno seja finalizado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   int i=5;      // vari√°vel local da fun√ß√£o
     {
      int i=10;  // vari√°vel de fun√ß√£o
      Print(&quot;Dentro do bloco i = &quot;,i); // resultado √© i=10;
     }
   Print(&quot;Fora do bloco i = &quot;,i);  // resultado √© i=5;
</code></pre>
<p>
  }
Isso significa que enquanto o bloco interno est√° rodando, ele v√™ os valores de seus pr√≥prios
identificadores locais, e n√£o os valores dos identificadores com nomes id√™nticos no bloco externo.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   int i=5;      // vari√°vel local da fun√ß√£o
   for(int i=0;i&lt;3;i++)
      Print(&quot;Dentro for i = &quot;,i);
   Print(&quot;Fora do bloco i = &quot;,i);
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
246
</p>
<pre><code class="language-mql5">
/* Resultado da execu√ß√£o
</code></pre>
<p>
<h3>Dentro for i = 0</h3>
<h3>Dentro for i = 1</h3>
<h3>Dentro for i = 2</h3>
<h3>Fora do bloco i = 5</h3>
*/
Vari√°veis locais declaradas como est√°ticas (static) t√™m escopo de bloco, apesar do fato de elas
existirem desde o in√≠cio do programa.
<h3>Pilha (Stack)</h3>
Em todo programa MQL5, uma √°rea especial de mem√≥ria chamada pilha √© alocada para armazenar
vari√°veis locais de fun√ß√µes que s√£o criadas automaticamente. S√≥ uma pilha √© alocada para todas as
fun√ß√µes e, por padr√£o, seu tamanho √© de 1 MB. Em Advisors e scripts, o tamanho da pilha pode ser
gerenciado usando a diretiva de compila√ß√£o #property stacksize (define o tamanho da pilha em bytes),
por padr√£o, para eles s√£o alocados 8MB.
Vari√°veis locais est√°ticas (static) s√£o armazenadas no mesmo lugar onde outras vari√°veis est√°ticas e
globais s√£o armazenadas - em uma √°rea especial de mem√≥ria, que existe separadamente da pilha.
Vari√°veis criadas dinamicamente tamb√©m usam uma √°rea de mem√≥ria separada da pilha.
A cada chamada de fun√ß√£o, um lugar na pilha √© alocado para vari√°veis internas n√£o est√°ticas. Ap√≥s
sair da fun√ß√£o, a mem√≥ria fica dispon√≠vel para uso novamente.
Se da primeira fun√ß√£o, uma segunda fun√ß√£o for chamada, ent√£o a segunda fun√ß√£o ocupa o tamanho
requerido da mem√≥ria restante da pilha para suas vari√°veis. Portanto, ao usar fun√ß√µes inclu√≠das, a
mem√≥ria da pilha ser√° seq√ºencialmente ocupada por cada fun√ß√£o. Isso pode levar a uma falta de
mem√≥ria durante uma das chamadas de fun√ß√£o, tal situa√ß√£o √© chamada de estouro de pilha (stack
overflow).
Portanto, para grandes dados √© melhor usar mem√≥ria din√¢mica - ao entrar em uma fun√ß√£o, aloque a
mem√≥ria que √© requerida para as necessidades locais (new, ArrayResize()), e ao sair da fun√ß√£o, libere
a mem√≥ria (delete, ArrayFree()).
<h3>Tamb√©m Veja</h3>
Tipos de Dados, Encapsulamento e Extensibilidade de Tipos, Inicializa√ß√£o de Vari√°veis, Visibilidade
Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo Objetos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
247
<h3>Par√¢metros Formais</h3>
Par√¢metros passados para a fun√ß√£o s√£o locais. O escopo √© de bloco de fun√ß√£o. Par√¢metros formais
devem ter nomes diferentes de vari√°veis ‚Äãexternas e vari√°veis ‚Äãlocais definidas dentro de uma fun√ß√£o.
Alguns valores podem ser atribu√≠dos a par√¢metros formais no bloco de fun√ß√£o. Se um par√¢metro
formal √© declarado com o modificador const , seu valor n√£o pode ser modificado dentro da fun√ß√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void func(const int &amp; x[], double y, bool z)
  {
   if(y&gt;0.0 &amp;&amp; !z)
      Print(x[0]);
   ...
</code></pre>
<p>
  }
Par√¢metros formais podem ser inicializados por constantes. Neste caso, o valor de inicializa√ß√£o √©
considerado como o valor default (padr√£o). Par√¢metros, pr√≥ximos ao par√¢metro inicializado, tamb√©m
devem ser inicializados.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void func(int x, double y = 0.0, bool z = true)
  {
   ...
</code></pre>
<p>
  }
Ao chamar tal fun√ß√£o, os par√¢metros inicializados podem ser omitidos, os valores default ser√£o usados
no lugar deles.
<h3>Exemplo:</h3>
func(123, 0.5);
Par√¢metros de tipos simples s√£o passados por valor, isto √©, modifica√ß√µes da correspondente vari√°vel
local deste tipo dentro da fun√ß√£o chamada n√£o ir√° se refletir na fun√ß√£o chamadora. Arrays de qualquer
tipo e dados do tipo estrutura s√£o passados sempre por refer√™ncia. Se for necess√°rio proibir
modifica√ß√µes no conte√∫do de um array ou estrutura, os par√¢metros destes tipos devem ser declarados
com a palavra-chava const.
Existe a possibilidade de passar par√¢metros de tipos simples por refer√™ncia. Neste caso, modifica√ß√µes
nestes par√¢metros de dentro da fun√ß√£o chamada afetar√£o as vari√°veis correspondentes passadas por
refer√™ncia. A fim de indicar que um par√¢metro √© passado por refer√™ncia, coloque o modificador &amp; ap√≥s
do tipo do par√¢metro.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void func(int&amp; x, double&amp; y, double &amp; z[])
  {
   double calculated_tp;
   ...
   for(int i=0; i&lt;OrdersTotal(); i++)
     {</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
248
</p>
<pre><code class="language-mql5">
      if(i==ArraySize(z))       break;
      if(OrderSelect(i)==false) break;
      z[i]=OrderOpenPrice();
     }
   x=i;
   y=calculated_tp;
</code></pre>
<p>
  }
Par√¢metros passados por refer√™ncia n√£o podem ser inicializados por valores default.
No m√°ximo 64 par√¢metros podem ser passado para um fun√ß√£o.
<h3>Tamb√©m Veja</h3>
Vari√°veis de Entrada, Tipo de Dados, Encapsulamento e Extensibilidade de Tipos, Inicializa√ß√£o de
Vari√°veis, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo Objetos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
249
<h3>Vari√°veis Est√°ticas</h3>
A classe de armazenamento est√°tico (static) define uma vari√°vel est√°tica. O modificador static √©
indicado antes do tipo do dado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int somefunc()
  {
   static int flag=10;
   ...
   return(flag);
</code></pre>
<p>
  }
Uma vari√°vel est√°tica pode ser inicializada por uma constante ou express√£o constante correspondente
ao seu tipo, diferentemente de uma vari√°vel local simples, que pode ser inicializada por qualquer
express√£o.
Vari√°veis est√°ticas existem a partir do momento de execu√ß√£o do programa e s√£o inicializados somente
uma vez antes que a fun√ß√£o especializada OnInit() seja chamada. Se valores iniciais n√£o forem
especificados, vari√°veis da classe de armazenamento est√°tico assumem valores iniciais zero.
Vari√°veis locais declarados com a palavra-chave static ret√©m seus valores durante todo o tempo de
vida da fun√ß√£o. A cada pr√≥xima chamada da fun√ß√£o, tais vari√°veis locais cont√™m os valores que elas
tinham durante a chamada anterior.
Quaisquer vari√°veis em um bloco, exceto par√¢metros formais de uma fun√ß√£o, podem ser definidas
como est√°ticas. Se uma vari√°vel declarada em n√≠vel local n√£o for uma vari√°vel est√°tica, a mem√≥ria
para tal vari√°vel √© alocada automaticamente em uma pilha de programa.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int Counter()
  {
   static int count;
   count++;
   if(count%100==0) Print(&quot;A fun√ß√£o Counter tem sido chamada &quot;,count,&quot; tempos&quot;);
   return count;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   int c=345;
   for(int i=0;i&lt;1000;i++)
     {
      int c=Counter();
     }
   Print(&quot;c =&quot;,c);
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
250
Tipos de Dados, Encapsulamento e Extensibilidade de Tipos, Inicializa√ß√£o de Vari√°veis, Visibilidade
Escopo e Tempo de Vida de Vari√°veis, Cria√ß√£o e Exclus√£o de Objetos, Membros de Classe Est√°ticos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
251
<h3>Vari√°veis Globais</h3>
Vari√°veis globais s√£o criadas colocando suas declara√ß√µes fora de descri√ß√µes da fun√ß√£o. Vari√°veis
globais s√£o definidas no mesmo n√≠vel que fun√ß√µes, isto √©, elas n√£o s√£o locais de algum bloco.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
int GlobalFlag=10;   // Vari√°vel global
int OnStart()
  {
   ...
</code></pre>
<p>
  }
O escopo de vari√°veis globais √© o programa inteiro. Vari√°veis globais s√£o acess√≠veis a partir de todas
as fun√ß√µes definidas no programa. Elas s√£o inicializadas com zero a menos que um outro valor inicial
seja explicitamente definido. Uma vari√°vel global pode ser inicializada somente por uma constante, ou
express√£o de constante que corresponde ao tipo dela.
As vari√°veis globais s√£o inicializadas apenas uma vez ap√≥s o programa ser carregado na mem√≥ria do
terminal do cliente e antes da primeira manipula√ß√£o do evento Init. Para as vari√°veis globais que
representam objetos de classe, durante sua inicializa√ß√£o os construtores correspondentes s√£o
chamados. Em scripts, as vari√°veis globais s√£o inicializadas antes de manipular o evento Start.
Observa√ß√£o: Vari√°veis declaradas em n√≠vel global n√£o devem ser confundidas com vari√°veis globais do
terminal cliente que podem ser acessadas usando as fun√ß√µes GlobalVariable...().
<h3>Tamb√©m Veja</h3>
Tipos de Dados, Encapsulamento e Extensibilidade de Tipos, Inicializa√ß√£o de Vari√°veis, Visibilidade
Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo Objetos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
252
<h3>Vari√°veis de Entrada</h3>
A classe de armazenamento input define uma vari√°vel externa. O modificador input √© indicada antes
do tipo de dado. Uma vari√°vel com o modificador input n√£o pode ser modificada dentro de programas
mql5, tais vari√°veis podem ser acessadas somente para leitura. Valores de vari√°veis de entrada
podem ser modificados pelo usu√°rio somente a partir da janela de propriedades do programa. Le
variabili esterne vengono sempre reinizializzate immediatamente prima che OnInit() venga chiamato. 
O comprimento m√°ximo de um nome de vari√°vel input √© 63 caracteres. Al√©m disso, para um
par√¢metro de entrada do tipo string o comprimento do valor m√°ximo (comprimento da string) pode
variar de 191 a 253 caracteres (veja a Observa√ß√£o) O comprimento m√≠nimo √© de 0 caracteres (nenhum
valor especificado).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- par√¢metros de entrada
input int            MA_Period=13;
input int            MA_Shift=0;
input ENUM_MA_METHOD MA_Method=MODE_SMMA;
</code></pre>
<p>
Vari√°veis de entrada determinam a entrada de par√¢metros de um programa. Eles est√£o dispon√≠veis a
partir da janela de Propriedades de um programa.
√â poss√≠vel definir uma outra forma de exibir nomes de par√¢metros de entrada na aba Par√¢metros de
Entrada. Para fazer isso, um coment√°rio string √© usado, que deve estar localizado ap√≥s a descri√ß√£o de
um par√¢metro de entrada na mesma linha. Assim, nomes mais compreensivos para o usu√°rio podem
ser associados aos par√¢metros de entrada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- par√¢metros de entrada
input int            InpMAPeriod=13;         // Per√≠odo suavizado</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
253
</p>
<pre><code class="language-mql5">
input int            InpMAShift=0;           // Deslocamento da linha horizontal
input ENUM_MA_METHOD InpMAMethod=MODE_SMMA;  // M√©todo de Suaviza√ß√£o
</code></pre>
<p>
Observa√ß√£o:Arrays e vari√°veis de tipos complexos n√£o podem agir como vari√°veis de entrada.
Observa√ß√£o:O comprimento de um coment√°rio string para as vari√°veis ‚Äãde entrada n√£o pode exceder
63 caracteres.
Observa√ß√£o: Para vari√°veis input do tipo string a limita√ß√£o do comprimento do valor (o comprimento
da string) √© especificada pelas seguintes condi√ß√µes:
¬∑ o valor do par√¢metro √© representado pela string &quot;parameter_name=parameter_value&quot; (o s√≠mbolo &#x27;=&#x27; √©
levado em considera√ß√£o),
¬∑ comprimento m√°ximo de representa√ß√£o de 255 caracteres (total_length_max=255 ou 254 caracteres
excluindo &#x27;=&#x27;),
¬∑ comprimento m√°ximo de um nome de par√¢metro de string parameter_name_length = 63 caracteres.
Assim, o tamanho m√°ximo da string para um par√¢metro de string pode ser calculado pela f√≥rmula:
parameter_value_length=total_length_max-parameter_name_length=254-parameter_name_lengt
Isso d√° um tamanho m√°ximo de string de 191 (parameter_name_length=63) a 253 caracteres
(parameter_name_length=1).
Passando Par√¢metros Ao Chamar Indicadores Customizados a partir de
<h3>Programas MQL5</h3>
Indicadores Customizados s√£o chamados usando a fun√ß√£o iCustom(). Ap√≥s o nome do indicador
customizado, os par√¢metros devem aparecer em estrita conformidade com a declara√ß√£o das vari√°veis
de entrada deste indicador customizado. Se os par√¢metros indicados s√£o em n√∫mero menor que as
vari√°veis de entrada declaradas no indicador customizado chamado, os par√¢metros faltantes s√£o
preenchidos com os valores especificados durante a declara√ß√£o de vari√°veis.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
254
Se o indicador customizado usar a fun√ß√£o OnCalculate do primeiro tipo (isto √©, o indicador √© calculado
usando o mesmo array dos dados), ent√£o um dos valores ENUM_APPLIED_PRICE ou o manuseio de um
outro indicador deve ser usado como o √∫ltimo par√¢metro ao chamar tal indicador customizado. Todos
os par√¢metros correspondentes √†s vari√°veis de entrada devem ser claramente indicados.
<h3>Enumera√ß√µes como Par√¢metros de Entrada</h3>
N√£o apenas enumera√ß√µes internas fornecidos no MQL5, mas tamb√©m vari√°veis definidas pelo usu√°rio
podem ser usadas como vari√°veis de entrada (par√¢metros de entrada para programas MQL5). N√£o
apenas enumera√ß√µes internas fornecidos no MQL5, mas tamb√©m vari√°veis definidas pelo usu√°rio
podem ser usadas como vari√°veis de entrada (par√¢metros de entrada para programas MQL5).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property script_show_inputs
//--- dias da semana
enum dayOfWeek 
  {
   S=0,     // Domingo
   M=1,     // Segunda-feira
   T=2,     // Ter√ßa-feira
   W=3,     // Quarta-feira
   Th=4,    // Quinta-feira
   Fr=5,    // Sexta-feira,
   St=6,    // S√°bado
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- par√¢metros de entrada
input dayOfWeek swapday=W;
</code></pre>
<p>
A fim de permitir a um usu√°rio selecionar um valor necess√°rio da janela de propriedades durante o
in√≠cio da execu√ß√£o de um script, n√≥s usamos o comando de pr√©-processamento #property script show
inputs. Iniciamos o script e podemos escolher um dos valores da enumera√ß√£o dayOfWeek da lista.
Iniciamos o script EnumInInput e vamos para a aba Par√¢metros de Entrada. Por default, o valor de
swapday (dia de cobran√ßa tripla de swap) √© Wednesday (W = 3), mas n√≥s podemos especificar qualquer
outro valor, e usar este valor para mudar a opera√ß√£o do programa.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
255
O n√∫mero de poss√≠veis valores de uma enumera√ß√£o √© limitada. A fim de obter o c√≥digo de erro, a
fun√ß√£o GetLastError() deve ser chamada. Nomes mnem√¥nicos de membros da enumera√ß√£o s√£o usados
para valores exibidos na lista. Se um coment√°rio √© associado com um nome mnem√¥nico, como
mostrado no exemplo, o conte√∫do do coment√°rio √© usado ao inv√©s do nome mnem√¥nico.
Cada valor da enumera√ß√£o dayOfWeek tem seu valor de 0 a 6, mas na lista de par√¢metros, os
coment√°rios especificados para cada valor ser√° exibido. Isso fornece flexibilidade adicional para
escrever programas com descri√ß√µes mais claras dos par√¢metros de entrada.
<h3>Vari√°veis com Modificador sinput</h3>
Vari√°veis com modificador input n√£o apenas permitem definir par√¢metros externos ao iniciar
programas mas tamb√©m s√£o necess√°rias na otimiza√ß√£o de estrat√©gias de negocia√ß√£o no Provador de
Estrat√©gia. Cada vari√°vel de entrada excluindo-se o do tipo string pode ser usada em optimiza√ß√£o. 
Algumas vezes, √© necess√°rio excluir alguns par√¢metros externos do programa da √°rea total de passos
do Provador de Estrat√©gia. O modificador de mem√≥ria sinput foi introduzido para tais casos. sinput
significa declara√ß√£o de vari√°vel externa est√°tica (sinput = static input). Significa que a declara√ß√£o
seguinte em um c√≥digo Expert Advisor
sinput       int layers=6;   // N√∫mero de camadas
ser√° equivalente a declara√ß√£o completa
static input int layers=6;   // N√∫mero de camadas
A vari√°vel declarada com o modificador sinput √© um par√¢metro de entrada de um programa MQL5. O
valor deste par√¢metro pode ser modificado ao iniciar o programa. Entretanto, esta vari√°vel n√£o pode
ser usado na otimiza√ß√£o de par√¢metros de entrada. Em outras palavras, seu valor n√£o √© enumerado ao
procurar pelo melhor conjunto ajustado de par√¢metros a uma condi√ß√£o espec√≠fica.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
256
O Expert Advisor mostrado acima tem 5 par√¢metros externos. &quot;N√∫mero de camadas&quot; √© declarado para
ser sinput e igual a 6. Este par√¢metro n√£o pode ser modificado durante um otimiza√ß√£o de estrat√©gia
de negocia√ß√£o. Podemos especificar o valor necess√°rio para ele ser usado mais adiante. Os campos
Iniciar, Passo, Parar n√£o ficam dispon√≠veis para tal vari√°vel.
Portanto, usu√°rios n√£o ser√£o capazes de otimizar este par√¢metro ap√≥s especificarmos o modificador
sinput para a vari√°vel. Em outras palavras, o usu√°rio do terminal n√£o ser√° capaz de definir os valores
inicial e final para ele no Provador de Estrat√©gia para enumera√ß√£o autom√°tica na faixa especificada
durante uma otimiza√ß√£o.
Por√©m, existe uma exce√ß√£o a esta regra: vari√°veis sinput podem variar em tarefas de optimiza√ß√£o
usando a fun√ß√£o ParameterSetRange(). Esta fun√ß√£o foi introduzida especificamente para o programa
controlar os conjuntos de valores dispon√≠veis para qualquer vari√°vel input, incluindo aquelas
declaradas como static input (sinput). A fun√ß√£o ParameterGetRange() permite receber os valores
vari√°veis ‚Äãde entrada quando a otimiza√ß√£o √© iniciada (com o manipulador OnTesterInit()) e redefine
uma altera√ß√£o do valor do passo e um intervalo, no qual uma otimiza√ß√£o dos valores dos par√¢metros
ser√£o enumerados.
Desta forma, ao combinando o modificador sinput com duas fun√ß√µes que trabalham com par√¢metros
de entrada, isso permite criar regras flex√≠veis para definir intervalos de otimiza√ß√£o de par√¢metros de
entrada que dependem dos valores de outros par√¢metros de entrada.
<h3>Agrupando Par√¢metros de Entrada</h3>
Para facilitar o trabalho com programas MQL5, os par√¢metros de entrada podem ser divididos em
blocos nomeados usando a palavra-chave group. Isso permite que voc√™ separe visualmente alguns
par√¢metros de outros com base na l√≥gica incorporada neles.
</p>
<pre><code class="language-mql5">
input group           &quot;Nome do grupo&quot;
input int             variable1 = ...
input double          variable1 = ...
input double          variable3= ...
</code></pre>
<p>
Todos os par√¢metros de entrada ap√≥s essa declara√ß√£o s√£o visualmente agrupados no grupo
especificado, facilitando para o usu√°rio do programa MQL5 configurar par√¢metros ao executar no
gr√°fico ou no testador de estrat√©gia. A indica√ß√£o de cada grupo √© v√°lida at√© que apare√ßa uma
declara√ß√£o do grupo:
</p>
<pre><code class="language-mql5">
input group           &quot;Nome do grupo #1&quot;
input int             group1_var1 = ...</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
257
</p>
<pre><code class="language-mql5">
input double          group1_var2 = ...
input double          group1_var3 = ...
input group           &quot;Nome do grupo #2
input int             group2_var1 = ...
input double          group2_var2 = ...
input double          group2_var3 = ...
</code></pre>
<p>
Exemplo de EA no qual o bloco de par√¢metros de entrada √© dividido segundo sua finalidade:
</p>
<pre><code class="language-mql5">
input group           &quot;Signal&quot;
input int             ExtBBPeriod   = 20;       // Bollinger Bands period
input double          ExtBBDeviation= 2.0;      // deviation
input ENUM_TIMEFRAMES ExtSignalTF=PERIOD_M15;   // BB timeframe
input group           &quot;Trend&quot;
input int             ExtMAPeriod  = 13;        // Moving Average period
input ENUM_TIMEFRAMES ExtTrendTF=PERIOD_M15;    // MA timeframe
input group           &quot;ExitRules&quot;
input bool            ExtUseSL      = true;     // use StopLoss
input int             Ext_SL_Points = 50;       // StopLoss in points
input bool            ExtUseTP      = false;    // use TakeProfit
input int             Ext_TP_Points = 100;      // TakeProfit in points
input bool            ExtUseTS      = true;     // use Trailing Stop
input int             Ext_TS_Points = 30;       // Trailing Stop in points
input group           &quot;MoneyManagement&quot;
</code></pre>
<p>
sinput double         ExtInitialLot = 0.1;      // initial lot value
</p>
<pre><code class="language-mql5">
input bool            ExtUseAutoLot = true;     // automatic lot calculation
input group           &quot;Auxiliary&quot;
</code></pre>
<p>
sinput int            ExtMagicNumber = 123456;  // EA Magic Number
sinput bool           ExtDebugMessage= true;    // print debug messages
Ao iniciar este EA no testador de estrat√©gia, voc√™ pode clicar duas vezes no nome do grupo para
recolher e expandir o bloco de par√¢metros de entrada, al√©m de selecionar todos os seus par√¢metros
com um clique na caixa de sele√ß√£o do grupo para otimiza√ß√£o.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
258
<h3>Veja Tamb√©m</h3>
iCustom, Enumera√ß√µes, Propriedades de Programas</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
259
<h3>Vari√°veis Externas</h3>
A palavra-chave extern √© usado para declarar identificadores de vari√°veis como identificadores da
classe de armazenamento est√°tica (est√°tico) com tempo de vida global. Estas vari√°veis existem a
partir do inicio do programa e a mem√≥ria para elas √© alocada e inicializada imediatamente ap√≥s o
inicio do programa.
Voc√™ pode criar programas que consistem de m√∫ltiplos arquivos fontes; neste caso a diretiva para o
preprocessador #include √© usada. Vari√°veis declaradas como extern com o mesmo tipo e identificador
podem existir em arquivos fontes diferentes de um projeto.
Ao compilar o projeto inteiro, todas as vari√°veis extern com o mesmo tipo e identificador s√£o
associados com uma parte da mem√≥ria do conjunto (pool) de vari√°veis globais. Vari√°veis extern s√£o
√∫teis para compila√ß√£o separada de arquivos fontes. Vari√°veis externas podem ser inicializadas, mas
apenas uma vez - a exist√™ncia de v√°rias vari√°veis externas inicializadas do mesmo tipo e com o
mesmo identificador √© proibida.
<h3>Tamb√©m Veja</h3>
Tipos de Dados, Encapsulamento e Extensibilidade de Tipos, Inicializa√ß√£o de Vari√°veis, Visibilidade
Escopo e Tempo de Vida de Vari√°veis, Criando e Excluindo Objetos</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
260
<h3>Inicializa√ß√£o de Vari√°veis</h3>
Qualquer vari√°vel pode ser inicializada durante a defini√ß√£o. Se uma vari√°vel n√£o √© inicializada
explicitamente, o valor armazenado nesta vari√°vel pode ser qualquer coisa. Inicializa√ß√£o impl√≠cita n√£o
√© usada.
Vari√°veis globais e est√°ticas podem ser inicializadas uma vez por uma constante do tipo
correspondente ou uma express√£o constante. Vari√°veis locais podem ser inicializados por qualquer
express√£o, n√£o apenas por uma constante.
A inicializa√ß√£o de vari√°veis globais e est√°ticas √© realizada apenas uma vez. A inicializa√ß√£o de
vari√°veis locais √© feita toda a vez que se chama as fun√ß√µes correspondentes.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
int    n       = 1;
string s       = &quot;Ol√°&quot;;
double f[]     = { 0.0, 0.236, 0.382, 0.5, 0.618, 1.0 };
int    a[4][4] = { {1, 1, 1, 1}, {2, 2, 2, 2}, {3, 3, 3, 3}, {4, 4, 4, 4 } };
//--- de tetris
int    right[4]={WIDTH_IN_PIXELS+VERT_BORDER,WIDTH_IN_PIXELS+VERT_BORDER,
                 WIDTH_IN_PIXELS+VERT_BORDER,WIDTH_IN_PIXELS+VERT_BORDER};
//--- inicializa√ß√£o de todos os campos da estrutura com valores zero
</code></pre>
<p>
<h3>MqlTradeRequest request={};</h3>
A lista de valores dos elementos de um array devem estar entre chaves. Seq√º√™ncias de inicializa√ß√µes
faltantes s√£o consideradas iguais a 0. 
Se o tamanho do array inicializado n√£o √© especificado, ele √© determinado pelo compilador, baseado no
tamanho da seq√º√™ncia de inicializa√ß√£o. 
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
struct str3
  {
   int               low_part;
   int               high_part;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
struct str10
  {
   str3              s3;
   double            d1[10];
   int               i3;
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   str10 s10_1={{1,0},{1.0,2.1,3.2,4.4,5.3,6.1,7.8,8.7,9.2,10.0},100};
   str10 s10_2={{1,0},{},100};
   str10 s10_3={{1,0},{1.0}};
//---
   Print(&quot;1.  s10_1.d1[5] = &quot;,s10_1.d1[5]);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
261
</p>
<pre><code class="language-mql5">
   Print(&quot;2.  s10_2.d1[5] = &quot;,s10_2.d1[5]);
   Print(&quot;3.  s10_3.d1[5] = &quot;,s10_3.d1[5]);
   Print(&quot;4.  s10_3.d1[0] = &quot;,s10_3.d1[0]);
</code></pre>
<p>
  }
Para vari√°vel de tipo estrutura, inicializa√ß√£o parcial √© permitida, bem como para arrays est√°ticos.
Pode-se inicializar um ou mais primeiros elementos de uma estrutura ou array, os demais elementos
ser√£o inicializados com zeros neste caso.
<h3>Tamb√©m Veja</h3>
Tipos de Dados, Encapsulamento e Tipo de Extensibilidade, Visibilidade Escopo e Tempo de Vida de
<h3>Vari√°veis, Criando e Excluindo Objetos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
262
Visibilidade Escopo e Tempo de Vida de Vari√°veis
Existem dois tipos b√°sicos de escopo: escopo local e escopo global.
Uma vari√°vel declarada fora de todas as fun√ß√µes est√° localizada no escopo global. O acesso a tais
vari√°veis pode ser feito de qualquer lugar no programa. Estas vari√°veis s√£o localizadas no conjunto
(pool) global de mem√≥ria, assim seus tempos de vida coincidem com o tempo de vida do programa.
Uma vari√°vel declarada dentro de um bloco (parte do c√≥digo entre chaves) pertence ao escopo local.
Tal vari√°vel n√£o √© vis√≠vel (e portanto n√£o √© dispon√≠vel) fora do bloco no qual est√° definida. O caso
mais comum de declara√ß√£o local √© uma vari√°vel declarada dentro de uma fun√ß√£o. Uma vari√°vel
declarada localmente est√° localizada na pilha (stack), e o tempo de vida de tal vari√°vel √© igual ao
tempo de vida da fun√ß√£o.
J√° que o escopo de uma vari√°vel local √© o bloco em que ela est√° declarada, √© poss√≠vel declarar
vari√°veis com o mesmo nome que vari√°veis declaradas em outros blocos, mesmo aquelas declaradas
em n√≠veis mais acima, at√© o n√≠vel global.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void CalculateLWMA(int rates_total,int prev_calculated,int begin,const double &amp;price[]
  {
   int        i,limit;
   static int weightsum=0;
   double     sum=0;
//---
   if(prev_calculated==0)
     {
      limit=MA_Period+begin;
      //--- define valor vazio para primeiras barras limite
      for(i=0; i&lt;limit; i++) LineBuffer[i]=0.0;
      //--- calcula primeiro valor vis√≠vel
      double firstValue=0;
      for(int i=begin; i&lt;limit; i++)
        {
         int k=i-begin+1;
         weightsum+=k;
         firstValue+=k*price[i];
        }
      firstValue/=(double)weightsum;
      LineBuffer[limit-1]=firstValue;
     }
   else
     {
      limit=prev_calculated-1;
     }
   for(i=limit;i&lt;rates_total;i++)
     {
      sum=0;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
263
</p>
<pre><code class="language-mql5">
      for(int j=0; j&lt;MA_Period; j++) sum+=(MA_Period-j)*price[i-j];
      LineBuffer[i]=sum/weightsum;
     }
//---
</code></pre>
<p>
  }
Preste aten√ß√£o na vari√°vel i, declarada na linha
</p>
<pre><code class="language-mql5">
      for(int i=begin; i&lt;limit; i++)
        {
         int k=i-begin+1;
         weightsum+=k;
         firstValue+=k*price[i];
        }
</code></pre>
<p>
Seu escopo √© somente o ciclo do for; fora deste ciclo existe uma outra vari√°vel com o mesmo nome,
declarada no come√ßo da fun√ß√£o. Al√©m disso, a vari√°vel k est√° declarada no corpo do loop, seu escopo √©
o corpo do loop.
Vari√°veis locais podem ser declarados com o especificador de acesso static. Neste caso, o compilador
tem uma vari√°vel no conjunto (pool) global de mem√≥ria. Portanto, o tempo de vida de uma vari√°vel
est√°tica √© igual ao tempo de vida do programa. Aqui o escopo de tal vari√°vel √© limitado ao bloco no
qual ela est√° declarada.
<h3>Tamb√©m Veja</h3>
Data Types, Encapsulation and Extensibility of Types,Initialization of Variables, Creating and
<h3>Deleting Objects</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
264
<h3>Cria√ß√£o e Exclus√£o de Objetos</h3>
Ap√≥s um programa MQL5 ser carregado para execu√ß√£o, mem√≥ria √© alocada para cada vari√°vel de
acordo com seu tipo. De acordo com o n√≠vel de acesso, todas as vari√°veis s√£o dividas em dois tipos -
vari√°veis globais e vari√°veis locais. De acordo com a classe de mem√≥ria, elas pode ser par√¢metros de
entrada de um programa MQL5, est√°ticas (static) e autom√°ticas. Se necess√°rio, cada vari√°vel √©
inicializada por um valor correspondente. Ap√≥s ser usada, uma vari√°vel √© desinicializada e a mem√≥ria
usada por ela √© retornada ao sistema execut√°vel MQL5.
<h3>Inicializa√ß√£o e Desinicializa√ß√£o de Vari√°veis Globais</h3>
Vari√°veis globais s√£o inicializados automaticamente logo ap√≥s um programa mql5 ser carregado e
antes de qualquer fun√ß√£o ser chamada. Durante a inicializa√ß√£o valores iniciais s√£o atribu√≠dos a
vari√°veis de tipos simples e um construtor (se existir algum) √© chamado para objetos. Vari√°veis de
entrada s√£o sempre declarados em um n√≠vel global, e s√£o inicializados por valores definidos pelo
usu√°rio na janela de di√°logo durante o come√ßo do programa.
Apesar do fato de que vari√°veis est√°ticas serem geralmente declaradas em um n√≠vel local, a mem√≥ria
para estas vari√°veis √© pr√©-alocada, e a inicializa√ß√£o √© realizada logo ap√≥s um programa ser carregado;
o mesmo para vari√°veis globais.
A ordem de inicializa√ß√£o corresponde a ordem de declara√ß√£o da vari√°vel no programa. A
desinicializa√ß√£o √© realizada em ordem inversa. Este regra √© verdadeira apenas para as vari√°veis que
n√£o foram criadas pelo operador new. Tais vari√°veis s√£o criadas e inicializadas automaticamente logo
ap√≥s carregamento, e s√£o desinicializadas depois do descargamento do programa.
<h3>Inicializa√ß√£o e Desinicializa√ß√£o de Vari√°veis Locais</h3>
Se uma vari√°vel declarada em um n√≠vel local n√£o √© est√°tica, mem√≥ria √© alocada automaticamente para
tal vari√°vel. Vari√°veis locais, bem como vari√°veis globais, s√£o inicializados automaticamente no
momento que a execu√ß√£o do programa encontra a declara√ß√£o de uma vari√°vel local. Assim, a ordem de
inicializa√ß√£o corresponde √† ordem de declara√ß√£o.
Vari√°veis locais s√£o desinicializados no final do bloco do programa, no qual elas foram declaradas, e na
ordem oposta de suas declara√ß√µes. Um bloco de programa √© um operador de composi√ß√£o que pode ser
uma parte de um operador de sele√ß√£o switch, operador de ciclo (for, while, do-while), um corpo de
fun√ß√£o ou uma parte do operador if-else.
Vari√°veis locais s√£o inicializados somente no momento em que a execu√ß√£o do programa encontra a
declara√ß√£o da vari√°vel. Se durante a execu√ß√£o do programa o bloco, no qual a vari√°vel est√° declarada,
n√£o for executada, tal vari√°vel n√£o √© inicializada.
<h3>Inicializa√ß√£o e Desinicializa√ß√£o de Objetos Colocados</h3>
Um caso especial √© aquele com ponteiros de objeto, porque a declara√ß√£o de um ponteiro n√£o implica
em inicializa√ß√£o de objetos correspondentes. Objetos colocados dinamicamente s√£o inicializados
somente no momento em que a inst√¢ncia da classe √© criada pelo operador new. Inicializa√ß√£o de
objetos pressup√µe chamada de um construtor da classe correspondente. Se n√£o existir construtor
correspondente na classe, seus membros de tipo simples n√£o ser√£o automaticamente inicializados;
membros de tipos string, array din√¢mico e objeto complexo ser√£o automaticamente inicializados.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
265
Ponteiros podem ser declarados em n√≠vel local ou global; e eles podem ser inicializados pelo valor vazio
de NULL ou pelo valor do ponteiro do mesmo ou herdado tipo. Se o operador new √© chamado para um
ponteiro declarado em um n√≠vel local, o operador delete para este ponteiro deve ser chamado antes de
sair do n√≠vel. Caso contr√°rio, o ponteiro estar√° perdido e a exclus√£o expl√≠cita do objeto falhar√°. 
Todos os objetos criados pela express√£o object_pointer=new Class_name, devem ser ent√£o exclu√≠dos
pelo operador delete(object_pointer). Se por algum raz√£o tal vari√°vel n√£o for exclu√≠da por meio do
operador delete quando o programa estiver conclu√≠do, a correspondente entrada aparecer√° no di√°rio
&quot;Experts&quot;. Pode-se declarar v√°rias vari√°veis e atribuir um ponteiro de um objeto para todas elas.
Se um objeto criado dinamicamente tiver um construtor, este construtor ser√° chamado no momento
da execu√ß√£o do operador new. Se um objeto tiver um destrutor, ele ser√° chamado durante a execu√ß√£o
do operador  delete.
Assim objetos colocados dinamicamente s√£o criados somente no momento em que s√£o criados pelo
operador new, e s√£o certamente exclu√≠dos tanto pelo operador delete ou automaticamente pelo
sistema de execu√ß√£o do MQL5 durante a descarga do programa. A ordem de declara√ß√£o de ponteiros
criados dinamicamente n√£o influenciam na ordem de suas inicializa√ß√µes. A ordem de inicializa√ß√£o e
desinicializa√ß√£o √© totalmente controlada pelo programador.
<h3>Caracter√≠sticas Transit√≥rias de Vari√°veis</h3>
A principal informa√ß√£o sobre a ordem de cria√ß√£o, exclus√£o, sobre chamadas de construtores e
destrutores √© dada na tabela a baixo.
<h3>Vari√°vel autom√°tica</h3>
global
<h3>Vari√°vel autom√°tica</h3>
local
<h3>Objeto criado</h3>
dinamicamente
<h3>Inicializa√ß√£o</h3>
logo 
ap√≥s 
um
programa MQL5 ser
carregado
quando a linha de
c√≥digo onde ela est√°
declarada √© alcan√ßada
durante execu√ß√£o
na 
execu√ß√£o 
do
operador new
<h3>Ordem</h3>
de
inicializa√ß√£o
na 
ordem 
da
declara√ß√£o
na 
ordem 
da
declara√ß√£o
independente 
da
ordem de declara√ß√£o
<h3>Desinicializa√ß√£o</h3>
antes de um programa
<h3>MQL5</h3>
ser
descarregado
quando a execu√ß√£o sai
do bloco da declara√ß√£o
quando 
o 
operador
delete √© executado ou
antes de um programa
mql5 ser descarregado
<h3>Ordem</h3>
de
desinicializa√ß√£o
na ordem oposta da
ordem de inicializa√ß√£o
na ordem oposta da
ordem de inicializa√ß√£o
independente 
da
ordem de inicializa√ß√£o
<h3>Chamada</h3>
de
construtor
no carregamento do
programa MQL5
na inicializa√ß√£o
na 
execu√ß√£o 
do
operador new
<h3>Chamada</h3>
de
destrutor
na 
descarga 
do
programa MQL5
quando sair do bloco
onde a vari√°vel foi
inicializada
na 
execu√ß√£o 
do
operador delete
<h3>Logs de Erro</h3>
mensagem de log no
di√°rio &quot;Experts&quot; sobre
mensagem de log no
di√°rio &quot;Experts&quot; sobre
mensagem de logo no
di√°rio &quot;Experts&quot; sobre</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
266
<h3>Vari√°vel autom√°tica</h3>
global
<h3>Vari√°vel autom√°tica</h3>
local
<h3>Objeto criado</h3>
dinamicamente
a tentativa de excluir
um 
objeto 
criado
automaticamente
a tentativa de excluir
um 
objeto 
criado
automaticamente
objetos 
criados
dinamicamente 
n√£o
exclu√≠dos na descarga
de um programa mql5
<h3>Tamb√©m Veja</h3>
Tipos de Dados, Encapsulamento e Tipos de Extensibilidade, Inicializa√ß√£o de Vari√°veis, Visibilidade
Escope e Tempo de Vida de Vari√°veis</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
267
<h3>Preprocessador</h3>
Preprocessador √© um subsistema especial do compilador MQL5 que √© destinado √† prepara√ß√£o do c√≥digo
fonte do programa imediatamente antes do programa ser compilado.
O preprocessador permite melhorar a legibilidade do c√≥digo fonte. O c√≥digo pode ser estruturado por
meio de inclus√£o de arquivos espec√≠ficos contendo c√≥digos fonte de programas-mql5. A possibilidade
de atribuir nomes mnem√¥nicos a constantes espec√≠ficas contribui para melhoria da legibilidade do
c√≥digo.
O preprocessador tamb√©m permite determinar par√¢metros espec√≠ficos de programas MQL5:
¬∑ Declarar constantes
¬∑ Definir propriedades de programa
¬∑ Incluir arquivos no texto do programa
¬∑ Importar fun√ß√µes
¬∑ Conditional compilation
As diretivas do pr√©-processador s√£o usadas ‚Äãpelo do compilador para pr√©-processamento do c√≥digo
fonte antes de sua compila√ß√£o. A diretiva sempre come√ßa com o # (jogo da velha), por isso o
compilador pro√≠be o uso deste s√≠mbolo nos nomes das vari√°veis, fun√ß√µes, etc.
Cada diretiva √© descrita por um registro separado e opera antes da mudan√ßa de linha. N√£o se podem
utilizar v√°rias diretivas num s√≥ registro. Se o registro da diretiva for muito grande, ele pode ser
dividido em v√°rias linhas usando a barra invertida &#x27;\&#x27;, neste caso, a pr√≥xima linha √© considerada uma
continua√ß√£o do registro da diretiva.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  pseudo-operador foreach                                         |
//+------------------------------------------------------------------+
#define ForEach(index, array) for (int index = 0,                    \
   max_##index=ArraySize((array));                                   \
   index&lt;max_##index; index++)    
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   string array[]={&quot;12&quot;,&quot;23&quot;,&quot;34&quot;,&quot;45&quot;};
//--- rastreamento da matriz usando o ForEach
   ForEach(i,array)
     {
      PrintFormat(&quot;%d: array[%d]=%s&quot;,i,i,array[i]);
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
/* Resultado de sa√≠da  
   0: array[0]=12
   1: array[1]=23
   2: array[2]=34</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
268
</p>
<pre><code class="language-mql5">
   3: array[3]=45
</code></pre>
<p>
*/
Para o compilador, estas tr√™s linhas da diretiva #define aparecer√£o como uma linha longa. Neste
exemplo, tamb√©m √© usado o caractere duplo do jogo da velha ##, ele √© chamado operador de fus√£o e √©
usado nas macros #define, para combinar dois tokens numa macro. O operador de fus√£o de tokens n√£o
pode ser o primeiro ou o √∫ltimo na defini√ß√£o de macro.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
269
<h3>Substitui√ß√£o de Macro (#define, #undef)</h3>
As diretivas do pr√©-processador s√£o usadas ‚Äãpelo do compilador para pr√©-processamento do c√≥digo
fonte antes de sua compila√ß√£o. A diretiva sempre come√ßa com o # (jogo da velha), por isso o
compilador pro√≠be o uso deste s√≠mbolo nos nomes das vari√°veis, fun√ß√µes, etc.
Cada diretiva √© descrita por um registro separado e opera antes da mudan√ßa de linha. N√£o se podem
utilizar v√°rias diretivas num s√≥ registro. Se o registro da diretiva for muito grande, ele pode ser
dividido em v√°rias linhas usando a barra invertida &#x27;\&#x27;, neste caso, a pr√≥xima linha √© considerada uma
continua√ß√£o do registro da diretiva.
A diretiva #define pode ser usada para atribuir nomes mnem√¥nicos a constantes. Existem duas
formas:
</p>
<pre><code class="language-mql5">
#define identificador express√£o¬†                // forma sem par√¢metro
#define identificador(par1,... par8) express√£o¬† // forma param√©trica
</code></pre>
<p>
A diretiva #define substitui em express√£o todas as entradas encontradas adiante do identificador no
texto fonte. O identificador √© substitu√≠do somente se ele √© um s√≠mbolo (token) separado. O
identificador n√£o √© substitu√≠do se ele √© parte de um coment√°rio, parte de uma string, ou parte de um
outro identificador mais longo.
O identificador de constante √© governado pelas mesmas regras de nomes de vari√°veis. O valor pode
ser de qualquer tipo:
</p>
<pre><code class="language-mql5">
#define ABC               100
#define PI                3.14
#define COMPANY_NAME      &quot;MetaQuotes Software Corp.&quot;
</code></pre>
<p>
...
</p>
<pre><code class="language-mql5">
void ShowCopyright()
  {
   Print(&quot;Copyright  2001-2009, &quot;,COMPANY_NAME);
   Print(&quot;https://www.metaquotes.net&quot;);
</code></pre>
<p>
  }
Uma express√£o pode consistir de v√°rios s√≠mbolos (tokens), tais como palavras chave, constantes,
express√µes constantes e n√£o-constantes. Uma express√£o termina com o fim da linha e n√£o pode ser
transferida para a pr√≥xima linha.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#define TWO        2
#define THREE      3
#define INCOMPLETE TWO+THREE
#define COMPLETE  (TWO+THREE)
void OnStart()
  {
   Print(&quot;2 + 3*2 = &quot;,INCOMPLETE*2);
   Print(&quot;(2 + 3)*2 = &quot;,COMPLETE*2);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
// Resultado
// 2 + 3*2 = 8</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
270
</p>
<pre><code class="language-mql5">
// (2 + 3)*2 = 10
</code></pre>
<p>
<h3>Forma param√©trica do #define</h3>
Na forma param√©trica, todas as subseq√ºentes entradas encontradas do identificador ser√£o
substitu√≠das pela express√£o levando em conta os respectivos par√¢metros. Por exemplo:
</p>
<pre><code class="language-mql5">
 // exemplo com dois par√¢metros a e b
#define A 2+3
#define B 5-1
#define MUL(a, b) ((a)*(b))
double c=MUL(A,B);
</code></pre>
<p>
<h3>Print(&quot;c=&quot;,c);</h3>
</p>
<pre><code class="language-mql5">
/*
</code></pre>
<p>
express√£o double c=MUL(A,B);
√© equivalente a double c=((2+3)*(5-1));
*/
</p>
<pre><code class="language-mql5">
// Resultado
// c=20
</code></pre>
<p>
Se assegure de colocar os par√¢metros entre par√™nteses ao usar os par√¢metros na express√£o, uma vez
que isso ajudar√° a evitar erros n√£o √≥bvios que s√£o dif√≠ceis de encontrar. Se reescrevermos o c√≥digo
sem o uso de par√™ntesis, o resultado ser√° diferente:
</p>
<pre><code class="language-mql5">
 // exemplo com dois par√¢metros a e b
#define A 2+3
#define B 5-1
#define MUL(a, b) a*b
double c=MUL(A,B);
</code></pre>
<p>
<h3>Print(&quot;c=&quot;,c);</h3>
</p>
<pre><code class="language-mql5">
/*
</code></pre>
<p>
express√£o double c=MUL(A,B);
√© equivalente a double c=2+3*5-1;
*/
</p>
<pre><code class="language-mql5">
// Resultado
// c=16
</code></pre>
<p>
Ao usar a forma param√©trica, s√£o permitidos no m√°ximo 8 par√¢metros.
</p>
<pre><code class="language-mql5">
 // forma param√©trica correta
#define LOG(text)  Print(__FILE__,&quot;(&quot;,__LINE__,&quot;) :&quot;,text)   // um par√¢metro - &#x27;text&#x27;
 // forma param√©trica incorreta        
#define WRONG_DEF(p1, p2, p3, p4, p5, p6, p7, p8, p9)   p1+p2+p3+p4 // mais do que 8 p</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
271
<h3>The #undef directive</h3>
The #undef directive cancels declaration of the macro substitution, defined before.
<h3>Example:</h3>
</p>
<pre><code class="language-mql5">
#define MACRO
void func1()
  {
</code></pre>
<p>
#ifdef MACRO
</p>
<pre><code class="language-mql5">
   Print(&quot;MACRO is defined in &quot;,__FUNCTION__);   
</code></pre>
<p>
#else
</p>
<pre><code class="language-mql5">
   Print(&quot;MACRO is not defined in &quot;,__FUNCTION__);
</code></pre>
<p>
#endif
  }
#undef MACRO
</p>
<pre><code class="language-mql5">
void func2()
  {
</code></pre>
<p>
#ifdef MACRO
</p>
<pre><code class="language-mql5">
   Print(&quot;MACRO is defined in &quot;,__FUNCTION__);
</code></pre>
<p>
#else
</p>
<pre><code class="language-mql5">
   Print(&quot;MACRO is not defined in &quot;,__FUNCTION__);
</code></pre>
<p>
#endif
  }
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   func1();
   func2();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
/* Resultado:
</code></pre>
<p>
<h3>MACRO is defined in func1</h3>
<h3>MACRO is not defined in func2</h3>
*/
<h3>Tamb√©m Veja</h3>
<h3>Identificador, Constantes de Caractere</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
272
<h3>Propriedades de Programa (#property)</h3>
Todo programa mql5 permite especificar par√¢metros espec√≠ficos adicionais denominados #property
que ajudam o terminal de cliente a prover adequadamente servi√ßos a programas sem a necessidade de
inici√°-los explicitamente. Isso diz respeito a configura√ß√µes externas de indicadores, em primeiro
lugar. Propriedades descritas em arquivos inclu√≠dos (included files) s√£o completamente ignoradas.
Propriedades devem ser especificadas no arquivo MQL5 principal.
</p>
<pre><code class="language-mql5">
#property identifier value
</code></pre>
<p>
O compilador escrever√° valores declarados na configura√ß√£o do m√≥dulo executado.
<h3>Constante</h3>
<h3>Tipo</h3>
<h3>Descri√ß√£o</h3>
icon
string
Caminho para o arquivo da imagem que ser√° usada
como um √≠cone do programa EX5. Regras de
especifica√ß√£o de caminho s√£o as mesmas para
recursos. A propriedade deve ser especificada no
m√≥dulo principal com o c√≥digo fonte MQL5. O
arquivo de √≠cone deve estar no formato ICO.
link
string
<h3>Link para o website da empresa</h3>
copyright
string
<h3>O nome da empresa</h3>
version
string
Vers√£o do programa, m√°ximo de 31 caracteres
description
string
Breve descri√ß√£o em texto do programa MQL5. Pode
haver v√°rios description, cada um descrevendo uma
linha do texto. O comprimento total de todo
description n√£o pode exceder 511 caracteres
incluindo a quebra de linha.
stacksize
int
Tamanho do stack no programa MQL5. √â necess√°rio
um stack de tamanho satisfat√≥rio ao executar
chamadas recursivas da fun√ß√£o.
Ao iniciar um script ou um Expert Advisor no
gr√°fico, √© alocado um stack de pelo menos 8 MB. No
caso de indicadores, o tamanho da pilha √© sempre
fixo e igual a 1 MB.
Quando um programa √© iniciado no testador de
estrat√©gia, para ele √© sempre alocado um stack de
16 MB.
library
Uma biblioteca (library); nenhuma fun√ß√£o start √©
atribu√≠da, fun√ß√µes com o modificador export podem
ser importadas em outros programas mql5
indicator_applied_price
int
Especifica o valor padr√£o para o campo &quot;Aplicar a&quot;.
<h3>Pode-se</h3>
especificar 
um 
dos 
valores 
de
<h3>ENUM_APPLIED_PRICE. Se a propriedade n√£o √©</h3>
especificada, o valor padr√£o √© PRICE_CLOSE
indicator_chart_window
Exibe o indicador na janela do gr√°fico</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
273
<h3>Constante</h3>
<h3>Tipo</h3>
<h3>Descri√ß√£o</h3>
indicator_separate_window
Exibe o indicador em uma janela separada
indicator_height 
int
Altura (height) fixa da sub-janela do indicador em
pixels (property INDICATOR_HEIGHT)
indicator_buffers
int
N√∫mero de buffers para c√°lculo do indicador
indicator_plots
int
<h3>N√∫mero de s√©ries gr√°ficas no indicador</h3>
indicator_minimum
double
O limite de escala inferior para uma janela de
indicador separada
indicator_maximum
double
O limite de escala superior para uma janela de
indicador separada
indicator_labelN
string
Define o r√≥tulo para a N-√©sima s√©rie gr√°fica exibida
na Janela de Dados. Para s√©ries gr√°ficas que
requerem 
m√∫ltiplos 
buffers 
de 
indicador
(DRAW_CANDLES, DRAW_FILLING e outros), os
nomes de r√≥tulos s√£o definidos por meio do
separador &#x27;;&#x27;.
indicator_colorN
color
A cor de exibi√ß√£o da linha N, onde N √© o n√∫mero da
s√©rie gr√°fica; numera√ß√£o come√ßando em 1
indicator_widthN
int
Espessura de linha na s√©rie gr√°fica, onde N -
n√∫mero da s√©rie gr√°fica, numera√ß√£o come√ßando em
1
indicator_styleN
int
Estilo da linha na s√©rie gr√°fica, especificado a
partir dos valores de ENUM_LINE_STYLE. N -
n√∫mero de s√©ries gr√°ficas, numera√ß√£o come√ßando
em 1
indicator_typeN
int
Tipo de plotagem gr√°fica, especificado a partir de
valores de ENUM_DRAW_TYPE. N - n√∫mero de
s√©ries gr√°ficas, numera√ß√£o come√ßando em 1
indicator_levelN
double
N√≠vel horizontal de N em uma janela de indicador
separada
indicator_levelcolor
color
<h3>Cor dos n√≠veis horizontais do indicador</h3>
indicator_levelwidth
int
<h3>Espessura dos n√≠veis horizontais do indicador</h3>
indicator_levelstyle
int
<h3>Estilo dos n√≠veis horizontais do indicador</h3>
script_show_confirm
Exibe uma janela de confirma√ß√£o antes de executar
o script
script_show_inputs
Exibe uma janela com as propriedades antes de
executar o script e desabilita esta janela de
confirma√ß√£o</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
274
<h3>Constante</h3>
<h3>Tipo</h3>
<h3>Descri√ß√£o</h3>
tester_indicator
string
Nome de um indicador customizado no formato de
&quot;nome_indicador.ex5&quot;. Indicadores que requeiram
teste s√£o definidos automaticamente a partir da
fun√ß√£o iCustom(), se o correspondente par√¢metro √©
definido atrav√©s de uma string constante. Para
todos 
os 
demais 
casos 
(uso 
da 
fun√ß√£o
IndicatorCreate() ou uso de uma string n√£o-
constante no par√¢metro que define o nome do
indicador) esta propriedade √© requerida
tester_file
string
Nome de arquivo para um testador com a indica√ß√£o
de extens√£o, entre aspas duplas (como uma string
constante). O arquivo especificado ser√° passado
para o Testador de Estrat√©gias. Arquivos de
entrada 
para 
serem 
testados, 
se 
forem
necess√°rios, devem sempre ser especificados.
tester_library
string
Nome da biblioteca (library) com a extens√£o, entre
aspas duplas. Uma biblioteca pode ter extens√£o dll
ou ex5. Bibliotecas que requeiram teste s√£o
definidas automaticamente. Contudo, se alguma
biblioteca for usada por um indicador customizado,
esta propriedade √© requerida
tester_set
string
Nome de arquivo set com valores e o step dos
par√¢metros de entrada. O arquivo especificado ser√°
transferido para testador antes do teste ou
otimiza√ß√£o. 
<h3>O</h3>
nome 
do 
arquivo 
deve 
ser
especificado com a extens√£o e usando aspas como
uma string constante.
Se, no nome do arquivo set, voc√™ especificar o
nome 
do 
expert 
e 
o 
n√∫mero 
de 
vers√£o
&quot;&lt;expert_name&gt;_&lt;number&gt;.set&quot;, 
ele 
ser√°
automaticamente 
adicionado 
ao 
menu 
para
carregar as vers√µes dos par√¢metros de acordo com
o n√∫mero de vers√£o &lt;number&gt;. Por exemplo, o
nome &quot;MACD Sample_4.set&quot; indica que se trata de
um arquivo set para o expert &quot;MACD Sample.mq5&quot;
com um n√∫mero de vers√£o igual 4.
<h3>Para estudar formato √© recomendado salvar</h3>
manualmente as configura√ß√µes de teste/otimiza√ß√£o
no testador de estrat√©gias, e, em seguida, abrir o
arquivo set criado dessa maneira.
tester_no_cache
string
O testador de estrat√©gia, durante a otimiza√ß√£o,
salva todos os resultados das corridas no cache de
otimiza√ß√£o em que para cada conjunto 
de
par√¢metros de entrada √© salvo o resultado do teste.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
275
<h3>Constante</h3>
<h3>Tipo</h3>
<h3>Descri√ß√£o</h3>
Isso permite, durante uma nova otimiza√ß√£o, nos
mesmos par√¢metros obter os resultados prontos
sem rec√°lculo e demora. 
Mas para algumas tarefas - por exemplo, em
c√°lculos matem√°ticos - pode ser necess√°rio realizar
c√°lculos, independentemente da disponibilidade de
resultados prontos no cache de otimiza√ß√£o. Nesse
caso, o arquivo deve incluir a propriedade
tester_no_cache. Al√©m disso, embora isso, os
pr√≥prios resultados do teste ser√£o armazenados no
cache, para que voc√™ possa ver todos os dados nas
corridas conclu√≠das no testador de estrat√©gias.
tester_everytick_calculate
string
No testador de estrat√©gias, os indicadores s√£o
calculados somente quando s√£o acessados para
obter dados, isto √©, somente no momento em que
s√£o solicitados os valores dos buffers de indicador.
Isto d√° uma acelera√ß√£o significativa durante o teste
e a otimiza√ß√£o, se voc√™ n√£o precisar obter os
valores do indicador em cada tick.
<h3>A propriedade tester_everytick_calculate permite -</h3>
durante o teste - ativar for√ßosamente o modo de
c√°lculo do indicador em cada tick. 
Os indicadores no testador de estrat√©gia tamb√©m
s√£o contados for√ßosamente em cada tick nos
seguintes casos:
¬∑ ao testar em modo visual;
¬∑ se 
no 
indicador 
houver 
as 
fun√ß√µes
<h3>EventChartCustom, OnChartEvent, OnTimer;</h3>
¬∑ se o indicador for criado pelo compilador com
n√∫mero de compila√ß√£o abaixo de 1916.
Esta propriedade se aplica apenas ao trabalho no
testador de estrat√©gias, no terminal os indicadores
s√£o sempre contados em cada tick entrante.
optimization_chart_mode
string
Indica o tipo de gr√°fico e os nomes de dois
par√¢metros de entrada que ser√£o usados para
visualizar resultados de otimiza√ß√£o. Por exemplo,
‚Äú3d, InpX, InpY‚Äù significa que um gr√°fico 3D com
eixos de coordenadas ser√° mostrado com base nos
valores dos par√¢metros InpX e InpY iterados. Desse
modo, com a ajuda desta propriedade, voc√™ pode
especificar diretamente no c√≥digo os par√¢metros</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
276
<h3>Constante</h3>
<h3>Tipo</h3>
<h3>Descri√ß√£o</h3>
que ser√£o usados para exibir o gr√°fico de
otimiza√ß√£o e o tipo do gr√°fico em si.
<h3>Poss√≠veis variantes:</h3>
¬∑ &quot;3d, 
input_parameter_name1,
input_parameter_name2&quot; 
‚Äì 
gr√°fico 
de
visualiza√ß√£o 3D que pode 
ser 
girado,
ampliado, afastado. √â constru√≠do de acordo
com dois par√¢metros de entrada.
¬∑ &quot;2d, 
input_parameter_name1,
input_parameter_name2&quot; ‚Äì gr√°fico plano na
forma 
de 
grade, 
cujas 
c√©lulas 
s√£o
sombreadas em 
cores, 
dependendo 
do
resultado. √â constru√≠do de acordo com dois
par√¢metros de entrada.
¬∑ &quot;1d, 
input_parameter_name1,
input_parameter_name2&quot; ‚Äì gr√°fico linear em
que os resultados s√£o classificados pelo
par√¢metro especificado. Cada corrida √©
exibida na forma de um ponto, √© constru√≠da
de acordo com o par√¢metro de entrada.
¬∑ &quot;0d, 
input_parameter_name1,
input_parameter_name2&quot; ‚Äì gr√°fico regular
com resultados classificados de acordo com a
ordem de chegada do resultado da corrida.
Cada corrida √© exibida como um ponto. N√£o
requer especifica√ß√£o de par√¢metros, mas
esses par√¢metros ser√£o usados ao alternar
manualmente para outro tipo de gr√°fico.
Voc√™ pode especificar apenas o tipo de gr√°fico e
n√£o especificar um ou dois par√¢metros de entrada,
pois, nesse caso, o pr√≥prio terminal selecionar√° os
par√¢metros necess√°rios para exibir o gr√°fico de
otimiza√ß√£o.
Exemplo de Descri√ß√£o e N√∫mero de Vers√£o
</p>
<pre><code class="language-mql5">
#property version     &quot;3.70&quot;      // Vers√£o atual do Expert Advisor
#property description &quot;ZigZag universal com Pesavento Patterns&quot;
#property description &quot;Atualmente est√£o inclusos no indicador v√°rios ZigZags com difer
#property description &quot;√â poss√≠vel embutir um grande n√∫mero de outros indicadores exibi
#property description &quot;fundos e automaticamente construir a partir destes topos e fund</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
277
Exemplos especificando um r√≥tulo separado para cada buffer do indicador ( &quot;C open; C high; C
low; C close&quot;)
</p>
<pre><code class="language-mql5">
#property indicator_chart_window
#property indicator_buffers 4
#property indicator_plots   1
#property indicator_type1   DRAW_CANDLES
#property indicator_width1  3
#property indicator_label1  &quot;C open;C high;C low;C close&quot;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
278
<h3>Incluindo Arquivos (#include)</h3>
A linha de comando #include pode ser colocada em qualquer lugar no programa, mas geralmente todas
as inclus√µes s√£o colocadas no come√ßo do c√≥digo fonte. Formato da chamada:
</p>
<pre><code class="language-mql5">
#include &lt;file_name&gt;
#include &quot;file_name&quot;
</code></pre>
<p>
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
#include &lt;WinUser32.mqh&gt;
#include &quot;mylib.mqh&quot;
</code></pre>
<p>
O preprocessador substitui a linha #include &lt;file_name&gt; com o conte√∫do do arquivo WinUser32.mqh.
Colchetes angulares (&quot;&lt;&gt;&quot;) indicam que o arquivo WinUser32.mqh file ser√° obtido a partir do diret√≥rio
padr√£o (geralmente terminal_installation_directory\MQL5\Include). O diret√≥rio corrente n√£o √© vis√≠vel.
Se o nome do arquivo √© colocado entre aspas, a procura √© feita no diret√≥rio corrente (que cont√©m o
arquivo fonte principal). O diret√≥rio padr√£o n√£o √© vis√≠vel.
<h3>Tamb√©m Veja</h3>
<h3>Standard Library, Importando Fun√ß√µes</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
279
<h3>Importando Fun√ß√µes (#import)</h3>
Fun√ß√µes s√£o importadas a partir de m√≥dulos MQL5 compilados (arquivos *.ex5) e a partir de m√≥dulos
do sistema operacional (arquivos *.dll). O nome do m√≥dulo √© especificado na diretiva #import. Para
que o compilador formate corretamente a chamada da fun√ß√£o importada e organize a correta
transfer√™ncia de par√¢metros, √© necess√°ria uma descri√ß√£o completa das fun√ß√µes. Descri√ß√µes de fun√ß√£o
sucedem imediatamente √† diretiva #import &quot;nome do m√≥dulo&quot;. O novo comando #import (pode-se sem
par√¢metros) completa o bloco da descri√ß√£o das fun√ß√µes importadas.
#import &quot;file_name&quot;
</p>
<pre><code class="language-mql5">
    func1 define;
    func2 define;
    ...
    funcN define;
</code></pre>
<p>
#import
Fun√ß√µes importadas podem ter qualquer nome. Fun√ß√µes importadas podem ter qualquer nome. Voc√™
pode importar simultaneamente m√≥dulos - de diferentes fun√ß√µes - com o mesmo nome. Fun√ß√µes
importadas podem ter nomes que coincidem com os nomes de fun√ß√µes internas. A opera√ß√£o de
resolu√ß√£o de contexto determina quais das fun√ß√µes devem ser chamadas.
A ordem de pesquisa do arquivo especificado ap√≥s a palavra-chave #import √© descrita na se√ß√£o
Chamada de Fun√ß√µes Importadas.
J√° que fun√ß√µes importadas est√£o do lado de fora do m√≥dulo compilado, o compilador n√£o pode
verificar a validade dos par√¢metros passados. Portanto, para evitar erros em tempo de execu√ß√£o,
deve-se descrever com precis√£o a composi√ß√£o e ordem dos par√¢metros passados para fun√ß√µes
importadas. Par√¢metros passados para fun√ß√µes importadas (tanto de EX5, como de m√≥dulo DLL)
podem ter valores por padr√£o.
Nas fun√ß√µes importadas, voc√™ n√£o pode usar como par√¢metros:
¬∑ pointers (*);
¬∑ links de objetos que contenham arrays din√¢micos e/ou ponteiros.
Nas fun√ß√µes importadas da DLL, voc√™ n√£o pode passar - como par√¢metros - classes, arrays de string
ou objetos complexos contendo strings e/ou arrays din√¢micos de qualquer tipo.
<h3>Exemplos:</h3>
#import &quot;stdlib.ex5&quot;
</p>
<pre><code class="language-mql5">
string ErrorDescription(int error_code);
int    RGB(int red_value,int green_value,int blue_value);
bool   CompareDoubles(double number1,double number2);
string DoubleToStrMorePrecision(double number,int precision);
string IntegerToHexString(int integer_number);
</code></pre>
<p>
#import &quot;ExpertSample.dll&quot;
</p>
<pre><code class="language-mql5">
int    GetIntValue(int);
double GetDoubleValue(double);
string GetStringValue(string);
double GetArrayItemValue(double &amp;arr[],int,int);
bool   SetArrayItemValue(double &amp;arr[],int,int,double);
double GetRatesItemValue(double &amp;rates[][6],int,int,int);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
280
#import
Para importar fun√ß√µes durante a execu√ß√£o de um programa mql5, √© usada vincula√ß√£o inicial (early
binding). Isso significa que a biblioteca √© carregada durante a carga de um programa usando seu
programa ex5.
N√£o √© recomendado que usar o nome completo do m√≥dulo a carregar, como Drive:
\Directory\FileName.Ext. 
<h3>Bibiliotecas</h3>
<h3>MQ5</h3>
s√£o 
carregadas 
a 
partir 
da 
pasta
terminal_dir\MQL5\Libraries.
Se a fun√ß√£o importada tiver diferentes op√ß√µes de chamada para as vers√µes de 32 e 64 bits do
Windows, voc√™ dever√° importar ambas e chamar explicitamente a variante de fun√ß√£o desejada com
ajuda da vari√°vel _IsX64. 
<h3>Exemplo:</h3>
#import &quot;user32.dll&quot;
</p>
<pre><code class="language-mql5">
//--- para um sistema de 32 bits
int    MessageBoxW(uint hWnd,string lpText,string lpCaption,uint uType);
//--- para um sistema de 64 bits
int    MessageBoxW(ulong hWnd,string lpText,string lpCaption,uint uType);
</code></pre>
<p>
#import
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  MessageBox_32_64_bit usa a varia√ß√£o correta do  MessageBoxW()   |
//+------------------------------------------------------------------+
int MessageBox_32_64_bit()
  {
   int res=-1;
   // --- se tivermos o Windows de 64 bits
   if(_IsX64)
     {
      ulong hwnd=0;
      res=MessageBoxW(hwnd,&quot;Exemplo de como chamar a vers√£o de 64 bits do MessageBoxW&quot;
     }
   else  // temos o Windows de 32 bits
     {
      uint hwnd=0;
      res=MessageBoxW(hwnd,&quot;Exemplo de chamada de uma vers√£o de 32 bits do MessageBoxW
     }
   return (res);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//---
   int ans=MessageBox_32_64_bit();
   PrintFormat(&quot;MessageBox_32_64_bit returned %d&quot;,ans);
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
281
<h3>Importando fun√ß√µes de bibliotecas .NET</h3>
Para trabalhar com as fun√ß√µes da biblioteca .NET, basta importar a pr√≥pria DLL sem especificar
fun√ß√µes espec√≠ficas. O MetaEditor importa automaticamente todas as fun√ß√µes com as quais √© poss√≠vel
o trabalho:
¬∑ Estruturas simples (POD, plain old data), isto √©, estruturas que cont√™m apenas tipos de dados
simples.
¬∑ Fun√ß√µes est√°ticas p√∫blicas cujos par√¢metros usam apenas tipos simples e estruturas de POD ou seus
arrays.
Para chamar fun√ß√µes da biblioteca, basta import√°-la:
#import &quot;TestLib.dll&quot;
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   int x=41;
   TestClass::Inc(x);
   Print(x);
</code></pre>
<p>
  }
O c√≥digo C# para a fun√ß√£o Inc da classe TestClass √© semelhante ao seguinte:
public class TestClass
</p>
<pre><code class="language-mql5">
  {
   public static void Inc(ref int x)
     {
      x++;
     }
</code></pre>
<p>
  }
Como resultado, o script retornar√° o valor 42.
<h3>Veja Tamb√©m</h3>
<h3>Incluindo Arquivos</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
282
<h3>Conditional Compilation (#ifdef, #ifndef, #else, #endif)</h3>
As diretivas do pr√©-processador s√£o usadas ‚Äãpelo do compilador para pr√©-processamento do c√≥digo
fonte antes de sua compila√ß√£o. A diretiva sempre come√ßa com o # (jogo da velha), por isso o
compilador pro√≠be o uso deste s√≠mbolo nos nomes das vari√°veis, fun√ß√µes, etc.
Cada diretiva √© descrita por um registro separado e opera antes da mudan√ßa de linha. N√£o se podem
utilizar v√°rias diretivas num s√≥ registro. Se o registro da diretiva for muito grande, ele pode ser
dividido em v√°rias linhas usando a barra invertida &#x27;\&#x27;, neste caso, a pr√≥xima linha √© considerada uma
continua√ß√£o do registro da diretiva.
As diretrizes de compila√ß√£o condicional do pr√©-processador permitem compilar ou pular uma parte do
programa dependendo do cumprimento de uma determinada condi√ß√£o.
Essa condi√ß√£o pode assumir uma das seguintes formas.
#ifdef identifier
</p>
<pre><code class="language-mql5">
   // O c√≥digo aqui √© compilado se o identificador j√° tiver sido definido para o pr√©-p
</code></pre>
<p>
#endif
#ifndef identifier
</p>
<pre><code class="language-mql5">
   // O c√≥digo localizado aqui √© compilado se o identificador n√£o est√° definido atualm
</code></pre>
<p>
#endif
Qualquer uma das diretrizes de compila√ß√£o condicional pode ser seguida por qualquer n√∫mero de linhas
possivelmente contendo a diretiva #else e terminando com #endif. Se a condi√ß√£o verificada for
verdadeira, as linhas entre #else e #endif ser√£o ignoradas. Se a condi√ß√£o verificada n√£o for cumprida,
todas as linhas entre a verifica√ß√£o e a diretiva #else (ou a diretiva #endif se a primeira estiver
ausente) ser√£o ignoradas.
<h3>Exemplo:</h3>
#ifndef TestMode
</p>
<pre><code class="language-mql5">
   #define TestMode
</code></pre>
<p>
#endif
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de in√≠cio do programa script                              |
//+------------------------------------------------------------------+
void OnStart()
  {
   #ifdef TestMode
      Print(&quot;Test mode&quot;);
   #else
      Print(&quot;Normal mode&quot;);
   #endif
</code></pre>
<p>
  }
Dependendo do tipo de programa e do modo de compila√ß√£o, os padr√µes macros s√£o definidos da
seguinte forma:
__MQL5__  macro √© definido ao compilar o arquivo *.mq5, __MQL4__ macro √© definido ao compilar o
*.mq4.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
283
_DEBUG macro √© definido ao compilar o modo de depura√ß√£o.
_RELEASE macro √â definido ao compilar no modo de libera√ß√£o.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   #ifdef __MQL5__
      #ifdef _DEBUG
         Print(&quot;Hello from MQL5 compiler [DEBUG]&quot;);
      #else
        #ifdef _RELEASE
           Print(&quot;Hello from MQL5 compiler [RELEASE]&quot;);
        #endif
      #endif
   #else
      #ifdef __MQL4__
        #ifdef _DEBUG
           Print(&quot;Hello from MQL4 compiler [DEBUG]&quot;);
        #else
           #ifdef _RELEASE
              Print(&quot;Hello from MQL4 compiler [RELEASE]&quot;);
           #endif
        #endif
      #endif
   #endif
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
284
<h3>Programa√ß√£o Orientada a Objetos</h3>
Programa√ß√£o orientada a objetos (OOP) √© programar basicamente focada em dados, enquanto dados e
comportamento est√£o inseparavelmente ligados. Juntos, dados e comportamento, constituem uma
classe, enquanto objetos s√£o inst√¢ncias de classe.
Os componentes da abordagem orientada a objetos s√£o:
¬∑ Encapsulamento e extensibilidade de tipo
¬∑ Heran√ßa
¬∑ Polimorfismo
¬∑ Sobrecarga
¬∑ Fun√ß√µes virtuais
OOP considera computa√ß√£o como modelagem de comportamento. O item modelado √© o objeto
representado pelas abstra√ß√µes computacionais. Suponha que n√≥s quis√©ssemos escrever &quot;Tetris&quot;, um
jogo bem conhecido. Para fazer isso, n√≥s devemos aprender como modelar a apar√™ncia de uma forma
aleat√≥rias compostas de quatro quadrados ligados nas bordas. Tamb√©m n√≥s precisar√≠amos regular a
velocidade de queda das figuras e definir opera√ß√µes de rota√ß√£o e deslocamento. A movimenta√ß√£o das
formas na tela √© limitada pelas bordas da pe√ßa, este requerimento tamb√©m deve ser modelado. Al√©m
disso, linhas preenchidas de cubos devem ser destru√≠das e pontos conseguidos devem ser contados.
Assim, este jogo de f√°cil entendimento requer a cria√ß√£o de v√°rios modelos - modelo de forma, modelo
de pe√ßa, modelo de movimenta√ß√£o da figura, e assim por diante. Todas estes modelos s√£o abstra√ß√µes,
representadas por c√°lculos no computador. Para descrever estes modelos, o conceito de Tipo de Dados
Abstratos, ADT (tipo de dados complexos), √© usado. Estritamente falando, o modelo do movimento
das &quot;formas&quot; no jogo n√£o √© um tipo de dado, mas √© um conjunto de opera√ß√µes sobre o tipo de dado
&quot;forma&quot;, usando as restri√ß√µes do tipo de dado &quot;pe√ßa&quot;.
Objetos s√£o vari√°veis de classe. A programa√ß√£o orientada a objetos permite a voc√™ facilmente criar e
usar ADT. A programa√ß√£o orientada a objetos usa o mecanismo de heran√ßa. O benef√≠cio da heran√ßa
est√° no fato de permitir obter tipos derivados a partir de tipos de dados j√° definidos por um usu√°rio.
Por exemplo, para criar formas Tetris, √© conveniente primeiro criar uma classe base Forma. As outras
classes representando todos os sete poss√≠veis tipos de forma podem ser derivadas desta base. O
comportamento das figuras √© definido na classe base, enquanto que a implementa√ß√£o do
comportamento de cada figura separada √© definida em classes derivadas.
Em OOP, objetos s√£o respons√°veis por seu comportamento. O desenvolvedor de ADT deve incluir um
c√≥digo para descrever qualquer comportamento que normalmente seria esperado dos objetos
correspondentes. O fato do objeto ser respons√°vel por seu comportamento, simplifica enormemente a
tarefa de programa√ß√£o deste objeto pelo usu√°rio.
Se quis√©ssemos desenhar uma figura na tela, precisar√≠amos conhecer onde o centro desta figura
estaria e como desenh√°-la. Se um forma separada sabe como se desenhar, o programador deve enviar
uma mensagem de &quot;desenhe&quot; ao usar tal forma.
A linguagem MQL5 √© semelhante ao C++, e ela tamb√©m tem mecanismos de encapsulamento para a
implementa√ß√£o de ADT. Por um lado, o encapsulamento esconde os detalhes internos da
implementa√ß√£o de um tipo particular, e por outro lado, torna acess√≠vel externamente fun√ß√µes que
podem influenciar objetos deste tipo. Detalhes de implementa√ß√£o podem ser inacess√≠veis a um
programa que usa este tipo.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
285
O conceito de OOP tem um conjunto de conceitos relacionados, incluindo o seguinte:
¬∑ Simula√ß√£o de a√ß√µes do mundo real
¬∑ Tipos de dados definidos pelo usu√°rio
¬∑ Ocultamente de detalhes de implementa√ß√£o
¬∑ Possibilidade de reutiliza√ß√£o de c√≥digo atrav√©s de heran√ßa
¬∑ Interpreta√ß√£o de chamadas de fun√ß√£o durante execu√ß√£o
Alguns destes conceitos s√£o bastante vagos, alguns s√£o abstratos, outros s√£o gerais.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
286
<h3>Encapsulamento e Extensibilidade de Tipo</h3>
OOP √© uma abordagem balanceada para escrever software. Dados e comportamento s√£o empacotados
juntos. Este encapsulamento cria tipos de dados definidos pelo usu√°rio, estendendo os tipos de dados
da linguagem e interagindo com eles. Extensibilidade de tipos √© uma oportunidade de adicionar √†
linguagem tipos de dados definidos pelo usu√°rio, que s√£o tamb√©m f√°ceis de usar, tanto quanto os
tipos b√°sicos.
Um tipo de dado abstrato (ADT), por exemplo, uma string, √© uma descri√ß√£o do ideal, bem conhecido
tipo de comportamento.
O usu√°rio de string sabe que as opera√ß√µes de string, tais como concatena√ß√£o ou impress√£o, t√™m um
certo comportamento. Opera√ß√µes de concatena√ß√£o e impress√£o s√£o chamados m√©todos.
Uma certa implementa√ß√£o de ADT pode ter algumas restri√ß√µes, por exemplo, strings podem ser
limitados no comprimento. Estas limita√ß√µes afetam o comportamento aberto a todos. Ao mesmo
tempo, detalhes da implementa√ß√£o privada ou interna n√£o afetam diretamente a jeito como o usu√°rio
v√™ o objeto. Por exemplo, a string √© freq√ºentemente implementado como um array, enquanto o
endere√ßo de base interno deste array e seu nome n√£o s√£o essenciais para o usu√°rio.
Encapsulamento √© a habilidade de ocultar os detalhes de implementa√ß√£o quando a interface aberta
para o tipo definido pelo usu√°rio √© fornecida. Em MQL5, assim como em in C++, defini√ß√µes de classe e
estrutura (class e struct) s√£o usadas para as provis√µes de encapsulamento em combina√ß√£o com as
palavras-chave de acesso private, protected e public. 
A palavra-chave public mostra que o acesso aos membros que ficam depois dela, √© aberto sem
restri√ß√µes. Sem esta palavra-chave, membros de classe ficariam bloqueados por default. Membros
privados s√£o acess√≠veis somente por fun√ß√µes membro de sua pr√≥pria classe.
Fun√ß√µes de classe protegidas s√£o dispon√≠veis para fun√ß√µes de classe n√£o apenas em sua classe, mas
tamb√©m em suas classes herdeiras. Fun√ß√µes de classe publicas s√£o dispon√≠veis para qualquer fun√ß√£o
dentro do escopo da declara√ß√£o da classe. A prote√ß√£o torna poss√≠vel ocultar parte da implementa√ß√£o
da classe, evitando assim mudan√ßas inesperadas na estrutura dos dados. Restri√ß√£o de acesso ou
ocultamento de dados √© uma caracter√≠stica da programa√ß√£o orientada a objetos.
Geralmente, fun√ß√µes de classe s√£o protegidas e declaradas com o modificador protected, a leitura e a
escrita de valores s√£o realizadas por meio do uso de m√©todos especiais chamados set e get que s√£o
definidos por meio do modificador de acesso public.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
class CPerson
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   string            first_name;                 // nome
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              SetName(string n){m_name=n;}// atribui o nome
   string            GetName(){return (m_name);} // retorna o nome
</code></pre>
<p>
  };</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
287
Esta abordagem oferece v√°rias vantagens. Primeiro, por meio do nome da fun√ß√£o n√≥s podemos
entender o que ela faz - define (sets) ou obt√©m (gets) o valor de um membro de classe. Segundo,
talvez no futuro precisemos modificar o tipo da vari√°vel m_name na classe CPerson ou em qualquer de
suas classes derivadas.
Neste caso, necessitar√≠amos apenas alterar a implementa√ß√£o das fun√ß√µes SetName() e GetName(),
enquanto que objetos da classe CPerson estariam dispon√≠veis para uso em um programa sem nenhuma
altera√ß√£o de c√≥digo, porque o usu√°rio nem ao menos saberia que o tipo de dado do m_name foi
alterado.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
struct Name
  {
   string            first_name;                 // nome
   string            last_name;                  // √∫ltimo nome
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
class CPerson
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   Name              m_name;                     // nome
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              SetName(string n);
   string            GetName(){return(m_name.first_name+&quot; &quot;+m_name.last_name);}
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   string            GetFirstName(string full_name);
   string            GetLastName(string full_name);
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
void CPerson::SetName(string n)
  {
   m_name.first_name=GetFirstName(n);
   m_name.last_name=GetLastName(n);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
string CPerson::GetFirstName(string full_name)
  {
   int pos=StringFind(full_name,&quot; &quot;);
   if(pos&gt;0) StringSetCharacter(full_name,pos,0);
   return(full_name);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
string CPerson::GetLastName(string full_name)
  {
   string ret_string;
   int pos=StringFind(full_name,&quot; &quot;);
   if(pos&gt;0) ret_string=StringSubstr(full_name,pos+1);
   else      ret_string=full_name;
   return(ret_string);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
288
  }
<h3>Tamb√©m Veja</h3>
<h3>Tipos de Dados</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
289
<h3>Heran√ßa</h3>
O principal caracter√≠stica da OOP √© o incentivo √† reutiliza√ß√£o de c√≥digo atrav√©s de heran√ßa. Uma nova
classe √© feita a partir de uma j√° existente, que √© chamada de classe base. A classe derivada usa os
membros da classe base, mas tamb√©m pode modificar e complement√°-los.
Muitos tipos s√£o varia√ß√µes de tipos j√° existentes. √â muitas vezes tedioso desenvolver um novo c√≥digo
para cada um deles. Al√©m disso, um novo c√≥digo implica em novos erros. A classe derivada herda a
descri√ß√£o da classe base, assim qualquer re-desenvolvimento e re-teste de c√≥digo √© desnecess√°rio. As
rela√ß√µes de heran√ßa s√£o hier√°rquicas.
Hierarquia √© um m√©todo que permite copiar os elementos em toda a sua diversidade e complexidade.
Ela introduz a classifica√ß√£o de objetos. Por exemplo, a tabela peri√≥dica de elementos tem gases. Eles
possuem propriedades inerentes a todos os elementos peri√≥dicos.
Gases inertes constituem a pr√≥xima importante subclasse. A hierarquia √© que o g√°s inerte, como
√°rgon, √© um g√°s, e um g√°s, por sua vez, √© parte do sistema. Tal hierarquia permite interpretar o
comportamento dos gases inertes com facilidade. Sabemos que seus √°tomos cont√™m pr√≥tons e
el√©trons, o que √© verdade para todos os outros elementos.
Sabemos que eles est√£o no estado gasoso √† temperatura ambiente, como todos os gases. Sabemos
que nenhum g√°s da subclasse de gases inertes entra usualmente em rea√ß√µes qu√≠micas com outros
elementos, e isso √© uma propriedade de todos os gases inertes.
Considere um exemplo de heran√ßa de formas geom√©tricas. Para descrever a completa variedade de
formas simples (c√≠rculos, tri√¢ngulos, ret√¢ngulos, quadrados, etc.), a melhor forma √© criar uma classe
base (ADT), que √© o predecessor de todas as classes derivadas.
Vamos criar uma classe base CShape, que cont√©m apenas a maioria dos membros comuns que
descrevem a forma. Estes membros descrevem propriedades que s√£o caracter√≠sticas de qualquer
forma - o tipo da forma e as coordenadas do ponto de ancoragem principal.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- A classe base da forma (Shape)
class CShape
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   int       m_type;                   // Tipo de Forma
   int       m_xpos;                   // X - coordenada do ponto base
   int       m_ypos;                   // Y - coordenada do ponto base
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
             CShape(){m_type=0; m_xpos=0; m_ypos=0;} // construtor
   void      SetXPos(int x){m_xpos=x;} // define X
   void      SetYPos(int y){m_ypos=y;} // define Y
</code></pre>
<p>
  };
Sem seguida, criamos novas classes derivadas da classe base, nas quais adicionaremos campos
necess√°rios, cada um especificando uma certa classe. Para a forma C√≠rculo, √© necess√°rio adicionar um
membro que cont√©m o valor do raio. A forma Quadrado √© caracterizada pelo valor do lado. Portanto,
classes derivadas, herdadas da classe base CShape, ser√£o declaradas como se segue:</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
290
</p>
<pre><code class="language-mql5">
//--- A classe derivada c√≠rculo (Circle)
class CCircle : public CShape        // Depois de um dois pontos, n√≥s definimos a clas
  {                                    // a partir da qual a heran√ßa √© feita
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   int             m_radius;           // raio do c√≠rculo
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                   CCircle(){m_type=1;}// construtor, tipo 1 
</code></pre>
<p>
  };
Para a classe do Quadrado, a declara√ß√£o √© semelhante:
</p>
<pre><code class="language-mql5">
//--- a classe derivada quadrado (Square)
class CSquare : public CShape        // Depois de um dois pontos, n√≥s definimos a clas
  {                                    // a partir da qual a heran√ßa √© feita
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   int            m_square_side;       // lado do quadrado
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                  CSquare(){m_type=2;} // construtor, tipo 2 
</code></pre>
<p>
  };
Deve-se notar que enquanto um objeto √© criado, o construtor da classe base √© chamado primeiro, e
ent√£o o construtor da classe derivada √© chamado. Quando um objeto √© destru√≠do, primeiro o destrutor
da classe derivada √© chamado, e ent√£o o destrutor da classe base √© chamado.
Assim, ao declarar a maioria do membros gerais na classe base, podemos acrescentar membros
adicionais nas classes derivadas que especificam uma classe particular. A heran√ßa permite criar
bibliotecas de c√≥digo poderosas que podem ser reutilizadas muitas vezes.
A sintaxe para criar uma classe derivada a partir de uma classe j√° existente √© a seguinte:
</p>
<pre><code class="language-mql5">
class class_name : 
          (public | protected | private) opt  base_class_name
  {                                    
¬†  declara√ß√£o de membros de classe
</code></pre>
<p>
  };
Um dos aspectos da classe derivada √© a visibilidade (abertura) de seus sucessores membros
(herdeiros). As palavras-chave public, protected e private s√£o usadas para indicar qu√£o dispon√≠veis os
membros da classe base estar√£o dispon√≠veis para a classe derivada. A palavra-chave public ap√≥s um
dois pontos no cabe√ßalho de uma classe derivada indica que os membros protegidos e p√∫blicos da
classe base CShape devem ser herdados como membros protegidos e p√∫blicos da classe derivada
CCircle.
Os membros privados da classe base n√£o s√£o dispon√≠veis para a classe derivada. A heran√ßa p√∫blica
tamb√©m significa que classes derivadas (CCircle e CSquare) s√£o CShapes. Isto √©, o Quadrado
(CSquare) √© uma Forma (CShape), mas a Forma n√£o necessariamente tem que ser um Quadrado.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
291
A classe derivada √© uma modifica√ß√£o da classe base, ele herda os membros protegidos e p√∫blicos da
classe base. Os construtores e destrutores da classe base n√£o podem ser herdados. Al√©m de membros
da classe base, novos membros s√£o adicionados em uma classe derivada.
A classe derivada pode incluir a implementa√ß√£o de fun√ß√µes membro, diferentes da classe base. Isso
n√£o tem nada a ver com uma sobrecarga, quando o significado de um mesmo nome de uma fun√ß√£o
pode ser diferente para diferentes assinaturas.
Em heran√ßa protegida, membros p√∫blicos e protegidos da classe base tornam-se membros protegidos
da classe derivada. Em heran√ßa privada, os membros p√∫blicos e protegidos da classe base tornam-se
membros privados da classe derivada.
Em heran√ßa protegida e privada, a rela√ß√£o &quot;o objeto de uma classe derivada √© objeto da classe base&quot;
n√£o √© verdade. Os tipos protegido e privado de heran√ßa s√£o raros, e cada um deles precisam ser
usados com cautela.
Deve ser entendido que o tipo de heran√ßa (public, protected ou private) n√£o afeta a forma de acessar
os membros de classes base na hierarquia de heran√ßa a partir de uma classe derivada. Para
qualquer tipo de heran√ßa, somente membros da classe base declarados com especificadores de acesso
public e protected estar√£o dispon√≠veis fora das classes derivadas. Vamos verificar isso no seguinte
exemplo:
</p>
<pre><code class="language-mql5">
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
//+------------------------------------------------------------------+
//| Exemplo de classe com alguns tipos de acesso¬†                    |
//+------------------------------------------------------------------+
class CBaseClass
  {
</code></pre>
<p>
private:             //--- O membro privado n√£o √© dispon√≠vel a partir de classe deriva
</p>
<pre><code class="language-mql5">
   int               m_member;
</code></pre>
<p>
protected:           //--- O m√©todo protegido √© dispon√≠vel a partir da classe base e s
</p>
<pre><code class="language-mql5">
   int               Member(){return(m_member);}
</code></pre>
<p>
public:              // O construtor de classe √© dispon√≠vel para todos os membros
</p>
<pre><code class="language-mql5">
                     CBaseClass(){m_member=5;return;};
</code></pre>
<p>
private:             //--- Um m√©todo particular para atribuir um valor para m_member
</p>
<pre><code class="language-mql5">
   void              Member(int value) { m_member=value;};
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Classe derivada com erros¬†                                       |
//+------------------------------------------------------------------+
class CDerived: public CBaseClass // especifica√ß√£o da heren√ßa p√∫blica pode ser omitido
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void Func() // Na classe derivada, defina uma fun√ß√£o com chamadas aos membros da cl
     {
      //--- Uma tentativa de alterar um membro privado da classe base
      m_member=0;        // Erro, o membro privado da classe base n√£o √© dispon√≠vel</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
292
</p>
<pre><code class="language-mql5">
      Member(0);         // Erro, o m√©todo privado da classe base n√£o √© dispon√≠vel em 
      //--- Leitura do membro da classe base
      Print(m_member);   // Erro, o membro privado da classe base n√£o √© dispon√≠vel
      Print(Member());   // Sem erro, m√©todo protegido √© acess√≠vel a partir da classe 
     }
</code></pre>
<p>
  };
No exemplo acima, CBaseClass tem apenas um m√©todo p√∫blico - o construtor. Construtores s√£o
chamados automaticamente na cria√ß√£o de um objeto de classe. Portanto, o membro privado
m_member e o m√©todo protegido Member() n√£o podem ser chamados do lado de fora. Mas no caso de
heran√ßa p√∫blica, o membro Member() da classe base estar√° dispon√≠vel a partir de classes derivadas.
No caso de heran√ßa protegida, todos os membros da classe base com acessos p√∫blico e protegido
tornam-se protegidos. Isso significa que membros de dados e m√©todos p√∫blicos da classe base, com
heran√ßa protegida eles passam a ser dispon√≠veis somente a partir de classes derivadas e de suas
derivadas seguintes.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Exemplo de classe com alguns tipos de acesso¬†                    |
//+------------------------------------------------------------------+
class CBaseMathClass
  {
</code></pre>
<p>
private:             //--- O membro privado n√£o √© dispon√≠vel a partir de classe deriva
</p>
<pre><code class="language-mql5">
   double            m_Pi;
</code></pre>
<p>
public:              //--- Obtendo e definindo um valor para m_Pi
</p>
<pre><code class="language-mql5">
   void              SetPI(double v){m_Pi=v;return;};
   double            GetPI(){return m_Pi;};
</code></pre>
<p>
public:              // O construtor de classe √© dispon√≠vel para todos os membros
</p>
<pre><code class="language-mql5">
                     CBaseMathClass() {SetPI(3.14);  PrintFormat(&quot;%s&quot;,__FUNCTION__);};
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Uma classe derivada, em que m_Pi n√£o pode ser modificada¬†        |
//+------------------------------------------------------------------+
class CProtectedChildClass: protected CBaseMathClass // Heran√ßa protegida
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double            m_radius;
</code></pre>
<p>
public:              //--- M√©todos p√∫blicos na classe derivada
</p>
<pre><code class="language-mql5">
   void              SetRadius(double r){m_radius=r; return;};
   double            GetCircleLength(){return GetPI()*m_radius;};
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o de script¬†                               |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Ao criar uma classe derivada, o construtor da classe base ser√° chamada automatic
   CProtectedChildClass pt;
//--- Especifica o raio
   pt.SetRadius(10);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
293
</p>
<pre><code class="language-mql5">
   PrintFormat(&quot;Length=%G&quot;,pt.GetCircleLength());
//--- Se comentar a string abaixo, obteremos um erro na etapa de compila√ß√£o, j√° que Se
// pt.SetPI(3); 
//--- Agora declare um vari√°vel da classe base e tente definir a constante Pi igual a 
   CBaseMathClass bc;
   bc.SetPI(10);
//--- Aqui est√° o resultado
   PrintFormat(&quot;bc.GetPI()=%G&quot;,bc.GetPI());
</code></pre>
<p>
  }
O exemplo mostra que os m√©todos SetPI() e GetPI() na classe base CBaseMathClasse est√£o abertos e
dispon√≠veis para chamadas a partir de qualquer lugar do programa. Mas ao mesmo tempo, para
CProtectedChildClasse, que √© derivada dela, estes m√©todos podem ser chamados somente a partir de
m√©todos da classe CProtectedChildClass ou suas classes derivadas.
No caso de heran√ßa privada, todos os membros da classe base com acesso p√∫blico e protegido tornam-
se privados, e cham√°-los torn√°-se imposs√≠vel em heran√ßa posterior.
MQL5 n√£o tem heran√ßa m√∫ltipla.
<h3>Tamb√©m Veja</h3>
<h3>Estruturas e Classes</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
294
<h3>Polimorfismo</h3>
Polimorfismo √© uma oportunidade para diferentes classes de objetos, relacionadas atrav√©s de heran√ßa,
de responder de v√°rias formas quando o mesmo elemento de fun√ß√£o for chamado. Isso ajuda a criar
um mecanismo universal descrevendo o comportamento n√£o apenas da classe base, mas tamb√©m das
classes descendentes.
Vamos continuar a desenvolver uma classe base CShape, e definir uma fun√ß√£o membro GetArea(),
destinado a calcular a √°rea de uma forma. Em todas as classes descendentes, produzidas por heran√ßa
a partir da classe base, n√≥s redefinimos esta fun√ß√£o de acordo com as regras de c√°lculo de √°rea de
uma forma (shape) particular.
Para um quadrado (classe CSquare), a √°rea √© calculada atrav√©s de seu lado, para um c√≠rculo (classe
CCircle), a √°rea √© expressa atrav√©s de seu raio, etc. N√≥s podemos criar um array para armazenas
objetos do tipo CShape, no qual tanto objetos da classe base como todos os objetos de classes
descendentes podem ser armazenados. Mais adiante, podemos chamar a mesma fun√ß√£o para cada
elemento do array.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- Classe Base
class CShape
  {
</code></pre>
<p>
protected: 
</p>
<pre><code class="language-mql5">
   int            m_type;                // tipo da forma
   int            m_xpos;                // X - coordenada do ponto base
   int            m_ypos;                // Y - coordenada do ponto de base
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void           CShape(){m_type=0;};   // construtor, tipo=0
   int            GetType(){return(m_type);};// retorna o tipo da forma
</code></pre>
<p>
virtual
</p>
<pre><code class="language-mql5">
   double         GetArea(){return (0); }// retorna a √°rea da forma
</code></pre>
<p>
  };
Agora, todas as classes derivadas t√™m uma fun√ß√£o membro getArea(), que retorna o valor zero. A
implementa√ß√£o desta fun√ß√£o em cada descendente n√£o ser√° a mesma.
</p>
<pre><code class="language-mql5">
//--- A classe derivada Circle
class CCircle : public CShape            // Depois do dois pontos definimos a classe b
  {                                      // a partir do qual a heran√ßa √© feita
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double         m_radius;              // raio do c√≠rculo
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void           CCircle(){m_type=1;};  // construtor, tipo=1 
   void           SetRadius(double r){m_radius=r;};
   virtual double GetArea(){return (3.14*m_radius*m_radius);}// √°rea do c√≠rculo
</code></pre>
<p>
  };
Para a classe Square, a declara√ß√£o √© a mesma:
</p>
<pre><code class="language-mql5">
//--- A classe derivada Square</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
295
</p>
<pre><code class="language-mql5">
class CSquare : public CShape            // Depois do dois pontos definimos a classe b
  {                                      // a partir do qual a heran√ßa √© feita
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double          m_square_side;        // lado do quadrado
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void            CSquare(){m_type=2;}; // construtor, tipo=2
   void            SetSide(double s){m_square_side=s;};
   virtual double  GetArea(){return (m_square_side*m_square_side);}// √°rea quadrada
</code></pre>
<p>
  };
Para calcular a √°rea do quadrado e c√≠rculo, precisamos dos correspondentes valores de m_radius e
m_square_side, por isso n√≥s adicionamos as fun√ß√µes SetRadius() e SetSide() na declara√ß√£o da
correspondente classe.
Assumimos que objetos de diferentes tipos (CCircle e CSquare) derivados do tipo base CShape s√£o
usados em nosso programa. Polimorfismo permite criar um array de objetos da classe base CShape,
mas ao declarar este array, estes objetos s√£o desconhecidos e o tipo deles √© indefinido.
A decis√£o sobre que tipo de objeto estar√° contido em cada elemento do array ser√° tomada
diretamente durante a execu√ß√£o do programa. Isso envolve a cria√ß√£o din√¢mica de objetos das classes
apropriadas, e portanto a necessidade do uso de ponteiros de objeto ao inv√©s de objetos. 
O operador new √© usado para cria√ß√£o din√¢mica de objetos. Cada um destes objetos devem ser
individualmente e explicitamente exclu√≠dos usando o operador delete. Portanto declararemos um array
de ponteiros do tipo CShape, e criaremos um objeto de um tipo apropriado para cada elemento (new
Class_Name), como mostrado no exemplo de script seguinte:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Declararmos um array de ponteiros de objeto do tipo base
   CShape *shapes[5];   // Um array de ponteiros para objetos CShape
//--- Aqui preenchemos o array com objetos derivados
//--- Declaramos um ponteiro para o objeto de tipo CCircle
   CCircle *circle=new CCircle();
//--- Definimos propriedades do objeto usando o ponteiro do c√≠rculo
   circle.SetRadius(2.5);
//--- Colocamos o valor do ponteiro em shapes[0]
   shapes[0]=circle;
//--- Criamos um outro objeto CCircle e escrevemos seu ponteiro em shapes[1]
   circle=new CCircle();
   shapes[1]=circle;
   circle.SetRadius(5);
//--- Aqui n√≥s intencionalmente &quot;esquecemos&quot; de definir um valor para shapes[2]
//circle=new CCircle();</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
296
</p>
<pre><code class="language-mql5">
//circle.SetRadius(10);
//shapes[2]=circle;
//--- Definimos NULL para o elemento que n√£o √© usado
   shapes[2]=NULL;
//--- Criamos um objeto CSquare e escrevemos seu ponteiro em shapes[3]
   CSquare *square=new CSquare();
   square.SetSide(5);
   shapes[3]=square;
//--- Criamos um objeto CSquare e escrevemos seu ponteiro em shapes[4]
   square=new CSquare();
   square.SetSide(10);
   shapes[4]=square;
//--- Temos um array de ponteiros, obtemos seu tamanho
   int total=ArraySize(shapes);
//--- Passamos em um loop atrav√©s de todos os ponteiros no array
   for(int i=0; i&lt;5;i++)
     {
      //--- Se o ponteiro no √≠ndice especificado √© v√°lido
      if(CheckPointer(shapes[i])!=POINTER_INVALID)
        {
         //--- Imprimi o tipo e √°rea da forma
         PrintFormat(&quot;O objeto do tipo %d tem a √°rea %G&quot;,
               shapes[i].GetType(),
               shapes[i].GetArea());
        }
      //--- Se o ponteiro tem o tipo POINTER_INVALID
      else
        {
         //--- Notificamos um erro
         PrintFormat(&quot;Objeto shapes[%d] n√£o foi inicializado! Seu ponteiro pe %s&quot;,
                     i,EnumToString(CheckPointer(shapes[i])));
        }
     }
//--- Devemos excluir todos os objetos criados dinamicamente
   for(int i=0;i&lt;total;i++)
     {
      //--- N√≥s podemos excluir somente objetos com ponteiros do tipo POINTER_DYNAMIC
      if(CheckPointer(shapes[i])==POINTER_DYNAMIC)
        {
         //--- Notifica√ß√£o de exclus√£o
         PrintFormat(&quot;Excluindo shapes[%d]&quot;,i);
         //--- Exclu√≠mos um objeto por meio de seu ponteiro
         delete shapes[i];
        }</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
297
</p>
<pre><code class="language-mql5">
     }
</code></pre>
<p>
  }
Favor notar que ao excluir um objeto usando o operador delete, o tipo de seu ponteiro deve ser
verificado. Somente objetos com ponteiro do tipo POINTER_DYNAMIC podem ser exclu√≠dos usando
delete. Para ponteiros de outros tipos, um erro ser√° retornado.
Al√©m da redefini√ß√£o de fun√ß√µes durante heran√ßa, o polimorfismo tamb√©m inclui a implementa√ß√£o de
uma mesma fun√ß√£o com diferentes conjuntos de par√¢metros dentro de uma classe. Isso significa que a
classe pode ter v√°rias fun√ß√µes com o mesmo nome, mas com um tipo e/ou conjunto de par√¢metros
diferentes. Neste caso, o polimorfismo √© implementado atrav√©s de sobrecarga de fun√ß√£o.
<h3>Tamb√©m Veja</h3>
<h3>Standard Library</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
298
<h3>Sobrecarga (Overload)</h3>
Dentro de uma classe √© poss√≠vel definir dois ou mais m√©todos que usam o mesmo nome, mas tem
n√∫mero diferente de par√¢metros. Quando isso ocorre, estes m√©todos s√£o chamados de
sobrecarregados e tal processo √© referido como sobrecarga de m√©todo.
Sobrecarga de m√©todo √© uma forma de realiza√ß√£o de polimorfismo. Sobrecarga de m√©todos √© realizado
em concord√¢ncia com as mesmas regras da sobrecarga de fun√ß√£o.
Se a fun√ß√£o chamada n√£o tem correspond√™ncia exata, o compilador busca por uma fun√ß√£o adequada
em tr√™s n√≠veis seq√ºencialmente:
1. busca dentre os m√©todos da classe;
2. busca dentre os m√©todos da classe base, consistentemente a partir do ancestral mais pr√≥ximo at√©
o mais distante.
3. busca entre outras fun√ß√µes.
Se n√£o houver correspond√™ncia exata em todos os n√≠veis, mas v√°rias fun√ß√µes adequadas em
diferentes n√≠veis foram encontradas, a fun√ß√£o encontrada no menor n√≠vel √© usada. Dentro de um n√≠vel,
n√£o pode haver mais de uma fun√ß√£o adequada.
<h3>Tamb√©m Veja</h3>
<h3>Recarregando Fun√ß√µes</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
299
<h3>Fun√ß√µes Virtuais</h3>
A palavra-chave virtual √© o especificador de fun√ß√£o que fornece um mecanismo para selecionar
dinamicamente em tempo de execu√ß√£o uma fun√ß√£o-membro apropriada entre as fun√ß√µes de classes
base e derivadas. Estrutura n√£o podem ter fun√ß√µes virtuais. Pode ser usado para alterar as
declara√ß√µes de fun√ß√µes-membro somente.
A fun√ß√£o virtual, assim como uma fun√ß√£o comum, deve ter um corpo execut√°vel. Ao ser chamada, sua
sem√¢ntica √© a mesma que das outras fun√ß√µes.
Uma fun√ß√£o virtual pode ser sobreposta (overridden) em um classe derivada. A escolha de qual
defini√ß√£o de fun√ß√£o deve ser chamada para uma fun√ß√£o virtual √© feita dinamicamente (em tempo de
execu√ß√£o). Um caso t√≠pico √© quando uma classe base cont√©m uma fun√ß√£o virtual, e as classes
derivadas t√™m sua pr√≥pria vers√£o desta fun√ß√£o.
O ponteiro para a classe base pode indicar tanto um objeto da classe base quanto um objeto de uma
classe derivada. A escolha da fun√ß√£o-membro a ser chamada ser√° executada em tempo de execu√ß√£o e
depender√° do tipo do objeto, n√£o do tipo do ponteiro. Se n√£o houver nenhum membro de um tipo
derivado, a fun√ß√£o virtual da classe base √© usada por default.
Destrutores s√£o sempre virtuais, independentemente se elas est√£o declaradas com a palavra-chave
virtual ou n√£o.
Vamos considerar o uso de fun√ß√µes virtuais no exemplo do MT5_Tetris.mq5. A classe base
CTetrisShape com a fun√ß√£o virtual de desenhar 
√© 
definjida 
na 
inclus√£o 
do 
arquivo
MT5_TetisShape.mqh.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
class CTetrisShape
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   int               m_type;
   int               m_xpos;
   int               m_ypos;
   int               m_xsize;
   int               m_ysize;
   int               m_prev_turn;
   int               m_turn;
   int               m_right_border;
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              CTetrisShape();
   void              SetRightBorder(int border) { m_right_border=border; }
   void              SetYPos(int ypos)          { m_ypos=ypos;           }
   void              SetXPos(int xpos)          { m_xpos=xpos;           }
   int               GetYPos()                  { return(m_ypos);        }
   int               GetXPos()                  { return(m_xpos);        }
   int               GetYSize()                 { return(m_ysize);       }
   int               GetXSize()                 { return(m_xsize);       }
   int               GetType()                  { return(m_type);        }
   void              Left()                     { m_xpos-=SHAPE_SIZE;    }
   void              Right()                    { m_xpos+=SHAPE_SIZE;    }</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
300
</p>
<pre><code class="language-mql5">
   void              Rotate()                   { m_prev_turn=m_turn; if(++m_turn&gt;3) m
   virtual void      Draw()                     { return;                }
   virtual bool      CheckDown(int&amp; pad_array[]);
   virtual bool      CheckLeft(int&amp; side_row[]);
   virtual bool      CheckRight(int&amp; side_row[]);
</code></pre>
<p>
  };
Mais adiante, para cada classe derivada, esta fun√ß√£o √© implementada de acordo com as caracter√≠sticas
da classe descendente. Por exemplo, a primeira forma CTetrisShape1 tem sua implementa√ß√£o pr√≥pria
da fun√ß√£o Draw():
</p>
<pre><code class="language-mql5">
class CTetrisShape1 : public CTetrisShape
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- desenhando formato
   virtual void      Draw()
     {
      int    i;
      string name;
      //---
      if(m_turn==0 || m_turn==2)
        {
         //--- horizontal
         for(i=0; i&lt;4; i++)
           {
            name=SHAPE_NAME+(string)i;
            ObjectSetInteger(0,name,OBJPROP_XDISTANCE,m_xpos+i*SHAPE_SIZE);
            ObjectSetInteger(0,name,OBJPROP_YDISTANCE,m_ypos);
           }
        }
      else
        {
         //--- vertical
         for(i=0; i&lt;4; i++)
           {
            name=SHAPE_NAME+(string)i;
            ObjectSetInteger(0,name,OBJPROP_XDISTANCE,m_xpos);
            ObjectSetInteger(0,name,OBJPROP_YDISTANCE,m_ypos+i*SHAPE_SIZE);
           }
        }
     }
</code></pre>
<p>
  }
A forma Quadrado √© descrita por meio da classe CTetrisShape6 e tem sua implementa√ß√£o pr√≥pria do
m√©todo Draw():
</p>
<pre><code class="language-mql5">
class CTetrisShape6 : public CTetrisShape
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- desenhando formato</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
301
</p>
<pre><code class="language-mql5">
   virtual void      Draw()
     {
      int    i;
      string name;
      //---
      for(i=0; i&lt;2; i++)
        {
         name=SHAPE_NAME+(string)i;
         ObjectSetInteger(0,name,OBJPROP_XDISTANCE,m_xpos+i*SHAPE_SIZE);
         ObjectSetInteger(0,name,OBJPROP_YDISTANCE,m_ypos);
        }
      for(i=2; i&lt;4; i++)
        {
         name=SHAPE_NAME+(string)i;
         ObjectSetInteger(0,name,OBJPROP_XDISTANCE,m_xpos+(i-2)*SHAPE_SIZE);
         ObjectSetInteger(0,name,OBJPROP_YDISTANCE,m_ypos+SHAPE_SIZE);
        }
     }
</code></pre>
<p>
  };
Dependendo da classe da qual o objeto criado pertence, √© chamada a fun√ß√£o virtual desta ou daquela
classe derivada.
</p>
<pre><code class="language-mql5">
void CTetrisField::NewShape()
  {
//--- criando uma dos 7 poss√≠veis formas aleatoriamente
   int nshape=rand()%7;
   switch(nshape)
     {
      case 0: m_shape=new CTetrisShape1; break;
      case 1: m_shape=new CTetrisShape2; break;
      case 2: m_shape=new CTetrisShape3; break;
      case 3: m_shape=new CTetrisShape4; break;
      case 4: m_shape=new CTetrisShape5; break;
      case 5: m_shape=new CTetrisShape6; break;
      case 6: m_shape=new CTetrisShape7; break;
     }
//--- desenhar
   m_shape.Draw();
//---
</code></pre>
<p>
  }
<h3>Modificador override</h3>
O modificador override indica que a fun√ß√£o declarada deve substituir o m√©todo da classe pai. O uso
deste modificador permite evitar erros durante as substitui√ß√µes, por exemplo, durante uma altera√ß√£o
aleat√≥ria na assinatura do m√©todo. Ou, por exemplo, na classe base, est√° definido o m√©todo func, ele
√© usado como argumento da vari√°vel do tipo int:</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
302
</p>
<pre><code class="language-mql5">
class CFoo
  {
   void virtual func(int x) const { }
</code></pre>
<p>
  };
A seguir, o m√©todo √© substitu√≠do na classe que est√° sendo herdada:
</p>
<pre><code class="language-mql5">
class CBar : public CFoo
  {
   void func(short x) { }
</code></pre>
<p>
  };
No entanto, no caso de haver um erro, o tipo de argumento √© alterado de int para short. De fato, aqui
acontece uma sobrecarga do m√©todo. Agindo em conformidade com o algoritmo de estabelecimento da
fun√ß√£o sobrecarregada, em determinadas situa√ß√µes, o compilador pode selecionar o m√©todo definido
na classe base, em vez de escolher o m√©todo de substitui√ß√£o.
Para evitar esses erros, √© necess√°rio adicionar o modificador override ao m√©todo de substitui√ß√£o.
</p>
<pre><code class="language-mql5">
class CBar : public CFoo
  {
   void func(short x) override { }
</code></pre>
<p>
  };
Se, durante a substitui√ß√£o, for alterada a assinatura do m√©todo, o compilador n√£o conseguir√°
encontrar, na classe pai, o m√©todo com essa mesma assinatura e emitir o erro de compila√ß√£o:
&#x27;CBar::func&#x27; method is declared with &#x27;override&#x27; specifier but does not override any ba
<h3>Modificador final</h3>
Ao contr√°rio do anterior, o modificador final pro√≠be a substitui√ß√£o do m√©todo em classes de heran√ßa.
Se a implementa√ß√£o do m√©todo for auto-suficiente e conclu√≠da na sua totalidade, declare esse fato
usando o modificador final, para ele n√£o ser alterado em conseq√º√™ncia.
</p>
<pre><code class="language-mql5">
class CFoo
  {
   void virtual func(int x) final { }
</code></pre>
<p>
  };
 
</p>
<pre><code class="language-mql5">
class CBar : public CFoo
  {
   void func(int) { }
</code></pre>
<p>
  };
 
Como no exemplo acima, ao tentar substituir o m√©todo usando o modificador final, o compilador ir√°
emitir um erro:
&#x27;CFoo::func&#x27; method declared as &#x27;final&#x27; cannot be overridden by &#x27;CBar::func&#x27;
see declaration of &#x27;CFoo::func&#x27;
<h3>Veja Tamb√©m</h3>
<h3>Standard Library</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
303
<h3>Membros Est√°ticos de uma Classe/Estrutura</h3>
<h3>Membros Est√°ticos</h3>
Os membros de uma classe podem ser declarados usando o modificador de classe de armazenamento
static. Esses membros de dados s√£o compartilhados por todos as inst√¢ncias desta classe e s√£o
armazenados em um lugar. Membros de dados n√£o est√°ticos s√£o criados para cada vari√°vel de objeto
de classe.
A incapacidade de declarar membros est√°ticos de uma classe teria levado a necessidade de declarar
estes dados no n√≠vel global do programa. Isso quebraria a rela√ß√£o entre os dados e a classe deles, e
n√£o seria consistente com o paradigma b√°sico da OOP - juntar dados e m√©todos para manipul√°-los em
uma classe. O membro est√°tico permite que dados de classe n√£o espec√≠ficos a uma particular inst√¢ncia
existam no escopo da classe.
Desde que um membro de classe est√°tica n√£o dependa de uma particular inst√¢ncia, a refer√™ncia a ele
√© como se segue:
class_name::variable
onde class_name √© o nome da classe, e variable √© o nome do membro da classe.
Como se v√™, para acessar o membro est√°tico de uma classe, o operador de resolu√ß√£o de contexto :: √©
usado. Ao acessar um membro est√°tico de dentro de m√©todos da classe, o operador de contexto √©
opcional. 
Membro est√°tico de uma classe deve ser explicitamente inicializado com o valor desejado. Para isso,
deve ser declarado e inicializado em escopo global. A sequ√™ncia de inicializa√ß√£o dos membros
est√°ticos corresponder√° a sequ√™ncia de sua declara√ß√£o em escopo global.
Por exemplo, temos a classe CParser usado para separar o texto, e precisamos contar o n√∫mero total
de palavras e caracteres processados. N√≥s s√≥ precisamos declarar os membros de classe necess√°rios
como est√°ticos e inicializ√°-los no n√≠vel global. Ent√£o todas as inst√¢ncias da classe usar√£o um contador
comum para palavras e caracteres.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Classe &quot;Analisador de Texto&quot;¬†                                    |
//+------------------------------------------------------------------+
class CParser
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   static int        s_words;
   static int        s_symbols;
   //--- Construtor e destrutor
                     CParser(void);
                    ~CParser(void){};
</code></pre>
<p>
  };
...
</p>
<pre><code class="language-mql5">
//--- Inicializa√ß√£o de membros est√°ticos da classe Parser no n√≠vel global
int CParser::s_words=0;
int CParser::s_symbols=0;</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
304
Um membro de classe est√°tico pode ser declarado com a palavra-chave const. Tais constantes
est√°ticas devem ser inicializadas no n√≠vel global com a palavra-chave const:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Classe &quot;Stack&quot; para armazenar dados processados¬†                 |
//+------------------------------------------------------------------+
class CStack
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     CStack(void);
                    ~CStack(void){};
</code></pre>
<p>
...
private:
</p>
<pre><code class="language-mql5">
   static const int  s_max_length; // Capacidade m√°xima da pilha
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- Inicializa√ß√£o da constante est√°tica da classe CStack
</code></pre>
<p>
const int CStack::s_max_length=1000;
<h3>Ponteiro this</h3>
A palavra-chave this denota um ponteiro implicitamente declarado para si mesmo ‚Äì para uma inst√¢ncia
espec√≠fica da classe, no contexto do qual o m√©todo √© executado. Pode ser usado somente em m√©todos
n√£o est√°ticos da classe. O ponteiro this √© um membro n√£o est√°tico impl√≠cito de qualquer classe.
Em fun√ß√µes est√°ticas voc√™ pode acessar somente membros/m√©todos est√°ticos de uma classe.
<h3>M√©todos Est√°ticos</h3>
Em MQL5, fun√ß√µes membro do tipo est√°tico podem ser usadas. O modificador static deve preceder o
tipo do retorno de uma fun√ß√£o na declara√ß√£o dentro de uma classe.
</p>
<pre><code class="language-mql5">
class CStack
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Construtor e destrutor
                     CStack(void){};
                    ~CStack(void){};
   //--- Capacidade m–±xima da pilha
   static int        Capacity();
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   int               m_length;     // O n—ämero de elementos na pilha
   static const int  s_max_length; // Capacidade m–±xima da pilha
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna o n—ämero m–±ximo de elementos armazenados na pilha¬†       |
//+------------------------------------------------------------------+
int CStack::Capacity(void)
  {
   return(s_max_length);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
305
  }
</p>
<pre><code class="language-mql5">
//--- Inicializa–∑–≥o da constante est–±tica da classe CStack
</code></pre>
<p>
const int CStack::s_max_length=1000;
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- declare CStack type variable
   CStack stack;
//--- call the object&#x27;s static method
   Print(&quot;CStack.s_max_length=&quot;,stack.Capacity());
//--- it can also be called the following way, as the method is static and does not re
   Print(&quot;CStack.s_max_length=&quot;,CStack::Capacity());
</code></pre>
<p>
  }
Um m√©todo com o modificador const √© chamado de constante e n√£o pode alterar membros impl√≠citos
de sua classe. A declara√ß√£o de fun√ß√µes constantes de uma classe e par√¢metros constantes √© chamado
de controle const-corre√ß√£o. Atrav√©s deste controle pode-se assegurar que o compilador garantir√° a
consist√™ncia de valores de objetos e retornar√° um erro durante a compila√ß√£o se existir algo errado. 
O modificador const √© colocado ap√≥s a lista de argumentos dentro de uma declara√ß√£o de classe. A
defini√ß√£o do lado de fora de uma classe deve tamb√©m incluir o modificador const:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Class &quot;Ret√¢ngulo&quot;                                                |
//+------------------------------------------------------------------+
class CRectangle
  {
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double            m_width;      // Largura¬†
   double            m_height;     // Altura
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- Construtor e destrutor
                     CRectangle(void):m_width(0),m_height(0){};
                     CRectangle(const double w,const double h):m_width(w),m_height(h){
                    ~CRectangle(void){};
   //--- Calculando a √°rea
   double            Square(void) const;
   static double     Square(const double w,const double h);// { return(w*h); }
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna a √°rea do objeto &quot;Ret√¢ngulo&quot;¬†                            |
//+------------------------------------------------------------------+
double CRectangle::Square(void) const
  {
   return(Square(m_width,m_height));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna o produto de duas vari√°veis¬†                             |</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
306
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
</code></pre>
<p>
static double CRectangle::Square(const double w,const double h)
</p>
<pre><code class="language-mql5">
  {
   return(w*h);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- Criar um ret√¢ngulo reto com os lados iguais a 5 e 6
   CRectangle rect(5,6);
//--- Procurar a √°rea do ret√¢ngulo usando um m√©todo constante
   PrintFormat(&quot;rect.Square()=%.2f&quot;,rect.Square());
//--- Procurar o produto de n√∫meros usando o m√©todo est√°tico da classe CRectangle
   PrintFormat(&quot;CRectangle::Square(2.0,1.5)=%f&quot;,CRectangle::Square(2.0,1.5));
</code></pre>
<p>
  }
Um argumento adicional a favor do uso do controle de const√¢ncia √© o fato de que neste caso, o
compilador gera uma otimiza√ß√£o especial, por exemplo, coloca um objeto constante na mem√≥ria de
somente-leitura.
Uma fun√ß√£o est√°tica n√£o pode ser determinada com o modificador const, porque este modificar
garante a const√¢ncia dos membros de inst√¢ncia quando chamar esta fun√ß√£o. Mas, como mencionado
acima, a fun√ß√£o est√°tica n√£o pode acessar membros de classe n√£o est√°tica.
<h3>Tamb√©m Veja</h3>
Vari√°veis Est√°ticas, Vari√°veis, Refer√™ncias. Modificador &amp; e Palavra-chave this</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
307
<h3>Templates de Fun√ß√£o</h3>
Fun√ß√µes sobrecarregadas s√£o normalmente usadas para realizar opera√ß√µes similares em v√°rios tipos
de dados. ArraySize() √© um exemplo simples de tal fun√ß√£o em MQL5. Ela retorna o tamanho de
qualquer tipo de array. De fato, esta fun√ß√£o de sistema √© sobrecarregada e a implementa√ß√£o completa
de tal sobrecarga √© escondida dos desenvolvedores de aplicativos MQL5:
</p>
<pre><code class="language-mql5">
int¬† ArraySize(
   void&amp;¬† array[]¬†     // array verificado
   );
</code></pre>
<p>
Isso significa que o compilador da linguagem MQL5 insere a implementa√ß√£o necess√°ria para cada
chamada desta fun√ß√£o. Por exemplo, √© assim que √© implementado para arrays de tipo inteiro:
</p>
<pre><code class="language-mql5">
int¬† ArraySize(
   int&amp;¬† array[]¬†     // array com elementos de tipo int
   );
</code></pre>
<p>
A fun√ß√£o ArraySize() pode ser exibida da seguinte forma para array de tipo MqlRates para trabalhar
com cota√ß√µes em formato de dados hist√≥ricos:
</p>
<pre><code class="language-mql5">
int¬† ArraySize(
   MqlRates&amp;¬† array[]¬†// array preenchido com valores de tipo MqlRates
   );
</code></pre>
<p>
Assim, √© muito conveniente usar a mesma fun√ß√£o para trabalhar com tipos diferentes. No entanto,
todo trabalho preliminar deve ser realizado - a fun√ß√£o necess√°ria deve ser sobrecarregada para todos
os tipos de dados com os quais a fun√ß√£o deve trabalhar corretamente.
Existe uma solu√ß√£o conveniente. Se opera√ß√µes similares devem ser executadas para cada tipo de
dado, √© poss√≠vel usar templates de fun√ß√£o. Neste caso, um programador precisa escrever somente
uma descri√ß√£o de template de fun√ß√£o. Ao descrever o template de tal forma, n√≥s devemos especificar
somente alguns par√¢metros formais ao inv√©s de alguns tipos de dados definidos com os quais a fun√ß√£o
deve trabalhar. O compilador automaticamente gerar√° v√°rias fun√ß√µes para o apropriado handling de
cada tipo baseado nos tipos de argumentos usados ao chamar a fun√ß√£o.
A defini√ß√£o de template de fun√ß√£o come√ßa com a palavra-chave template seguida pela lista de
par√¢metros entre chaves angulares. Cada par√¢metro formal √© precedido pela palavra-chave typename.
Tipos de par√¢metros formais s√£o tipos incorporados ou definidos pelo usu√°rio. Eles s√£o usados:
¬∑ para especificar os tipos de argumentos da fun√ß√£o,
¬∑ para especificar o tipo de valor de retorno da fun√ß√£o,
¬∑ para declarar as vari√°veis dentro da defini√ß√£o da fun√ß√£o
O n√∫mero de par√¢metros de template n√£o pode exceder oito. Cada par√¢metro formal na defini√ß√£o de
template deve aparecer na lista de par√¢metros da fun√ß√£o pelo menos uma vez. Cada nome de um
par√¢metro formal deve ser √∫nico.
Abaixo est√° um exemplo de um template de fun√ß√£o para buscar do valor mais alto em um array de
qualquer tipo num√©rico (n√∫meros inteiros ou reais):</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
308
template&lt;typename T&gt;
<h3>T ArrayMax(T &amp;arr[])</h3>
</p>
<pre><code class="language-mql5">
  {
   uint size=ArraySize(arr);
   if(size==0) return(0);          
   
   T max=arr[0];
   for(uint n=1;n&lt;size;n++)
      if(max&lt;arr[n]) max=arr[n];
//---
   return(max);
</code></pre>
<p>
  }
Este template define a fun√ß√£o que encontra o valor mais alto no array passado e retorna este valor
como resultado. Lembre-se que a fun√ß√£o ArrayMaximum() constru√≠da em MQL5 retorna apenas o
√≠ndice do valor mais alto que pode ser usado para encontrar o valor em si. Por exemplo:
</p>
<pre><code class="language-mql5">
//--- criar array
   double array[];
   int size=50;
   ArrayResize(array,size);
//--- preenche com valores aleat√≥rios
   for(int i=0;i&lt;size;i++)
     {
      array[i]=MathRand();
     }
//--- encontra a posi√ß√£o do valor mais alto no array
   int max_position=ArrayMaximum(array);
//--- agora, obt√©m o valor mais alto propriamente no array
   double max=array[max_position];
//--- exibe o valor encontrado
   Print(&quot;Valor max = &quot;,max);
</code></pre>
<p>
Assim, n√≥s realizamos dois passos para obter obter o valor mais alto no array. Com o template de
fun√ß√£o ArrayMax(), n√≥s podemos obter o resultado do tipo necess√°rio apenas passando o array de tipo
apropriado para esta fun√ß√£o. Isso significa que ao inv√©s das √∫ltimas duas linhas:
</p>
<pre><code class="language-mql5">
//--- encontra a posi√ß√£o do valor mais alto no array
   int max_position=ArrayMaximum(array);
//--- agora, receber o valor mais alto propriamente no array
   double max=array[max_position];
</code></pre>
<p>
n√≥s podemos usar somente uma linha, cujo resultado retornado tem o mesmo tipo que o array passado
para a fun√ß√£o:
</p>
<pre><code class="language-mql5">
//--- encontra o valor mais alto
   double max=ArrayMax(array);
</code></pre>
<p>
Neste caso, o tipo do resultado retornado pela fun√ß√£o ArrayMax() corresponder√° automaticamente ao
tipo do array.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
309
Use a palavra chave typename para obter o tipo do argumento como uma string a fim de criar m√©todos
de prop√≥sito geral para trabalhar com v√°rios tipos de dados. Vamos considerar um exemplo espec√≠fico
da fun√ß√£o que retorna tipo de dado como uma string:
</p>
<pre><code class="language-mql5">
#include &lt;Trade\Trade.mqh&gt;
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- 
   CTrade trade;   
   double d_value=M_PI;
   int i_value=INT_MAX;
   Print(&quot;d_value: tipo=&quot;,GetTypeName(d_value), &quot;,   valor=&quot;, d_value);
   Print(&quot;i_value: tipo=&quot;,GetTypeName(i_value), &quot;,   valor=&quot;, i_value);
   Print(&quot;trade: tipo=&quot;,GetTypeName(trade));
//--- 
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Tipo √© retornado como uma linha¬†                                 |
//+------------------------------------------------------------------+
</code></pre>
<p>
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
string GetTypeName(const T &amp;t)
  {
//--- retorna o tipo como uma linha
   return(typename(T));
//---
</code></pre>
<p>
  }
Templates de fun√ß√£o podem tamb√©m serem usados para m√©todos de classe, por exemplo:
</p>
<pre><code class="language-mql5">
class CFile
  {
   ...
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   ...
   template&lt;typename T&gt;
   uint WriteStruct(T &amp;data);
</code></pre>
<p>
  };
template&lt;typename T&gt;
uint CFile::WriteStruct(T &amp;data)
</p>
<pre><code class="language-mql5">
  {
   ...
   return(FileWriteStruct(m_handle,data));
</code></pre>
<p>
  }</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
310
Os templates de fun√ß√£o n√£o deve ser declarados com as palavras-chave export, virtual e #import.
<h3>Sobrecarga de fun√ß√µes de modelo</h3>
Em alguns casos, pode ser necess√°rio sobrecarregar uma fun√ß√£o de modelo. Por exemplo, temos uma
fun√ß√£o de modelo que grava, no primeiro par√¢metro, o valor do segundo par√¢metro com ajuda da
convers√£o expl√≠cita de tipos. Na linguagem MQL5, √© proibida a convers√£o do tipo string para o tipo
bool, n√≥s podemos fazer isto sozinhos, para tal fim, criamos a sobrecarga da fun√ß√£o de modelo. Por
exemplo:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de modelo                                                |
//+------------------------------------------------------------------+
</code></pre>
<p>
template&lt;typename T1,typename T2&gt;
</p>
<pre><code class="language-mql5">
string Assign(T1 &amp;var1,T2 var2)
  {
   var1=(T1)var2;
   return(__FUNCSIG__);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Sobrecarga especial para o caso bool+string                    |
//+------------------------------------------------------------------+
string Assign(bool &amp;var1,string var2)
  {
   var1=(StringCompare(var2,&quot;true&quot;,false) || StringToInteger(var2)!=0);
   return(__FUNCSIG__);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   int i;
   bool b;
   Print(Assign(i,&quot;test&quot;));
   Print(Assign(b,&quot;test&quot;));
</code></pre>
<p>
  }
Como resultado da execu√ß√£o deste c√≥digo, vemos que, para o par int+string, foi usada a fun√ß√£o de
modelo Assign(), enquanto, ap√≥s a segunda chamada, para o par bool+string, j√° foi usada a vers√£o
sobrecarregada.
</p>
<pre><code class="language-mql5">
string Assign&lt;int,string&gt;(int&amp;,string)
string Assign(bool&amp;,string)
</code></pre>
<p>
<h3>Veja tamb√©m</h3>
<h3>Sobrecarga</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
311
Qual √© a melhor coisa sobre os modelos?
Os modelos das fun√ß√µes s√£o usados quando √© necess√°rio realizar as mesmas opera√ß√µes com diferentes
tipos de dados, por exemplo, localizar o elemento m√°ximo na matriz. A principal vantagem da
utiliza√ß√£o de modelos √© que o programador n√£o necessita escrever uma sobrecarga separada para cada
tipo. Ou seja, em vez de v√°rias declara√ß√µes do conjunto de sobrecargas para cada tipo
</p>
<pre><code class="language-mql5">
double ArrayMax(double array[])
  {
   ...
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
int¬†ArrayMax(int¬†array[])
  {
   ...
</code></pre>
<p>
  }
uint ArrayMax(uint array[])
</p>
<pre><code class="language-mql5">
  {
   ...
</code></pre>
<p>
  }
long ArrayMax(long¬†array[])
</p>
<pre><code class="language-mql5">
  {
   ...
</code></pre>
<p>
  }
datetime ArrayMax(datetime¬†array[])
</p>
<pre><code class="language-mql5">
  {
   ...
</code></pre>
<p>
  }
basta escrever uma fun√ß√£o de modelo
template&lt;typename T&gt; 
<h3>T¬†ArrayMax(T array[])</h3>
</p>
<pre><code class="language-mql5">
  {
   if(ArraySize()==0) 
      return(0);
   uint max_index=ArrayMaximum(array);  
   return(array[max_index]);
</code></pre>
<p>
  }
e, em seguida, us√°-la em seu c√≥digo:
</p>
<pre><code class="language-mql5">
double high[];
</code></pre>
<p>
datetime time[];
....
</p>
<pre><code class="language-mql5">
double max_high=ArrayMax(high);
</code></pre>
<p>
datetime lasttime=ArrayMax(time);
Neste caso, o par√¢metro formal T especifica o tipo de dados utilizados, durante a compila√ß√£o, ele √©
substitu√≠do pelo tipo real utilizado, ou seja, o compilador gera automaticamente uma fun√ß√£o separada
para cada tipo, isto √©, double, datetime e assim por diante. Da mesma forma, na linguagem MQL5,
voc√™ pode criar modelos de classes usando todas as vantagens de tal abordagem.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
312
<h3>Modelos de classes</h3>
O modelo de classe √© declarado usando a palavra-chave template, seguida pelos colchetes angulares
&lt;&gt;, nos quais s√£o listados os par√¢metros formais com a palavra-chave typename. Este registro indica
ao compilador que est√° perante uma classe gen√©rica na com o par√¢metro formal T que especifica o
tipo real da vari√°vel ao implementar a classe. Por exemplo, criamos uma classe vector para armazenar
a matriz com elementos do tipo T:
</p>
<pre><code class="language-mql5">
#define TOSTR(x) #x+&quot; &quot;   // macro para exibir o nome do objeto 
//+------------------------------------------------------------------+
//| Classe vector para armazenar elementos do tipo T                       |
//+------------------------------------------------------------------+
</code></pre>
<p>
template &lt;typename T&gt;
</p>
<pre><code class="language-mql5">
class TArray
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   T                 m_array[];
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- por padr√£o, o construtor cria uma matriz de 10 elementos
   void TArray(void){ArrayResize(m_array,10);}
   //--- construtor para criar um vetor com o tamanho definido da matriz
   void TArray(int size){ArrayResize(m_array,size);}
   //--- retorna o tipo e n√∫mero de dados que s√£o armazenados no objeto do tipo TArray
   string Type(void){return(typename(m_array[0])+&quot;:&quot;+(string)ArraySize(m_array));};
</code></pre>
<p>
  };
Em seguida, no programa, criamos de maneiras diferentes tr√™s objetos TArray  para trabalhar com
diferentes tipos
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   TArray&lt;double&gt; double_array;   // por padr√£o, o tamanho do vetor √© 10 
   TArray&lt;int&gt; int_array(15);     // o tamanho do vetor √© 15
   TArray&lt;string&gt; *string_array;  // ponteiro para o vetor TArray&lt;string&gt; 
//--- criamos o objeto din√¢mico
   string_array=new TArray&lt;string&gt;(20);
//--- no Di√°rio, exibimos o nome do objeto, tipo de dados e tamanho do vetor
   PrintFormat(&quot;%s (%s)&quot;,TOSTR(double_array),double_array.Type());
   PrintFormat(&quot;%s (%s)&quot;,TOSTR(int_array),int_array.Type());
   PrintFormat(&quot;%s (%s)&quot;,TOSTR(string_array),string_array.Type());
//--- exclu√≠mos o objeto din√¢mico antes de encerrar o programa
   delete(string_array);   
</code></pre>
<p>
  }
<h3>Resultado do script:</h3>
  double_array  (double:10)
  int_array  (int:15)
  string_array  (string:20)</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
313
Como resultado, foram criados 3 vetores com diferentes tipos de dados: double, int e string.
Os modelos de classes s√£o adequados para desenvolver recipientes, isto √©, os objetos destinados a
encapsular qualquer tipo de objeto. Os objetos dos recipientes s√£o cole√ß√µes que j√° cont√™m objetos de
um tipo particular. Normalmente, o recipiente imediatamente √© integrado e implementado para
trabalhar com dados que s√£o armazenados nele.
Por exemplo, √© poss√≠vel criar um modelo de classe que n√£o permita acessar um elemento fora da
matriz e, assim, evitar o erro cr√≠tico &quot;out of range&quot;.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
// | Classe para acessar com seguran√ßa um elemento da matriz¬†             |
//+------------------------------------------------------------------+
</code></pre>
<p>
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
class TSafeArray
  {
</code></pre>
<p>
protected:
</p>
<pre><code class="language-mql5">
   T                 m_array[];
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- construtor por padr√£o
   void              TSafeArray(void){}
   //--- construtor para criar a matriz do tamanho especificado
   void              TSafeArray(int size){ArrayResize(m_array,size);}
   //--- tamanho de matriz 
   int               Size(void){return(ArraySize(m_array));}
   //--- altera√ß√£o do tamanho da matriz 
   int               Resize(int size,int reserve){return(ArrayResize(m_array,size,rese
   //--- liberta√ß√£o da matriz 
   void              Erase(void){ZeroMemory(m_array);}
   //--- operador de acesso ao elemento da matriz de acordo com o √≠ndice
   T                 operator[](int index);
   //--- operador de atribui√ß√£o para obter imediatamente todos os elementos a partir d
   void              operator=(const T  &amp;array[]); // matriz do tipo T 
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Opera√ß√£o de obten√ß√£o do elemento segundo o √≠ndice                           |
//+------------------------------------------------------------------+
</code></pre>
<p>
template&lt;typename T&gt;
<h3>T TSafeArray::operator[](int index)</h3>
</p>
<pre><code class="language-mql5">
  {
   static T invalid_value;
//---
   int max=ArraySize(m_array)-1;
   if(index&lt;0 || index&gt;=ArraySize(m_array))
     {
      PrintFormat(&quot;%s index %d is not in range (0-%d)!&quot;,__FUNCTION__,index,max);
      return(invalid_value);
     }
//---
   return(m_array[index]);</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
314
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Opera√ß√£o de atribui√ß√£o para a matriz                                |
//+------------------------------------------------------------------+
</code></pre>
<p>
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
void TSafeArray::operator=(const T  &amp;array[])
  {
   int size=ArraySize(array);
   ArrayResize(m_array,size);
//--- o tipo T deve suportar o operador de c√≥pia
   for(int i=0;i&lt;size;i++)
      m_array[i]=array[i];
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
   int copied,size=15;  
   MqlRates rates[];
//--- copiamos a matriz de cota√ß√µes
   if((copied=CopyRates(_Symbol,_Period,0,size,rates))!=size)
     {
      PrintFormat(&quot;CopyRates(%s,%s,0,%d) retornou o c√≥digo de erro %d&quot;,
      _Symbol,EnumToString(_Period),size,GetLastError());
      return;
     }
//--- criamos o recipiente e colocamos nele a matriz dos valores MqlRates
   TSafeArray&lt;MqlRates&gt; safe_rates;
   safe_rates=rates;
   //--- √≠ndice nos limites da matriz
   int index=3;
   PrintFormat(&quot;Close[%d]=%G&quot;,index,safe_rates[index].close);
   //--- √≠ndice fora dos limites da matriz
   index=size;
   PrintFormat(&quot;Close[%d]=%G&quot;,index,safe_rates[index].close);
</code></pre>
<p>
  }
Note-se que, na descri√ß√£o dos m√©todos fora da declara√ß√£o da classe, tamb√©m √© necess√°rio utilizar a
declara√ß√£o de modelo:
template&lt;typename T&gt;
<h3>T TSafeArray::operator[](int index)</h3>
</p>
<pre><code class="language-mql5">
  {
   ...
</code></pre>
<p>
  }
template&lt;typename T&gt;
</p>
<pre><code class="language-mql5">
void TSafeArray::operator=(const T  &amp;array[])</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
315
</p>
<pre><code class="language-mql5">
  {
   ...
</code></pre>
<p>
  }
Os modelos de classes e fun√ß√µes permitem especificar v√°rios par√¢metros formais, separados por
v√≠rgulas, por exemplo, cole√ß√£o Map para armazenar os pares &quot;chave - valor&quot;:
template&lt;typename Key, template Value&gt;
</p>
<pre><code class="language-mql5">
class TMap
  {
   ...
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>Modelos de fun√ß√µes, Sobrecarga</h3></p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
316
Classes abstratas e fun√ß√µes meramente virtuais (puras)
As classes abstratas est√£o projetadas para criar entidades generalizadas, cuja base, no futuro, prev√™
a cria√ß√£o de classes derivadas mais espec√≠ficas. Uma classe abstrata √© uma classe que pode ser
utilizada apenas como classe base para alguma outra classe, por isso √© imposs√≠vel criar um objeto do
tipo classe abstrata
Uma classe, que contenha pelo menos uma fun√ß√£o meramente virtual, √© abstrata. Portanto, as classes
derivadas da classe abstrata devem implementar todas as suas fun√ß√µes meramente virtuais, caso
contr√°rio, elas ser√£o tamb√©m classes abstratas.
A fun√ß√£o virtual √© declarada como &quot;pura&quot; utilizando a sintaxe do especificador de pureza.
Consideremos, como exemplo, uma classe CAnimal, criada apenas para fornecer fun√ß√µes comuns - s√£o
os pr√≥prios objetos do tipo CAnimal que t√™m um car√°ter demasiado geral para um uso pr√°tico. Assim,
a classe CAnimal √© uma boa candidata para classe abstrata:
</p>
<pre><code class="language-mql5">
class CAnimal
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                      CAnimal();     // construtor
   virtual void       Sound() = 0;   // fun√ß√£o meramente virtual (pura)
</code></pre>
<p>
private:
</p>
<pre><code class="language-mql5">
   double             m_legs_count;  // n√∫mero de patas do animal
</code></pre>
<p>
  };
Aqui a fun√ß√£o Sound() √© meramente virtual, porque √© declarada com o especificador da fun√ß√£o
meramente virtual PURE (=0).
S√£o fun√ß√µes meramente virtuais apenas aquelas fun√ß√µes virtuais para as quais √© exibido o
especificador de pureza¬†PURE, nomeadamente: (=NULL) ou (=0). Exemplo de declara√ß√£o e utiliza√ß√£o de
uma classe abstrata:
</p>
<pre><code class="language-mql5">
class CAnimal
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   virtual void       Sound()=NULL;   // PURE method, deve ser substitu√≠do no descende
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- descendente a partir da classe abstrata
class CCat : public CAnimal
 {
</code></pre>
<p>
public:
  virtual void        Sound() { Print(&quot;Myau&quot;); } // PURE √© substitu√≠da, classe CCat n√£
 };
</p>
<pre><code class="language-mql5">
//--- exemplos de utiliza√ß√£o incorreta
</code></pre>
<p>
new CAnimal;         // erro &#x27;CAnimal&#x27; - compilador –≤—ã–¥–∞—Å—Ç –æ—à–∏–±–∫—É &quot;n√£o √© poss√≠vel inst
CAnimal some_animal; // –æ—à–∏–±–∫–∞ &#x27;CAnimal&#x27; - –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—ã–¥–∞—Å—Ç –æ—à–∏–±–∫—É &quot;n√£o √© poss√≠vel in
</p>
<pre><code class="language-mql5">
//--- exemplos de utiliza√ß√£o correta
</code></pre>
<p>
new CCat;  // sem erros - a classe CCat n√£o √© abstrata
CCat cat;  // sem erros - a classe CCat n√£o √© abstrata</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
317
Restri√ß√µes sobre o uso de classes abstratas
Quando voc√™ chamar, com o construtor, uma fun√ß√£o virtual pura (direta ou indiretamente), o
resultado ser√° incerto.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Classe b√°sica abstrata                                        |
//+------------------------------------------------------------------+
class CAnimal
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   //--- fun√ß√£o virtual √∫nica
   virtual void      Sound(void)=NULL;
   //--- fun√ß√£o
   void              CallSound(void) { Sound(); }
   //--- construtor
   CAnimal()
    {
     //--- chamada expl√≠cita para um m√©todo virtual
     Sound();
     //--- chamada impl√≠cita (atrav√©s de uma terceira fun√ß√£o)
     CallSound();
     //--- no construtor e/ou destruidor sempre s√£o chamadas suas fun√ß√µes,
     //--- apesar da virtualidade e substitu√≠√ß√£o da fun√ß√£o chamada no descendente
     //--- se a fun√ß√£o chamada for meramente virutal (pura), ent√£o,
     //--- a chamada ir√° resultar no erro de execu√ß√£o: &quot;pure virtual function call&quot;
    }
</code></pre>
<p>
  };
No entanto, os construtores e destruidores de classes abstratas podem chamar outras fun√ß√µes
membro.</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
318
<h3>Espa√ßos de nomes</h3>
O namespace (espa√ßo para nome) √© uma √°rea especialmente declarada dentro da qual s√£o definidos
v√°rios identificadores: vari√°veis, fun√ß√µes, classes, etc. A. √à definido com ajuda da palavra-chave
namespace:
namespace nome_espa√ßo { 
</p>
<pre><code class="language-mql5">
  // lista de defini√ß√µes de fun√ß√µes, de classes e de vari√°veis
}
</code></pre>
<p>
O uso do namespace permite dividir o namespace global em subespa√ßos. Todos os identificadores no
namespace est√£o dispon√≠veis um para o outro sem especifica√ß√£o. Para acessar membros do
namespace de fora, √© usado o operador :: (opera√ß√£o de resolu√ß√£o de contexto).
namespace ProjectData
</p>
<pre><code class="language-mql5">
{
class DataManager
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
   void              LoadData() {}
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
void Func(DataManager&amp; manager) {}
}
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- trabalhando com o namespace ProjectData
   ProjectData::DataManager mgr;
   mgr.LoadData();
   ProjectData::Func(mgr);
</code></pre>
<p>
  }
Os namespace s√£o usados para organizar o c√≥digo como grupos l√≥gicos e para evitar conflitos de
nomes que podem ocorrer quando s√£o usadas v√°rias bibliotecas em um programa. Nesses casos, cada
biblioteca pode ser declarada em seu namespace, para que possa acessar explicitamente as fun√ß√µes e
classes necess√°rias de cada biblioteca.
Um namespace pode ser declarado em v√°rios blocos em um ou em v√°rios arquivos. O compilador re√∫ne
todas as partes durante o pr√©-processamento e namespace resultante cont√©m todos os membros
declarados em todas as partes. Suponhamos que implementemos a classe A no arquivo inclu√≠do
<h3>Sample.mqh:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                       Sample.mqh |
//+------------------------------------------------------------------+
class A
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     A() {Print(__FUNCTION__);}</p>
<p></code></pre>
<p>
<h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
319
  };
Queremos usar essa classe em nosso projeto, mas j√° temos a classe A. Para poder usar as duas
classes e evitar conflitos de identidade, basta agrupar o arquivo inclu√≠do em um namespace:
</p>
<pre><code class="language-mql5">
//--- declaramos a primeira classe A
class A
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     A() {Print(__FUNCTION__);}
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
//--- embrulhamos a classe A do arquivo &quot;Sample.mqh&quot; no namespace &quot;Library&quot; para evita
</code></pre>
<p>
namespace Library
</p>
<pre><code class="language-mql5">
{
#include &quot;Sample.mqh&quot;
}
//--- adicionamos outra classe ao namespace &quot;Library&quot;
</code></pre>
<p>
namespace Library
</p>
<pre><code class="language-mql5">
{
class B
  {
</code></pre>
<p>
public:
</p>
<pre><code class="language-mql5">
                     B() {Print(__FUNCTION__);}
</code></pre>
<p>
  };
</p>
<pre><code class="language-mql5">
}
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- usamos a classe A do namespace global
   A a1;
//--- usamos as classes A e B do namespace &quot;Library&quot;
   Library::A a2;
   Library::B b;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
/*
</code></pre>
<p>
<h3>Resultado:</h3>
</p>
<pre><code class="language-mql5">
   A::A
   Library::A::A
   Library::B::B
</code></pre>
<p>
*/
Os namespace podem ser aninhados. Um namespace aninhado tem acesso ilimitado aos membros do
seu espa√ßo pai, mas os membros do espa√ßo pai n√£o t√™m acesso ilimitado ao espa√ßo para nome
aninhado.
namespace General</p>
<p><h3>Elementos B√°sicos da Linguagem</h3>
¬© 2000-2025, MetaQuotes Ltd.
320
</p>
<pre><code class="language-mql5">
{
int Func();
</code></pre>
<p>
namespace Details
</p>
<pre><code class="language-mql5">
{
</code></pre>
<p>
 int Counter;
 int Refresh()  {return Func(); }
</p>
<pre><code class="language-mql5">
}
int GetBars()   {return(iBars(Symbol(), Period()));};
int Size(int i) {return Details::Counter;}
}
</code></pre>
<p>
<h3>Namespace global</h3>
Se o identificador n√£o for declarado explicitamente no namespace, ele √© implicitamente considerado
parte do namespace global. Para especificar explicitamente um identificador global, use operador de
escopo de resolu√ß√£o sem nome. Isso permite distinguir esse identificador de qualquer outro elemento
com o mesmo nome localizado em um namespace diferente. Por exemplo, ao importar uma fun√ß√£o:
#import &quot;lib.dll&quot;
</p>
<pre><code class="language-mql5">
int Func();
</code></pre>
<p>
#import
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Alguma das nossas fun√ß√µes                                              |
//+------------------------------------------------------------------+
int Func()
  {
   return(0);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//+--- chamada de fun√ß√£o impotada
   Print(lib::Func());
//+--- chamada de nossa fun√ß√£o
   Print(::Func());
</code></pre>
<p>
  }
Nesse caso, todas as fun√ß√µes importadas da DLL s√£o inclu√≠das no namespace com o mesmo nome. Isso
permite que o compilador determine exclusivamente qual fun√ß√£o chamar.
<h3>V√©ase tambi√©n</h3>
Vari√°veis Globais, Vari√°veis Locais, Visibilidade Escopo e Tempo de Vida de Vari√°veis, Cria√ß√£o e
<h3>Exclus√£o de Objetos</h3>
</p>
        </article>
        
        <footer>
            <p>Documenta√ß√£o MQL5 - Fonte: MetaQuotes Ltd.</p>
        </footer>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function toggleSidebar() {
            document.querySelector('.sidebar').classList.toggle('open');
        }
        
        function filterNav() {
            const filter = document.getElementById('search').value.toLowerCase();
            const items = document.querySelectorAll('.nav-list li');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }
    </script>
</body>
</html>