<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modelos ONNX - MQL5 Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>MQL5 Docs</h1>
            <p>Documenta√ß√£o Completa</p>
        </div>
        <div class="search-box">
            <input type="text" id="search" placeholder="Buscar..." onkeyup="filterNav()">
        </div>
        <ul class="nav-list" id="nav-list">
            <li class=""><a href="index.html">üìö √çndice</a></li>
            <li class=""><a href="introducao.html">Introducao</a></li>
<li class=""><a href="refer√™ncia_mql5.html">Refer√™ncia MQL5</a></li>
<li class=""><a href="elementos_b√°sicos_da_linguagem.html">Elementos B√°sicos da Linguagem</a></li>
<li class=""><a href="constantes,_enumeradores_e_estruturas.html">Constantes, Enumeradores e Estruturas</a></li>
<li class=""><a href="programas_mql5.html">Programas MQL5</a></li>
<li class=""><a href="vari√°veis_predefinidas.html">Vari√°veis Predefinidas</a></li>
<li class=""><a href="fun√ß√µes_comuns.html">Fun√ß√µes Comuns</a></li>
<li class=""><a href="fun√ß√µes_para_array.html">Fun√ß√µes para Array</a></li>
<li class=""><a href="m√©todos_matriciais_e_vetoriais.html">M√©todos matriciais e vetoriais</a></li>
<li class=""><a href="fun√ß√µes_de_convers√£o.html">Fun√ß√µes de Convers√£o</a></li>
<li class=""><a href="fun√ß√µes_matem√°ticas.html">Fun√ß√µes Matem√°ticas</a></li>
<li class=""><a href="fun√ß√µes_de_string.html">Fun√ß√µes de String</a></li>
<li class=""><a href="data_e_hora.html">Data e Hora</a></li>
<li class=""><a href="informa√ß√µes_de_conta.html">Informa√ß√µes de Conta</a></li>
<li class=""><a href="verificando_estado.html">Verificando Estado</a></li>
<li class=""><a href="manipula√ß√£o_de_eventos.html">Manipula√ß√£o de eventos</a></li>
<li class=""><a href="informa√ß√µes_de_mercado.html">Informa√ß√µes de Mercado</a></li>
<li class=""><a href="calend√°rio_econ√¥mico.html">Calend√°rio econ√¥mico</a></li>
<li class=""><a href="s√©ries_temporais_e_acesso_a_indicadores.html">S√©ries Temporais e Acesso a Indicadores</a></li>
<li class=""><a href="s√≠mbolos_personalizados.html">S√≠mbolos personalizados</a></li>
<li class=""><a href="opera√ß√µes_de_gr√°ficos.html">Opera√ß√µes de Gr√°ficos</a></li>
<li class=""><a href="fun√ß√µes_de_negocia√ß√£o.html">Fun√ß√µes de Negocia√ß√£o</a></li>
<li class=""><a href="gerenciamento_de_sinais.html">Gerenciamento de sinais</a></li>
<li class=""><a href="fun√ß√µes_de_rede.html">Fun√ß√µes de rede</a></li>
<li class=""><a href="vari√°veis_globais_do_terminal.html">Vari√°veis Globais do Terminal</a></li>
<li class=""><a href="fun√ß√µes_de_arquivo.html">Fun√ß√µes de Arquivo</a></li>
<li class=""><a href="indicadores_customizados.html">Indicadores Customizados</a></li>
<li class=""><a href="fun√ß√µes_de_objeto.html">Fun√ß√µes de Objeto</a></li>
<li class=""><a href="indicadores_t√©cnicos.html">Indicadores T√©cnicos</a></li>
<li class=""><a href="trabalhando_com_resultados_de_otimiza√ß√£o.html">Trabalhando com Resultados de Otimiza√ß√£o</a></li>
<li class=""><a href="trabalhando_com_eventos.html">Trabalhando com Eventos</a></li>
<li class=""><a href="trabalhando_com_opencl.html">Trabalhando com OpenCL</a></li>
<li class=""><a href="trabalhar_com_bancos_de_dados.html">Trabalhar com bancos de dados</a></li>
<li class=""><a href="trabalho_com_directx.html">Trabalho com DirectX</a></li>
<li class=""><a href="metatrader_para_python.html">MetaTrader para Python</a></li>
<li class="active"><a href="modelos_onnx.html">Modelos ONNX</a></li>
<li class=""><a href="biblioteca_padr√£o.html">Biblioteca Padr√£o</a></li>
<li class=""><a href="migrando_do_mql4.html">Migrando do MQL4</a></li>
<li class=""><a href="lista_de_fun√ß√µes_mql5.html">Lista de Fun√ß√µes MQL5</a></li>
<li class=""><a href="lista_de_constantes_mql5.html">Lista de Constantes MQL5</a></li>

        </ul>
    </nav>
    
    <main class="content">
        <header>
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1>Modelos ONNX</h1>
        </header>
        
        <article>
            <p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3234
<h3>Modelos ONNX em aprendizado de m√°quina</h3>
O ONNX (Open Neural Network Exchange) √© uma biblioteca aberta para a cria√ß√£o de redes neurais de
aprendizagem profunda. Este projeto tem v√°rias vantagens importantes:
¬∑ Suporte a ONNX que √© oferecido por grandes empresas, como Microsoft, Facebook, Amazon e outros
parceiros.
¬∑ O formato aberto permite a implementa√ß√£o de convers√£o de formatos entre diferentes ferramentas
de aprendizado de m√°quina,  ONNXMLTools da Microsoft oferece a possibilidade de converter
modelos no formato ONNX.
¬∑ MQL5 oferece autoconvers√£o de dados de entrada e sa√≠da do modelo se o tipo de par√¢metro passado
n√£o corresponder ao modelo.
¬∑ Cria√ß√£o de modelos ONNX que pode ser realizada com muitas ferramentas de aprendizado de
m√°quina, atualmente suportadas pelo Caffe2, Microsoft Cognitive Toolkit, MXNet, PyTorch e
OpenCV; tamb√©m h√° interfaces para muitas outras estruturas e bibliotecas populares. 
¬∑ A linguagem MQL5 possibilita implementar o modelo ONNX em uma estrat√©gia de negocia√ß√£o e tirar
o m√°ximo proveito da plataforma MetaTrader 5 para trabalhar nos mercados financeiros de maneira
eficiente.
¬∑ Antes de executar o modelo na negocia√ß√£o real, voc√™ pode verificar o modelo em rela√ß√£o aos dados
hist√≥ricos no testador de estrat√©gias sem o uso de ferramentas de terceiros.
As seguintes fun√ß√µes s√£o disponibilizadas na MQL5 para trabalhar com o ONNX:
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>OnnxCreate</h3>
Cria uma sess√£o ONNX com carregamento de modelo a partir de um
arquivo *.onnx
<h3>OnnxCreateFromBuffer</h3>
Cria uma sess√£o ONNX com carregamento de modelo a partir de uma
matriz de dados
<h3>OnnxRelease</h3>
<h3>Exclus√£o de sess√£o ONNX</h3>
<h3>OnnxRun</h3>
<h3>Execu√ß√£o do modelo ONNX</h3>
<h3>OnnxGetInputCount</h3>
Obten√ß√£o do n√∫mero de par√¢metros de entrada do modelo ONNX
<h3>OnnxGetOutputCount</h3>
Obten√ß√£o do n√∫mero de par√¢metros de sa√≠da do modelo ONNX
<h3>OnnxGetInputName</h3>
Obten√ß√£o do nome do par√¢metro de entrada do modelo por √≠ndice
<h3>OnnxGetOutputName</h3>
Obten√ß√£o do nome do par√¢metro de sa√≠da do modelo por √≠ndice
<h3>OnnxGetInputTypeInfo</h3>
Obten√ß√£o de uma descri√ß√£o do tipo de par√¢metro de entrada do
modelo
<h3>OnnxGetOutputTypeInfo</h3>
Obten√ß√£o de uma descri√ß√£o do tipo de par√¢metro de sa√≠da do modelo
<h3>OnnxSetInputShape</h3>
Define a dimensionalidade dos dados de entrada do modelo por √≠ndice
<h3>OnnxSetOutputShape</h3>
Define a dimensionalidade dos dados de sa√≠da do modelo por √≠ndice</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3235
<h3>Suporte a ONNX em MQL5</h3>
ONNX √© um formato aberto criado para representar modelos de aprendizado de m√°quina. Esse padr√£o
define um conjunto comum de operadores e formatos de arquivo que permite que os desenvolvedores
usem os modelos em diferentes plataformas e ambientes de execu√ß√£o, com diferentes ferramentas e
compiladores.
Esse formato aberto ONNX permite obter e mover modelos de aprendizado de m√°quina entre
diferentes plataformas e ferramentas de aprendizado de m√°quina. √â por isso que o suporte a ONNX foi
adicionado √† linguagem MQL5, assim os desenvolvedores de IA podem executar modelos criados em
um ambiente de execu√ß√£o de alto desempenho na plataforma MetaTrader 5. 
A linguagem MQL5 √© t√£o r√°pida quanto os aplicativos desenvolvidos em C++. Os resultados da
execu√ß√£o de testes padr√£o em MQL5 e C++ confirmam esse fato. Quanto menor a coluna, menos
tempo √© gasto para a execu√ß√£o, melhor o resultado (tempo em milissegundos). Testes realizados no
Windows 10 (build 17763) x64, Xeon E5-2630 v4 @ 2.20GHz, Mem√≥ria: 65457 Mb.
Com as novas opera√ß√µes de negocia√ß√£o ass√≠ncronas e o suporte nativo ao ONNX, surgem novas
possibilidades que antes estavam dispon√≠veis apenas para profissionais selecionados e operadores
institucionais. O suporte a ONNX em MQL5 permite que os operadores treinem modelos para mercados
financeiros em seu ambiente de desenvolvimento preferido e, por sua vez, negociem com baixos
custos de rede, com uma alta taxa de atualiza√ß√£o de cota√ß√µes e com o envio ass√≠ncrono de ordens.
Atualmente, o ONNX est√° sendo desenvolvido e suportado em conjunto pela Microsoft, Facebook,
Amazon e outros parceiros, garantindo o desenvolvimento desse projeto de c√≥digo aberto.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3236</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3237
<h3>Convers√£o de formatos</h3>
O formato ONNX √© aberto, permitindo que modelos de v√°rias ferramentas de aprendizado de m√°quina
sejam armazenados nele. Esse formato √© suportado por muitas plataformas, incluindo Chainer,
Caffee2 e PyTorch. 
Uma das ferramentas mais populares para converter modelos no formato ONNX √© o¬†ONNXMLTools
desenvolvida pela Microsoft.
As instru√ß√µes para instalar e usar o ONNXMLTools est√£o dispon√≠veis no GitHub. Atualmente, h√°
suporte para os seguintes pacotes de ferramentas:
¬∑  Keras (shell do conversor keras2onnx)
¬∑ Tensorflow (shell do conversor tf2onnx)
¬∑ scikit-learn (shell do conversor skl2onnx)
¬∑ Apple Core ML
¬∑ Spark ML (modo experimental)
¬∑ LightGBM
¬∑ libscm;
¬∑ XGBoost;
¬∑ H2O
¬∑ CatBoost
A instala√ß√£o do ONNXMLTools √© simples e est√° descrita 
na 
p√°gina 
do 
projeto 
em
https://github.com/onnx/onnxmltools#install, onde h√° tamb√©m alguns exemplos de convers√£o de
modelos.onde h√° tamb√©m alguns exemplos de convers√µes de modelos</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3238
Autoconvers√£o de valores de entrada e sa√≠da ao executar
modelos ONNX
Na vers√£o atual do ONNX em MQL5 como valores do tipo input/output s√£o suportados apenas tensores,
que s√£o matrizes de dados com um dos seguintes tipos de elementos:
<h3>Tipo ONNX</h3>
<h3>Em conformidade com o tipo MQL5</h3>
<h3>ONNX_DATA_TYPE_BOOL</h3>
bool
<h3>ONNX_DATA_TYPE_FLOAT</h3>
float
<h3>ONNX_DATA_TYPE_UINT8</h3>
uchar
<h3>ONNX_DATA_TYPE_INT8</h3>
char
<h3>ONNX_DATA_TYPE_UINT16</h3>
ushort
<h3>ONNX_DATA_TYPE_INT16</h3>
short
<h3>ONNX_DATA_TYPE_INT32</h3>
int
<h3>ONNX_DATA_TYPE_INT64</h3>
long
<h3>ONNX_DATA_TYPE_FLOAT16</h3>
‚Äî
<h3>ONNX_DATA_TYPE_DOUBLE</h3>
double
<h3>ONNX_DATA_TYPE_UINT32</h3>
uint
<h3>ONNX_DATA_TYPE_UINT64</h3>
ulong
<h3>ONNX_DATA_TYPE_COMPLEX64</h3>
‚Äî
<h3>ONNX_DATA_TYPE_COMPLEX128</h3>
complex
<h3>ONNX_DATA_TYPE_BFLOAT16</h3>
‚Äî
<h3>ONNX_DATA_TYPE_STRING</h3>
‚Äî
Como valores do tipo input/output no modelo ONNX s√≥ √© poss√≠vel transferir matrizes, vetores ou
matrizes (Dados). 
Se o tipo de par√¢metro passado n√£o corresponder ao tipo de par√¢metro do modelo ONNX e se o
sinalizador OnnxRun n√£o for especificado ao chamar ONNX_NO_CONVERSION, ser√° usada a
autoconvers√£o. A autoconvers√£o implica que, antes de executar o modelo ONNX, os dados do usu√°rio
Dadosser√£o copiados para os sensores ONNX com convers√£o.
Ao executar um modelo ONNX sem autoconvers√£o, o modelo ONNX √© calculado em Dados sem nenhuma
c√≥pia adicional.
ADVERT√äNCIA!A autoconvers√£o n√£o controla o truncamento, portanto, deve-se tomar cuidado com
os dados e tipos de dados que s√£o passados para o modelo ONNX.
A autoconvers√£o √© compat√≠vel com os seguintes tipos de ONNX:</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3239
¬∑ ONNX_DATA_TYPE_BOOL
¬∑ ONNX_DATA_TYPE_FLOAT
¬∑ ONNX_DATA_TYPE_UINT8
¬∑ ONNX_DATA_TYPE_INT8
¬∑ ONNX_DATA_TYPE_UINT16
¬∑ ONNX_DATA_TYPE_INT16
¬∑ ONNX_DATA_TYPE_INT32
¬∑ ONNX_DATA_TYPE_INT64
¬∑ ONNX_DATA_TYPE_FLOAT16
¬∑ ONNX_DATA_TYPE_DOUBLE
¬∑ ONNX_DATA_TYPE_UINT32
¬∑ ONNX_DATA_TYPE_UINT64
¬∑ ONNX_DATA_TYPE_COMPLEX64
¬∑ ONNX_DATA_TYPE_COMPLEX128
<h3>Tipos n√£o suportados:</h3>
¬∑ ONNX_DATA_TYPE_BFLOAT16
¬∑ ONNX_DATA_TYPE_STRING
Regras de autoconvers√£o por tipos de tensor
Se o tipo MQL5 n√£o estiver entre os tipos suportados pelo modelo, o modelo ONNX ser√° encerrado com
o erro ERR_ONNX_NOT_SUPPORTED (c√≥digo de erro 5802).
 Nota: durante a autoconvers√£o, o tipo color √© processado como uint e o tipo datetime √© processado
como long.
<h3>Autoconvers√£o de valores input</h3>
<h3>Tipo ONNX (tipo de elemento tensor)</h3>
<h3>Tipo MQL5, suportado pela autoconvers√£o</h3>
<h3>ONNX_DATA_TYPE_BOOL</h3>
bool, char, uchar, short, ushort, int, color, uint,
datetime, long, folat, double, complex
Ao converter elementos de Dados √© verificado
por uma compara√ß√£o simples de zero a zero.
<h3>ONNX_DATA_TYPE_FLOAT16</h3>
float, double
<h3>ONNX_DATA_TYPE_FLOAT</h3>
char, uchar, short, ushort, int, color, uint,
datetime, long, ulong, float, double
<h3>ONNX_DATA_TYPE_UINT8</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT8</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3240
<h3>Tipo ONNX (tipo de elemento tensor)</h3>
<h3>Tipo MQL5, suportado pela autoconvers√£o</h3>
<h3>ONNX_DATA_TYPE_UINT16</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT16</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT32</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT64</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_DOUBLE</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_UINT32</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_UINT64</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_COMPLEX64</h3>
complex
<h3>ONNX_DATA_TYPE_COMPLEX128</h3>
complex
<h3>Autoconvers√£o de valores output</h3>
<h3>Tipo ONNX (tipo de elemento tensor)</h3>
<h3>Tipo MQL5, suportado pela autoconvers√£o</h3>
<h3>ONNX_DATA_TYPE_BOOL</h3>
bool, char, uchar, short, ushort, int, color, uint,
datetime, long, folat, double, complex
Se um elemento do tensor for zero, o elemento
Dados ser√° definido como 0; caso contr√°rio,
ser√° definido como 1.
<h3>ONNX_DATA_TYPE_FLOAT16</h3>
float, double
<h3>ONNX_DATA_TYPE_FLOAT</h3>
char, uchar, short, ushort, int, color, uint,
datetime, long, ulong, float, double
<h3>ONNX_DATA_TYPE_UINT8</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT8</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_UINT16</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT16</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT32</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_INT64</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_DOUBLE</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_UINT32</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_UINT64</h3>
<h3>Veja. ONNX_DATA_TYPE_FLOAT</h3>
<h3>ONNX_DATA_TYPE_COMPLEX64</h3>
complex
<h3>ONNX_DATA_TYPE_COMPLEX128</h3>
complex</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3241
<h3>Veja tamb√©m</h3>
<h3>Coer√ß√£o de tipos</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3242
<h3>Cria√ß√£o de modelo</h3>
Existem v√°rias maneiras de obter um modelo ONNX pronto para uso. Uma biblioteca reconhecida √© a
ONNX Model Zoo, que cont√©m v√°rios modelos ONNX pr√©-treinados para diferentes tipos de tarefas. A
vantagem dessa cole√ß√£o √© que o notebook de cada modelo cont√©m refer√™ncias ao conjunto de dados de
treinamento, bem como links para o documento cient√≠fico original que descreve a arquitetura do
modelo. 
A maioria das plataformas de aprendizado de m√°quina usa Python. Para instalar o ambiente de
execu√ß√£o do ONNX para Python, use um dos seguintes comandos:
pip install onnxruntime       # CPU build
pip install onnxruntime-gpu   # GPU build
Para chamar o ambiente de execu√ß√£o do ONNX em Python, use o seguinte comando
import onnxruntime
session = onnxruntime.InferenceSession(&quot;path to model&quot;)
Os dados de entrada e sa√≠da para usar o modelo devem ser vistos na documenta√ß√£o do modelo
correspondente. Ferramentas de visualiza√ß√£o como Netron ou WinML Dashboard tamb√©m podem ser
usadas para visualizar o modelo. O ambiente de execu√ß√£o do ONNX tamb√©m permite consultar os
metadados do modelo e seus dados de entrada e sa√≠da:.
results = session.run([&quot;output1&quot;, &quot;output2&quot;], {
</p>
<pre><code class="language-mql5">
                      &quot;input1&quot;: indata1, &quot;input2&quot;: indata2})
</code></pre>
<p>
results = session.run([], {&quot;input1&quot;: indata1, &quot;input2&quot;: indata2})
Voc√™ pode criar modelos ONNX diretamente no terminal MetaTrader 5 ou no ambiente de
desenvolvimento MetaEditor em Python.
<h3>Python no MetaTrader 5</h3>
A plataforma MetaTrader 5 suporta o trabalho com scripts Python assim que retirados da embalagem.
Para isso, os desenvolvedores do terminal disponibilizam o m√≥dulo MetaTrader 5 para Python -
https://pypi.org/project/MetaTrader5.
O ambiente de desenvolvimento integrado MetaEditor permite n√£o apenas escrever aplicativos em
MQL5, mas tamb√©m executar scripts Python diretamente do editor. Para fazer isso, especifique o
caminho para o arquivo execut√°vel nas configura√ß√µes do MetaEditor:.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3243
Se voc√™ n√£o tiver o Python em seu computador, clique em &quot;Instalar&quot; para baixar o arquivo de
instala√ß√£o.
Voc√™ pode criar um script Python no MetaEdtior ou carreg√°-lo na pasta de dados do terminal e execut√°-
lo imediatamente pressionando F7 (&quot;Compilar&quot;). Depois disso, o terminal MetaTrader 5 ser√° aberto e o
script ser√° rodado no gr√°fico atual. As mensagens do console Python (stdout, stderr) ser√£o exibidas na
se√ß√£o &quot;Error&quot;.
Como trabalhar com modelos no MetaTrader 5
A linguagem MQL5 permite que voc√™ execute modelos ONNX diretamente no terminal MetaTrader 5.
Isso pode ser feito em tr√™s etapas:
1. Treinar um modelo em uma plataforma de terceiros, por exemplo, em Python.
2. Convers√£o do modelo no ONNX
3. Incorpore o modelo ONNX no EA usando fun√ß√µes ONNX e execute no terminal do MetaTrader 5.
Integra√ß√£o Python da linguagem MQL5 permite executar um script python e salvar o modelo ONNX no
MetaEditor ou at√© mesmo execut√°-lo em um gr√°fico no MetaTrader 5. Voc√™ pode treinar seu modelo
usando um script escrito em Python com a frequ√™ncia desejada diretamente no terminal. Como a
biblioteca cont√©m fun√ß√µes prontas incorporadas para obter dados de pre√ßos com os quais voc√™ pode
alimentar o modelo ONNX:
¬∑ copy_rates_from - recebe barras a partir de uma determinada data;
¬∑ copy_rates_from_pos - recebe barras a partir de um determinado √≠ndice;
¬∑ copy_rates_range - recebe barras no intervalo de datas especificado;
¬∑ copy_ticks_from - recebe ticks a partir de uma determinada data;
¬∑ copy_ticks_range - recebe ticks referentes ao intervalo de datas especificado.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3244
Exemplo de um modelo pronto para uso
Voc√™ pode encontrar esse exemplo de modelo ONNX pronto em projetos p√∫blicos. Para fazer isso,
primeiro ative o MQL5 Storage no Navegador, especificando seu login MQL5 nas configura√ß√µes do
MetaEditor, diferenciando mai√∫sculas de min√∫sculas.
Ap√≥s a ativa√ß√£o, localize o projeto ONNX.Price.Prediction e acesse-o por meio do comando do menu de
contexto.
Em seguida, atualize o projeto a partir do MQL5 Storage.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3245
Depois disso, o projeto estar√° dispon√≠vel, voc√™ encontrar√° nele um modelo ONNX pronto, dois scripts
python, 
um 
script 
<h3>MQL5</h3>
para 
rodar 
o 
projeto 
e 
o 
arquivo 
de 
projeto 
<h3>MQL5</h3>
(ONNX.Price.Prediction.mqproj).</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3246
Voc√™ mesmo pode criar um modelo ONNX usando o script PricePredictionTraining.py inclu√≠do no
projeto. Para fazer isso, primeiro instale os m√≥dulos necess√°rios a partir da linha de comando em seu
computador.
python.exe -m pip install --upgrade pip
python -m pip install --upgrade tensorflow
python -m pip install --upgrade pandas
python -m pip install --upgrade scikit-learn
python -m pip install --upgrade matplotlib
python -m pip install --upgrade tqdm
python -m pip install --upgrade metatrader5
python -m pip install --upgrade onnx==1.12
python -m pip install --upgrade tf2onnx
python -m pip install --upgrade numpy
python -m pip install onnxruntime
Depois de instalar os m√≥dulos, abra o script PricePredictionTraining.py no MetaEditor e execute-o
pressionando o bot√£o &quot;Compile&quot; ou a tecla F7.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3247
Antes de executar o script python, confira se seu terminal MetaTrader 5 est√° conectado ao servidor
com o s√≠mbolo EURUSD. Por exemplo, conecte-se ao servidor MetaQuotes-Demo e verifique a caixa de
sele√ß√£o &quot;Integra√ß√£o com Python&quot; nas configura√ß√µes do terminal.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3248
Durante o treinamento da rede, o MetaEditor exibir√° mensagens do script Python at√© que o
treinamento seja conclu√≠do.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3249
Quando o resultado for 100%, o modelo ONNX estar√° pronto e ser√° salvo na pasta do projeto &lt;pasta de
dados do terminal&gt;\MQL5\Shared Projects\ONNX.Price.Prediction\Python.
Verifique o modelo resultante executando o segundo script PricePrediction.py clicando em F7.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3250
<h3>Inicializa√ß√£o do modelo</h3>
Para utilizar o modelo ONNX em MQL5, √© necess√°rio seguir tr√™s etapas:
1. Carreg√°-lo a partir do arquivo *.onnx usando a fun√ß√£o OnnxCreate ou a partir de um array usando
OnnxCreateFromBuffer.
2. Especificar a forma dos dados de entrada e sa√≠da por meio das fun√ß√µes OnnxSetInputShape e
OnnxSetOutputShape.
3. Iniciar o modelo usando OnnxRun, ap√≥s lhe dar par√¢metros de entrada e sa√≠da.
4. Encerrar o modelo, se necess√°rio, com OnnxRelease.
Ao criar o modelo ONNX, √© necess√°rio considerar os limites e restri√ß√µes existentes descritos em
https://github.com/microsoft/onnxruntime/blob/rel-1.14.0/docs/OperatorKernels.md
<h3>Por exemplo, aqui est√£o algumas delas:</h3>
<h3>Opera√ß√£o</h3>
<h3>Tipos de dados suportados</h3>
<h3>ReduceSum</h3>
tensor(double), tensor(float), tensor(int32), tensor(int64)
<h3>Mul</h3>
tensor(bfloat16), 
tensor(double), 
tensor(float), 
tensor(float16),
tensor(int32), tensor(int64), tensor(uint32), tensor(uint64)
Veja abaixo um exemplo de c√≥digo MQL5 extra√≠do do projeto p√∫blico ONNX.Price.Prediction. 
const long   ExtOutputShape[] = {1,1};    // forma dos dados de sa√≠da do modelo
const long   ExtInputShape [] = {1,10,4}; // forma dos dados de entrada do modelo
#resource &quot;Python/model.onnx&quot; as uchar ExtModel[]// modelo em forma de recurso
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
int OnStart(void)
  {
   matrix rates;
//--- obtemos 10 barras
   if(!rates.CopyRates(&quot;EURUSD&quot;,PERIOD_H1,COPY_RATES_OHLC,2,10))
      return(-1);
//--- alimentamos com um conjunto de vetores OHLC
   matrix x_norm=rates.Transpose();
   vector m=x_norm.Mean(0);               
   vector s=x_norm.Std(0);
   matrix mm(10,4);
   matrix ms(10,4);
//--- preenchemos matrizes de normaliza√ß√£o
   for(int i=0; i&lt;10; i++)
     {
      mm.Row(m,i);
      ms.Row(s,i);
     }</p>
<p></code></pre>
<p>
<h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3251
</p>
<pre><code class="language-mql5">
//--- normalizamos os dados de entrada
   x_norm-=mm;
   x_norm/=ms;
//--- criamos o modelo
   long handle=OnnxCreateFromBuffer(ExtModel,ONNX_DEBUG_LOGS);
//--- especificamos a forma dos dados de entrada
   if(!OnnxSetInputShape(handle,0,ExtInputShape))
     {
      Print(&quot;OnnxSetInputShape failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- especificamos a forma dos dados de sa√≠da
   if(!OnnxSetOutputShape(handle,0,ExtOutputShape))
     {
      Print(&quot;OnnxSetOutputShape failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- convertemos dados de entrada normalizados em dados do tipo float
   matrixf x_normf;
   x_normf.Assign(x_norm);
//--- obtemos o resultado do modelo - a previs√£o de pre√ßo
   vectorf y_norm(1);
//--- iniciamos o modelo
   if(!OnnxRun(handle,ONNX_DEBUG_LOGS | ONNX_NO_CONVERSION,x_normf,y_norm))
     {
      Print(&quot;OnnxRun failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- registramos no log o valor de sa√≠da do modelo
   Print(y_norm);
//--- realizamos uma transforma√ß√£o inversa para obter o pre√ßo previsto
   double y_pred=y_norm[0]*s[3]+m[3];
   Print(&quot;price predicted:&quot;,y_pred);
//--- conclu√≠mos o trabalho
   OnnxRelease(handle);
   return(0);
</code></pre>
<p>
  }
Veja um exemplo de execu√ß√£o do script:
ONNX: Creating and using per session threadpools since use_per_session_threads_ is tru
ONNX: Dynamic block base set to 0
ONNX: Initializing session.
ONNX: Adding default CPU execution provider.
ONNX: Total shared scalar initializer count: 0
ONNX: Total fused reshape node count: 0</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3252
ONNX: Total shared scalar initializer count: 0
ONNX: Total fused reshape node count: 0
<h3>ONNX: Use DeviceBasedPartition as default</h3>
ONNX: Saving initialized tensors.
<h3>ONNX: Done saving initialized tensors</h3>
ONNX: Session successfully initialized.
[0.28188983]
predicted 1.0559258806393044
O terminal MetaTrader 5 seleciona de forma independente o melhor executor para os c√°lculos ‚Äî  ONNX
Runtime Execution Provider. Neste caso, o modelo realiza seu trabalho usando a CPU.
Vamos modificar o script para calcular a porcentagem de previs√µes bem-sucedidas do pre√ßo de
fechamento com base nos valores das 10 barras anteriores.
#resource &quot;Python/model.onnx&quot; as uchar ExtModel[]// modelo em forma de recurso
</p>
<pre><code class="language-mql5">
#define TESTS 10000  // n√∫mero de amostras de teste
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
int OnStart()
  {
//--- criamos o modelo
   long session_handle=OnnxCreateFromBuffer(ExtModel,ONNX_DEBUG_LOGS);
   if(session_handle==INVALID_HANDLE)
     {
      Print(&quot;Cannot create model. Error &quot;,GetLastError());
      return(-1);
     }
//--- como o modelo n√£o tem dimens√µes de tensor de entrada definidas, devemos defini-l
//--- o primeiro √≠ndice √© o tamanho do pacote; o segundo √≠ndice, tamanho da s√©rie; o t
   const long input_shape[]={1,10,4};
   if(!OnnxSetInputShape(session_handle,0,input_shape))
     {
      Print(&quot;OnnxSetInputShape error &quot;,GetLastError());
      return(-2);
     }
//--- como o modelo n√£o tem dimens√µes de tensor de sa√≠da definidas, devemos defini-las
//--- o primeiro √≠ndice √© o tamanho do lote, que deve corresponder ao tamanho do lote 
//--- o segundo √≠ndice √© o n√∫mero de pre√ßos previstos (prevemos apenas o Close)
   const long output_shape[]={1,1};
   if(!OnnxSetOutputShape(session_handle,0,output_shape))
     {
      Print(&quot;OnnxSetOutputShape error &quot;,GetLastError());
      return(-3);
     }
//--- iniciamos os testes</p>
<p></code></pre>
<p>
<h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3253
</p>
<pre><code class="language-mql5">
   vector closes(TESTS);      // vetor para armazenar pre√ßos de verifica√ß√£o
   vector predicts(TESTS);    // vetor para armazenar as previs√µes resultantes
   vector prev_closes(TESTS); // vetor para armazenar os pen√∫ltimos pre√ßos
   matrix rates;              // matriz para obter uma s√©rie OHLC
   matrix splitted[2];        // duas submatrizes para dividir a s√©rie em uma de teste
   ulong  parts[]={10,1};     // dimens√µes dos subarrays separ√°veis
//--- come√ßamos a partir da barra anterior
   for(int i=1; i&lt;=TESTS; i++)
     {
      //--- obtemos 11 barras
      rates.CopyRates(&quot;EURUSD&quot;,PERIOD_H1,COPY_RATES_OHLC,i,11);
      //--- dividimos a matriz em uma de teste e outra de verifica√ß√£o
      rates.Vsplit(parts,splitted);
      //--- pegamos o pre√ßo Close a partir da matriz de verifica√ß√£o
      closes[i-1]=splitted[1][3][0];
      //--- √∫ltimo Close na s√©rie de teste
      prev_closes[i-1]=splitted[0][3][9];
      //--- enviamos ao teste uma matriz de teste de 10 barras
      predicts[i-1]=PricePredictionTest(session_handle,splitted[0]);
      //--- erro de execu√ß√£o
      if(predicts[i-1]&lt;=0)
        {
         OnnxRelease(session_handle);
         return(-4);
        }
     }
//--- conclu√≠mos o trabalho
   OnnxRelease(session_handle);
//--- avaliamos se o movimento de pre√ßo previsto est√° correto
   int    right_directions=0;
   vector delta_predicts=prev_closes-predicts;
   vector delta_actuals=prev_closes-closes;
   for(int i=0; i&lt;TESTS; i++)
      if((delta_predicts[i]&gt;0 &amp;&amp; delta_actuals[i]&gt;0) || (delta_predicts[i]&lt;0 &amp;&amp; delta_
         right_directions++;
   PrintFormat(&quot;right direction predictions = %.2f%%&quot;,(right_directions*100.0)/double
//--- 
   return(0);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Preparando os dados e utilizando o modelo                       |
//+------------------------------------------------------------------+
double PricePredictionTest(const long session_handle,matrix&amp; rates)
  {
   static matrixf input_data(10,4); // matriz para dados de entrada transformados</p>
<p></code></pre>
<p>
<h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3254
</p>
<pre><code class="language-mql5">
   static vectorf output_data(1);   // vetor para obter o resultado
   static matrix mm(10,4);          // matriz de vetores horizontais Mean
   static matrix ms(10,4);          // matriz de vetores horizontais Std
//--- o modelo deve ser alimentado com um conjunto de vetores OHLC verticais
   matrix x_norm=rates.Transpose();
//--- normalizamos os pre√ßos
   vector m=x_norm.Mean(0);
   vector s=x_norm.Std(0);
   for(int i=0; i&lt;10; i++)
     {
      mm.Row(m,i);
      ms.Row(s,i);
     }
   x_norm-=mm;
   x_norm/=ms;
//--- iniciamos o modelo
   input_data.Assign(x_norm);
   if(!OnnxRun(session_handle,ONNX_DEBUG_LOGS,input_data,output_data))
     {
      Print(&quot;OnnxRun error &quot;,GetLastError());
      return(0);
     }
//--- revertemos a normaliza√ß√£o do pre√ßo a partir do valor de sa√≠da
   double y_pred=output_data[0]*s[3]+m[3];
   return(y_pred);
</code></pre>
<p>
  }
Executamos o script e obtemos uma precis√£o de previs√£o de cerca de 51%
ONNX: Creating and using per session threadpools since use_per_session_threads_ is tru
ONNX: Dynamic block base set to 0
ONNX: Initializing session.
ONNX: Adding default CPU execution provider.
ONNX: Total shared scalar initializer count: 0
ONNX: Total fused reshape node count: 0
ONNX: Total shared scalar initializer count: 0
ONNX: Total fused reshape node count: 0
<h3>ONNX: Use DeviceBasedPartition as default</h3>
ONNX: Saving initialized tensors.
<h3>ONNX: Done saving initialized tensors</h3>
ONNX: Session successfully initialized.
right direction predictions = 51.34 %</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3255</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3256
Verifica√ß√£o do modelo no testador de estrat√©gia
Os modelos para mercados financeiros podem ser testados no testador de estrat√©gias do terminal
MetaTrader 5. Essa √© a op√ß√£o mais r√°pida e conveniente que n√£o exige esfor√ßos adicionais para
emular o ambiente de mercado e as condi√ß√µes de negocia√ß√£o.
Reescreveremos o c√≥digo do projeto p√∫blico ONNX.Price.Prediction no EA para verificar o modelo. Isso
requer pequenas edi√ß√µes.
Transferimos a cria√ß√£o do modelo para a fun√ß√£o OnInit e encerramos a sess√£o onnx em OnDeinit.
Colocamos o bloco principal de manipula√ß√£o do modelo no manipulador OnTick. 
Tamb√©m adicionamos uma fun√ß√£o para obter o pre√ßo de fechamento das duas barras anteriores a fim
de comparar o pre√ßo de fechamento real e a previs√£o.
O c√≥digo do EA √© pequeno e f√°cil de ler.
const long   ExtInputShape [] = {1,10,4}; // forma dos dados de entrada do modelo
const long   ExtOutputShape[] = {1,1};    // forma dos dados de sa√≠da do modelo
#resource &quot;Python/model.onnx&quot; as uchar ExtModel[];// modelo em forma de recurso
long handle;         // identificador do modelo
ulong predictions=0; // contador de previs√µes
ulong confirmed=0;   // contador de previs√µes bem-sucedidas
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- verifica√ß√µes b√°sicas
   if(_Symbol!=&quot;EURUSD&quot;)
     {
      Print(&quot;Symbol must be EURUSD, testing aborted&quot;);
      return(-1);
     }
   if(_Period!=PERIOD_H1)
     {
      Print(&quot;Timeframe must be H1, testing aborted&quot;);
      return(-1);
     }
//--- criamos o modelo
   handle=OnnxCreateFromBuffer(ExtModel,ONNX_DEBUG_LOGS);
//--- especificamos a forma dos dados de entrada
   if(!OnnxSetInputShape(handle,0,ExtInputShape))
     {
      Print(&quot;OnnxSetInputShape failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }</p>
<p></code></pre>
<p>
<h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3257
</p>
<pre><code class="language-mql5">
//--- especificamos a forma dos dados de sa√≠da
   if(!OnnxSetOutputShape(handle,0,ExtOutputShape))
     {
      Print(&quot;OnnxSetOutputShape failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- conclu√≠mos o trabalho do modelo
   OnnxRelease(handle);
//--- calculamos e exibimos estat√≠sticas de previs√£o
   PrintFormat(&quot;Successfull predictions = %.2f %%&quot;,confirmed*100./double(predictions))
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   static datetime open_time=0;
   static double predict;
//--- verificamos o tempo de abertura da barra atual
   datetime time=iTime(_Symbol,_Period,0);
   if(time==0)
     {
      PrintFormat(&quot;Failed to get Time(0), error %d&quot;, GetLastError());
      return;
     }
//--- se o tempo de abertura da barra n√£o muda, ent√£o sa√≠mos antes da pr√≥xima chamada 
   if(time==open_time)
      return;
//--- obtemos os pre√ßos de fechamento das √∫ltimas 2 barras conclu√≠das
   double close[];
   int recieved=CopyClose(_Symbol,_Period,1,2,close);
   if(recieved!=2)
     {
      PrintFormat(&quot;CopyClose(2 bars) failed, error %d&quot;,GetLastError());
      return;
     }
   double delta_predict=predict-close[0]; // movimento de pre√ßo previsto
   double delta_actual=close[1]-close[0]; // varia√ß√£o real de pre√ßos
   if((delta_predict&gt;0 &amp;&amp; delta_actual&gt;0) || (delta_predict&lt;0 &amp;&amp; delta_actual&lt;0))
      confirmed++;</p>
<p></code></pre>
<p>
<h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3258
</p>
<pre><code class="language-mql5">
//--- calculamos o pre√ßo de fechamento em uma nova barra para verificar na pr√≥xima bar
   matrix rates;
//--- obtemos 10 barras
   if(!rates.CopyRates(&quot;EURUSD&quot;,PERIOD_H1,COPY_RATES_OHLC,1,10))
      return;
//--- alimentamos com um conjunto de vetores OHLC
   matrix x_norm=rates.Transpose();
   vector m=x_norm.Mean(0);
   vector s=x_norm.Std(0);
   matrix mm(10,4);
   matrix ms(10,4);
//--- preenchemos matrizes de normaliza√ß√£o
   for(int i=0; i&lt;10; i++)
     {
      mm.Row(m,i);
      ms.Row(s,i);
     }
//--- normalizamos os dados de entrada
   x_norm-=mm;
   x_norm/=ms;
//--- convertemos dados de entrada normalizados em dados do tipo float
   matrixf x_normf;
   x_normf.Assign(x_norm);
//--- obtemos o resultado do modelo - a previs√£o de pre√ßo
   vectorf y_norm(1);
//--- iniciamos o modelo
   if(!OnnxRun(handle,ONNX_DEBUG_LOGS | ONNX_NO_CONVERSION,x_normf,y_norm))
     {
      Print(&quot;OnnxRun failed, error &quot;,GetLastError());
     }
//--- realizamos uma transforma√ß√£o inversa para obter o pre√ßo previsto e verificamos e
   predict=y_norm[0]*s[3]+m[3];
   predictions++;  // aumentamos o contador de previs√µes
   Print(predictions,&quot;. close prediction = &quot;,predict);
//--- memorizamos o tempo de abertura da barra para verificar no pr√≥ximo tick
   open_time=time;
</code></pre>
<p>
  }
Compilamos o Expert Advisor e come√ßamos a testar no intervalo 2022, especificando o s√≠mbolo
EURUSD e o per√≠odo de tempo H1 com os quais o modelo foi treinado. O modo de simula√ß√£o de ticks
n√£o importa, pois o c√≥digo tem uma verifica√ß√£o do aparecimento de nova barra.  </p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3259
Executamos e obtemos o resultado no log de teste ‚Äî pouco mais de 50% das previs√µes corretas para
2022. 
Se os resultados da verifica√ß√£o preliminar do modelo forem satisfat√≥rios, podemos come√ßar a escrever
uma estrat√©gia de negocia√ß√£o completa e us√°-la.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3260</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3261
<h3>OnnxCreate</h3>
Cria uma sess√£o ONNX com carregamento de modelo a partir de um arquivo *.onnx
long¬† OnnxCreate(
</p>
<pre><code class="language-mql5">
   string  filename,  // caminho do arquivo
   uint    flags      // sinalizadores para cria√ß√£o de um modelo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
filename
[in]  Caminho para o arquivo *.onnx do modelo em rela√ß√£o √† pasta \MQL5\Files\.
flags
[in] Sinalizador de ENUM_ONNX_FLAGS, que descreve o modo de cria√ß√£o do modelo ‚Äî
ONNX_COMMON_FOLDER e ONNX_DEBUG_LOGS.
<h3>Valor retornado</h3>
Identificador da sess√£o criada ou INVALID_HANDLE em caso de erro. Para obter o c√≥digo do erro
chame a fun√ß√£o GetLastError.
<h3>Observa√ß√£o</h3>
Se o arquivo especificado n√£o for encontrado no disco, ser√° feita uma segunda tentativa de abrir o
arquivo com a extens√£o &#x27;.onnx&#x27; anexada ao nome.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3262
<h3>OnnxCreateFromBuffer</h3>
Cria uma sess√£o ONNX com carregamento de modelo a partir de uma matriz de dados
long¬† OnnxCreateFromBuffer(
</p>
<pre><code class="language-mql5">
   const uchar&amp;  buffer[],   // refer√™ncia para uma matriz
   ulong         flags       // sinalizadores para cria√ß√£o de um modelo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
buffer
[in]  Matriz com dados do modelo ONNX.
flags
[in] Sinalizador de ENUM_ONNX_FLAGS, que descreve o modo de cria√ß√£o do modelo ‚Äî
ONNX_COMMON_FOLDER e ONNX_DEBUG_LOGS.
<h3>Valor retornado</h3>
Identificador da sess√£o criada ou INVALID_HANDLE em caso de erro. Para obter o c√≥digo do erro
chame a fun√ß√£o GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3263
<h3>OnnxRelease</h3>
Exclus√£o de sess√£o ONNX.
</p>
<pre><code class="language-mql5">
bool¬† OnnxRelease(
   long   onnx_handle  // Identificador de sess√£o ONNX
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false. Para obter o c√≥digo de erro chame a fun√ß√£o
GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3264
<h3>OnnxRun</h3>
Execu√ß√£o do modelo ONNX.
</p>
<pre><code class="language-mql5">
bool¬† OnnxRun(
   long    onnx_handle,  // identificador de sess√£o
   ulong   flags,        // sinalizadores que descrevem o modo de execu√ß√£o
   ...¬†                  // par√¢metros de entrada e sa√≠da do modelo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
flags
[in] Sinalizador de ENUM_ONNX_FLAGS, que descreve o modo de execu√ß√£o ‚Äî ONNX_DEBUG_LOGS e
ONNX_NO_CONVERSION.
...
[in] [out]  Par√¢metros de entrada e sa√≠da do modelo.
Retorna true se for bem-sucedido, caso contr√°rio, false. Para obter o c√≥digo de erro chame a fun√ß√£o
GetLastError.
<h3>ENUM_ONNX_FLAGS</h3>
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>ONNX_DEBUG_LOGS</h3>
<h3>Sa√≠da de registros de depura√ß√£o</h3>
<h3>ONNX_NO_CONVERSION</h3>
Proibir a autoconvers√£o, usar os dados do
usu√°rio como est√£o
<h3>ONNX_COMMON_FOLDER</h3>
Carga do arquivo do modelo a partir da pasta
<h3>Common/Files, igual em valor ao sinalizador</h3>
<h3>FILE_COMMON</h3>
<h3>Exemplo:</h3>
const long                             ExtOutputShape[] = {1,1};    // forma dos dados
const long                             ExtInputShape [] = {1,10,4}; // forma dos dados
#resource &quot;Python/model.onnx&quot; as uchar ExtModel[]                   // modelo em forma
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
int OnStart(void)
  {
   matrix rates;</p>
<p></code></pre>
<p>
<h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3265
</p>
<pre><code class="language-mql5">
//--- obtemos 10 barras
   if(!rates.CopyRates(&quot;EURUSD&quot;,PERIOD_H1,COPY_RATES_OHLC,2,10))
      return(-1);
//--- alimentamos com um conjunto de vetores OHLC
   matrix x_norm=rates.Transpose();
   vector m=x_norm.Mean(0);               
   vector s=x_norm.Std(0);
   matrix mm(10,4);
   matrix ms(10,4);
//--- preenchemos matrizes de normaliza√ß√£o
   for(int i=0; i&lt;10; i++)
     {
      mm.Row(m,i);
      ms.Row(s,i);
     }
//--- normalizamos os dados de entrada
   x_norm-=mm;
   x_norm/=ms;
//--- criamos o modelo
   long handle=OnnxCreateFromBuffer(ExtModel,ONNX_DEBUG_LOGS);
//--- especificamos a forma dos dados de entrada
   if(!OnnxSetInputShape(handle,0,ExtInputShape))
     {
      Print(&quot;OnnxSetInputShape failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- especificamos a forma dos dados de sa√≠da
   if(!OnnxSetOutputShape(handle,0,ExtOutputShape))
     {
      Print(&quot;OnnxSetOutputShape failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- convertemos dados de entrada normalizados em dados do tipo float
   matrixf x_normf;
   x_normf.Assign(x_norm);
//--- obtemos o resultado do modelo - a previs√£o de pre√ßo
   vectorf y_norm(1);
//--- iniciamos o modelo
   if(!OnnxRun(handle,ONNX_DEBUG_LOGS | ONNX_NO_CONVERSION,x_normf,y_norm))
     {
      Print(&quot;OnnxRun failed, error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- registramos no log o valor de sa√≠da do modelo
   Print(y_norm);
//--- realizamos uma transforma√ß√£o inversa para obter o pre√ßo previsto</p>
<p></code></pre>
<p>
<h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3266
</p>
<pre><code class="language-mql5">
   double y_pred=y_norm[0]*s[3]+m[3];
   Print(&quot;price predicted:&quot;,y_pred);
//--- conclu√≠mos o trabalho
   OnnxRelease(handle);
   return(0);
</code></pre>
<p>
  };
<h3>Veja tamb√©m</h3>
<h3>OnnxSetInputShape, OnnxSetOutputShape</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3267
<h3>OnnxGetInputCount</h3>
Obten√ß√£o do n√∫mero de par√¢metros de entrada do modelo ONNX.
long¬† OnnxGetInputCount(
</p>
<pre><code class="language-mql5">
   long   onnx_handle  // Identificador de sess√£o ONNX
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
<h3>Valor retornado</h3>
Se for bem-sucedido, retorna o n√∫mero de par√¢metros de entrada; caso contr√°rio, retorna -1. Para
obter o c√≥digo de erro chame a fun√ß√£o GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3268
<h3>OnnxGetOutputCount</h3>
Obten√ß√£o do n√∫mero de par√¢metros de sa√≠da do modelo ONNX.
long¬† OnnxGetOutputCount(
</p>
<pre><code class="language-mql5">
   long   onnx_handle  // Identificador de sess√£o ONNX
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
<h3>Valor retornado</h3>
Se for bem-sucedido, retorna o n√∫mero de par√¢metros de sa√≠da; caso contr√°rio, retorna -1. Para
obter o c√≥digo de erro chame a fun√ß√£o GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3269
<h3>OnnxGetInputName</h3>
Obten√ß√£o do nome do par√¢metro de entrada do modelo por √≠ndice.
</p>
<pre><code class="language-mql5">
string¬† OnnxGetInputName(
   long   onnx_handle,  // identificador de sess√£o
   long   index         // √≠ndice de par√¢metro
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
index
[in]  √çndice do par√¢metro de entrada, a partir de 0.
<h3>Valor retornado</h3>
Retorna o nome do par√¢metro de entrada se for bem-sucedido; caso contr√°rio, retorna NULL. Para
obter o c√≥digo de erro chame a fun√ß√£o GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3270
<h3>OnnxGetOutputName</h3>
Obten√ß√£o do nome do par√¢metro de sa√≠da do modelo por √≠ndice.
</p>
<pre><code class="language-mql5">
string¬† OnnxGetOutputName(
   long   onnx_handle,  // identificador de sess√£o
   long   index         // √≠ndice de par√¢metro
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
index
[in]  √çndice do par√¢metro de sa√≠da, a partir de 0.
<h3>Valor retornado</h3>
Retorna o nome do par√¢metro de sa√≠da se for bem-sucedido; caso contr√°rio, retorna NULL. Para
obter o c√≥digo de erro chame a fun√ß√£o GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3271
<h3>OnnxGetInputTypeInfo</h3>
Obten√ß√£o de uma descri√ß√£o do tipo de par√¢metro de entrada do modelo.
</p>
<pre><code class="language-mql5">
bool¬† OnnxGetInputTypeInfo(
   long           onnx_handle,  // identificador de sess√£o
   long           index,        // √≠ndice de par√¢metro
   OnnxTypeInfo&amp;  typeinfo      // descri√ß√£o do tipo de par√¢metro
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
index
[in]  √çndice do par√¢metro de entrada, a partir de 0.
typeinfo
[out]  Estrutura OnnxTypeInfo, que descreve o tipo de par√¢metro de entrada.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false. Para obter o c√≥digo de erro chame a fun√ß√£o
GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3272
<h3>OnnxGetOutputTypeInfo</h3>
Obten√ß√£o de uma descri√ß√£o do tipo de par√¢metro de sa√≠da do modelo.
</p>
<pre><code class="language-mql5">
bool¬† OnnxGetOutputTypeInfo(
   long           onnx_handle,  // identificador de sess√£o
   long           index,        // √≠ndice de par√¢metro
   OnnxTypeInfo&amp;  typeinfo      // descri√ß√£o do tipo de par√¢metro
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
index
[in]  √çndice do par√¢metro de sa√≠da, a partir de 0.
typeinfo
[out]  Estrutura OnnxTypeInfo, que descreve o tipo de par√¢metro de sa√≠da.
<h3>Valor retornado</h3>
Retorna true se for bem-sucedido, caso contr√°rio, false. Para obter o c√≥digo de erro chame a fun√ß√£o
GetLastError.</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3273
<h3>OnnxSetInputShape</h3>
Define a dimensionalidade dos dados de entrada do modelo por √≠ndice.
</p>
<pre><code class="language-mql5">
bool¬† OnnxSetInputShape(
   long          onnx_handle,  // identificador de sess√£o
   long          input_index,  // √≠ndice do par√¢metro de entrada
   const ulong&amp;  shape[]       // matriz que descreve a dimensionalidade dos dados de 
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
input_index
[in]  √çndice do par√¢metro de entrada, a partir de 0.
shape
[in]  Matriz que descreve a dimensionalidade dos dados de entrada.
<h3>Valor retornado</h3>
Retorna o nome do par√¢metro de entrada se for bem-sucedido; caso contr√°rio, retorna NULL. Para
obter o c√≥digo de erro chame a fun√ß√£o GetLastError.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//---- descrevemos a dimensionalidade dos dados de entrada do modelo
   const long  ExtOutputShape[] = {1,1};
   const long  ExtInputShape [] = {1,10,4};
//--- criamos o modelo
   long handle=OnnxCreateFromBuffer(model,ONNX_DEBUG_LOGS);
//--- especificamos a forma dos dados de entrada
   if(!OnnxSetInputShape(handle,0,ExtInputShape))
     {
      Print(&quot;failed, OnnxSetInputShape error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- especificamos a forma dos dados de sa√≠da
   if(!OnnxSetOutputShape(handle,0,ExtOutputShape))
     {
      Print(&quot;failed, OnnxSetOutputShape error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
</code></pre>
<p>
<h3>Veja tamb√©m</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3274
<h3>OnnxSetOutputShape</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3275
<h3>OnnxSetOutputShape</h3>
Define a dimensionalidade dos dados de sa√≠da do modelo por √≠ndice.
</p>
<pre><code class="language-mql5">
bool¬† OnnxSetOutputShape(
   long          onnx_handle,   // identificador de sess√£o
   long          output_index,  // √≠ndice do par√¢metro de sa√≠da
   const ulong&amp;  shape[]        // matriz que descreve a dimensionalidade dos dados de
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
onnx_handle
[in]  Identificador do objeto da sess√£o ONNX, criado por meio de OnnxCreate ou
OnnxCreateFromBuffer.
output_index
[in]  √çndice do par√¢metro de sa√≠da, a partir de 0.
shape
[in]  Matriz que descreve a dimensionalidade dos dados de sa√≠da.
<h3>Valor retornado</h3>
Retorna o nome do par√¢metro de entrada se for bem-sucedido; caso contr√°rio, retorna NULL. Para
obter o c√≥digo de erro chame a fun√ß√£o GetLastError.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//---- descrevemos a dimensionalidade dos dados de entrada do modelo
   const long  ExtOutputShape[] = {1,1};
   const long  ExtInputShape [] = {1,10,4};
//--- criamos o modelo
   long handle=OnnxCreateFromBuffer(model,ONNX_DEBUG_LOGS);
//--- especificamos a forma dos dados de entrada
   if(!OnnxSetInputShape(handle,0,ExtInputShape))
     {
      Print(&quot;failed, OnnxSetInputShape error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
//--- especificamos a forma dos dados de sa√≠da
   if(!OnnxSetOutputShape(handle,0,ExtOutputShape))
     {
      Print(&quot;failed, OnnxSetOutputShape error &quot;,GetLastError());
      OnnxRelease(handle);
      return(-1);
     }
</code></pre>
<p>
<h3>Veja tamb√©m</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3276
<h3>OnnxSetInputShape</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3277
<h3>Estruturas de dados</h3>
As seguintes estruturas de dados s√£o usadas para trabalhar com modelos ONNX:
<h3>OnnxTypeInfo</h3>
A estrutura descreve o tipo de par√¢metro de entrada ou sa√≠da do modelo ONNX
</p>
<pre><code class="language-mql5">
struct OnnxTypeInfo
  {
   ENUM_ONNX_TYPE         type;           // tipo de par√¢metro
   OnnxTensorTypeInfo     tensor;         // descri√ß√£o do tensor
   OnnxMapTypeInfo        map;            // descri√ß√£o do mapa
   OnnxSequenceTypeInfo   sequence;       // descri√ß√£o da sequ√™ncia
</code></pre>
<p>
  };
Somente o tensor (ONNX_TYPE_TENSOR) pode ser usado como par√¢metro de entrada; nesse caso,
somente o campo OnnxTypeInfo::tensor √© preenchido com valores; os outros campos (mapa e
sequ√™ncia) permanecem indefinidos.
<h3>Apenas</h3>
um 
dos 
tr√™s 
tipos 
<h3>OnnxTypeInfo</h3>
(ONNX_TYPE_TENSOR, 
<h3>ONNX_TYPE_MAP</h3>
ou
ONNX_TYPE_SEQUENCE) pode ser usado como par√¢metro de sa√≠da, dependendo do tipo, ser√°
preenchida 
a 
subestrutura 
apropriada 
(OnnxTypeInfo::tensor, 
<h3>OnnxTypeInfo::map</h3>
ou
OnnxTypeInfo::sequence).
<h3>OnnxTensorTypeInfo</h3>
A estrutura descreve o tensor no par√¢metro de entrada ou sa√≠da do modelo ONNX
</p>
<pre><code class="language-mql5">
struct OnnxTensorTypeInfo
  {
   const ENUM_ONNX_DATA_TYPE    data_type;      // tipo de dados no tensor
   const long                   dimensions[];   // n√∫mero de elementos no tensor
</code></pre>
<p>
  };
<h3>OnnxMapTypeInfo</h3>
A estrutura descreve o mapa que √© obtido no par√¢metro de sa√≠da do modelo ONNX
</p>
<pre><code class="language-mql5">
struct OnnxMapTypeInfo
  {
   const ENUM_ONNX_DATA_TYPE    key_type;       // tipo de chave
   const OnnxTypeInfo&amp;          value_type;     // tipo de valor
</code></pre>
<p>
  };
<h3>OnnxSequenceTypeInfo</h3>
A estrutura descreve a sequ√™ncia que resulta no par√¢metro de sa√≠da do modelo ONNX</p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3278
</p>
<pre><code class="language-mql5">
struct OnnxSequenceTypeInfo
  {
   const OnnxTypeInfo&amp;          value_type;     // tipo de dados da sequ√™ncia
</code></pre>
<p>
  };
<h3>ENUM_ONNX_TYPE</h3>
A enumera√ß√£o ENUM_ONNX_TYPE descreve o tipo de par√¢metro do modelo
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>ONNX_TYPE_UNKNOWN</h3>
<h3>Desconhecido</h3>
<h3>ONNX_TYPE_TENSOR</h3>
<h3>Tensor</h3>
<h3>ONNX_TYPE_SEQUENCE</h3>
<h3>Sequ√™ncia</h3>
<h3>ONNX_TYPE_MAP</h3>
<h3>Mapa</h3>
<h3>ONNX_TYPE_OPAQUE</h3>
<h3>Abstrato</h3>
<h3>ONNX_TYPE_SPARSETENSOR</h3>
<h3>Tensor esparso</h3>
<h3>ENUM_ONNX_DATA_TYPE</h3>
A enumera√ß√£o ENUM_ONNX_DATA_TYPE descreve o tipo de dados usados
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>ONNX_DATA_TYPE_UNDEFINED</h3>
<h3>N√£o definido</h3>
<h3>ONNX_DATA_TYPE_FLOAT</h3>
float
<h3>ONNX_DATA_TYPE_INT8</h3>
</p>
<pre><code class="language-mql5">
int de 8 bits
</code></pre>
<p>
<h3>ONNX_DATA_TYPE_UINT16</h3>
uint de 16 bits
<h3>ONNX_DATA_TYPE_INT16</h3>
</p>
<pre><code class="language-mql5">
int de 16 bits
</code></pre>
<p>
<h3>ONNX_DATA_TYPE_INT32</h3>
</p>
<pre><code class="language-mql5">
int de 32 bits
</code></pre>
<p>
<h3>ONNX_DATA_TYPE_INT64</h3>
</p>
<pre><code class="language-mql5">
int de 64 bits
</code></pre>
<p>
<h3>ONNX_DATA_TYPE_STRING</h3>
string
<h3>ONNX_DATA_TYPE_BOOL</h3>
bool
<h3>ONNX_DATA_TYPE_FLOAT16</h3>
float de 16 bits
<h3>ONNX_DATA_TYPE_DOUBLE</h3>
double
<h3>ONNX_DATA_TYPE_UINT32</h3>
uint de 32 bits
<h3>ONNX_DATA_TYPE_UINT64</h3>
uint de 64 bits
<h3>ONNX_DATA_TYPE_COMPLEX64</h3>
<h3>N√∫mero complexo de 64 bits</h3></p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3279
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>ONNX_DATA_TYPE_COMPLEX128</h3>
<h3>N√∫mero complexo de 128 bits</h3>
<h3>ONNX_DATA_TYPE_BFLOAT16</h3>
bfloat de 16 bits (Brain Floating Point)
<h3>ENUM_ONNX_FLAGS</h3>
A enumera√ß√£o ENUM_ONNX_FLAGS descreve o modo de inicializa√ß√£o do modelo
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>ONNX_DEBUG_LOGS</h3>
<h3>Sa√≠da de registros de depura√ß√£o</h3>
<h3>ONNX_NO_CONVERSION</h3>
Proibir a autoconvers√£o, usar os dados do
usu√°rio como est√£o
<h3>ONNX_COMMON_FOLDER</h3>
Carga do arquivo do modelo a partir da pasta
<h3>Common/Files, igual em valor ao sinalizador</h3>
<h3>FILE_COMMON</h3>
Convers√£o de arrays ao trabalhar com modelos ONNX
Em tarefas de aprendizado de m√°quina, nem sempre √© necess√°ria uma grande precis√£o nos c√°lculos.
Para acelerar os c√°lculos, alguns modelos utilizam tipos de dados com menor precis√£o, como Float16 e
at√© mesmo Float8. Para que os usu√°rios possam fornecer esses dados de entrada aos modelos, no
MQL5 foram adicionadas 4 fun√ß√µes especiais que convertem os tipos padr√µes do MQL5 para os tipos
especiais FP16 e FP8.
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>ArrayToFP16</h3>
Realiza a c√≥pia de um array do tipo float ou double para um
array do tipo ushort com o formato especificado.
<h3>ArrayToFP8</h3>
Realiza a c√≥pia de um array do tipo float ou double para um
array do tipo uchar com o formato especificado.
<h3>ArrayFromFP16</h3>
Realiza a c√≥pia de um array do tipo ushort para um array do
tipo float ou double com um formato especificado.
<h3>ArrayFromFP8</h3>
Realiza a c√≥pia de um array do tipo uchar para um array do
tipo float ou double com um formato especificado.
Essas fun√ß√µes para convers√£o de arrays utilizam formatos especiais, definidos nas enumera√ß√µes
abaixo.
<h3>ENUM_FLOAT16_FORMAT</h3>
Enumera√ß√£o ENUM_FLOAT16_FORMAT descreve 2 formatos do tipo FP16. </p>
<p><h3>Modelos ONNX</h3>
¬© 2000-2025, MetaQuotes Ltd.
3280
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>FLOAT_FP16</h3>
Formato padr√£o de 16 bits, tamb√©m conhecido como half
<h3>FLOAT_BFP16</h3>
<h3>Formato especial brain float point</h3>
Ambos os formatos t√™m suas vantagens e limita√ß√µes. FLOAT16 oferece maior precis√£o, mas requer
mais recursos para armazenamento e c√°lculos. BFLOAT16, por outro lado, oferece maior desempenho
e efici√™ncia no processamento de dados, mas pode ser menos preciso.
<h3>ENUM_FLOAT8_FORMAT</h3>
Enumera√ß√£o ENUM_FLOAT8_FORMAT descreve 4 formatos do tipo FP8.
O formato FP8 (n√∫mero de ponto flutuante de 8 bits) √© um dos tipos de dados usados para representar
n√∫meros de ponto flutuante. No FP8, cada n√∫mero √© representado por 8 bits de dados, que geralmente
s√£o divididos em tr√™s componentes: sinal, expoente e mantissa. Este formato oferece um
compromisso entre precis√£o e efici√™ncia de armazenamento de dados, tornando-o atraente para uso
em aplicativos onde a economia de mem√≥ria e recursos computacionais √© necess√°ria.  
<h3>Identificador</h3>
<h3>Descri√ß√£o</h3>
<h3>FLOAT_FP8_E4M3FN</h3>
N√∫mero de ponto flutuante de 8 bits, 4 bits de ordem e 3 bits
de mantissa. Geralmente usado como coeficientes.
<h3>FLOAT_FP8_E4M3FNUZ</h3>
N√∫mero de ponto flutuante de 8 bits, 4 bits de ordem e 3 bits
de mantissa. Suporta NaN, n√£o suporta zero negativo e Inf.
Geralmente usado como coeficientes.
<h3>FLOAT_FP8_E5M2FN</h3>
N√∫mero de ponto flutuante de 8 bits, 5 bits de ordem e 2 bits
de mantissa. Suporta NaN e Inf. Geralmente usado para
gradientes.
<h3>FLOAT_FP8_E5M2FNUZ</h3>
N√∫mero de ponto flutuante de 8 bits, 5 bits de ordem e 2 bits
de mantissa. Suporta NaN e Inf, n√£o suporta zero negativo.
Tamb√©m utilizado para gradientes.
Uma das principais vantagens do FP8 √© sua efici√™ncia no processamento de grandes volumes de dados.
Gra√ßas √† representa√ß√£o compacta de n√∫meros, FP8 permite reduzir os requisitos de mem√≥ria e
acelerar os c√°lculos. Isso √© especialmente importante em aplica√ß√µes de aprendizado de m√°quina e
intelig√™ncia artificial, onde o processamento de grandes conjuntos de dados √© comum.
</p>
        </article>
        
        <footer>
            <p>Documenta√ß√£o MQL5 - Fonte: MetaQuotes Ltd.</p>
        </footer>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function toggleSidebar() {
            document.querySelector('.sidebar').classList.toggle('open');
        }
        
        function filterNav() {
            const filter = document.getElementById('search').value.toLowerCase();
            const items = document.querySelectorAll('.nav-list li');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }
    </script>
</body>
</html>