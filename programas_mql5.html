<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programas MQL5 - MQL5 Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>MQL5 Docs</h1>
            <p>Documenta√ß√£o Completa</p>
        </div>
        <div class="search-box">
            <input type="text" id="search" placeholder="Buscar..." onkeyup="filterNav()">
        </div>
        <ul class="nav-list" id="nav-list">
            <li class=""><a href="index.html">üìö √çndice</a></li>
            <li class=""><a href="introducao.html">Introducao</a></li>
<li class=""><a href="refer√™ncia_mql5.html">Refer√™ncia MQL5</a></li>
<li class=""><a href="elementos_b√°sicos_da_linguagem.html">Elementos B√°sicos da Linguagem</a></li>
<li class=""><a href="constantes,_enumeradores_e_estruturas.html">Constantes, Enumeradores e Estruturas</a></li>
<li class="active"><a href="programas_mql5.html">Programas MQL5</a></li>
<li class=""><a href="vari√°veis_predefinidas.html">Vari√°veis Predefinidas</a></li>
<li class=""><a href="fun√ß√µes_comuns.html">Fun√ß√µes Comuns</a></li>
<li class=""><a href="fun√ß√µes_para_array.html">Fun√ß√µes para Array</a></li>
<li class=""><a href="m√©todos_matriciais_e_vetoriais.html">M√©todos matriciais e vetoriais</a></li>
<li class=""><a href="fun√ß√µes_de_convers√£o.html">Fun√ß√µes de Convers√£o</a></li>
<li class=""><a href="fun√ß√µes_matem√°ticas.html">Fun√ß√µes Matem√°ticas</a></li>
<li class=""><a href="fun√ß√µes_de_string.html">Fun√ß√µes de String</a></li>
<li class=""><a href="data_e_hora.html">Data e Hora</a></li>
<li class=""><a href="informa√ß√µes_de_conta.html">Informa√ß√µes de Conta</a></li>
<li class=""><a href="verificando_estado.html">Verificando Estado</a></li>
<li class=""><a href="manipula√ß√£o_de_eventos.html">Manipula√ß√£o de eventos</a></li>
<li class=""><a href="informa√ß√µes_de_mercado.html">Informa√ß√µes de Mercado</a></li>
<li class=""><a href="calend√°rio_econ√¥mico.html">Calend√°rio econ√¥mico</a></li>
<li class=""><a href="s√©ries_temporais_e_acesso_a_indicadores.html">S√©ries Temporais e Acesso a Indicadores</a></li>
<li class=""><a href="s√≠mbolos_personalizados.html">S√≠mbolos personalizados</a></li>
<li class=""><a href="opera√ß√µes_de_gr√°ficos.html">Opera√ß√µes de Gr√°ficos</a></li>
<li class=""><a href="fun√ß√µes_de_negocia√ß√£o.html">Fun√ß√µes de Negocia√ß√£o</a></li>
<li class=""><a href="gerenciamento_de_sinais.html">Gerenciamento de sinais</a></li>
<li class=""><a href="fun√ß√µes_de_rede.html">Fun√ß√µes de rede</a></li>
<li class=""><a href="vari√°veis_globais_do_terminal.html">Vari√°veis Globais do Terminal</a></li>
<li class=""><a href="fun√ß√µes_de_arquivo.html">Fun√ß√µes de Arquivo</a></li>
<li class=""><a href="indicadores_customizados.html">Indicadores Customizados</a></li>
<li class=""><a href="fun√ß√µes_de_objeto.html">Fun√ß√µes de Objeto</a></li>
<li class=""><a href="indicadores_t√©cnicos.html">Indicadores T√©cnicos</a></li>
<li class=""><a href="trabalhando_com_resultados_de_otimiza√ß√£o.html">Trabalhando com Resultados de Otimiza√ß√£o</a></li>
<li class=""><a href="trabalhando_com_eventos.html">Trabalhando com Eventos</a></li>
<li class=""><a href="trabalhando_com_opencl.html">Trabalhando com OpenCL</a></li>
<li class=""><a href="trabalhar_com_bancos_de_dados.html">Trabalhar com bancos de dados</a></li>
<li class=""><a href="trabalho_com_directx.html">Trabalho com DirectX</a></li>
<li class=""><a href="metatrader_para_python.html">MetaTrader para Python</a></li>
<li class=""><a href="modelos_onnx.html">Modelos ONNX</a></li>
<li class=""><a href="biblioteca_padr√£o.html">Biblioteca Padr√£o</a></li>
<li class=""><a href="migrando_do_mql4.html">Migrando do MQL4</a></li>
<li class=""><a href="lista_de_fun√ß√µes_mql5.html">Lista de Fun√ß√µes MQL5</a></li>
<li class=""><a href="lista_de_constantes_mql5.html">Lista de Constantes MQL5</a></li>

        </ul>
    </nav>
    
    <main class="content">
        <header>
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1>Programas MQL5</h1>
        </header>
        
        <article>
            <p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1058
<h3>Programas MQL5</h3>
Para um programa-mql5 funcionar, ele deve ser compilado (bot√£o Compilar ou tecla F7). A compila√ß√£o
deve passar sem erros (alguns avisos s√£o poss√≠veis; eles devem ser analisados). Neste processo, um
arquivo execut√°vel com o mesmo nome e com extens√£o EX5 deve ser criado no diret√≥rio
correspondente, 
terminal_dir\MQL5\Experts, 
terminal_dir\MQL5\indicators 
ou
terminal_dir\MQL5\scripts. Este arquivo pode ser executado.
Caracter√≠sticas operacionais de programas MQL5 s√£o descritas nas seguintes se√ß√µes:
¬∑ Execu√ß√£o de Programa ‚Äì ordem de chamada de manipuladores de eventos predefinidos.
¬∑ Testando estrat√©gias de negocia√ß√£o ‚Äì caracter√≠sticas operacionais de programas MQL5 no Provador
de Estrat√©gias.
¬∑ Eventos do terminal cliente ‚Äì descri√ß√£o de eventos, que podem ser processados em programas.
¬∑ Chamada de fun√ß√µes importadas ‚Äì ordem de descri√ß√£o, par√¢metros permitidos, detalhes de busca e
conven√ß√£o de chamada para fun√ß√µes importadas.
¬∑ Erros em tempo de execu√ß√£o ‚Äì obten√ß√£o de informa√ß√µes sobre erros cr√≠ticos e em tempo de
execu√ß√£o.
Expert Advisors, indicadores customizados e scripts s√£o anexados a um dos gr√°ficos abertos atrav√©s
do m√©todo &quot;Arrastar e Soltar&quot; a partir da janela Navegador.
Para um Expert Advisor parar de funcionar, ele deve ser removido de um gr√°fico. Para fazer isso
selecione a &quot;Lista de Experts&quot; no menu de contexto do gr√°fico, ent√£o selecione um Expert Advisor da
lista e clique no bot√£o &quot;Remover&quot;. O funcionamento de Expert Advisors √© tamb√©m afetado pelo estado
do bot√£o &quot;AutoTrading&quot;.
A fim de parar um indicador customizado, ele deve ser removido de um gr√°fico.
Indicadores customizados e Expert Advisors trabalham at√© eles serem explicitamente removidos de um
gr√°fico; informa√ß√µes sobre Expert Advisors e Indicadores s√£o salvos entre sess√µes do terminal cliente.
Scripts s√£o executados uma vez e s√£o exclu√≠dos automaticamente na conclus√£o da opera√ß√£o ou
mudan√ßa de estado do gr√°fico corrente, ou no encerramento do terminal cliente. Ap√≥s o rein√≠cio do
terminal cliente, scripts n√£o s√£o iniciados, porque as informa√ß√µes sobre eles n√£o s√£o salvas.
Em um gr√°fico podem operar no m√°ximo um Expert Advisor, um script e um n√∫mero ilimitado de
indicadores.
Os servi√ßos n√£o precisam estar vinculados ao gr√°fico para funcionarem e s√£o projetados para executar
fun√ß√µes auxiliares. Por exemplo, no servi√ßo voc√™ pode criar um s√≠mbolo personalizado, abrir o gr√°fico
do s√≠mbolo criado e, em um loop infinito, obter dados para ele usando fun√ß√µes de rede e atualizar
continuamente. </p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1059
<h3>Execu√ß√£o de Programa</h3>
Cada script, servi√ßo e EA √© executado em seu pr√≥prio fluxo separado. Todos os indicadores calculados
com base em um s√≠mbolo, mesmo se estiverem sendo executados em gr√°ficos diferentes, funcionam
no mesmo fluxo. Assim, todos os indicadores em um s√≠mbolo compartilham os recursos de um fluxo.
Todas as outras a√ß√µes associadas a um s√≠mbolo, como processamento de ticks e sincroniza√ß√£o de
hist√≥rico, tamb√©m s√£o consistentemente realizadas no mesmo segmento com indicadores. Isso
significa que se uma a√ß√£o infinita √© realizada em um indicador, todos os outros eventos associados a
seu ativo nunca ser√£o realizados.
Ao executar um Expert Advisor, certifique-se de que ele tem um ambiente de negocia√ß√£o real e pode
acessar o hist√≥rico do requerido ativo e per√≠odo, e sincronizar dados entre o terminal e o servidor.
Para todos estes procedimentos, o terminal fornece um atraso de inicia√ß√£o de n√£o mais que 5
segundos, ap√≥s o qual o Expert Advisor ser√° iniciado com os dados dispon√≠veis. Portanto, no caso de
n√£o haver conex√£o com o servidor, isso pode levar a um atraso na inicia√ß√£o de um Expert Advisor.
A tabela abaixo cont√©m um breve resumo sobre programas MQL5:
<h3>Programa</h3>
<h3>Execu√ß√£o</h3>
<h3>Observa√ß√£o</h3>
<h3>Servi√ßo</h3>
No fluxo em si, h√° o mesmo
n√∫mero de servi√ßos e de fluxos de
execu√ß√£o para eles
<h3>O servi√ßo em loop n√£o pode</h3>
atrapalhar outros programas
<h3>Script</h3>
<h3>Um segmento separado, o n√∫mero</h3>
de segmentos para scripts √© igual
ao n√∫mero de scripts
Um script em loop n√£o √© capaz de
interromper a execu√ß√£o de outros
programas
<h3>Expert Advisor</h3>
<h3>Um segmento separado, o n√∫mero</h3>
de segmentos para Expert Advisor
√© igual ao n√∫mero de Expert
<h3>Advisor</h3>
Um Expert Advisor em loop n√£o √©
capaz de interromper a execu√ß√£o
de outros programas
<h3>Indicador</h3>
<h3>Um segmento para todos os</h3>
indicadores de um s√≠mbolo. O
n√∫mero de segmentos √© igual ao
n√∫mero 
de 
s√≠mbolos 
com
indicadores
<h3>Um loop infinito em um indicador</h3>
ir√° 
parar 
todos 
os 
outros
indicadores sobre este ativo
Logo ap√≥s um programa ser anexado a um gr√°fico, ele √© carregado para a mem√≥ria do terminal
cliente, bem como vari√°veis globais s√£o inicializadas. Caso alguma vari√°vel global do tipo classe tiver
um construtor, este construtor ser√° chamado durante a inicializa√ß√£o das vari√°veis globais.
Ap√≥s isso, o programa fica esperando por um evento do terminal cliente. Cada programa-MQL5 deve
ter ao menos um manipulador (handler) de evento, caso contr√°rio o programa carregado n√£o ser√°
executado. Handlers de evento t√™m nomes pr√©-definidos, par√¢metros e tipos de retorno.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1060
<h3>Tipo</h3>
<h3>Nome da</h3>
<h3>Fun√ß√£o</h3>
<h3>Par√¢metros</h3>
<h3>Aplicativo</h3>
<h3>Coment√°rio</h3>
int
<h3>OnInit</h3>
nenhum
<h3>Expert Advisors</h3>
e indicadores
<h3>Handler de</h3>
evento
<h3>Init. Ele permite usar</h3>
o tipo de retorno
void.
void
<h3>OnDeinit</h3>
const int reason
<h3>Expert Advisors</h3>
e indicadores
<h3>Handler de</h3>
evento
Deinit.
void
<h3>OnStart</h3>
nenhum
scripts e servi√ßos
<h3>Handler de</h3>
evento
Start.
int
<h3>OnCalculate</h3>
const int rates_total,
const 
int
prev_calculated,
const datetime &amp;Time[],
const double &amp;Open[],
const double &amp;High[],
const double &amp;Low[],
const double &amp;Close[],
const 
long
&amp;TickVolume[],
const long &amp;Volume[],
const int &amp;Spread[]
indicadores
<h3>Handler de</h3>
evento
<h3>Calculate para todos</h3>
os pre√ßos.
int
<h3>OnCalculate</h3>
const int rates_total,
const 
int
prev_calculated,
const int begin,
const double &amp;price[]
indicadores
<h3>Handler de</h3>
evento
<h3>Calculate sobre um</h3>
array 
√∫nico 
de
dados. 
<h3>Um</h3>
indicador 
n√£o
pode 
ter
simultaneamente
dois 
handlers 
de
evento.
<h3>Neste caso apenas</h3>
um 
handler
(manipulador) 
de
evento vai trabalhar
na array de dados.
void
<h3>OnTick</h3>
nenhum
<h3>Expert Advisors</h3>
<h3>Handler de</h3>
evento
<h3>NewTick. Enquanto o</h3>
evento 
de
recebimento de um
novo tick est√° sendo
processado, nenhum
outro evento deste
tipo √© recebido.
void
<h3>OnTimer</h3>
nenhum
<h3>Expert Advisors</h3>
e indicadores
<h3>Handler de</h3>
evento
Timer.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1061
<h3>Tipo</h3>
<h3>Nome da</h3>
<h3>Fun√ß√£o</h3>
<h3>Par√¢metros</h3>
<h3>Aplicativo</h3>
<h3>Coment√°rio</h3>
void
<h3>OnTrade</h3>
nenhum
<h3>Expert Advisors</h3>
<h3>Handler de</h3>
evento
Trade.
double
<h3>OnTester</h3>
nenhum
<h3>Expert Advisors</h3>
<h3>Handler de</h3>
evento
Tester.
void
<h3>OnChartEvent</h3>
const int id,
const long &amp;lparam,
const double &amp;dparam,
const string &amp;sparam
<h3>Expert Advisors</h3>
e indicadores
<h3>Handler de</h3>
evento
ChartEvent.
void
<h3>OnBookEvent</h3>
const 
string
&amp;symbol_name
<h3>Expert Advisors</h3>
e indicadores
<h3>Handler de</h3>
evento
BookEvent.
Um terminal cliente envia novos eventos para o gr√°fico aberto correspondente. Os eventos podem ser
gerados por gr√°ficos (Eventos de gr√°fico) ou programas-MQL5 (eventos customizados). A gera√ß√£o de
eventos de cria√ß√£o ou exclus√£o de objetos gr√°ficos sobre um gr√°fico pode ser habilitado ou
desabilitado atrav√©s da defini√ß√£o das propriedades de gr√°fico CHART_EVENT_OBJECT_CREATE e
CHART_EVENT_OBJECT_DELETE. Cada programa MQL5 e cada gr√°fico t√™m sua pr√≥pria fila de eventos,
onde todos os novos eventos que chegam s√£o adicionados.
Um programa recebe somente eventos do gr√°fico no qual ele est√° rodando. Todos os eventos s√£o
processados um ap√≥s o outro na ordem que em eles s√£o recebidos. Se um fila j√° tiver um evento
NewTick, ou este evento est√° correntemente sendo processado, ent√£o um novo evento NewTick n√£o √©
colocado na fila do programa MQL5. Similarmente, se ChartEvent j√° esta enfileirado, ou este evento
est√° sendo processado, nenhum novo evento deste tipo √© enfileirado. Os eventos de timer s√£o
tratados da mesma forma ‚Äì se o evento Timer est√° na filha ou sendo tratado, um novo evento timer
n√£o √© enfileirado .
Filas de evento t√™m um tamanho limitado mas suficiente, de modo que a sobrecarga de uma fila em
programas bem escritos √© improv√°vel. No caso de uma sobrecarga de fila, novos eventos s√£o
descartados sem enfileiramento.
Evite usar loops infinitos para manipular eventos. As √∫nicas exce√ß√µes a essa regra s√£o scripts e
servi√ßos que manipulam um √∫nico evento Start.
Bibliotecas n√£o tratam nenhum evento.
Fun√ß√µes proibidas em Indicadores e Expert Advisors
Indicatores, scripts e Expert Advisors s√£o programas execut√°veis escritos em MQL5. Eles s√£o
projetados para diferentes tipos de tarefas. Portanto existem algumas restri√ß√µes quanto ao uso de
certas fun√ß√µes, dependendo do tipo de programa. As seguintes fun√ß√µes s√£o proibidas em indicadores:
¬∑ OrderCalcMargin();
¬∑ OrderCalcProfit();
¬∑ OrderCheck();</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1062
¬∑ OrderSend();
¬∑ SendFTP();
¬∑ Sleep();
¬∑ ExpertRemove();
¬∑ MessageBox().
Todas as fun√ß√µes projetadas para indicadores s√£o proibidas em Expert Advisors e scripts:
¬∑ SetIndexBuffer();
¬∑ IndicatorSetDouble();
¬∑ IndicatorSetInteger();
¬∑ IndicatorSetString();
¬∑ PlotIndexSetDouble();
¬∑ PlotIndexSetInteger();
¬∑ PlotIndexSetString();
¬∑ PlotIndexGetInteger.
A biblioteca (library) n√£o √© um programa independente e √© executado no contexto do programa MQL5
que a chamou: script, indicador ou Expert Advisor. Desta forma, as restri√ß√µes acima se aplicam √†
biblioteca (library) chamada.
Proibi√ß√£o do uso de fun√ß√µes nos servi√ßos
Os servi√ßos n√£o aceitam eventos, pois n√£o est√£o vinculados a gr√°ficos. Nos servi√ßos s√£o proibidas as
seguintes fun√ß√µes:
<h3>ExpertRemove();</h3>
<h3>EventSetMillisecondTimer();</h3>
<h3>EventSetTimer();</h3>
<h3>EventKillTimer();</h3>
<h3>SetIndexBuffer();</h3>
<h3>IndicatorSetDouble();</h3>
<h3>IndicatorSetInteger();</h3>
<h3>IndicatorSetString();</h3>
<h3>PlotIndexSetDouble();</h3>
<h3>PlotIndexSetInteger();</h3>
<h3>PlotIndexSetString();</h3>
<h3>PlotIndexGetInteger();</h3>
<h3>Carga e Descarga de Indicadores</h3></p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1063
<h3>Indicadores s√£o carregados nos seguintes casos:</h3>
¬∑ um indicador √© anexado a um gr√°fico;
¬∑ inicio do terminal (se o indicador estava anexado a um gr√°fico antes do encerramento do terminal);
¬∑ carga de um template (se o indicador anexado a um gr√°fico estiver especificado no template);
¬∑ altera√ß√£o de um perfil (se o indicador estiver anexado a um dos gr√°ficos do perfil alterado);
¬∑ altera√ß√£o de um ativo e/ou per√≠odo de um gr√°fico, no qual o indicador est√° anexado;
¬∑ altera√ß√£o da conta na qual o terminal est√° conectado;
¬∑ ap√≥s uma bem sucedida recompila√ß√£o de um indicador, se o indicador estiver anexado a um gr√°fico;
¬∑ altera√ß√£o de par√¢metros de entrada do indicador.
<h3>Indicadores s√£o descarregados nos seguintes casos:</h3>
¬∑ ao desanexar um indicador de um gr√°fico;
¬∑ encerramento do terminal (se o indicador estiver anexado a um gr√°fico);
¬∑ carga de um template, se um indicador estiver anexado a um gr√°fico;
¬∑ fechamento de um gr√°fico, no qual o indicador estava anexado;
¬∑ altera√ß√£o de um perfil, se o indicador estiver anexado a um dos gr√°ficos do perfil alterado;
¬∑ altera√ß√£o de um ativo e/ou per√≠odo de um gr√°fico, no qual o indicador est√° anexado;
¬∑ altera√ß√£o da conta na qual o terminal est√° conectado;
¬∑ altera√ß√£o de par√¢metros de entrada do indicador.
<h3>Carga e Descarga de Expert Advisors</h3>
Expert Advisors s√£o carregados nos seguintes casos:
¬∑ ao anexar um Expert Advisor a um gr√°fico;
¬∑ in√≠cio de terminal (se o Expert Advisor estava anexado a um gr√°fico antes do encerramento do
terminal);
¬∑ carga de um template (se o Expert Advisor anexado a um gr√°fico est√° especificado no template);
¬∑ altera√ß√£o de um perfil (se o Expert Advisor est√° anexado a um dos gr√°ficos do perfil);
¬∑ conex√£o a uma conta, mesmo se o n√∫mero da conta for o mesmo (se o Expert Advisor estava
anexado ao gr√°fico antes da autoriza√ß√£o do terminal no servidor.
Expert Advisors s√£o descarregados nos seguintes casos:
¬∑ ao desanexar um Expert Advisor de um gr√°fico;
¬∑ Se um novo Expert Advisor √© anexo a um gr√°fico, e um outro Expert Advisor j√° estava anexado,
este Expert Advisor √© descarregado.
¬∑ encerramento do terminal (se o Expert Advisor estiver anexado a um gr√°fico);
¬∑ carga de um template, se um Expert Advisor est√° anexado a um gr√°fico;
¬∑ fechamento de um gr√°fico, no qual o Expert Advisor est√° anexado.
¬∑ altera√ß√£o de um perfil, se o Expert Advisor est√° anexado a um dos gr√°ficos do perfil alterado;</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1064
¬∑ altera√ß√£o da conta na qual o terminal est√° conectado (se o Expert Advisor estava anexado a um
gr√°fico antes da autoriza√ß√£o do terminal no servidor;
¬∑ calling the ExpertRemove() function.
Em caso de altera√ß√£o de ativo ou per√≠odo de um gr√°fico, no qual o Expert Advisor est√° anexado,
Expert Advisors n√£o s√£o carregados ou descarregados. Neste caso o terminal cliente
subseq√ºentemente chama os handlers OnDeinit() sobre o ativo/per√≠odo antigo e OnInit() sobre o novo
ativo/per√≠odo; valores de vari√°veis globais e vari√°veis est√°ticas n√£o s√£o redefinidos. Todos os
eventos que foram recebidos pelo Expert Advisor antes da inicializa√ß√£o ser conclu√≠da (fun√ß√£o OnInit())
s√£o pulados.
<h3>Carga e Descarga de Scripts</h3>
Scripts s√£o carregados imediatamente ap√≥s eles serem anexados a um gr√°fico e descarregados
imediatamente ap√≥s eles conclu√≠rem sua opera√ß√£o. OnInit() e OnDeinit() n√£o s√£o chamados por
scripts.
Quando um programa √© descarregado (exclu√≠do de um gr√°fico) o terminal cliente realiza a
desinicializa√ß√£o de vari√°veis globais e exclu√≠ a fila de eventos. Neste caso a desinicializa√ß√£o significa
a redefini√ß√£o de todas as vari√°veis de tipo string, desaloca√ß√£o de objetos de array din√¢mico e
chamada de seus destrutores se eles estiverem dispon√≠veis.
<h3>Carga e Descarga de Servi√ßos</h3>
Os servi√ßos s√£o carregados imediatamente ap√≥s o in√≠cio do terminal, se, ao parar o terminal, eles s√£o
iniciados. Os servi√ßos s√£o descarregados imediatamente ap√≥s o t√©rmino de seu trabalho.
Os servi√ßos t√™m um √∫nico manipulador OnStart() no qual voc√™ pode organizar um loop infinito de
recebimento e de processamento de dados, por exemplo, ao criar e atualizar s√≠mbolos personalizados
usando fun√ß√µes de rede.
Ao contr√°rio de EAs, de indicadores e de scripts, os servi√ßos n√£o est√£o vinculados a um gr√°fico
espec√≠fico, portanto, para iniciar o servi√ßo √© fornecido um mecanismo separado. A cria√ß√£o de uma
nova inst√¢ncia do servi√ßo √© feita a partir do Navegador usando o comando Adicionar servi√ßo. Para
iniciar, parar, remover uma inst√¢ncia de servi√ßo, use seu menu. Para gerenciar todas as inst√¢ncias,
use o menu do pr√≥prio servi√ßo.
Para um melhor entendimento do funcionamento de um Expert Advisor, n√≥s recomendamos compilar o
c√≥digo do seguinte Expert Advisor e realizar a√ß√µes de carga/descarga, altera√ß√£o de template,
altera√ß√£o de ativo, altera√ß√£o de per√≠odo, etc:
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                   TestExpert.mq5 |
//|                        Copyright 2009, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1065
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
#property copyright &quot;2009, MetaQuotes Software Corp.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
class CTestClass
  {
</code></pre>
<p>
public:  
</p>
<pre><code class="language-mql5">
   CTestClass() { Print(&quot;CTestClass construtor&quot;); }
   ~CTestClass() { Print(&quot;CTestClass destruidor&quot;); }
</code></pre>
<p>
  };
<h3>CTestClass global;</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   Print(&quot;Inicializa√ß√£o&quot;);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de Desinicializa√ß√£o do Expert                             |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
   Print(&quot;Desinicializa√ß√£o com motivo&quot;,reason);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o tick (ponto) de um Expert                                 |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
</code></pre>
<p>
<h3>Tamb√©m Veja</h3>
Eventos do terminal cliente, Handlers de Evento</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1066
<h3>Trade Permission</h3>
<h3>Trade Automation</h3>
A linguagem MQL5 fornece um grupo especial de fun√ß√µes de negocia√ß√£o projetado para o
desenvolvimento de sistemas de negocia√ß√£o automatizados. Programas desenvolvidos para negocia√ß√£o
automatizada sem interven√ß√£o humana s√£o chamados Expert Advisors ou rob√¥s de negocia√ß√£o. Para
criar um Expert Advisor no MetaEditor, abra o MQL5 Wizard e selecione uma das duas op√ß√µes:
¬∑ Expert Advisor (modelo) ‚Äì permite-lhe criar um modelo com uma fun√ß√£o de manipula√ß√£o de eventos
que devem ser complementados com toda a funcionalidade necess√°ria por meio de programa√ß√£o.
¬∑ Expert 
<h3>Advisor</h3>
(generate) 
‚Äì 
permite 
voc√™ 
desenvolver 
um 
rob√¥ 
de 
negocia√ß√£o
completoSimplesmente selecionando os m√≥dulos necess√°rios: m√≥dulo de negocia√ß√£o de sinais,
m√≥dulo de gerenciamento de dinheiro e m√≥dulo de parada final.
As fun√ß√µes de negocia√ß√£o podem funcionar apenas em Expert Advisors e scripts. A negocia√ß√£o n√£o √©
permitida para os indicadores.
<h3>Verificando</h3>
a 
<h3>Permiss√£o</h3>
para 
<h3>Realizar</h3>
uma 
<h3>Negocia√ß√£o</h3>
<h3>Automatizada</h3>
A fim de desenvolver um Expert Advisor confi√°vel capaz de trabalhar sem interven√ß√£o humana, √©
necess√°rio organizar um conjunto de verifica√ß√µes importantes. Primeiro, devemos verificar
programaticamente se a negocia√ß√£o √© permitida em tudo. Esta √© uma verifica√ß√£o b√°sica que √©
indispens√°vel ao desenvolver qualquer sistema automatizado.
Verifica√ß√£o da permiss√£o para realizar a negocia√ß√£o automatizada no terminal</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1067
As configura√ß√µes de terminal fornecem a voc√™ a capacidade de permitir ou proibir a negocia√ß√£o
automatizada de todos os programas.
Voc√™ pode alternar a op√ß√£o de negocia√ß√£o automatizada diretamente no painel Padr√£o do terminal:  
¬∑
‚Äì negocia√ß√£o automatizada habilitada, fun√ß√µes de negocia√ß√£o em aplicativos
lan√ßados s√£o permitidos para uso.
¬∑
 ‚Äì negocia√ß√£o automatizada desabilitada, as aplica√ß√µes em execu√ß√£o n√£o
conseguem executar fun√ß√µes de negocia√ß√£o. 
<h3>Verificar amostra:</h3>
</p>
<pre><code class="language-mql5">
if (!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED)) 
   Alert(&quot;Verifique se a negocia√ß√£o automatizada √© permitida nas configura√ß√µes do term
</code></pre>
<p>
Verificando se a negocia√ß√£o √© permitida para uma determinada execu√ß√£o do
<h3>Expert Advisor/script</h3>
Voc√™ pode permitir ou proibir a negocia√ß√£o automatizada para um determinado programa ao lan√ß√°-lo.
Para fazer isso, use a caixa de sele√ß√£o especial nas propriedades do programa.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1068
<h3>Verificar amostra:</h3>
</p>
<pre><code class="language-mql5">
   if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))
      Alert(&quot;Verifique se a negocia√ß√£o automatizada √© permitida nas configura√ß√µes do t
   else
     {
      if(!MQLInfoInteger(MQL_TRADE_ALLOWED))
         Alert(&quot;A negocia√ß√£o automatizada √© proibida nas configura√ß√µes do &quot;,__FILE__);
     }
</code></pre>
<p>
Verificando se a negocia√ß√£o √© permitida para qualquer Expert Advisors/scripts
para a conta corrente
A negocia√ß√£o automatizada pode ser desativada no lado do servidor de negocia√ß√£o. Verificar amostra:
</p>
<pre><code class="language-mql5">
   if(!AccountInfoInteger(ACCOUNT_TRADE_EXPERT))
      Alert(&quot;Negocia√ß√£o automatizada √© proibida para a conta &quot;,AccountInfoInteger(ACCO
      &quot; no lado do servidor de negocia√ß√£o&quot;);
</code></pre>
<p>
Se a negocia√ß√£o automatizada estiver desativada para uma conta de negocia√ß√£o, as opera√ß√µes de
negocia√ß√£o de Expert Advisors/scripts n√£o ser√£o executadas.
Verificando se a negocia√ß√£o √© permitida para a conta corrente
Em alguns casos, quaisquer opera√ß√µes de negocia√ß√£o s√£o desativadas para uma determinada conta de
negocia√ß√£o - nem manual nem automatizado de negocia√ß√£o pode ser realizada. Exemplo de verifica√ß√£o
quando uma senha de investidor foi usada para conectar-se a uma conta de negocia√ß√£o:
</p>
<pre><code class="language-mql5">
   if(!AccountInfoInteger(ACCOUNT_TRADE_ALLOWED))
      Comment(&quot;A negocia√ß√£o √© proibida para a conta &quot;,AccountInfoInteger(ACCOUNT_LOGIN
            &quot;.\n Talvez uma senha de investidor tenha sido usada para conectar-se √† co
            &quot;\n Verifique o di√°rio do terminal para a seguinte entrada:&quot;,</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1069
</p>
<pre><code class="language-mql5">
            &quot;\n\&#x27;&quot;,AccountInfoInteger(ACCOUNT_LOGIN),&quot;\&#x27;: negocia√ß√£o foi desativada - 
</code></pre>
<p>
AccountInfoInteger(ACCOUNT_TRADE_ALLOWED) deve retornar falsa nos casos seguintes:
¬∑ Sem 
conex√£o 
com 
o 
servidor 
de 
negocia√ß√£o. 
<h3>Isso</h3>
pode 
ser 
verificado 
usando
<h3>TerminalInfoInteger(TERMINAL_CONNECTED);</h3>
¬∑ Conta de negocia√ß√£o comutada para modo somente leitura (enviada para o arquivo);
¬∑ A negocia√ß√£o na conta √© desativada no lado do servidor de negocia√ß√£o;
¬∑ A conex√£o com uma conta de negocia√ß√£o foi realizada no modo Investidor.
<h3>Veja tamb√©m</h3>
Propriedades do terminal do cliente, Propriedades da Conta, Propriedades de um programa MQL5 em
execu√ß√£o</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1070
<h3>Eventos do Terminal Cliente</h3>
<h3>Init</h3>
Imediatamente ap√≥s o terminal cliente carregar um programa (uma Expert Advisor ou um indicador
customizado) e come√ßar o processo de inicializa√ß√£o de vari√°veis globais, o evento Init ser√° enviado, e
ser√° processado pelo handler de evento OnInit(), caso exista. Este evento tamb√©m √© gerado ap√≥s um
instrumento financeiro e / ou prazo gr√°fico ser alterado, depois de um programa ser recompilado no
MetaEditor, depois dos par√¢metros de entrada serem alterados a partir da janela de configura√ß√£o de
um Expert Advisor ou um indicador personalizado. Um Expert Advisor √© tamb√©m inicializado ap√≥s a
conta ser alterada. O evento Init n√£o √© gerado para scripts.
<h3>Deinit</h3>
Antes de vari√°veis globais serem desinicializadas e o programa (Expert Advisor ou indicador
customizado) ser descarregado, o terminal cliente envia o evento Deinit para o programa. Deinit √©
tamb√©m gerado quando o terminal cliente √© encerrado, quando um gr√°fico √© fechado, logo antes o
ativo e/ou per√≠odo ser alterado, em uma recompila√ß√£o de programa bem sucedida, quando par√¢metros
de input s√£o alterados e quando a conta √© alterada.
O motivo de desinicializa√ß√£o pode ser obtido a partir do par√¢metro passado para a fun√ß√£o OnDeinit().
A execu√ß√£o da fun√ß√£o OnDeinit() est√° restrita a 2.5 segundos. Se durante este tempo a fun√ß√£o n√£o for
conclu√≠da, ent√£o ela √© finalizada de forma for√ßada. O evento Deinit (Desinicializar) n√£o √© gerada para
scripts.
<h3>Start</h3>
Evento Start ‚Äì evento especial para executar um script ou servi√ßo depois que ele √© carregado. Este
evento √© tratado pela fun√ß√£o OnStart. Evento Start n√£o √© enviado para EAs e indicadores
personalizados.
<h3>NewTick</h3>
O evento NewTick √© gerado caso existam novas cota√ß√µes, ele √© processado pelo OnTick() de Expert
Advisors anexados. No caso de uma nova cota√ß√£o ser recebida enquanto a fun√ß√£o OnTick estiver
processando a cota√ß√£o anterior, a nova cota√ß√£o ser√° ignorada pelo Expert Advisor, porque o evento
correspondente n√£o ser√° enfileirado.
Todas as novas cota√ß√µes que s√£o recebidas enquanto o programa est√° rodando s√£o ignoradas at√© que
a execu√ß√£o da fun√ß√£o OnTick() esteja conclu√≠da. Ap√≥s isso, a fun√ß√£o rodar√° somente ap√≥s uma nova
cota√ß√£o ser recebida. O evento NewTick √© gerado independentemente da negocia√ß√£o autom√°tica ser
permitida ou n√£o (bot√£o &quot;AutoTrading Permite/Pro√≠be&quot;). A proibi√ß√£o de negocia√ß√£o autom√°tica
significa somente que o envio de solicita√ß√µes de negocia√ß√£o a partir de um Expert Advisor n√£o √©
permitido, enquanto o Expert Advisor continua trabalhando.
A proibi√ß√£o de negocia√ß√£o autom√°tica ao apertar o bot√£o apropriado n√£o parar√° a execu√ß√£o corrente
da fun√ß√£o OnTick().
<h3>Calculate</h3>
O evento Calculate √© gerado somente para indicadores logo ap√≥s o evento Init ser enviado e em
qualquer altera√ß√£o de dados de pre√ßos. Ele √© processado pela fun√ß√£o OnCalculate.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1071
<h3>Timer</h3>
O evento Timer √© periodicamente gerado pelo terminal cliente para o Expert Advisor que ativou o
timer atrav√©s da fun√ß√£o EventSetTimer. Geralmente, esta fun√ß√£o √© chamada na fun√ß√£o OnInit. O
processamento do evento Timer √© realizado pela fun√ß√£o OnTimer. Ap√≥s a opera√ß√£o do Expert Advisor
estar conclu√≠da, √© necess√°rio destruir o timer usando a fun√ß√£o EventKillTimer, que √© geralmente
chamada na fun√ß√£o OnDeinit.
<h3>Trade</h3>
O evento Trade √© gerado quando uma opera√ß√£o de trade √© conclu√≠da em um servidor de negocia√ß√£o. O
evento Trade √© tratado pela fun√ß√£o OnTrade() para as seguintes opera√ß√µes de negocia√ß√£o:
¬∑ envio, modifica√ß√£o e remo√ß√£o de uma ordem pendente;
¬∑ cancelamento de uma ordem pendente com aus√™ncia de dinheiro suficiente ou expira√ß√£o;
¬∑ ativa√ß√£o de uma ordem pendente;
¬∑ abertura, acr√©scimo ou encerramento de uma posi√ß√£o (ou parte da posi√ß√£o);
¬∑ modifica√ß√£o da posi√ß√£o aberta (altera√ß√£o de stops - Stop Loss e/ou Take Profit).
<h3>TradeTransaction</h3>
Ao realizar algumas a√ß√µes espec√≠ficas em uma conta de negocia√ß√£o, seu estado muda. Tais a√ß√µes
includem:
¬∑ Envio de uma solicita√ß√£o de negocia√ß√£o a partir de algum aplicativo MQL5 no terminal usando as
fun√ß√µes OrderSend e OrderSendAsync e sua posterior execu√ß√£o.
¬∑ Envio de uma solicita√ß√£o de negocia√ß√£o por meio da interface gr√°fica do terminal e sua posterior
execu√ß√£o.
¬∑ Ativa√ß√£o de ordens pendentes e ordens de stop no servidor.
¬∑ Realiza√ß√£o de opera√ß√µes no lado de um servidor de negocia√ß√£o.
As seguintes transa√ß√µes de negocia√ß√£o s√£o realizadas como resultado destas a√ß√µes:
¬∑ tratamento de uma solicita√ß√£o de negocia√ß√£o
¬∑ mudan√ßa de ordens de abertura
¬∑ mudan√ßa de hist√≥rico de ordens
¬∑ mudan√ßa de hist√≥rico de opera√ß√µes (deals)
¬∑ mudan√ßa de posi√ß√µes
Por exemplo, ao enviar uma ordem de compra de mercado, ela √© tratada, uma ordem de compra
apropriada √© criada para a conta, a ordem √© ent√£o executada e removida da lista de ordens em
aberto, e ent√£o ela √© adicionada ao hist√≥rico de ordens, uma apropriada opera√ß√£o (deal) √© adicionada
ao hist√≥rico e uma nova posi√ß√£o √© criada. Todas estas a√ß√µes s√£o transa√ß√µes de negocia√ß√£o. A chegada
de tal transa√ß√£o no terminal √© um evento TradeTransaction. Este evento √© tratado pela fun√ß√£o
OnTradeTransaction.
<h3>Tester</h3>
O evento Tester √© gerado ap√≥s um teste de um Expert Advisor sob dados de hist√≥rico ter acabado. O
evento √© tratado pela fun√ß√£o OnTester().</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1072
<h3>TesterInit</h3>
O evento TesterInit √© gerado no in√≠cio de uma otimiza√ß√£o no Provador de Estrat√©gia antes do primeiro
passo de otimiza√ß√£o. O evento TesterInit √© tratado pela fun√ß√£o OnTesterInit().
<h3>TesterPass</h3>
O evento TesterPass √© gerado quando uma nova estrutura de dados √© recebido. O evento TesterPass √©
tratado pela fun√ß√£o OnTesterPass().
<h3>TesterDeinit</h3>
O evento TesterDeinit √© gerado ap√≥s o fim de um otimiza√ß√£o de um Expert Advisor no Provador de
Estrat√©gia. O evento TesterDeinit √© tratado pela fun√ß√£o OnTesterDeinit().
<h3>ChartEvent</h3>
O evento ChartEvent  √© gerado  pelo terminal cliente quando um usu√°rio est√° trabalhando com um
gr√°fico:
¬∑ pressionar de teclado, quando a janela de gr√°fico est√° com foco
¬∑ objeto gr√°fico criado
¬∑ objeto gr√°fico exclu√≠do
¬∑ pressionar de mouse sobre um objeto gr√°fico do gr√°fico
¬∑ movimenta√ß√£o do objeto gr√°fico usando o mouse
¬∑ fim de edi√ß√£o de texto no LabelEdit
Tamb√©m existe o evento customizado ChartEvent, que pode ser enviado para um Expert Advisor
atrav√©s de qualquer programa mql5 por meio do uso da fun√ß√£o EventChartCustom. O evento √©
processado pela fun√ß√£o OnChartEvent.
<h3>BookEvent</h3>
O evento BookEvent √© gerado pelo terminal cliente ap√≥s a Profundida de Mercado ser alterada; ele √©
processado pela fun√ß√£o OnBookEvent. Para come√ßar a gera√ß√£o de BookEvent para um ativo
especificado, √© necess√°rio subscrever o ativo para este evento atrav√©s do uso da fun√ß√£o
MarketBookAdd.
Para desfazer a subscri√ß√£o de BookEvent para um ativo especificado, √© necess√°rio chamar a fun√ß√£o
MarketBookRelease. O evento BookEvent √© um evento do tipo-transmiss√£o - isso significa que √©
suficiente inscrever apenas um Consultor Especializado (Expert Advisor) para este evento, e todos os
outros Consultores Especializados (Expert Advisors) que t√™m o manipulador de eventos OnBookEvent,
v√£o receb√™-lo. √â por isso que √© necess√°rio analisar o nome do ativo, que √© passado para um handler
como um par√¢metro.
<h3>Tamb√©m Veja</h3>
<h3>Handlers de Evento, Execu√ß√£o de Programa</h3></p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1073
<h3>Recursos</h3>
Usando gr√°ficos e som em programas MQL5
Programas em MQL5 permitem trabalhar com som e arquivos gr√°ficos:
¬∑ PlaySound() executa um arquivo de som.
¬∑ ObjectCreate() permite criar interfaces de usu√°rio usando os objetos gr√°ficos OBJ_BITMAP e
OBJ_BITMAP_LABEL. 
<h3>PlaySound()</h3>
<h3>Exemplo de chamada da fun√ß√£o PlaySound():</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| A fun√ß√£o chama OrderSend() padr√£o e toca um som¬†                 |
//+------------------------------------------------------------------+
void OrderSendWithAudio(MqlTradeRequest  &amp;request, MqlTradeResult &amp;result)
  {
  //--- envia uma solicita√ß√£o para um servidor
   OrderSend(request,result);
   //--- se a solicita√ß√£o for aceite, executa o som Ok.wav
   if(result.retcode==TRADE_RETCODE_PLACED) PlaySound(&quot;Ok.wav&quot;);
   //--- se falhar, toca um alarme a partir do arquivo timeout.wav
   else PlaySound(&quot;timeout.wav&quot;);
</code></pre>
<p>
  }
O exemplo mostra como tocar sons a partir de arquivos &#x27;Ok.wav&#x27; e &#x27;timeout.wav&#x27;, que est√£o inclu√≠dos
no pacote do terminal padr√£o. Estes arquivos est√£o localizados na pasta terminal_directory\Sounds.
Aqui, terminal_directory √© uma pasta, a partir do qual o terminal de cliente da MetaTrader 5 √©
iniciado. A localiza√ß√£o do diret√≥rio do terminal pode ser encontrado a partir de um programa MQL5 da
seguinte forma:
</p>
<pre><code class="language-mql5">
//--- Pasta, na qual dados de terminal s√£o armazenados
   string terminal_path=TerminalInfoString(TERMINAL_PATH);
</code></pre>
<p>
Voc√™ pode usar arquivos de som n√£o somente da pasta terminal_directory\Sounds, mas tamb√©m de
qualquer sub-pasta localizada em terminal_data_directory\MQL5. Voc√™ pode descobrir a localiza√ß√£o
do diret√≥rio de dados do terminal a partir do menu do terminal &quot;Arquivo&quot; -&gt; &quot;Abrir&quot; dados do terminal
ou usar um m√©todo de programa:
</p>
<pre><code class="language-mql5">
//--- Pasta, na qual dados de terminal s√£o armazenados
   string terminal_data_path=TerminalInfoString(TERMINAL_DATA_PATH);
</code></pre>
<p>
Por exemplo, se o arquivo de som &#x27;Demo.wav&#x27; est√° localizado em terminal_data_directory\MQL5\Files,
ent√£o a chamada de PlaySound() deveria ser escrita da seguinte forma:
</p>
<pre><code class="language-mql5">
//--- toca Demo.wav a partir da pasta terminal_directory_data\MQL5\Files\Demo.wav
   PlaySound(&quot;\\Files\\Demo.wav&quot;);</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1074
Observe que no coment√°rio o caminho do arquivo est√° escrito usando uma barra invertida &quot;\&quot;, e na
fun√ß√£o √© usado &quot;\\&quot;.
Ao se especificar o caminho, sempre use barras invertidas duplas como separador, porque uma √∫nica
barra invertida √© um controle de s√≠mbolo para o compilador ao lidar com constantes de cadeias de
caracteres e constantes de caracteres no c√≥digo fonte do programa. 
Call PlaySound() function with NULL parameter to stop playback:
</p>
<pre><code class="language-mql5">
//--- Chamar o PlaySound() com par√¢metro NULL interrompe a reprodu√ß√£o
   PlaySound(NULL);
</code></pre>
<p>
<h3>ObjectCreate()</h3>
Exemplo de um Expert Advisor, que cria um r√≥tulo gr√°fico (OBJ_BITMAP_LABEL) usando a fun√ß√£o
ObjectCreate().
</p>
<pre><code class="language-mql5">
string label_name=&quot;currency_label&quot;;        // nome do objeto OBJ_BITMAP_LABEL
string euro      =&quot;\\Images\\euro.bmp&quot;;    // caminho do arquivo terminal_dara_directo
string dollar    =&quot;\\Images\\dollar.bmp&quot;;  // caminho do arquivo terminal_dara_directo
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- cria um bot√£o OBJ_BITMAP_LABEL, se ele j√° n√£o tiver sido criado
   if(ObjectFind(0,label_name)&lt;0)
     {
      //--- tenta criar objeto OBJ_BITMAP_LABEL
      bool created=ObjectCreate(0,label_name,OBJ_BITMAP_LABEL,0,0,0);
      if(created)
        {
         //--- vincula o bot√£o ao canto superior esquerdo do gr√°fico
         ObjectSetInteger(0,label_name,OBJPROP_CORNER,CORNER_RIGHT_UPPER);
         //--- agora configura as propriedades do objeto
         ObjectSetInteger(0,label_name,OBJPROP_XDISTANCE,100);
         ObjectSetInteger(0,label_name,OBJPROP_YDISTANCE,50);
         //--- redefine o c√≥digo do √∫ltimo erro para 0
         ResetLastError();
         //--- carrega uma figura para indicador o estado &quot;Pressionado&quot; do bot√£o
         bool set=ObjectSetString(0,label_name,OBJPROP_BMPFILE,0,euro);
         //--- testa o resultado
         if(!set)
           {
            PrintFormat(&quot;Falha no download a partir do arquivo de imagem %s. C√≥digo de
           }
         ResetLastError();
         //--- carrega uma figura para indicador do estado &quot;N√£o pressionado&quot; do bot√£o</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1075
</p>
<pre><code class="language-mql5">
         set=ObjectSetString(0,label_name,OBJPROP_BMPFILE,1,dollar);
         
         if(!set)
           {
            PrintFormat(&quot;Falha no download a partir do arquivo de imagem %s. C√≥digo de
           }
         //--- envia um comando para um gr√°fico para reatualiza√ß√£o, a fim de que o bot
         ChartRedraw(0);
        }
      else
        {
         //--- falha ao criar um objeto, notificar
         PrintFormat(&quot;Falha ao criar objeto OBJ_BITMAP_LABEL. Error code %d&quot;,GetLastEr
        }
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de Desinicializa√ß√£o do Expert                             |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- exclui um objeto de um gr√°fico
   ObjectDelete(0,label_name);
</code></pre>
<p>
  }
A cria√ß√£o e configura√ß√£o do objeto gr√°fico de nome currency_label s√£o executados na fun√ß√£o OnInit().
Os caminhos para os arquivos gr√°ficos s√£o definidos nas vari√°veis globais euro e dollar, uma barra
invertida dupla √© usada como separador:
</p>
<pre><code class="language-mql5">
string euro      =&quot;\\Images\\euro.bmp&quot;;    // caminho do arquivo terminal_dara_directo
string dollar    =&quot;\\Images\\dollar.bmp&quot;;  // caminho do arquivo terminal_dara_directo
</code></pre>
<p>
Os arquivos est√£o localizados na pasta terminal_data_directory\MQL5\Images.
O Objeto OBJ_BITMAP_LABEL √© na realizada um bot√£o, que exibe uma das duas imagens, dependendo
do estado do bot√£o (pressionado ou n√£o pressionado): euro.bmp ou dollar.bmp.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1076
O tamanho do bot√£o com uma interface gr√°fico √© automaticamente ajustada para o tamanho da
figura. A imagem √© alterada por um clique do bot√£o esquerdo do mouse sob o objeto
OBJ_BITMAP_LABEL (&quot;Disable selection&quot; deve estar definida nas propriedades). O objeto
OBJ_BITMAP √© criado da mesma forma - ele √© usado para criar o pano de fundo com um imagem
necess√°ria. 
O valor da propriedade OBJPROP_BMPFILE, que √© respons√°vel pela apar√™ncia dos objetos OBJ_BITMAP
e OBJ_BITMAP_LABEL, e pode ser alterado dinamicamente. Isso permite criar v√°rias interfaces
interativas de usu√°rio para programas MQL5.
Inclus√£o de recursos em arquivos execut√°veis durante compila√ß√£o
de programas MQL5
Um programa mql5 pode precisar de um monte de diferentes recursos baix√°veis na forma de arquivos
de imagem e som. A fim de eliminar a necessidade de transferir todos estes arquivos ao mover um
arquivo execut√°vel em MQL5, a diretriz do compilador #resource deve ser usada:
 #resource path_to_resource_file
O comando #resource diz ao compilador que o recurso no caminho especificado path_to_resource_file
deve ser inclu√≠do dentro do arquivo execut√°vel EX5. Assim, todos os sons e imagens necess√°rios
podem ser alocados diretamente dentro de um arquivo EX5, de modo que n√£o exista necessidade de
transferir separadamente os arquivos nele usados, caso voc√™ queira executar o programa em um
terminal diferente. Qualquer arquivo EX5 pode conter recursos, e qualquer programa EX5 pode usar
recursos de um outro programa EX5.
Os arquivo em formato BMP e WAV s√£o automaticamente comprimidos antes de serem inclu√≠dos em
um arquivo EX5. Isso significa que al√©m de criar programas completos em MQL5, o uso de recursos
tamb√©m permite reduzir o tamanho total dos arquivos necess√°rios ao usar gr√°ficos e sons, quando
comparado com a forma usual de escrever um programa MQL5.
O arquivo de recurso n√£o deve exceder 16 Mb.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1077
<h3>Busca por recursos espec√≠ficos pelo compilador</h3>
Um recurso √© inserido usando o comando #resorce &quot;&lt;path to the resource file&gt;&quot;
 #resource &quot;&lt;path_to_resource_file&gt;&quot;
O comprimento da constante string &lt;path_to_resource_file&gt; n√£o de exceder 63 caracteres.
O compilador busca por um recurso no caminho especificado na seguinte ordem:
¬∑ se o separador barra invertida &quot;\&quot; (escrito como &quot;\\&quot;) √© colocado no come√ßo do caminho, ele busca
pelo recurso referente ao diret√≥rio terminal_data_directory\MQL5\,
¬∑ se n√£o houver barra invertida, ele busca pelo recurso referente √† localiza√ß√£o do arquivo de recurso,
na qual o recurso foi escrito.
O caminho do recurso n√£o pode conter as sub-cadeias &quot;..\\&quot; e &quot;:\\&quot;.
<h3>Exemplos de inclus√£o de recurso:</h3>
</p>
<pre><code class="language-mql5">
//--- correct specification of resources
</code></pre>
<p>
#resource &quot;\\Images\\euro.bmp&quot; // euro.bmp est√° localizado em terminal_data_directory\
#resource &quot;picture.bmp&quot;        // picture.bmp est√° localizado no mesmo diretoria que o
#resource &quot;Resource\\map.bmp&quot;  // O recurso est√° localizado em source_file_directory\R
</p>
<pre><code class="language-mql5">
//--- especifica√ß√£o incorreta de recursos
</code></pre>
<p>
#resource &quot;:picture_2.bmp&quot;     // n√£o deve conter &quot;:&quot;
#resource &quot;..\\picture_3.bmp&quot;  // n√£o deve conter &quot;..&quot;
#resource &quot;\\Files\\Images\\Folder_First\\My_panel\\Labels\\too_long_path.bmp&quot; //mais 
<h3>Uso de Recursos</h3>
<h3>Nome de recurso</h3>
Ap√≥s um recurso ser declarado usando a diretiva #resource, ele pode ser usado em qualquer parte de
um programa. O nome do recurso √© seu caminho sem uma barra invertida no come√ßo da linha, que
define o caminho do recurso. Para usar seu pr√≥prio recurso no c√≥digo, o sinal especial &quot;::&quot; deve ser
adicionado antes do nome do recurso.
<h3>Exemplos:</h3>
</p>
<pre><code class="language-mql5">
//--- exemplos de especifica√ß√£o de recurso e seus nomes em coment√°rios
</code></pre>
<p>
#resource &quot;\\Images\\euro.bmp&quot;          // nome do recurso - Images\euro.bmp
#resource &quot;picture.bmp&quot;                 // nome do recurso - picture.bmp
#resource &quot;Resource\\map.bmp&quot;           // nome do recurso - Resource\map.bmp
#resource &quot;\\Files\\Pictures\\good.bmp&quot; // nome do recurso - Files\Pictures\good.bmp
#resource &quot;\\Files\\Demo.wav&quot;;          // nome do recurso - Files\Demo.wav&quot;
#resource &quot;\\Sounds\\thrill.wav&quot;;       // nome do recurso - Sounds\thrill.wav&quot;
...                                  </p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1078
</p>
<pre><code class="language-mql5">
//--- utiliza√ß√£o dos recursos
</code></pre>
<p>
ObjectSetString(0,bitmap_name,OBJPROP_BMPFILE,0,&quot;::Images\\euro.bmp&quot;);
...
ObjectSetString(0,my_bitmap,OBJPROP_BMPFILE,0,&quot;::picture.bmp&quot;);
...
set=ObjectSetString(0,bitmap_label,OBJPROP_BMPFILE,1,&quot;::Files\\Pictures\\good.bmp&quot;);
...
<h3>PlaySound(&quot;::Files\\Demo.wav&quot;);</h3>
...
<h3>PlaySound(&quot;::Sounds\\thrill.wav&quot;);</h3>
Deve se notar que ao definir imagens a partir de um recurso para os objetos OBJ_BITMAP e
OBJ_BITMAP_LABEL, o valor da propriedade OBJPROP_BMPFILE n√£o pode ser modificado manualmente.
Por exemplo, para criar OBJ_BITMAP_LABEL n√≥s usados euro.bmp e dollar.bmp.
#resource &quot;\\Images\\euro.bmp&quot;;    // euro.bmp est√° localizado em terminal_data_direct
#resource &quot;\\Images\\dollar.bmp&quot;;  // dollar.bmp est√° localizado em terminal_data_dire
Ao visualizar as propriedades deste objeto, veremos que as propriedades BitMap File (On) e BitMap
File (Off) s√£o esmaecidas e n√£o podem ser alteradas manualmente:
Usando os recursos em outros programas MQL5
Existe uma outra vantagem no uso de recurso ‚Äì em qualquer programa MQL5, os recursos de um outro
arquivo EX5 podem ser usados. Assim, os recursos de um arquivo EX5 podem ser usados em muitos
outros programas MQL5.
A fim de usar um nome de recurso de um outro arquivo, ele deve ser especificado como
&lt;path_EX5_file_name&gt;::&lt;resource_name&gt;. 
<h3>Por</h3>
exemplo, 
suponha 
que 
o 
script
Draw_Triangles_Script.mq5 cont√©m um recurso para uma imagem no arquivo triangle.bmp:
 #resource &quot;\\Files\\triangle.bmp&quot;</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1079
Ent√£o seu nome, para uso no script em si, se assemelhar√° a &quot;Files\triangle.bmp&quot;, e a fim de us√°-lo,
&quot;::&quot; deve ser adicionado ao nome do recurso.
</p>
<pre><code class="language-mql5">
//--- usando o curso no script
</code></pre>
<p>
ObjectSetString(0,my_bitmap_name,OBJPROP_BMPFILE,0,&quot;::Files\\triangle.bmp&quot;);
A fim de usar o mesmo recurso a partir de um outro programa, por exemplo, a partir de um Expert
Advisor, precisamos adicionar ao nome do recurso o caminho para o arquivo EX5 correspondente ao
terminal_data_directory\MQL5\ e o nome arquivo EX5 do script - Draw_Triangles_Script.ex5.
Suponha que o script est√° localizado na pasta padr√£o terminal_data_directory\MQL5\Scripts\, ent√£o
o chamado deve ser escrito da seguinte forma:
</p>
<pre><code class="language-mql5">
//--- usando um recurso de um script em um EA
</code></pre>
<p>
ObjectSetString(0,my_bitmap_name,OBJPROP_BMPFILE,0,&quot;\\Scripts\\Draw_Triangles_Script.e
Se o caminho para o arquivo execut√°vel n√£o for especificado ao chamar o recurso de um outro EX5, o
arquivo execut√°vel √© procurado na mesma pasta que cont√©m o programa que chama o recurso. Isso
significa que se um Expert Advisor chamar um recurso de Draw_Triangles_Script.ex5 sem especificar o
caminho, como abaixo:
</p>
<pre><code class="language-mql5">
//--- chama recurso de script em um EA sem especificar o caminho
</code></pre>
<p>
ObjectSetString(0,my_bitmap_name,OBJPROP_BMPFILE,0,&quot;Draw_Triangles_Script.ex5::Files\\
ent√£o o arquivo ser√° procurado na pasta terminal_data_directory\MQL5\Experts\, caso o Expert
Advisor esteja localizado em terminal_data_directory\MQL5\Experts\.
Trabalhando com indicadores personalizados que est√£o conectados como
recursos
O funcionamento de programas MQL5 pode exigir um ou mais indicadores personalizados, eles podem
ser inclu√≠dos no c√≥digo do programa execut√°vel MQL5. A inclus√£o de indicadores como recursos
simplifica a distribui√ß√£o de programas.
Exemplo de conex√£o e utiliza√ß√£o do indicador personalizado SampleIndicator.ex5, localizado na pasta:
diret√≥rio_de_dados_do_terminal\MQL5\Indicators\:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                     SampleEA.mq5 |
//|                        Copyright 2013, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
</code></pre>
<p>
#resource &quot;\\Indicators\\SampleIndicator.ex5&quot;
</p>
<pre><code class="language-mql5">
int handle_ind;
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   handle_ind=iCustom(_Symbol,_Period,&quot;::Indicators\\SampleIndicator.ex5&quot;);</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1080
</p>
<pre><code class="language-mql5">
   if(handle_ind==INVALID_HANDLE)
     {
      Print(&quot;Expert: iCustom call: Error code=&quot;,GetLastError());
      return(INIT_FAILED);
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
Os casos em que o indicador personalizado, na fun√ß√£o OnInit(), cria uma ou mais c√≥pias de si mesmo
exigem uma an√°lise separada. Lembre-se que para usar um recurso a partir de um programa mql5, √©
preciso especific√°-lo no formato:  &lt;caminho_do_nome_do_arquivo_EX5&gt;::&lt;nome_do_recurso&gt;.
Por exemplo, se o indicador SampleIndicator.ex5 estiver inclu√≠do no Expert Advisor SampleEA.ex5
como um recurso, ent√£o o caminho para si mesmo ser√° especificado ao chamar iCustom() na fun√ß√£o
de 
inicializa√ß√£o 
do 
indicador 
personalizado, 
isso 
ser√° 
da 
seguinte 
forma: 
&quot;\\Experts\
\SampleEA.ex5::Indicators\\SampleIndicator.ex5&quot;. Se for definido explicitamente o caminho, o
indicador personalizado SampleIndicator.ex5 ser√° firmemente ligado ao Advisor SampleEA.ex5 e
perder√° a capacidade de trabalhar de forma independente.
O caminho para si mesmo pode ser obtido utilizando a fun√ß√£o GetRelativeProgramPath(), a seguir, um
exemplo de utiliza√ß√£o:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                              SampleIndicator.mq5 |
//|                        Copyright 2013, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property indicator_separate_window
#property indicator_plots 0
int handle;
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- maneira errada para especificar uma refer√™ncia para si pr√≥prio
//--- string path=&quot;\\Experts\\SampleEA.ex5::Indicators\\SampleIndicator.ex5&quot;;   
//--- maneira correta para obter uma refer√™ncia a si mesmo
</code></pre>
<p>
  string path=GetRelativeProgramPath();
</p>
<pre><code class="language-mql5">
//--- indicator buffers mapping
   handle=iCustom(_Symbol,_Period,path,0,0);
   if(handle==INVALID_HANDLE)
     {
      Print(&quot;Indicator: iCustom call: Error code=&quot;,GetLastError());
      return(INIT_FAILED);
     }
   else Print(&quot;Indicator handle=&quot;,handle);
//---
   return(INIT_SUCCEEDED);</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1081
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| GetRelativeProgramPath                                           |
//+------------------------------------------------------------------+
string GetRelativeProgramPath()
  {
   int pos2;
//--- obtemos o caminho absoluto para o programa
   string path=MQLInfoString(MQL_PROGRAM_PATH);
//--- encontramos a posi√ß√£o da sub-cadeia de caracteres &quot;\MQL5\&quot;
   int    pos =StringFind(path,&quot;\\MQL5\\&quot;);
//--- sub-cadeia n√£o encontrada - erro
   if(pos&lt;0)
      return(NULL);
//--- ignoramos o diret√≥rio &quot;\MQL5&quot;
   pos+=5;
//--- ignoramos &#x27;\&#x27; extras
   while(StringGetCharacter(path,pos+1)==&#x27;\\&#x27;)
      pos++;
//--- se se tratar de um recurso, retornamos o caminho em rela√ß√£o ao diret√≥rio MQL5
   if(StringFind(path,&quot;::&quot;,pos)&gt;=0)
      return(StringSubstr(path,pos));
//--- encontramos o delimitador para o primeiro sub-diret√≥rio em MQL5 (por exemplo, MQ
//--- se ele n√£o existir, retornamos o caminho em rela√ß√£o ao diret√≥rio MQL5
   if((pos2=StringFind(path,&quot;\\&quot;,pos+1))&lt;0)
      return(StringSubstr(path,pos));
//--- retornamos o caminho em rela√ß√£o ao sub-diret√≥rio (–Ω–∞–ø—Ä–∏–º–µ—Ä, MQL5\Indicators)
   return(StringSubstr(path,pos2+1));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,        
                const double&amp; price[])
  {
//--- Valor de retorno do prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
<h3>Vari√°veis de recurso</h3>
Os recursos podem ser declarados usando as vari√°veis de recurso, e trat√°-los como se fossem uma
vari√°vel do tipo apropriado. Formato do declara√ß√£o:
#resource caminho_para_o_arquivo_do_recurso as tipo_de_vari√°vel_de_recurso nome_de_var</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1082
<h3>Exemplos de declara√ß√£o:</h3>
#resource &quot;data.bin&quot; as int ExtData[]             // declara√ß√£o de matriz de tipo num√©
#resource &quot;data.bin&quot; as MqlRates ExtData[]        // declara√ß√£o de matriz de estrutura
</p>
<pre><code class="language-mql5">
//--- cadeias de caracteres
</code></pre>
<p>
#resource &quot;data.txt&quot; as string ExtCode            // declara√ß√£o de cadeias de caracter
</p>
<pre><code class="language-mql5">
//--- recursos gr√°ficos
</code></pre>
<p>
#resource &quot;image.bmp&quot; as bitmap ExtBitmap[]       // declara√ß√£o de matriz unidimension
#resource &quot;image.bmp&quot; as bitmap ExtBitmap2[][]    // declara√ß√£o de matriz bidimensiona
Ao utilizar tal declara√ß√£o, os dados deste recurso podem ser tratados por interm√©dio de uma vari√°vel,
o endere√ßamento autom√°tico via &quot;::&lt;rsource name&gt;&quot; n√£o funciona. 
#resource &quot;\\Images\\euro.bmp&quot; as bitmap euro[][]
#resource &quot;\\Images\\dollar.bmp&quot;
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|  Fun√ß√£o de cria√ß√£o de objeto OBJ_BITMAP_LABEL usando o recurso|
//+------------------------------------------------------------------+
void Image(string name,string rc,int x,int y)
  {
   ObjectCreate(0,name,OBJ_BITMAP_LABEL,0,0,0);
   ObjectSetInteger(0,name,OBJPROP_XDISTANCE,x);
   ObjectSetInteger(0,name,OBJPROP_YDISTANCE,y);
   ObjectSetString(0,name,OBJPROP_BMPFILE,rc);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de in√≠cio do programa script                              |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- imprimimos os tamanhos da imagem [width, height], que √© armazenada na vari√°vel d
   Print(ArrayRange(euro,1),&quot;, &quot;,ArrayRange(euro,0));
//--- alteramos a imagem no euro - desenhamos uma faixa horizontal no meio
   for(int x=0;x&lt;ArrayRange(euro,1);x++)
      euro[ArrayRange(euro,1)/2][x]=0xFFFF0000;
//--- criamos o recurso gr√°fico usando a vari√°vel de recurso
   ResourceCreate(&quot;euro_icon&quot;,euro,ArrayRange(euro,1),ArrayRange(euro,0),0,0,ArrayRang
//--- criamos objeto do r√≥tulo gr√°fico Euro, para o qual colocamos a imagem a partir d
   Image(&quot;Euro&quot;,&quot;::euro_icon&quot;,10,40);
//--- outro modo de utilizar o recurso, n√≥s n√£o podemos desenhar nele
   Image(&quot;USD&quot;,&quot;::Images\\dollar.bmp&quot;,15+ArrayRange(euro,1),40);
//--- a maneira direta de endere√ßamento para o recurso euro.bmp n√£o est√° dispon√≠vel, u
   Image(&quot;E2&quot;,&quot;::Images\\euro.bmp&quot;,20+ArrayRange(euro,1)*2,40); // acontece o erro de 
</code></pre>
<p>
  }
Resultado de execu√ß√£o do script, est√£o criados apenas dois objetos OBJ_BITMAP_LABEL de tr√™s. Ao
mesmo tempo, na imagem do primeiro objeto, n√≥s vemos uma linha vermelha no meio.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1083
Uma vantagem importante do uso de recursos √© que os arquivos de recurso - antes de serem inclu√≠dos
num arquivo EX5 execut√°vel e compilados - s√£o comprimidos automaticamente. Assim, o uso de
vari√°veis ‚Äãde recurso permite n√£o s√≥ empacotar diretamente os dados necess√°rios num arquivo EX5
execut√°vel, mas tamb√©m reduzir o n√∫mero e o tamanho total dos arquivos em compara√ß√£o com o
m√©todo convencional de escrita de programas MQL5.
A utiliza√ß√£o de vari√°veis de recurso √© particularmente √∫til para publicar produtos no Mercado.
<h3>Caracter√≠sticas</h3>
¬∑ O tipo especial de vari√°vel de recurso bitmap informa ao compilador que o recurso √© uma
representa√ß√£o gr√°fica. Essas vari√°veis recebem o tipo uint. 
¬∑ A matriz-vari√°vel de recurso de tipo bitmap pode ter duas dimens√µes, neste caso, o tamanho da
matriz ser√° definido como [altura_de_imagem][largura_de_imagem]. No caso de uma matriz
unidimensional, 
o 
n√∫mero 
de 
elementos 
ser√° 
definido 
como 
o 
produto 
de
altura_de_imagem*largura_de_imagem.
¬∑ Ao carregar imagens de 24 bits, para todos os pixels da imagem de componente de canal-alfa,
define-se como 255.
¬∑ Ao carregar imagens de 32 bits, para todos os pixels da imagem de componente de canal-alfa,
define-se como 255.
¬∑ Ap√≥s carregar uma imagem de 32 bits com canal-alfa n√£o acontece nenhuma manipula√ß√£o de pixels.
¬∑ O tamanho do arquivo de recurso n√£o pode ser maior do que 128 MB.
¬∑ Para arquivos de sequ√™ncia de caracteres, a codifica√ß√£o de BOM (cabe√ßalho) √© detectada
automaticamente. Se n√£o houver nenhum BOM, a codifica√ß√£o ser√° determinada pelo conte√∫do. S√£o
suportados arquivos codificados em ANSI, UTF-8 e UTF-16. Todas as cadeias de caracteres s√£o
convertidas para Unicode.
<h3>Programas em OpenCL</h3></p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1084
A utiliza√ß√£o de vari√°veis - de sequ√™ncias de caracteres - de recurso pode facilitar muito a escrita de
alguns programas. Por exemplo, voc√™ pode escrever o c√≥digo de um programa OpenCL num arquivo CL
separado e, em seguida, incluir esse arquivo - como uma cadeia de caracteres - nos recursos de seu
programa MQL5. 
#resource &quot;seascape.cl&quot; as string cl_program
...
</p>
<pre><code class="language-mql5">
int context;
</code></pre>
<p>
if((cl_program=CLProgramCreate(context,cl_program)!=INVALID_HANDLE)
</p>
<pre><code class="language-mql5">
  {
   //--- executa a√ß√µes futuras com o programa OpenCL
</code></pre>
<p>
  }
Neste exemplo, sem a utiliza√ß√£o de uma vari√°vel de recursocl_program, voc√™ teria de descrever esse
c√≥digo como uma vari√°vel de cadeia grande.
<h3>Veja Tamb√©m</h3>
ResourceCreate(), ResourceSave(), PlaySound(), ObjectSetInteger(), ChartApplyTemplate(), Fun√ß√µes
de Arquivo</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1085
<h3>Chamadas de Fun√ß√µes Importadas</h3>
Para importar fun√ß√µes durante a execu√ß√£o de um programa-mql5, o terminal cliente usar &quot;early
binding&quot;. Isso significa que se um programa tem uma chamada de uma fun√ß√£o importada, o
correspondente m√≥dulo (ex5 ou dll) √© carregada durante a carga do programa. MQL5 e bibliotecas DLL
s√£o executadas na thread do m√≥dulo da chamada.
N√£o √© recomendado usar o nome do m√≥dulo com especifica√ß√£o completa para ser carregado, como
Drive:\Directory\FileName.Ext. 
<h3>As</h3>
bibliotecas 
<h3>MQL5</h3>
s√£o 
carregadas 
a 
partir 
da 
pasta
terminal_dir\MQL5\Libraries. Se a biblioteca n√£o for encontrada, ent√£o o terminal tenta carreg√°-la a
partir da pasta terminal_dir\experts. 
As bibliotecas de sistema (DLL) s√£o carregadas pelas regras do sistema operacional. Se a biblioteca j√°
estiver carregada (por exemplo, um outro Expert Advisor, e mesmo a partir de um outro terminal
cliente, executando em paralelo, ent√£o ele faz solicita√ß√µes para a biblioteca j√° carregada. Caso
contr√°rio, ele realiza uma busca na seguinte seq√º√™ncia:
1. Diret√≥rio do qual o m√≥dulo que importa a dll foi iniciado. O m√≥dulo aqui √© um Expert Advisor, um
script, um indicador ou uma biblioteca EX5.
2. Diret√≥rio terminal_data_directory\MQL5\Libraries (TERMINAL_DATA_PATH\MQL5\Libraries).
3. Diret√≥rio do qual o terminal cliente MetaTrader 5 foi iniciado.
4. Diret√≥rio de sistema.
5. Diret√≥rio do Windows.
6. Diret√≥rio corrente.
7. Diret√≥rios listados na vari√°vel de sistema PATH.
Se uma biblioteca DLL usa uma outra DLL no seu funcionamento, a primeira DLL n√£o pode ser
carregada no caso de n√£o existir a segunda DLL.
Antes de um Expert Advisor (script, indicador) ser carregado, uma lista comum de todos os m√≥dulos
de biblioteca EX5 √© formada. Vai ser usado a partir de um Expert Advisor carregado(script, indicador)e
das bibliotecas desta lista. Assim, √© necess√°rio apenas uma √∫nica carga de m√≥dulos de bibliotecas EX5
usadas muitas vezes. Bibliotecas usam vari√°veis predefinidas do Expert Advisor (script, indicador) que
as chamam.
A biblioteca importada EX5 √© procurada na seguinte seq√º√™ncia:
1. Diret√≥rio, caminho correspondente ao diret√≥rio do Expert Advisor (script, indicador) que importa o
EX5).
2. Diret√≥rio terminal_directory\MQL5\Libraries.
3. Diret√≥rio MQL5\Libraries no diret√≥rio comum a todos os terminais clientes MetaTrader 5
(Common\MQL5\Libraries).
Fun√ß√µes importadas DLL em um programa-mql5 devem garantir a conformidade de chamadas do
Windows API. Para garantir tal conformidade, no texto fonte de programas escritos em C ou C++, use
a palavra-chave _stdcall, que √© espec√≠fico para os compiladores Microsoft(r). Esta conformidade √©
caraterizada pelo seguinte:
¬∑ Chamador (no nosso caso, √© um programa-mql5) deve &quot;ver&quot; um proto-tipo de uma fun√ß√£o chamada
(importado da DLL), a fim de combinar par√¢metros em uma pilha de forma apropriada.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1086
¬∑ Chamador (em nosso caso, √© um programa-mql5) coloca par√¢metros na pilha em uma ordem
reversa, da direita para esquerda - nesta ordem uma fun√ß√£o l√™ os par√¢metros passados para ela.
¬∑ par√¢metros s√£o passados por valor, exceto aqueles explicitamente passados por refer√™ncia (em
nossos casos de strings)
¬∑ Uma fun√ß√£o importada limpa a pilha de forma independente atrav√©s da leitura dos par√¢metros
passados para ela.
Ao descrever o proto-tipo de uma fun√ß√£o importada, par√¢metros padr√£o podem ser usados.
Se a biblioteca correspondente √© incapaz de ser carregada, ou existe uma proibi√ß√£o quanto ao uso da
DLL, ou a fun√ß√£o importada n√£o √© encontrada - o Expert Advisor interrompe sua opera√ß√£o com a
mensagem apropriada &quot;Expert Advisor stopped&quot; no Di√°rio (arquivo de log). Neste caso o Expert
Advisor n√£o rodar√° at√© ser reiniciado. Um Expert Advisor pode ser reiniciado como resultado de
recompila√ß√£o ou ap√≥s a tabela de suas propriedades ser aberto e OK ser pressionado.
<h3>Passando Par√¢metros</h3>
Todos os par√¢metros de tipos simples s√£o passados por valor a menos que sejam explicitamente
indicados que eles devem ser passados por refer√™ncia. Quando uma string √© passada, o endere√ßo do
buffer da string copiada √© passado; se uma string √© passada por refer√™ncia, o endere√ßo do buffer
desta string sem copi√°-la √© passado para a fun√ß√£o importada da DLL.
Estruturas que cont√©m arrays din√¢micos, strings, classes, outras estruturas complexas, bem como
arrays est√°ticos ou din√¢micos dos objetos listados, n√£o podem ser passados como par√¢metro para uma
fun√ß√£o importada.
Ao passar um array para uma DLL, o endere√ßo do come√ßo do buffer de dados √© sempre passado
(independentemente da flag AS_SERIES). Uma fun√ß√£o dentro de uma DLL n√£o sabe nada sobre a flag
AS_SERIES, o array passado √© um array est√°tico de um comprimento indefinido; um par√¢metro
adicional deve ser usado para especificar o tamanho do array.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1087
<h3>Erros em Tempo de Execu√ß√£o</h3>
O subsistema de execu√ß√£o do terminal cliente tem a oportunidade de salvar o c√≥digo do erro em caso
de ocorr√™ncia durante a execu√ß√£o de um programa MQL5. Existe um vari√°vel predefinida _LastError
para cada programa execut√°vel MQL5.
Antes de iniciar a fun√ß√£o OnInit, a vari√°vel _LastError √© zerada. Em caso de uma situa√ß√£o de erro
ocorrer durante a processamento de c√°lculos ou no processo de chamada de fun√ß√µes internas, o a
vari√°vel _LastError recebe o c√≥digo do erro correspondente. O valor armazenado nesta vari√°vel pode
ser obtida usando a fun√ß√£o GetLastError().
Existem diversos erros cr√≠ticos cuja ocorr√™ncia faz com que um programa seja encerrado
imediatamente:
¬∑ divis√£o por zero
¬∑ ir al√©m dos limites de um array
¬∑ usando um ponteiro de objeto incorreto</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1088
<h3>Testando Estrat√©gias de Negocia√ß√£o</h3>
A ideia de negocia√ß√£o autom√°tica √© atraente pelo fato de que o rob√¥ de negocia√ß√£o pode trabalhar
sem parar 24 horas por dia, sete dias por semana. O rob√¥ n√£o fica cansado, em d√∫vida, ou com medo,
ele √© totalmente livre de quaisquer problemas psicol√≥gicos. Basta formalizar de forma clara as regras
de negocia√ß√£o e implement√°-las nos algoritmos, e o rob√¥ est√° pronto para trabalhar incansavelmente.
Mas primeiro, voc√™ deve se certificar de que as duas condi√ß√£o importantes seguintes est√£o
satisfeitas:
¬∑ O Expert Advisor realiza opera√ß√µes de negocia√ß√£o em concord√¢ncia com as regras do sistema de
negocia√ß√£o;
¬∑ A estrat√©gia de negocia√ß√£o, implementada no EA, demonstra lucro no hist√≥rico.
Para obter respostas para estas quest√µes, nos voltamos para o Provador de Estrat√©gia, inclu√≠do no
terminal cliente MetaTrader 5.
Esta se√ß√£o aborda as caracter√≠sticas do teste e otimiza√ß√£o de programa no Provador de Estrat√©gia:
¬∑ Function Limitations in the Strategy Tester
¬∑ Modos de Gera√ß√£o de Tick
¬∑ Simula√ß√£o de Spread
¬∑ Usando ticks reais durante os testes
¬∑ As Vari√°veis Globais do Terminal Cliente
¬∑ O C√°lculo de Indicadores durante um Teste
¬∑ Carregando Hist√≥rico durante Teste
¬∑ Teste Multi-Moeda
¬∑ Simula√ß√£o de Tempo no Provador de Estrat√©gia
¬∑ Objetos Gr√°ficos no Teste
¬∑ A Fun√ß√£o OnTimer() no Provador de Estrat√©gia
¬∑ A Fun√ß√£o Sleep() no Provador de Estrat√©gia
¬∑ Usando o Provador de Estrat√©gia para Problemas de Otimiza√ß√£o em C√°lculos Matem√°ticos
¬∑ A Sincroniza√ß√£o de Barras no modo &quot;Somente Pre√ßo de Abertura&quot;
¬∑ A fun√ß√£o IndicatorRelease() no Provador de Estrat√©gia
¬∑ Tratamento de Evento no Provador de Estrat√©gia
¬∑ Agentes de Teste
¬∑ A Troca de Dados entre o Terminal e o Agente
¬∑ Usando a Pasta Compartilhada para Todos os Terminais Cliente
¬∑ Usando DLLs
Limita√ß√µes de mem√≥ria e de espa√ßo em disco na MQL5 Cloud
<h3>Network</h3></p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1089
Ao executar a otimiza√ß√£o na MQL5 Cloud Network, h√° uma restri√ß√£o: o Expert Advisor testado n√£o
pode gravar mais de 4 GB de informa√ß√µes no disco e usar mais de 4 GB de RAM. Se o limite for
excedido, o agente de rede n√£o conseguir√° concluir o c√°lculo corretamente e voc√™ n√£o receber√° o
resultado do teste. Al√©m disso, voc√™ ser√° cobrado pelo tempo j√° gasto nos c√°lculos.
Se voc√™ precisar obter informa√ß√µes de cada passagem da otimiza√ß√£o, use enviar quadros sem gravar
no disco. Para n√£o usar opera√ß√µes de arquivo nos Expert Advisors durante os c√°lculos na MQL5 Cloud
<h3>Network, voc√™ pode aplicar essa verifica√ß√£o:</h3>
</p>
<pre><code class="language-mql5">
   int handle=INVALID_HANDLE;
   bool file_operations_allowed=true;
   if(MQLInfoInteger(MQL_OPTIMIZATION) || MQLInfoInteger(MQL_FORWARD))
      file_operations_allowed=false;
   if(file_operations_allowed)
     {
      ...
      handle=FileOpen(...);
      ...
     }
</code></pre>
<p>
Restri√ß√µes de trabalho das fun√ß√µes no testador de estrat√©gias de
negocia√ß√£o
Existem restri√ß√µes no que diz respeito ao trabalho de algumas fun√ß√µes no testador de estrat√©gias de
negocia√ß√£o
<h3>Fun√ß√µes Comment(), Print() e PrintFormat()</h3>
A fim de aumentar o desempenho na otimiza√ß√£o de par√¢metros do expert, n√£o s√£o executadas as
fun√ß√µes Comment(), Print() e PrintFormat(). A exce√ß√£o √© o uso dessas fun√ß√µes dentro do manipulador
Oninit(). Isto torna mais f√°cil procurar as causas de erros quando eles ocorrem.
<h3>Fun√ß√µes</h3>
<h3>Alert(),</h3>
<h3>MessageBox(),</h3>
<h3>PlaySound(),</h3>
<h3>SendFTP,</h3>
<h3>SendMail(),</h3>
<h3>SendNotification(), WebRequest()</h3>
Fun√ß√µes de intera√ß√£o com o &quot;mundo exterior&quot; Alert(), MessageBox(), PlaySound(), SendFTP(),
SendMail(), SendNotification() e WebRequest() n√£o s√£o executadas no testador de estrat√©gias.
<h3>Modos de Gera√ß√£o de Tick</h3>
Um Expert Advisor √© um programa, escrito em MQL5, que √© rodado a cada instante em resposta a
algum evento externo. O EA tem uma fun√ß√£o correspondente (handler de evento) para cada evento
pr√©-definido.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1090
O evento NewTick (mudan√ßa de pre√ßo) √© o evento principal para o EA e, portanto, precisamos gerar
um seq√º√™ncia de ticks para testar o EA. Existem 3 modos de gera√ß√£o de tick implementada no
Provador de Estrat√©gia do terminal cliente MetaTrader 5:
¬∑ Cada Tick
¬∑ OHLC por minuto (pre√ßos OHLC, Open-High-Low-Close, com barras de minuto)
¬∑ Somente Pre√ßos de Abertura
O b√°sico e mais detalhado √© o modo &quot;Cada Tick&quot;, os outros dois modos s√£o simplifica√ß√µes do modo
b√°sico, e ser√£o descritos em compara√ß√£o com o modo &quot;Cada Tick&quot;. Considere todos os tr√™s modos em
ordem para entender as diferen√ßas entre eles.
&quot;Cada Tick&quot;
Os dados de cota√ß√£o hist√≥rica para instrumentos financeiros s√£o transferidos do servidor de
negocia√ß√£o para o terminal cliente MetaTrader 5 na forma de barras de minuto empacotadas.
Informa√ß√µes detalhadas sobre a ocorr√™ncia de solicita√ß√µes e a constru√ß√£o das janelas de tempo
requiridas podem ser obtidas a partir do cap√≠tulo Organizando Acesso a Dados da Refer√™ncia MQL5.
O elemento m√≠nimo do hist√≥rico de pre√ßos √© a barra de minuto, a partir do qual pode-se obter
informa√ß√µes sobre os quatro valores de pre√ßos:
¬∑ Abertura (Open) - o pre√ßo em que a barra de minuto foi aberta;
¬∑ M√°ximo (High) - o m√°ximo que foi alcan√ßado durante esta barra de minuto;
¬∑ M√≠nimo (Low) - o m√≠nimo que foi alcan√ßado durante esta barra de minuto;
¬∑ Fechamento (Close) - o pre√ßo de fechamento da barra.
A nova barra de minuto n√£o √© aberta no momento que o novo minuto come√ßa (n√∫mero de segundos se
torna igual a 0), mas quando um tick ocorre - uma altera√ß√£o de pre√ßo de no m√≠nimo um ponto. A
figura mostra a primeira barra de minuto da nova semana de negocia√ß√£o, que tem a hora de abertura
de 2011.01.10 00:00. A diferen√ßa de pre√ßos entre Sexta e Segunda, que n√≥s vemos no gr√°fico √©
comum, j√° que taxas de moeda flutuam mesmo em fins-de-semana em resposta ao surgimento de
not√≠cias.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1091
Para esta barra, n√≥s sabemos apenas que a barra de minuto foi aberta em 10 de Janeiro de 2011 √†s 00
horas 00 minutos, mas n√≥s n√£o sabemos nada sobre os segundos. Ela poderia ter sido aberta √†s
00:00:12 ou 00:00:36 (12 ou 36 segundos ap√≥s o inicio de um novo dia) ou qualquer outro instante
dentro daquele minuto. Mas n√≥s sabemos que o pre√ßo de Abertura do EURUSD foi de 1.28940 no
instante de abertura da nova barra de minuto.
N√≥s tamb√©m n√£o sabemos, em termos de segundos, quando o tick, correspondente ao pre√ßo de
fechamento da barra de minuto considerada, foi recebido. N√≥s s√≥ sabemos uma coisa - o √∫ltimo pre√ßo
de Fechamento da barra de minuto. Para este minuto, o pre√ßo foi 1.28958. Os instantes de
aparecimento dos pre√ßos de M√°ximo e M√≠nimo tamb√©m s√£o desconhecidos, mas n√≥s sabemos que os
pre√ßos m√°ximo e m√≠nimo foram nos n√≠veis de 1.28958 e 1.28940, respectivamente.
Para testar a estrat√©gia de negocia√ß√£o, n√≥s precisamos de uma seq√º√™ncia de ticks, na qual o trabalho
do Expert Advisor ser√° simulado. Assim, para toda barra de minuto, n√≥s conhecemos os 4 pontos de
controle, onde os pre√ßos definitivamente estiveram. Se uma barra tem apenas 4 ticks, ent√£o isso √©
informa√ß√£o suficiente para realizar um teste, mas geralmente o volume de tick √© maior que 4.
Portanto, existe a necessidade de gerar pontos de controle adicionais para ticks, que ocorreram entre
os pre√ßos de Abertura, M√°ximo, M√≠nimo, e Fechamento. O princ√≠pio do modo de gera√ß√£o de ticks
&quot;Cada tick&quot; √© descrito dentro do O Algoritmo de Gera√ß√£o de Ticks dentro da Testador de Estrat√©gia do
Terminal MetaTrader 5, um n√∫mero a partir do qual √© apresentado a baixo.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1092
Ao testar no modo &quot;Cada Tick&quot;, a fun√ß√£o OnTick() do EA ser√° chamado a cada ponto de controle. Cada
ponto de controle √© um tick de uma seq√º√™ncia gerada. O EA receber√° a hora e pre√ßo do tick simulado,
assim como se estivesse trabalhando online.
Importante: o modo de teste &quot;Cada Tick&quot; √© o mais preciso, mas ao mesmo tempo, √© o que
consome mais tempo. Para um teste inicial da maioria das estrat√©gias de negocia√ß√£o, √©
geralmente suficiente usar um dos outros dois modos de teste.
&quot;OHLC por minuto&quot;
O modo &quot;Cada Tick&quot; √© o mais preciso dos tr√™s modos, mas √© ao mesmo tempo, o mais lento. A
execu√ß√£o do handler OnTick() ocorre a cada tick, a mesmo tempo que o volume de tick pode ser muito
grande. Para uma estrat√©gia, na qual a seq√º√™ncia de ticks da movimenta√ß√£o de pre√ßos em toda barra
n√£o importa, existe um modo de simula√ß√£o mais r√°pido e grosseiro - &quot;OHLC por minuto&quot;.
No modo &quot;OHLC por minuto&quot;, a seq√º√™ncia de ticks √© constru√≠da somente pelos pre√ßos OHLC das
barras de minuto, o n√∫mero de pontos de controle gerados √© significativamente reduzido - assim
como o tempo de teste. O disparo da fun√ß√£o OnTick() √© realizada sob todos os pontos de controle, que
s√£o constru√≠dos pelos pre√ßos OHLC das barras de minuto.
A op√ß√£o de n√£o gerar ticks intermedi√°rios adicionais entre os pre√ßos de Abertura, M√°ximo, M√≠nimo e
Fechamento, leva ao aparecimento de um r√≠gido determinismo na evolu√ß√£o dos pre√ßos, a partir do
momento que o pre√ßo de Abertura √© determinado. Isso torna poss√≠vel criar um &quot;Teste Graal&quot;, que
mostra um agrad√°vel gr√°fico ascendente do saldo do teste.
Um exemplo de tal Graal √© apresentado no C√≥digo Base - Grr-al.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1093
A figura mostra um gr√°fico muito atrativo deste teste de EA. Como ele foi obtido? N√≥s conhecemos 4
pre√ßos para uma barra de minuto, e n√≥s sabemos que o primeiro √© pre√ßo de Abertura, e o √∫ltimo √© o
pre√ßo de Fechamento. N√≥s temos os pre√ßos M√°ximo e M√≠nimo entre eles, e a seq√º√™ncia de suas
ocorr√™ncias √© desconhecida, mas √© sabido que o pre√ßo M√°ximo √© maior ou igual que o pre√ßo de
Abertura (e o pre√ßo M√≠nimo √© menor ou igual ao pre√ßo de Abertura).
√â suficiente determinar o momento da recep√ß√£o do pre√ßo de Abertura, e ent√£o analisar o pr√≥ximo tick
a fim de determinar que pre√ßo n√≥s temos no momento - ou o M√°ximo ou o M√≠nimo. Se o pre√ßo for
abaixo do pre√ßo de Abertura, ent√£o n√≥s temos um pre√ßo M√≠nimo e comprarmos neste tick, o pr√≥ximo
tick corresponder√° ao pre√ßo M√°ximo, no qual n√≥s encerramos a compra e abrimos para venda. O
pr√≥ximo tick √© o √∫ltimo, este √© o pre√ßo de Fechamento, e encerramos a venda nele.
Se ap√≥s o pre√ßo, n√≥s recebermos um tick com um pre√ßo maior que o pre√ßo de Abertura, ent√£o a
seq√º√™ncia de opera√ß√µes (deals) √© invertida. Processe uma barra de minuto neste modo &quot;trapaceiro&quot;, e
espere para pela pr√≥xima barra.
Ao testar tal EA no hist√≥rico, tudo vai bem, mas uma vez que lan√ßamos ele online, a verdade come√ßa a
ser revelada - a linha de saldo permanece regular, por√©m em dire√ß√£o descendente. Para expor este
truque, n√≥s simplesmente precisamos executar o EA no modo &quot;Cada Tick&quot;.
Observa√ß√£o: Se os resultados do teste do EA em modos de teste grosseiros (&quot;OHLC por minuto&quot; e
&quot;Somente Pre√ßos de Abertura&quot;) parecerem muito bons, certifique-se de testar-lo no modo &quot;Cada
Tick&quot;.
&quot;Somente Pre√ßos de Abertura&quot;
Neste modo os ticks s√£o gerados baseados nos pre√ßos OHLC das janelas de tempo selecionados para
teste. A fun√ß√£o OnTick() do Expert Advisor roda somente no come√ßo da barra, no pre√ßo de Abertura.
Devido a este caracter√≠stica, n√≠veis de stop e ordens pendentes podem disparar em um pre√ßo que
difere do pre√ßo especificado (especialmente ao testar em janelas de tempo mais altas). Em
contrapartida, n√≥s temos uma oportunidade de executar rapidamente um teste de avalia√ß√£o do Expert
Advisor.
Os per√≠odos W1 e MN1 s√£o exce√ß√µes no modo de gera√ß√£o de ticks &quot;Somente Pre√ßos de Abertura&quot;: para
estas janelas de tempo, ticks s√£o gerados para os pre√ßos OHLC de cada dia, e n√£o pre√ßos OHLC da
semana ou m√™s.
Suponha que n√≥s testemos um Expert Advisor sob EURUSD H1 no modo &quot;Somente Pre√ßos de Abertura&quot;.
Neste caso o n√∫mero total de ticks (pontos de controle) n√£o ser√° mais que 4 * n√∫mero de barras de</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1094
uma-hora dentro do intervalo testado. Mas o handler OnTick() √© chamado somente na abertura da
barra de uma-hora. As verifica√ß√µes requeridas para um teste correto ocorrem no resto dos ticks (que
s√£o &quot;escondidas&quot; do EA).
¬∑ O c√°lculo de requerimentos de margem;
¬∑ O disparo de n√≠veis de Stop Loss e Take Profit;
¬∑ O disparo de ordens pendentes;
¬∑ A remo√ß√£o de ordens pendentes expiradas.
Se n√£o existirem nenhum posi√ß√£o aberta ou ordens pendentes, n√≥s n√£o precisamos realizar destas
verifica√ß√µes nos ticks escondidos, e o aumento da velocidade pode ser bastante substancial. Este
modo &quot;Somente Pre√ßos de Abertura&quot; √© bem adequado para testar estrat√©gias que processam opera√ß√µes
(deals) somente na abertura da barra e n√£o usam ordens pendentes, bem como ordens Stop Loss e
Take Profit. Para estrat√©gias deste tipo, a necessidade de precis√£o do teste √© preservada.
Vamos usar o Expert Advisor Moving Average (M√©dia M√≥vel) do pacote padr√£o como exemplo de um
EA, que pode ser testado em qualquer modo. A l√≥gica deste EA √© constru√≠do de tal forma que todas as
decis√µes s√£o feitas na abertura da barra, e opera√ß√µes (deals) s√£o executadas imediatamente, sem o
uso de ordens pendentes.
Executar um teste de EA no EURUSD H1 sobre um intervalo a partir de 2010.09.01 to 2010.12.31, e
comparar os gr√°ficos. A figura mostra o gr√°fico de saldo do relat√≥rio de teste para todos os tr√™s
modos.
Como se pode ver, os gr√°ficos nos diferentes modos de teste s√£o exatamente o mesmo para o EA
Moving Average do pacote padr√£o.
Existem algumas limita√ß√µes no modo &quot;Somente Pre√ßos de Abertura&quot;:
¬∑ Voc√™ n√£o pode usar o modo de execu√ß√£o Atraso Aleat√≥rio.
¬∑ No Expert testado, voc√™ n√£o pode acessar os dados do per√≠odo inferior do per√≠odo utilizado para o
teste/otimiza√ß√£o. Por exemplo, se voc√™ rodar um teste em M20, voc√™ n√£o pode acessar dados de</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1095
M30, mas √© poss√≠vel acessar H1. Al√©m disso, os per√≠odos superiores que s√£o acessados ‚Äãdevem ser
m√∫ltiplos do per√≠odo do teste. Por exemplo, se voc√™ rodar um teste em M20, voc√™ n√£o pode acessar
dados de M30, mas √© poss√≠vel acessar H1. Estas limita√ß√µes est√£o relacionadas com a
impossibilidade de se obter dados de per√≠odos inferiores ou n√£o m√∫ltiplos de fora das barras geradas
durante o teste/otimiza√ß√£o.
¬∑ Limita√ß√µes no acesso a dados de outros per√≠odos tamb√©m se aplicam a outros ativos cujos dados
s√£o usados ‚Äãpelo Expert Advisor. Neste caso, a limita√ß√£o para cada ativo depende do primeiro per√≠odo
acessado durante o teste/otimiza√ß√£o. Suponha que durante teste em EURUSD H1, um Expert Advisor
acesse dados de GBPUSD M20. Neste caso, o Expert ser√° capaz de continuar a usar os dados de
EURUSD H1, H2, etc, bem como GBPUSD M20, H1, H2, etc.
Observa√ß√£o: O modo &quot;Somente Pre√ßos de Abertura&quot; tem o mais r√°pido tempo de teste, mas n√£o √©
adequado para todas as estrat√©gias de negocia√ß√£o. Selecione o modo de teste desejado baseado
nas caracter√≠sticas do sistema de negocia√ß√£o. 
Para concluir a se√ß√£o sobre os modos de gera√ß√£o de tick, vamos considerar uma compara√ß√£o visual
dos diferentes modos de gera√ß√£o de tick para EURUSD, para duas barras de M15 no intervalo de
2011.01.11 21:00:00 - 2011.01.11 21:30:00.
Os ticks foram salvos em arquivos diferentes usando o EA WriteTicksFromTester.mq5 e o fim desses
nomes de arquivos s√£o especificados nos par√¢metros de entrada filenameEveryTick, filenameOHLC e
filenameOpenPrice input-parameters.
Para obter tr√™s arquivos com tr√™s seq√º√™ncias de tick (para cada um dos seguintes modos: &quot;Cada Tick&quot;,
&quot;OHLC por minuto&quot; e &quot;Somente Pre√ßos de Abertura&quot;), o EA foi disparado tr√™s vezes nos modos
correspondentes, em execu√ß√µes individuais. Ent√£o, os dados destes tr√™s arquivos foram exibidos no
gr√°fico usando o indicador TicksFromTester.mq5. O c√≥digo do indicador est√° anexado neste artigo.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1096
Por padr√£o, todos as opera√ß√µes de arquivo na linguagem MQL5 s√£o feitas dentro da &quot;caixa de areia de
arquivo&quot; e durante um teste o EA tem acesso somente a sua pr√≥pria &quot;caixa de areia de arquivo&quot;. A fim
de que o indicador e o EA trabalhem com arquivos provenientes de uma pasta comum durante o teste,
n√≥s usados o flag FILE_COMMON. Um exemplo de c√≥digo do EA:
</p>
<pre><code class="language-mql5">
//--- abre o arquivo
   file=FileOpen(filename,FILE_WRITE|FILE_CSV|FILE_COMMON,&quot;;&quot;);
//--- verifica a handle de arquivo
   if(file==INVALID_HANDLE)
     {
      PrintFormat(&quot;Erro na abertura do arquivo %s para escrever. Erro de codigo=%d&quot;,fi
      return;
     }
   else
     {
      PrintFormat(&quot;O arquivo ser√° criado na %s pasta&quot;,TerminalInfoString(TERMINAL_COMM
     }
</code></pre>
<p>
Para ler dos dados no indicador, n√≥s tamb√©m usamos o flag FILE_COMMON. Isso n√≥s permite evitar
transferir manualmente os arquivos necess√°rios de uma pasta para outra.
</p>
<pre><code class="language-mql5">
//--- abre o arquivo
   int file=FileOpen(fname,FILE_READ|FILE_CSV|FILE_COMMON,&quot;;&quot;);
//--- verifica a handle de arquivo
   if(file==INVALID_HANDLE)
     {
      PrintFormat(&quot;Erro na abertura do arquivo %s para leitura. Erro de codigo=%d&quot;,fna
      return;
     }
   else
     {</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1097
</p>
<pre><code class="language-mql5">
      PrintFormat(&quot;Arquivo ser√° aberto a partir %s&quot;,TerminalInfoString(TERMINAL_COMMON
     }
</code></pre>
<p>
<h3>Simula√ß√£o de Spread</h3>
A diferen√ßa de pre√ßo entre os pre√ßos de Venda (Bid) e Compra (Ask) √© chamado de spread. Durante um
teste, o spread n√£o √© modelado mas √© obtido a partir de dados hist√≥ricos. If the spread is less than or
equal to zero in the historical data, then the last known (at the moment of generation) spread  of is
used by testing agent.
No Provador de Estrat√©gia, o spread √© sempre considerado flutuante. Isto √©, a fun√ß√£o
SymbolInfoInteger(symbol, SYMBOL_SPREAD_FLOAT) sempre retorna true.
Al√©m disso, os dados hist√≥ricos cont√©m valores de tick e volumes de negocia√ß√£o. Para o
armazenamento e recupera√ß√£o dos dados n√≥s usamos a estrutura especial MqlRates:
</p>
<pre><code class="language-mql5">
struct MqlRates
  {
   datetime time;         // Hora de in√≠cio do per√≠odo
   double   open;         // Pre√ßo de Abertura
   double   high;         // O mais alto pre√ßo do per√≠odo
   double   low;          // O mais baixo pre√ßo do per√≠odo
   double   close;        // Pre√ßo de Fechamento
   long     tick_volume;  // Volume de Tick
   int      spread;       // Spread
   long     real_volume;  // Volume de Negocia√ß√£o
</code></pre>
<p>
  };
<h3>Usando ticks reais durante os testes</h3>
O teste e a otimiza√ß√£o de acordo com ticks reais se aproximam ao m√°ximo das condi√ß√µes reais. Em
vez de ticks gerados com base em dados de minuto, s√£o usados ticks reais acumulados pela corretora.
Esses s√£o ticks provindos da bolsa e dos provedores de liquidez.
Para garantir a maior precis√£o - durante os testes em modo de ticks reais - tamb√©m s√£o usadas as
barras de minuto. Nelas s√£o verificados e corrigidos os dados de ticks. Isto tamb√©m evita a
diverg√™ncia de gr√°ficos no testador e no terminal de cliente.
O testador verifica a correspond√™ncia entre os dados de tick e os par√¢metros da barra de minuto, isto
√©: o tick n√£o deve ultrapassar os pre√ßos High/Low da barra; o tick que a abre e fecha o minuto deve
coincidir com os pre√ßos Open/Close da barra. Tamb√©m √© comparado o volume. Se identificada uma
diferen√ßa, s√£o descartados todos os ticks correspondentes a esta barra de minuto. Em vez deles,
ser√£o utilizados os ticks gerados (como no modo &quot;Cada tick&quot;).
Se no hist√≥rico do s√≠mbolo existir uma barra de minuto, mas, se, nesse minuto, n√£o houver dados de
ticks, o testador gerar√° ticks no modo &quot;Todos os ticks&quot;. Isto permite plotar corretamente o gr√°fico no
testador, caso a corretora tenha os dados de tick incompletos.
Se, no hist√≥rico do s√≠mbolo, n√£o existir uma barra de minuto, mas, se, nesse minuto, houver dados de
ticks, ent√£o, esses ticks podem ser utilizados. Por exemplo, as barras de s√≠mbolos de bolsa s√£o
formados de acordo com os pre√ßos Last. Se, a partir do servidor, chegarem apenas ticks com pre√ßos</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1098
Bid/Ask sem pre√ßo Last, a barra n√£o ser√° formada. O testador usar√° estes dados de ticks, uma vez
que eles n√£o contradizem as de minuto.
Os dados de ticks podem ser diferentes das barras de minuto por v√°rias raz√µes. Por exemplo, devido a
desconex√µes ou outras falhas, quando dados s√£o transferidos da fonte para o terminal de cliente. Ao
testar, os dados de minuto s√£o considerados mais confi√°veis.
Ao testar ticks reais, considere as seguintes particularidades:
¬∑ Ao executar o teste, n√£o s√≥ s√£o sincronizados os dados de ticks, mas tamb√©m os de minuto de
acordo com o instrumento.
¬∑ Os ticks s√£o armazenados no cache do s√≠mbolo no testador de estrat√©gias. O tamanho do cache √©
inferior a 128 000 ticks. Ap√≥s chegarem novos ticks, seus dados mais antigos ser√£o empurrados
para fora. No entanto, com ajuda da fun√ß√£o CopyTicks podem ser obtidos ticks fora do cache
(somente nos testes em ticks reais). Neste caso, os dados ser√£o solicitados a partir da base de ticks
do testador, ela corresponde completamente √† base de dados do terminal de cliente. Nesta base n√£o
√© feito nenhum ajuste de barras de minuto. Portanto, os ticks nele podem ser diferentes dos ticks
no cache.
<h3>As Vari√°veis Globais do Terminal Cliente</h3>
Durante um teste, as vari√°veis globais do terminal cliente s√£o tamb√©m emulados, mas elas n√£o est√£o
relacionadas como as vari√°veis globais correntes do terminal, que podem ser vistas no terminal
usando a tecla F3. Significa que todas as opera√ß√µes com as vari√°veis globais do terminal, durante um
teste, acontecem fora terminal cliente (no agente de teste).
O C√°lculo de Indicadores durante um Teste
No modo tempo-real, os valores dos indicadores s√£o calculados a cada tick.
No testador de estrat√©gia, os indicadores s√£o calculados apenas quando s√£o acessados √† procura de
dados, ou seja, apenas no momento em que os valores dos buffers dos indicadores s√£o solicitados. A
exce√ß√£o 
a 
isto 
√© 
quando 
indicadores 
personalizados 
s√£o 
definidos 
como 
</p>
<pre><code class="language-mql5">
#property
</code></pre>
<p>
tester_everytick_calculate, neste caso, o rec√°lculo √© feito a cada tick.
No modo de teste visual, todos os indicadores s√£o recalculados incondicionalmente com a chegada de
um novo tick, de modo a aparecerem corretamente no gr√°fico de teste visual.
O c√°lculo do indicador a cada tick √© feito uma vez e todas as subsequentes solicita√ß√µes de dados do
indicador antes da chegada de um novo tick n√£o provocar√£o um rec√°lculo. Por isso, se, no Expert
Advisor, o timer estiver ativo com a fun√ß√£o EventSetTimer(), antes da chamada do handler OnTimer()
ser√£o solicitados os dados do indicador desde a recep√ß√£o do √∫ltimo tick. Se o indicador ainda n√£o tiver
sido calculado no √∫ltimo tick, ser√° iniciado o c√°lculo dos valores do indicador. Se os dados j√° tiverem
sido preparados, eles ser√£o fornecidos sem um novo rec√°lculo.
Assim, todos os c√°lculos do indicador s√£o feitos da forma mais econ√¥mica poss√≠vel, quer dizer, se o
indicador j√° tiver sido calculado em um determinado tick, os dados do indicador ser√£o fornecidos
como est√£o, ou seja, o indicador n√£o √© ser√° recalculado.
<h3>Carregando Hist√≥rico durante Teste</h3></p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1099
O hist√≥rico de um ativo a ser testado √© sincronizado e carregado pelo terminal a partir do servidor de
negocia√ß√£o antes de come√ßar o processo de teste. Durante a primeira vez, o terminal carrega todo o
hist√≥rico dispon√≠vel de um ativo de forma a n√£o requerer este hist√≥rico mais tarde. Ap√≥s isso,
somente dados novos s√£o carregados.
Um agente de teste recebe o hist√≥rico de um ativo a ser testado a partir do terminal cliente logo ap√≥s
o come√ßo do teste. Se os dados de outros instrumentos s√£o usados no processo de teste (por exemplo,
√© um Expert Advisor multi-moeda), o agente de teste solicita o hist√≥rico requerido do terminal cliente
durante a primeira chamada a tais dados. Se os dados hist√≥ricos estiverem dispon√≠veis no terminal,
eles s√£o imediatamente passados para o agente de teste. Se os dados n√£o estiverem dispon√≠veis, o
terminal solicita e os baixa do servidor, e ent√£o os passa para o agente de teste.
Dados de instrumentos adicionais tamb√©m s√£o requeridos para calcular taxas-cruzadas de opera√ß√µes
de negocia√ß√£o. Por exemplo, ao testar uma estrat√©gia em EURCHF com a moeda de dep√≥sito em USD,
antes de processar a primeira opera√ß√£o de negocia√ß√£o, o agente de teste solicita os dados hist√≥ricos
de EURUSD e USDCHF do terminal cliente, embora a estrat√©gia n√£o contenha chamadas de uso direta a
estes ativos.
Antes de testar um estrat√©gia multi-moeda, √© recomend√°vel baixar todos os dados hist√≥ricos
necess√°rios para o terminal cliente. Isso ajudar√° a evitar atrasos em um teste/otimiza√ß√£o associado
com a baixa dos dados requeridos. Voc√™ pode baixar hist√≥rico, por exemplo, via abertura dos gr√°ficos
apropriados e rol√°-los para o come√ßa do hist√≥rico. Um exemplo de carga for√ßada de hist√≥rico para o
terminal est√° dispon√≠vel na se√ß√£o Organizando Acesso a Dados da Refer√™ncia MQL5.
Agentes de teste, por sua vez, recebem o hist√≥rico do terminal no formato compactado. Durante o
pr√≥ximo teste, o Provador de Estrat√©gia n√£o carrega o hist√≥rico do terminal, porque os dados
requeridos est√£o dispon√≠veis desde a execu√ß√£o anterior do Provador de Estrat√©gia.
¬∑ O termianl carrega o hist√≥rico a partir de um servidor de negocia√ß√£o apenas uma vez, na
primeira vez que o agente solicita o hist√≥rico de um ativo a ser testado do terminal. O hist√≥rico
√© carregado em forma de pacote para reduzir o tr√°fego.
¬∑ Ticks n√£o s√£o enviados pela rede, eles s√£o gerados nos agentes de teste.
<h3>Teste Multi-Moeda</h3>
O Provador de Estrat√©gia nos permite realizar um teste de estrat√©gias, negociando em m√∫ltiplos
ativos. Tais EAs s√£o convencionalmente referidos como Expert Advisors multi-moedas, j√° que
originalmente, um teste era realizado somente para um √∫nico ativo. No Provador de Estrat√©gia do
terminal MetaTrader 5, n√≥s podemos modelar negocia√ß√£o para todos os ativos dispon√≠veis.
O Provador de Estrat√©gia carrega o hist√≥rico dos ativos usados do terminal cliente (n√£o do servidor
de negocia√ß√£o!) automaticamente durante a primeira chamada aos dados do ativo.
O agente de teste baixa somente o hist√≥rico faltante, com uma pequena margem para fornecer os
dados necess√°rios no hist√≥rico para o c√°lculo dos indicadores no per√≠odo inicial do teste. Para as
janelas de tempo D1 ou menor, o volume m√≠nimo de hist√≥rico baixado √© de um ano.
Assim, se n√≥s rodarmos um teste no intervalo 2010.11.01-2010.12.01 (teste para um intervalo de um
m√™s) com um per√≠odo de M15 (cada barra e igual a 15 minutos), ent√£o ser√° solicitado ao terminal o
hist√≥rico do instrumento para o ano inteiro de 2010. Para a janela de tempo semanal, n√≥s
solicitaremos um hist√≥rico de 100 barras, que √© aproximadamente dois anos (um ano tem 52</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1100
semanas). Para testar em uma janela de tempo mensal, o agente solicitar√° o hist√≥rico de 8 anos (12
meses x 8 anos = 96 meses).
Se n√£o houver barras necess√°rias, a data de √≠nicio do teste ser√° automaticamente deslocada do
passado para o presente para fornecer a reserva necess√°ria de barras antes do teste.
Durante um teste, a janela &quot;Observa√ß√£o de Mercado&quot; √© tamb√©m emulada, a partir do qual se pode
obter informa√ß√µes sobre os ativos.
Por padr√£o, no come√ßo de um teste, existe somente um ativo na &quot;Observa√ß√£o de Mercado&quot; do
Provador de Estrat√©gia - o ativo em que o teste est√° rodando. Todos os ativos necess√°rios s√£o
conectados √† janela &quot;Observa√ß√£o de Mercado&quot; do Provador de Estrat√©gia (n√£o ao terminal!)
automaticamente quando referenciados.
Antes de come√ßar um teste de um Expert Advisor multi-moeda, √© necess√°rio selecionar os ativos
requeridos para o teste na janela &quot;Observa√ß√£o de Mercado&quot; do terminal e carregar os dados
requeridos. Durante a primeira chamada de um ativo &quot;estrangeiro&quot;, seu hist√≥rico ser√°
automaticamente sincronizado entre o agente de teste e o terminal cliente. Um ativo
&quot;estrangeiro&quot; √© o outro ativo, diferente daquele em que o teste √© rodado.
Refer√™ncia aos dados de um &quot;outro&quot; ativo ocorre nos seguintes casos:
¬∑ Ao usar a fun√ß√£o de indicadores t√©cnicos e IndicatorCreate() no ativo/per√≠odo;
¬∑ A solicita√ß√£o aos dados da janela &quot;Observa√ß√£o de Mercado&quot; por de um outro ativo:
1. SeriesInfoInteger
2. Bars
3. SymbolSelect
4. SymbolIsSynchronized
5. SymbolInfoDouble
6. SymbolInfoInteger
7. SymbolInfoString
8. SymbolInfoTick
9. SymbolInfoSessionQuote
10.SymbolInfoSessionTrade
11.MarketBookAdd
12.MarketBookGet
¬∑ Solicita√ß√£o da s√©rie de tempo para um ativo/janela de tempo atr√°ves do uso das seguintes fun√ß√µes:
1. CopyBuffer
2. CopyRates
3. CopyTime
4. CopyOpen
5. CopyHigh
6. CopyLow
7. CopyClose</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1101
8. CopyTickVolume
9. CopyRealVolume
10.CopySpread
No momento da primeira chamada a um &quot;outro&quot; ativo, o processo de teste √© interrompido e o hist√≥rico
√© baixado para o ativo/per√≠odo, do terminal para o agente de teste. Ao mesmo tempo, a gera√ß√£o da
seq√º√™ncia de tick para este ativo √© feita.
Uma seq√º√™ncia de tick individual √© gerada para cada ativo, de acordo com o modo de gera√ß√£o de tick
selecionado. Voc√™ tamb√©m pode solicitar explicitamente o hist√≥rico dos ativos desejados atrav√©s de
chamada ao SymbolSelect() no handler OnInit() - a baixa do hist√≥rico ser√° feita imediatamente antes
do teste do Expert Advisor.
Assim, n√£o √© necess√°rio nenhum esfor√ßo extra para realizar teste de multi-moeda no terminal cliente
MetaTrader 5. Apenas abra os gr√°ficos dos apropriados ativos no terminal cliente. O hist√≥rico ser√°
automaticamente carregado do servidor de negocia√ß√£o para todos os ativos requeridos, contanto que
ele contenha estes dados.
Simula√ß√£o de Tempo no Provador de Estrat√©gia
Durante um teste, a hora local TimeLocal() √© sempre igual a hora do servidor TimeTradeServer(). Por
sua vez, a hora do servidor √© sempre igual a hora correspondente √† hora GMT - TimeGMT(). Desta
forma, todas estas fun√ß√µes mostram a mesma hora durante um teste.
A aus√™ncia de diferen√ßa entre as horas GMT, local, e do servidor no Provador de Estrat√©gia √© feita
deliberadamente para o caso de n√£o haver conex√£o com o servidor. Os resultados do teste devem
sempre ser os mesmos, independentemente de haver ou n√£o uma conex√£o. Informa√ß√µes sobre a hora
do servidor n√£o √© armazenado localmente, e √© obtido do servidor.
<h3>Objetos Gr√°ficos no Teste</h3>
Durante um teste/otimiza√ß√£o objetos gr√°ficos n√£o s√£o plotados. Assim, ao referenciar as
propriedades de um objeto criado durante um teste/otimiza√ß√£o, um Expert Advisor receber√° valores
zero.
Este limita√ß√£o n√£o se aplica ao se testar em modo visual.
A Fun√ß√£o OnTimer() no Provador de Estrat√©gia
MQL5 fornece a oportunidade de tratar eventos de timer. A chamada ao handler OnTimer() √© feita
independentemente do modo do teste. Isso significa que se um teste √© rodado no modo &quot;Somente
Pre√ßos de Abertura&quot; para o per√≠odo H4, e o EA tem um timer definido para uma chamada por segundo,
ent√£o na abertura de cada barra de H4, o handler OnTick() ser√° chamado uma vez, e o handler
OnTimer() ser√° chamado 14400 vezes (3600 segundos * 4 horas). A quantidade de tempo de teste do
EA que ser√° aumentada depende da l√≥gica do EA.
Para verificar a depend√™ncia do tempo de teste a partir de um dada freq√º√™ncia do timer, n√≥s temos
que criar um EA simples sem nenhum opera√ß√£o de negocia√ß√£o.
</p>
<pre><code class="language-mql5">
//--- par√¢metros de entrada</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1102
</p>
<pre><code class="language-mql5">
input int      timer=1;              // valor do timer, segundos
input bool     timer_switch_on=true; // timer ativado
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- rodar o timer se timer_switch_on==true
   if(timer_switch_on)
     {
      EventSetTimer(timer);
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de Desinicializa√ß√£o do Expert                             |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- para o timer
   EventKillTimer();
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o Timer¬†                                                    |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
// nenhum a√ß√£o √© tomada, o corpo do handler est√° vazio
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
</code></pre>
<p>
As medi√ß√µes de tempo de tempo s√£o obtidas em valores diferentes do par√¢metro timer (periodicidade
do evento Timer). Sob os dados obtidos, n√≥s plotamos o tempo do teste como fun√ß√£o do per√≠odo do
Timer.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1103
Pode-se ver claramente que quanto menor √© o par√¢metro do timer, durante a a inicializa√ß√£o da fun√ß√£o
EventSetTimer, menor √© o per√≠odo entre as chamadas do handler OnTimer(), e maior √© o tempo de
teste, sob as mesmas outras condi√ß√µes.
A Fun√ß√£o Sleep() no Provador de Estrat√©gia
A fun√ß√£o Sleep() permite ao EA ou script suspender a execu√ß√£o do programa MQL5 por um tempo, ao
trabalhar no gr√°fico. Isso pode ser √∫til ao solicitar dados, que n√£o est√£o prontos no momento da
solicita√ß√£o e voc√™ precisa esperar at√© eles estarem prontos. Um exemplo detalhado do uso da fun√ß√£o
Sleep() pode ser encontrado na se√ß√£o Preparativo para acesso a dados.
O processo de teste n√£o √© atrasado por chamadas √† fun√ß√£o Sleep(). Quando voc√™ chama o Sleep(), os
ticks gerados s√£o &quot;jogados&quot; com um atraso especificado, que pode resultar no disparo de ordens
pendentes, stops, etc. Ap√≥s uma chamada do Sleep(), o tempo simulado no Provador de Estrat√©gia
aumenta em um intervalo, especificado no par√¢metro da fun√ß√£o Sleep.
Se como resultado da execu√ß√£o da fun√ß√£o Sleep(), o tempo corrente no Provador de Estrat√©gia passar
do per√≠odo de teste, ent√£o voc√™ receber√° o erro &quot;Infinite Sleep loop detected while testing&quot;. Se voc√™
receber este erro, os resultados do teste n√£o ser√£o rejeitados, todas as computa√ß√µes s√£o realizadas
em seus volumes completos (o n√∫mero de opera√ß√µes (deals), abrandamento, etc) e os resultados deste
teste s√£o transmitidos para o terminal.
A fun√ß√£o Sleep() n√£o funcionar√° em OnDeinit(), j√° que ap√≥s ele ser chamado, ser√° certo que o tempo
de teste ultrapassar√° a faixa do intervalo de teste.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1104
Usando o Provador de Estrat√©gia para Problemas de Otimiza√ß√£o em
<h3>C√°lculos Matem√°ticos</h3>
O Provador de Estrat√©gia no terminal MetaTrader 5 pode ser usado, n√£o apenas para testar
estrat√©gias de negocia√ß√£o, mas tamb√©m para c√°lculos matem√°ticos. Para usar-lo, √© necess√°rio
selecionar o modo &quot;C√°lculos matem√°ticos&quot;
Neste caso, somente tr√™s fun√ß√µes ser√£o chamadas: OnInit(), OnTester(), OnDeinit(). No modo
&quot;C√°lculos matem√°ticos&quot; o Provador de Estrat√©gia n√£o gera nenhum tick e n√£o baixa o hist√≥rico.
O Provador de Estrat√©gia tamb√©m trabalha em modo &quot;C√°lculos matem√°ticos&quot; se voc√™ especificar a
data inicial maior que a data final.
Ao usar o Provador de Estrat√©gia para resolver problemas matem√°ticos, a carga do hist√≥rico e a
gera√ß√£o de ticks n√£o ocorrem.
Um problema matem√°tico t√≠pico para ser revolvido no Provador de Estrat√©gias do MetaTrader 5 -
busca de um extremo de uma fun√ß√£o com muitas vari√°veis.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1105
<h3>Para resolv√™-lo nos precisamos que:</h3>
¬∑ O c√°lculo do valor da fun√ß√£o deve estar localizado na fun√ß√£o OnTester();
¬∑ Os par√¢metros da fun√ß√£o devem estar definidos como vari√°veis de entrada do Expert Advisor;
Compilar o EA, abrir a janela &quot;Provador de Estrat√©gia&quot;. Na guia &quot;Par√¢metros de entrada&quot;, selecionar as
requeridas vari√°veis de entrada, e definir o conjunto de valores de par√¢metros por meio da
especifica√ß√£o dos valores iniciar, parar, e passo de cada uma das vari√°veis da fun√ß√£o.
Selecionar o tipo de otimiza√ß√£o - &quot;Algoritmo completo lento&quot; (busca completa do espa√ßo de
par√¢metros) ou &quot;R√°pido (algoritmo gen√©tico)&quot;. Para uma busca simples do extremo da fun√ß√£o, √©
melhor escolher uma otimiza√ß√£o r√°pida, mas se voc√™ quiser calcular os valores para conjunto inteiro
de vari√°veis, ent√£o √© melhor usar a otimiza√ß√£o lenta.
Selecione o modo &quot;C√°lculo matem√°tico&quot; e usando o bot√£o &quot;Iniciar&quot;, executar a procedimento de
otimiza√ß√£o. Note que ao otimizar, o Provador de Estrat√©gia buscar√° pelos valores m√°ximos da fun√ß√£o
OnTester. Para encontrar um m√≠nimo local, retorne o inverso do valor computado da fun√ß√£o
proveniente da fun√ß√£o OnTester:
return(1/function_value);
√â necess√°rio verificar que o function_value n√£o √© igual a zero, j√° que de outra forma n√≥s podemos
obter um erro cr√≠tico de dividir por zero.
Existe uma outra forma, mais conveniente e que n√£o distorce os resultados da otimiza√ß√£o, ela foi
sugerida pelos leitores deste artigo:
return(-function_value);
Esta op√ß√£o n√£o requer a verifica√ß√£o do function_value ser igual a zero, e a superf√≠cie dos resultados
da otimiza√ß√£o em uma representa√ß√£o em 3D tem a mesma forma, por√©m √© espelhada da original.
<h3>Como exemplo, fornecemos a fun√ß√£o sink():</h3>
O c√≥digo do EA para encontrar o extremo desta fun√ß√£o √© colocada dentro do OnTester():
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                         Sink.mq5 |
//|                        Copyright 2011, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
//--- par√¢metros de entrada
input double   x=-3.0; // start=-3, step=0.05, stop=3
input double   y=-3.0; // start=-3, step=0.05, stop=3
//+------------------------------------------------------------------+
//| Tester function                                                  |
//+------------------------------------------------------------------+
double OnTester()</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1106
</p>
<pre><code class="language-mql5">
  {
//---
   double sink=MathSin(x*x+y*y);
//---
   return(sink);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
</code></pre>
<p>
Execute uma otimiza√ß√£o e veja os resultados da otimiza√ß√£o na forma de um gr√°fico 2D.
Quanto melhor for o valor para um dado par de par√¢metros (x,y), mais saturada √© a cor. Como era
esperado a partir da observa√ß√£o da forma da formula sink(), seus valores forma c√≠rculos conc√™ntricos
com centro em (0,0). Pode-se ver no gr√°fico 3D, que a fun√ß√£o sink() n√£o tem um √∫nico extremo
global:</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1107
A Sincroniza√ß√£o de Barras no modo &quot;Somente Pre√ßo de Abertura&quot;
O Provador de Estrat√©gia no terminal cliente do MetaTrader 5 permite-nos verificar os chamados EAs
&quot;multi-moedas&quot;. Uma EA multi-moeda - √© um EA que negocia sobre dois ou mais ativos.
O teste de estrat√©gias, que negociam em ativos m√∫ltiplos, imp√µe alguns requerimentos t√©cnicos
adicionais ao Provador de Estrat√©gia:
¬∑ A gera√ß√£o de ticks para estes ativos;
¬∑ O c√°lculo de valores de indicadores para estes ativos;
¬∑ O c√°lculo de requerimentos de margem para estes ativos;
¬∑ Sincroniza√ß√£o das seq√º√™ncias de ticks geradas para todos os ativos negociados.
O Provador de Estrat√©gia gera e joga uma seq√º√™ncia de ticks para cada instrumento em concord√¢ncia
com o modo de negocia√ß√£o selecionado. Ao mesmo tempo e para cada ativo, uma nova barra √© aberta,
independentemente de como a barra abriu em outro ativo. Isso significa que ao testar um EA multi-
moeda, uma situa√ß√£o pode ocorrer (e freq√ºentemente acontece), quando para um instrumento, uma
nova barra j√° abriu, e para o outro instrumento, ela n√£o abriu. Assim, em um teste, tudo acontece
como na realizada.
Esta simula√ß√£o aut√™ntica do hist√≥rico no Provador de Estrat√©gia n√£o causa nenhum problema contanto
que os modos de teste &quot;Cada Tick&quot; e &quot;OHLC por minuto&quot; sejam usados. Para estes modos, ticks
suficientes s√£o gerados para um candlestick, para ser capaz de esperar at√© a sincroniza√ß√£o das barras
de diferentes ativos aconte√ßa. Mas como n√≥s testamos estrat√©gias multi-moeda no modo &quot;Somente
Pre√ßos de Abertura&quot;, se a sincroniza√ß√£o das barras nos instrumentos de negocia√ß√£o √© obrigat√≥ria?
Neste modo, o EA √© chamado somente em um tick, que corresponde ao momento de abertura das
barras.
N√≥s ilustraremos isso com um exemplo: se n√≥s estamos testando um EA no EURUSD, e um novo
candlestick de hora abriu em EURUSD, ent√£o podemos reconhecer facilmente este fato - em um teste
no modo &quot;Somente Pre√ßos de Abertura&quot;, o evento NewTick corresponde ao momento da abertura da</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1108
barra sobre o per√≠odo do teste. Mas n√£o exitem garantias que o novo candlestick abriu no ativo
USPJPY, √© que usado no EA.
Em condi√ß√µes normais, √© suficiente completar o trabalho da fun√ß√£o OnTick() e verificar pelo
surgimento de uma nova barra em USDJPY no pr√≥ximo tick. Mas ao testar em modo &quot;Somente Pre√ßos
de Abertura&quot;, n√£o haver√° um outro tick, e assim pode parecer que este modo n√£o √© adequado para
testar EAs multi-moedas. Mas isso n√£o √© o caso - n√£o se esque√ßa que o testador no MetraTrader 5 se
comporta como se fosse no mundo real. Voc√™ pode esperar at√© uma nova barra ser aberta em outros
ativos usando a fun√ß√£o Sleep()!
O c√≥digo do EA Synchronize_Bars_Use_Sleep.mq5, que mostra um exemplo da sincroniza√ß√£o de barras
no modo &quot;Somente Pre√ßos de Abertura&quot;:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                   Synchronize_Bars_Use_Sleep.mq5 |
//|                        Copyright 2011, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
//--- par√¢metros de entrada
input string   other_symbol=&quot;USDJPY&quot;;
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- verifica ativo
   if(_Symbol==other_symbol)
     {
      PrintFormat(&quot;Voc√™ tem de especificar outro s√≠mbolo nos par√¢metros de entrada ou 
      //--- for√ßa parar teste
      return(INIT_PARAMETERS_INCORRECT);
     }
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o tick (ponto) de um Expert                                 |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- vari√°vel est√°tica usada para armazenar a hora da √∫ltima barra
   static datetime last_bar_time=0;
//--- flag de sincroniza√ß√£o
   static bool synchonized=false;
//--- caso a vari√°vel est√°tica n√£o esteja inicializada
   if(last_bar_time==0)
     {</p>
<p></code></pre>
<p>
<h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1109
</p>
<pre><code class="language-mql5">
      //--- √© a primeira chamada, salva hora da barra e saiu
      last_bar_time=(datetime)SeriesInfoInteger(_Symbol,Period(),SERIES_LASTBAR_DATE);
      PrintFormat(&quot;A vari√°vel last_bar_time √© inicializada com valor %s&quot;,TimeToString
     }
//--- obt√©m hora de abertura da √∫ltima barra do ativo do gr√°fico
   datetime curr_time=(datetime)SeriesInfoInteger(Symbol(),Period(),SERIES_LASTBAR_DAT
//--- se as horas n√£o s√£o iguais
   if(curr_time!=last_bar_time)
     {
      //--- salva a hora da barra aberta na vari√°vel est√°tica
      last_bar_time=curr_time;
      //--- n√£o sincronizado
      synchonized=false;
      //--- imprime mensagem
      PrintFormat(&quot;Uma nova barra est√° aparecendo no s√≠mbolo %s em %s&quot;,_Symbol,TimeToS
     }
//--- hora de abertura da barra de outra ativo
   datetime other_time;
//--- loop at√© a hora de abertura do outro ativo ser igual a curr_time
   while(!(curr_time==(other_time=(datetime)SeriesInfoInteger(other_symbol,Period(),SE
     {
      PrintFormat(&quot;Espera 5 segundos..&quot;);
      //--- espera 5 segundos e chama SeriesInfoInteger(other_symbol,Period(),SERIES_L
      Sleep(5000);
     }
//--- barras s√£o sincronizadas
   synchonized=true;
   PrintFormat(&quot;Tempo de abertura da barra do s√≠mbolo %s do gr√°fico: √© %s&quot;,_Symbol,Tim
   PrintFormat(&quot;Tempo de abertura da barra do s√≠mbolo %s: √© %s&quot;,other_symbol,TimeToStr
//--- TimeCurrent() n√£o √© √∫til, usar TimeTradeServer()
   Print(&quot;As barras s√£o sincronizadas em &quot;,TimeToString(TimeTradeServer(),TIME_SECONDS
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
</code></pre>
<p>
Perceba que a √∫ltima linha no EA, que exibe a hora corrente quando o sincroniza√ß√£o de fato foi
estabelecida:
</p>
<pre><code class="language-mql5">
   Print(&quot;As barras s√£o sincronizadas em &quot;,TimeToString(TimeTradeServer(),TIME_SECONDS
</code></pre>
<p>
Para exibir a hora corrente usamos a fun√ß√£o TimeTradeServer() ao inv√©s de TimeCurrent(). A fun√ß√£o
TimeCurrent() retorna o hora do √∫ltimo tick, que n√£o se altera ap√≥s usar Sleep(). Executa o EA no
modo &quot;Abertura de pre√ßos apenas&quot;,e voc√™ ver√° uma mensagem sobre a sincroniza√ß√£o dos barras.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1110
Use a fun√ß√£o TimeTradeServer() ao inv√©s de TimeCurrent(), se voc√™ precisar obter hora corrente do
servidor, e n√£o a hora da chegado do √∫ltimo tick.
Existe uma outra forma para sincronizar barras - usando um timer. Um exemplo de tal EA √©
Synchronize_Bars_Use_OnTimer.mq5, que est√° anexado neste artigo.
A fun√ß√£o IndicatorRelease() no Provador de Estrat√©gia
Ap√≥s completar um teste individual, um gr√°fico do instrumento √© automaticamente aberto, que exibe
as opera√ß√µes (deals) completas e os indicadores usados no EA. Isso ajuda a verificar visualmente os
pontos de entrada e sa√≠da, e comprar√°-los com os valores dos indicadores.  
Observa√ß√£o: indicadores, exibidos no gr√°fico, que automaticamente abrem ap√≥s a conclus√£o do
teste, s√£o calculados novamente ap√≥s a conclus√£o do teste. Mesmo se estes indicadores foram
usados no EA testado.
Mas em alguns casos, o programador pode querer ocultar a informa√ß√£o sobre quais indicadores
estavam envolvidos nos algoritmos de negocia√ß√£o. Por exemplo, o c√≥digo do EA √© alugado ou vendido
como um arquivo execut√°vel, sem o fornecimento do c√≥digo fonte. Para este prop√≥sito, a fun√ß√£o
IndicatorRelease() √© apropriada.
Se o terminal define um template com o nome tester.tpl no directory/profiles/templates do terminal
cliente, ent√£o ele ser√° aplicado ao gr√°fico aberto. Na usa aus√™ncia, o template padr√£o √© aplicado.
(default.tpl).
A fun√ß√£o IndicatorRelease() √© originalmente destinada para liberar a por√ß√£o de c√°lculo do indicador,
caso ele mais mais seja necess√°rio. Isso permite economizar tanto a mem√≥ria quando os recursos de
CPU, porque cada tick pede um c√°lculo do indicador. Seu segundo prop√≥sito - √© proibir a exibi√ß√£o de
um indicador no gr√°fico de teste, ap√≥s uma execu√ß√£o de teste individual.
Para proibir a exibi√ß√£o do indicador no gr√°fico ap√≥s um teste, chame o IndicatorRelease() com o
handle do indicator no handler OnDeinit(). A fun√ß√£o OnDeinit() √© sempre chamada ap√≥s a conclus√£o e
antes da exibi√ß√£o do gr√°fico de teste.
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de Desinicializa√ß√£o do Expert                             |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
   bool hidden=IndicatorRelease(handle_ind);
   if(hidden) Print(&quot;IndicatorRelease() completado com sucesso&quot;);
   else Print(&quot;IndicatorRelease() retorna false. Erro de c√≥digo &quot;,GetLastError());
</code></pre>
<p>
  }
A fim de proibir a exibi√ß√£o do indicador no gr√°fico, ap√≥s a conclus√£o de um teste √∫nico, use a fun√ß√£o
IndicatorRelease() no handler OnDeinit().
Tratamento de Evento no Provador de Estrat√©gia</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1111
A presen√ßa do handler OnTick() no EA n√£o √© obrigat√≥ria para que possa ser pass√≠vel de teste em dados
hist√≥ricos no Provador de Estrat√©gias do MetaTrader 5. √â suficiente para o EA conter pelo menos as
seguintes fun√ß√µes-handlers:
¬∑ OnTick() - Handler de evento de uma nova chegada de tick;
¬∑ OnTrade() - Handler de evento de negocia√ß√£o;
¬∑ OnTimer() - Handler de evento de uma chegada de sinal do timer;
¬∑ OnChartEvent() - um handler para eventos de cliente.
Ao testar um EA, n√≥s pode tratar eventos customizados usando a fun√ß√£o OnChartEvent(), mas nos
indicadores, esta fun√ß√£o n√£o pode ser chamada no testador. Mesmo se o indicador tiver o handler de
evento OnChartEvent() e este indicador for usado em um EA testado, o indicador em si n√£o receber√°
nenhum evento customizado.
<h3>Durante um</h3>
teste, 
um 
<h3>Indicador</h3>
pode 
gerar 
eventos 
customizados 
usando 
a 
fun√ß√£o
EventChartCustom(), e o EA pode processar este evento no OnChartEvent().
Al√©m destes eventos, eventos especiais associados com o processo de teste e otimiza√ß√£o s√£o gerados
no Provador de Estrat√©gia:
¬∑ Tester - este evento √© gerado ap√≥s conclus√£o do teste do Expert Advisor sobre dados hist√≥ricos. O
evento Tester √© tratado usando a fun√ß√£o OnTester(). Esta fun√ß√£o pode ser usada apenas quando
testar Expert Advisor e est√° destinada sobretudo para o c√°lculo de um valor que √© usado como um
crit√©rio m√°ximo personalizado para otimiza√ß√£o de par√¢metros de entrada gen√©rica.
¬∑ TesterInit - este evento √© gerado durante o in√≠cio da otimiza√ß√£o no Provador de Estrat√©gia e antes
do primeiro passo. O evento TesterInit √© tratado usando a fun√ß√£o OnTesterInit(). Durante o in√≠cio
da otimiza√ß√£o, um Expert Advisor com este handler √© carregado automaticamente em um gr√°fico de
terminal separado com o ativo e per√≠odo especificados no testador, e recebe o evento TesterInit.
Esta fun√ß√£o √© usada para inicializar um Expert Advisor antes de iniciar a otimiza√ß√£o para posterior
processamento dos resultados da otimiza√ß√£o.
¬∑ TesterPass - este evento √© gerado quanto um novo data frame √© recebido. O evento TesterPass √©
tratado usando a fun√ß√£o OnTesterPass(). Um Expert Advsor com este handler √© carregado
automaticamente em um gr√°fico de terminal separado com o ativo/per√≠odo especificados para
teste, e recebe um evento TesterPass quando um frame √© recebido durante otimiza√ß√£o. A fun√ß√£o √©
usado para tratamento din√¢mico de resultados de otimiza√ß√£o &quot;in loco&quot; sem esperar pela sua
conclus√£o. Frames s√£o adicionados usando a fun√ß√£o FrameAdd(), que pode ser chamada ap√≥s o fim
de um passo individual no handler OnTester().
¬∑ TesterDeinit - este evento √© gerado ap√≥s o fim da otimiza√ß√£o do Expert Advisor no Provador de
Estrat√©gia. O evento TesterDeinit √© tratado usando a fun√ß√£o OnTesterDeinit(). Um Expert Advisor
com este handler √© carregado automaticamente em um gr√°fico no come√ßo da otimiza√ß√£o, e recebe
TesterDeInit ap√≥s sua conclus√£o. A fun√ß√£o √© usado para o processamento final de todos os
resultados da otimiza√ß√£o. 
<h3>Agentes de Teste</h3>
O teste no terminal cliente MetaTrader 5 √© realizado usando agentes de teste. Agentes locais s√£o
criados e habilitados automaticamente. O n√∫mero padr√£o de agentes locais corresponde ao n√∫mero de
n√∫cleos em um computador.
Cada agente de teste tem sua pr√≥pria c√≥pia das vari√°veis globais, que n√£o s√£o relacionados com o
terminal cliente. O terminal em si √© o despachante, que distribui as tarefas para os agentes locais e</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1112
remotos. Apos executar uma tarefa no teste de um EA, com os par√¢metros dados, o agente retorna o
resultado para o terminal. Para um teste individual, somente um agente √© usado.
O agente armazena o hist√≥rico, recebido do terminal, em pastas separadas, pelo nome do
instrumento, assim o hist√≥rico para EURUSD √© armazenado em uma pasta chamada EURUSD. Al√©m
disso, o hist√≥rico dos instrumentos √© separado pelas suas fontes. A estrutura para armazenar o
hist√≥rico tem o seguinte forma:
tester_catalog\Agent-IPaddress-Port\bases\name_source\history\symbol_name
Por exemplo, o hist√≥rico para EURUSD proveniente do servidor MetaQuotes-Demo pode ser
armazenada na pasta tester_catalog\Agent-127.0.0.1-3000\bases\MetaQuotes-Demo\EURUSD.
Um agente local, ap√≥s a conclus√£o de um teste, entra em modo de espera, aguardando a pr√≥xima
tarefa por mais 5 minutos, de modo a n√£o perder tempo com o lan√ßamento para a pr√≥xima chamada.
Somente ap√≥s o per√≠odo de espera acabar, o agente local desliga e se descarrega da mem√≥ria do CPU.
No caso de uma conclus√£o antecipada do testador, por parte do usu√°rio (o bot√£o &quot;Cancelar&quot;), bem
como com o fechamento do terminal cliente, todos os agentes locais imediatamente param seu
trabalhar e s√£o descarregados da mem√≥ria.
A Troca de Dados entre o Terminal e o Agente
Ao rodar um teste, o terminal cliente prepara para enviar ao agente um n√∫mero de blocos de
par√¢metros:
¬∑ Par√¢metros de input para o teste (modo de simula√ß√£o, o intervalo do teste, instrumentos, crit√©rio
de otimiza√ß√£o, etc.)
¬∑ A lista dos ativos selecionados na janela &quot;Observa√ß√£o de Mercado&quot;
¬∑ A especifica√ß√£o do ativo do teste (o tamanho do contrato, as margens permitidas do mercado para
definir um StopLoss e Takeprofit, etc)
¬∑ O Expert Advisor (robot) para ser testado e os valores de seus par√¢metros de entrada
¬∑ Informa√ß√µes sobre arquivos adicionais (bibliotecas, indicadores, arquivos de dados - # property
tester_ ...)
tester_indicator
string
<h3>Nome</h3>
de 
um 
indicador 
customizado 
no 
formato 
de
&quot;indicator_name.ex5&quot;. Indicadores que requerem teste s√£o
definidos automaticamente a partir da chamada √† fun√ß√£o
iCustom(), se o correspondente par√¢metro estiver definido atrav√©s
de um string constante. Para todos os outros casos (use da fun√ß√£o
IndicatorCreate() ou uso de uma string n√£o constante no
par√¢metro que defini o nome do indicador) esta propriedade √©
requerida
tester_file
string
Nome de arquivo para um testador com a indica√ß√£o de extens√£o,
entre aspas duplas (como uma string constante). O arquivo
especificado ser√° passado para o Testador de Estrat√©gias.
Arquivos de entrada para serem testados, se forem necess√°rios,
devem sempre ser especificados.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1113
tester_indicator
string
<h3>Nome</h3>
de 
um 
indicador 
customizado 
no 
formato 
de
&quot;indicator_name.ex5&quot;. Indicadores que requerem teste s√£o
definidos automaticamente a partir da chamada √† fun√ß√£o
iCustom(), se o correspondente par√¢metro estiver definido atrav√©s
de um string constante. Para todos os outros casos (use da fun√ß√£o
IndicatorCreate() ou uso de uma string n√£o constante no
par√¢metro que defini o nome do indicador) esta propriedade √©
requerida
tester_library
string
Nome da biblioteca (library) com a extens√£o, entre aspas duplas.
Uma biblioteca pode ter extens√£o dll ou ex5. Bibliotecas que
requerem teste s√£o definidas automaticamente. No entanto, se
alguma das bibliotecas √© usada por um indicador customizado, esta
propriedade √© requerida
Para cada bloco de par√¢metros, uma impress√£o digital na forma de MD5-hash √© criada, que √© enviado
para o agente. O MD5-hash √© √∫nico para cada conjunto, seu volume √© muito menor que a quantidade
de informa√ß√£o na qual ele √© calculado
O agente recebe um hash de blocos e os compara com aqueles que ele j√° tem. Se a impress√£o digital
do bloco de par√¢metros dado n√£o est√° presente no agente, ou o hash recebido √© diferente daquele
existente, o agente solicita este bloco de par√¢metros. Isso reduz o tr√°fego entre o terminal e o
agente.
Ap√≥s o teste, o agente retorna ao terminal todos os resultados da execu√ß√£o, que s√£o exibidos nas
guias &quot;Resultados&quot; e &quot;Resultados da Otimiza√ß√£o&quot;: o lucro recebido, o n√∫mero de opera√ß√µes (deals), o
coeficiente Sharpe, o resultdo da fun√ß√£o OnTester(), etc.
Durante a otimiza√ß√£o, o terminal distribui tarefas de teste para os agentes em pequenos pacotes,
cada pacote contendo v√°rias tarefas (cada tarefa significando testes individuais com um conjunto de
par√¢metros de entrada). Isso reduz o tempo de troca entre o terminal e o agente.
Os agentes nunca gravam no disco r√≠gido o arquivo EX5, obtido do terminal (EA, indicadores,
bibliotecas, etc.) for raz√µes de seguran√ßa, de modo que um computador com um agente em execu√ß√£o
n√£o pode usar os dados enviados. Todos os outros arquivos, incluindo DLL, s√£o gravados na caixa de
areia. Em agentes remotos voc√™ n√£o pode testar EAs usando DLL.
Os resultados do teste s√£o adicionados pelo terminal em uma cache especial de resultados (o cache de
resultado), para um acesso r√°pido a estes resultados quando necess√°rio. Para cada conjunto de
par√¢metros, o terminal busca o cache de resultados por resultados j√° dispon√≠veis a partir de execu√ß√µes
anteriores, a fim de evitar re-execu√ß√µes. Se o resultado com tal conjunto de par√¢metros n√£o √©
encontrado, ao agente √© dado a tarefa de conduzir o teste.
Todo tr√°fego entre o terminal e o agente √© encripto-grafado.
Ticks n√£o s√£o enviados pela rede, eles s√£o gerados nos agentes de teste.
Usando a Pasta Compartilhada para Todos os Terminais Cliente
Todos os agentes de teste s√£o isolados uns dos outros e do terminal cliente: cada agente tem sua
pr√≥pria pasta na qual seus logs s√£o gravados. Al√©m disso, todas as opera√ß√µes de arquivo durante o</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1114
teste do agente ocorrem na pasta agent_name/MQL5/Files. Contudo, n√≥s podemos implementar a
intera√ß√£o entre os agentes locais e o terminal cliente atrav√©s de uma pasta compartilhada para todos
os terminais clientes, se durante a abertura do arquivo voc√™ especificar a flag FILE_COMMON:
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- a pasta compartilhada para todos os terminais cliente
   common_folder=TerminalInfoString(TERMINAL_COMMONDATA_PATH);
//--- imprime o nome desta pasta
   PrintFormat(&quot;Abrir o arquivo na pasta compartilhada dos terminais de cliente %s&quot;, c
//--- abre um arquivo na pasta compartilhada (indicada pelo flag FILE_COMMON)
   handle=FileOpen(filename,FILE_WRITE|FILE_READ|FILE_COMMON);
</code></pre>
<p>
¬† ... novas a√ß√µes
</p>
<pre><code class="language-mql5">
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
<h3>Usando DLLs</h3>
Para acelerar a otimiza√ß√£o n√≥s podemos usar n√£o somente agentes locais, mas tamb√©m agentes
remotos. Neste caso, existem algumas limita√ß√µes para agentes remotos. Primeiramente, agentes
remotos n√£o exibem em seus logs os resultados da execu√ß√£o da fun√ß√£o Print(), mensagens sobre a
abertura e enceramento de posi√ß√µes. Um m√≠nimo de informa√ß√£o √© exibida no log para impedir que EAs
escritos incorretamente de atolem o computador, no qual o agente remoto est√° trabalhando, com
mensagens.
A segunda limita√ß√£o - a proibi√ß√£o no uso de DLL ao testar EAs. Chamadas de DLL s√£o absolutamente
proibidas em agentes remotos por raz√µes de seguran√ßa. Em agentes locais, chamadas de DLL em EAs
testados s√£o permitidas somente com a apropriada permiss√£o &quot;Allow import DLL&quot;.</p>
<p><h3>Programas MQL5</h3>
¬© 2000-2025, MetaQuotes Ltd.
1115
Observa√ß√£o: Ao usar os c√≥digos recebidos dos EAs (scripts, indicadores) que requerem a
permiss√£o para fazer chamadas de DLL, voc√™ deve estar ciente dos riscos, que voc√™ assume ao
permitir este op√ß√£o nas configura√ß√µes do terminal. Independentemente de como a EA ser√° usada -
para teste ou para execu√ß√£o em um gr√°fico.
</p>
        </article>
        
        <footer>
            <p>Documenta√ß√£o MQL5 - Fonte: MetaQuotes Ltd.</p>
        </footer>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function toggleSidebar() {
            document.querySelector('.sidebar').classList.toggle('open');
        }
        
        function filterNav() {
            const filter = document.getElementById('search').value.toLowerCase();
            const items = document.querySelectorAll('.nav-list li');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }
    </script>
</body>
</html>