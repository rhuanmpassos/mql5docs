<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S√©ries Temporais e Acesso a Indicadores - MQL5 Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>MQL5 Docs</h1>
            <p>Documenta√ß√£o Completa</p>
        </div>
        <div class="search-box">
            <input type="text" id="search" placeholder="Buscar..." onkeyup="filterNav()">
        </div>
        <ul class="nav-list" id="nav-list">
            <li class=""><a href="index.html">üìö √çndice</a></li>
            <li class=""><a href="introducao.html">Introducao</a></li>
<li class=""><a href="refer√™ncia_mql5.html">Refer√™ncia MQL5</a></li>
<li class=""><a href="elementos_b√°sicos_da_linguagem.html">Elementos B√°sicos da Linguagem</a></li>
<li class=""><a href="constantes,_enumeradores_e_estruturas.html">Constantes, Enumeradores e Estruturas</a></li>
<li class=""><a href="programas_mql5.html">Programas MQL5</a></li>
<li class=""><a href="vari√°veis_predefinidas.html">Vari√°veis Predefinidas</a></li>
<li class=""><a href="fun√ß√µes_comuns.html">Fun√ß√µes Comuns</a></li>
<li class=""><a href="fun√ß√µes_para_array.html">Fun√ß√µes para Array</a></li>
<li class=""><a href="m√©todos_matriciais_e_vetoriais.html">M√©todos matriciais e vetoriais</a></li>
<li class=""><a href="fun√ß√µes_de_convers√£o.html">Fun√ß√µes de Convers√£o</a></li>
<li class=""><a href="fun√ß√µes_matem√°ticas.html">Fun√ß√µes Matem√°ticas</a></li>
<li class=""><a href="fun√ß√µes_de_string.html">Fun√ß√µes de String</a></li>
<li class=""><a href="data_e_hora.html">Data e Hora</a></li>
<li class=""><a href="informa√ß√µes_de_conta.html">Informa√ß√µes de Conta</a></li>
<li class=""><a href="verificando_estado.html">Verificando Estado</a></li>
<li class=""><a href="manipula√ß√£o_de_eventos.html">Manipula√ß√£o de eventos</a></li>
<li class=""><a href="informa√ß√µes_de_mercado.html">Informa√ß√µes de Mercado</a></li>
<li class=""><a href="calend√°rio_econ√¥mico.html">Calend√°rio econ√¥mico</a></li>
<li class="active"><a href="s√©ries_temporais_e_acesso_a_indicadores.html">S√©ries Temporais e Acesso a Indicadores</a></li>
<li class=""><a href="s√≠mbolos_personalizados.html">S√≠mbolos personalizados</a></li>
<li class=""><a href="opera√ß√µes_de_gr√°ficos.html">Opera√ß√µes de Gr√°ficos</a></li>
<li class=""><a href="fun√ß√µes_de_negocia√ß√£o.html">Fun√ß√µes de Negocia√ß√£o</a></li>
<li class=""><a href="gerenciamento_de_sinais.html">Gerenciamento de sinais</a></li>
<li class=""><a href="fun√ß√µes_de_rede.html">Fun√ß√µes de rede</a></li>
<li class=""><a href="vari√°veis_globais_do_terminal.html">Vari√°veis Globais do Terminal</a></li>
<li class=""><a href="fun√ß√µes_de_arquivo.html">Fun√ß√µes de Arquivo</a></li>
<li class=""><a href="indicadores_customizados.html">Indicadores Customizados</a></li>
<li class=""><a href="fun√ß√µes_de_objeto.html">Fun√ß√µes de Objeto</a></li>
<li class=""><a href="indicadores_t√©cnicos.html">Indicadores T√©cnicos</a></li>
<li class=""><a href="trabalhando_com_resultados_de_otimiza√ß√£o.html">Trabalhando com Resultados de Otimiza√ß√£o</a></li>
<li class=""><a href="trabalhando_com_eventos.html">Trabalhando com Eventos</a></li>
<li class=""><a href="trabalhando_com_opencl.html">Trabalhando com OpenCL</a></li>
<li class=""><a href="trabalhar_com_bancos_de_dados.html">Trabalhar com bancos de dados</a></li>
<li class=""><a href="trabalho_com_directx.html">Trabalho com DirectX</a></li>
<li class=""><a href="metatrader_para_python.html">MetaTrader para Python</a></li>
<li class=""><a href="modelos_onnx.html">Modelos ONNX</a></li>
<li class=""><a href="biblioteca_padr√£o.html">Biblioteca Padr√£o</a></li>
<li class=""><a href="migrando_do_mql4.html">Migrando do MQL4</a></li>
<li class=""><a href="lista_de_fun√ß√µes_mql5.html">Lista de Fun√ß√µes MQL5</a></li>
<li class=""><a href="lista_de_constantes_mql5.html">Lista de Constantes MQL5</a></li>

        </ul>
    </nav>
    
    <main class="content">
        <header>
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1>S√©ries Temporais e Acesso a Indicadores</h1>
        </header>
        
        <article>
            <p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2037
Acesso a s√©ries de tempo e indicadores
Estas s√£o fun√ß√µes para trabalhar com s√©ries de tempo e indicadores. Uma s√©rie de tempo difere de um
array de dados usual pela sua ordena√ß√£o reversa - elementos de s√©ries de tempo s√£o indexados do
final de um array para seu in√≠cio (a partir do mais recente para o mais antigo). Para copiar valores de
s√©ries de tempo e dados de indicadores, √© recomend√°vel usar somente arrays din√¢micos, porque as
fun√ß√µes de c√≥pia est√£o projetadas para alocar o tamanho necess√°rio dos arrays que recebem valores.
Existe uma importante exce√ß√£o a esta regra: se valores de s√©ries de tempo e indicadores precisam
ser copiados com freq√º√™ncia, por exemplo, a cada chamada de OnTick() em Expert Advisors ou a cada
chamada de OnCalculate() em indicadores, neste caso seria melhor usar arrays alocados
estaticamente, porque opera√ß√µes de aloca√ß√£o de mem√≥ria para arrays din√¢micos requerem um
tempo adicional, e isso ter√° efeitos durante os processos de teste e otimiza√ß√£o.
Ao usar fun√ß√µes de acesso a valores de s√©ries de tempo e indicadores, a dire√ß√£o de indexa√ß√£o deve
ser leva em considera√ß√£o. Isso √© descrito na se√ß√£o Dire√ß√£o de indexa√ß√£o em arrays e s√©ries de tempo.
O acesso a dados de indicadores e s√©ries de tempo √© implementado independentemente do fato dos
dados solicitados estarem prontos ou n√£o (o chamado acesso ass√≠ncrono). Isso √© extremamente
importante para os c√°lculos de um indicador customizado, porque se n√£o houver dados, as fun√ß√µes de
tipo Copy...() retornam imediatamente um erro. Contudo, ao acessar dados a partir de Expert
Advisors e scripts, as v√°rias tentativas para receber dados s√£o feitos com uma pausa pequena, cujo
objetivo √© fornecer algum tempo necess√°rio para baixar a s√©rie de tempo requerida para calcular
valores de um indicador.
A se√ß√£o Organizando Acesso a Dados descreve detalhes de recebimento, armazenamento e solicita√ß√£o
de dados de pre√ßo no terminal cliente MetaTrader 5.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2038
√â historicamente aceito que um acesso a dados de pre√ßo em um array √© realizado a partir do final dos
dados. Fisicamente, os novos dados s√£o sempre escritos no final do array, mas o √≠ndice do array √©
sempre igual a zero. O √≠ndice 0 no array de s√©rie de tempo denota dados da barra corrente, isto √©, a
barra que correspondente ao intervalo de tempo n√£o terminado nesta janela de tempo.
Uma janela de tempo √© o per√≠odo de tempo, durante o qual uma √∫nica barra de pre√ßo √© formada.
Existem 21 janelas de tempo padr√£o predefinidas. 
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>SeriesInfoInteger</h3>
Retorna informa√ß√£o sobre o estado dos dados hist√≥ricos
<h3>Bars</h3>
Retorna o n√∫mero de barras do hist√≥rico para um ativo e per√≠odo
especificados
<h3>BarsCalculated</h3>
Retorna o n√∫mero de dados calculados em um buffer de indicador ou -1 em
caso de erro (os dados n√£o foram calculados ainda)
<h3>IndicatorCreate</h3>
Retorna o handle para o indicador t√©cnico especificado criado por um array
de par√¢metros de tipo MqlParam
<h3>IndicatorParameters</h3>
Baseado no handle especificado, retorna o n√∫mero de par√¢metros de
entrada do indicador, bem como os valores e tipos dos par√¢metros
<h3>IndicatorRelease</h3>
Remove um handle de indicador e libera o bloco de c√°lculo do indicador, se
ele n√£o for usado por ningu√©m mais
<h3>CopyBuffer</h3>
Copia dados de um buffer especificado de um indicador especificado em
um array
<h3>CopyRates</h3>
Obt√©m dados hist√≥ricos da estrutura Rates para um ativo e per√≠odo
especificados em um array
<h3>CopySeries</h3>
Obt√©m no conjunto de arrays especificado as s√©ries temporais
sincronizadas da estrutura MqlRates para o s√≠mbolo-per√≠odo especificado
na quantidade especificada. 
<h3>CopyTime</h3>
Obt√©m dados hist√≥ricos sobre hora de abertura de barras para um ativo e
per√≠odo especificados em um array
<h3>CopyOpen</h3>
Obt√©m dados hist√≥ricos sobre pre√ßo de abertura de barras para um ativo e
per√≠odo especificados em um array
<h3>CopyHigh</h3>
Obt√©m hist√≥rico de dados sobre pre√ßo de barra m√°ximo para um ativo e
per√≠odo especificados em um array
<h3>CopyLow</h3>
Obt√©m hist√≥rico de dados sobre pre√ßo de barra minimo para um ativo e
per√≠odo especificados em um array
<h3>CopyClose</h3>
Obt√©m hist√≥rico de dados sobre pre√ßo de fechamento de barra para um
ativo e per√≠odo especificados em um array
<h3>CopyTickVolume</h3>
Obt√©m hist√≥rico de dados sobre volumes de tick para um ativo e per√≠odo
especificados em um array
<h3>CopyRealVolume</h3>
Obt√©m dados hist√≥ricos sobre volumes de negocia√ß√£o para um ativo e
per√≠odo especificados em um array</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2039
<h3>Fun√ß√£o</h3>
<h3>A√ß√£o</h3>
<h3>CopySpread</h3>
Obt√©m hist√≥rico de dados sobre spreads para um ativo e per√≠odo
especificados em um array
<h3>CopyTicks</h3>
Obt√©m, dentro da matriz ticks_array, ticks no formato MqlTick
<h3>CopyTicksRange</h3>
Obt√©m, na matriz ticks_array, ticks em formato MqlTick
iBars
Retorna o n√∫mero de barras - no hist√≥rico - do s√≠mbolo e do per√≠odo
correspondentes
iBarShift
Retorna o √≠ndice da barra na qual o tempo especificado coincide
iClose
Retorna o valor do pre√ßo de fechamento da barra (indicado pelo par√¢metro
shift) do gr√°fico correspondente
iHigh
Retorna o valor do pre√ßo m√°ximo da barra (especificado pelo par√¢metro
shift) do gr√°fico correspondente
iHighest
Retorna o √≠ndice do maior valor encontrado (deslocamento relativo √† barra
atual) do gr√°fico correspondente
iLow
Retorna o valor do pre√ßo m√≠nimo da barra (indicado pelo par√¢metro shift)
do gr√°fico correspondente
iLowest
Retorna o √≠ndice do menor valor encontrado (deslocamento relativo √† barra
atual) do gr√°fico correspondente
iOpen
Retorna o valor do pre√ßo de abertura da barra (indicado pelo par√¢metro
shift) do gr√°fico correspondente
iTime
Retorna o valor do tempo de abertura da barra (indicado pelo par√¢metro
shift) do gr√°fico correspondente
iTickVolume
Retorna o valor do volume de tick (especificado pelo par√¢metro shift) do
gr√°fico correspondente
iRealVolume
Retorna o valor do volume real da barra (indicado pelo par√¢metro shift) do
gr√°fico correspondente
iVolume
Retorna o valor do volume de tick (especificado pelo par√¢metro shift) do
gr√°fico correspondente
iSpread
Retorna o valor do spread da barra (indicado pelo par√¢metro shift) do
gr√°fico correspondente
Apesar do fato de que pelo uso da fun√ß√£o ArraySetAsSeries() √© poss√≠vel definir em arrays acesso aos
elementos como em s√©ries de tempo, deve ser lembrado que os elementos de arrays s√£o fisicamente
armazenados na mesma e √∫nica ordem - somente a dire√ß√£o de indexa√ß√£o muda. Para demonstrar este
fato, vamos apresentar um exemplo:
</p>
<pre><code class="language-mql5">
   datetime TimeAsSeries[];
//--- define acesso ao array como uma s√©rie de tempo
   ArraySetAsSeries(TimeAsSeries,true);
   ResetLastError();
   int copied=CopyTime(NULL,0,0,10,TimeAsSeries);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2040
</p>
<pre><code class="language-mql5">
   if(copied&lt;=0)
     {
      Print(&quot;A opera√ß√£o de c√≥pia dos valores do tempo de abertura para as √∫ltimas 10 b
      return;
     }
   Print(&quot;TimeCurrent =&quot;,TimeCurrent());
   Print(&quot;ArraySize(Time) =&quot;,ArraySize(TimeAsSeries));
   int size=ArraySize(TimeAsSeries);
   for(int i=0;i&lt;size;i++)
     {
      Print(&quot;TimeAsSeries[&quot;+i+&quot;] =&quot;,TimeAsSeries[i]);
     }
   datetime ArrayNotSeries[];
   ArraySetAsSeries(ArrayNotSeries,false);
   ResetLastError();
   copied=CopyTime(NULL,0,0,10,ArrayNotSeries);
   if(copied&lt;=0)
     {
      Print(&quot;A opera√ß√£o de c√≥pia dos valores do tempo de abertura para as √∫ltimas 10 b
      return;
     }   
   size=ArraySize(ArrayNotSeries);
   for(int i=size-1;i&gt;=0;i--)
     {
      Print(&quot;ArrayNotSeries[&quot;+i+&quot;] =&quot;,ArrayNotSeries[i]);
     }
</code></pre>
<p>
Como resultado n√≥s conseguimos a seguinte sa√≠da:
<h3>TimeCurrent = 2009.06.11 14:16:23</h3>
<h3>ArraySize(Time) = 10</h3>
<h3>TimeAsSeries[0] = 2009.06.11 14:00:00</h3>
<h3>TimeAsSeries[1] = 2009.06.11 13:00:00</h3>
<h3>TimeAsSeries[2] = 2009.06.11 12:00:00</h3>
<h3>TimeAsSeries[3] = 2009.06.11 11:00:00</h3>
<h3>TimeAsSeries[4] = 2009.06.11 10:00:00</h3>
<h3>TimeAsSeries[5] = 2009.06.11 09:00:00</h3>
<h3>TimeAsSeries[6] = 2009.06.11 08:00:00</h3>
<h3>TimeAsSeries[7] = 2009.06.11 07:00:00</h3>
<h3>TimeAsSeries[8] = 2009.06.11 06:00:00</h3>
<h3>TimeAsSeries[9] = 2009.06.11 05:00:00</h3>
<h3>ArrayNotSeries[9] = 2009.06.11 14:00:00</h3>
<h3>ArrayNotSeries[8] = 2009.06.11 13:00:00</h3>
<h3>ArrayNotSeries[7] = 2009.06.11 12:00:00</h3>
<h3>ArrayNotSeries[6] = 2009.06.11 11:00:00</h3>
<h3>ArrayNotSeries[5] = 2009.06.11 10:00:00</h3>
<h3>ArrayNotSeries[4] = 2009.06.11 09:00:00</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2041
<h3>ArrayNotSeries[3] = 2009.06.11 08:00:00</h3>
<h3>ArrayNotSeries[2] = 2009.06.11 07:00:00</h3>
<h3>ArrayNotSeries[1] = 2009.06.11 06:00:00</h3>
<h3>ArrayNotSeries[0] = 2009.06.11 05:00:00</h3>
Como vemos a partir da sa√≠da, a medida que o √≠ndice do array TimeAsSeries aumenta, o valor da hora
do √≠ndice diminui, isto √©, n√≥s nos movemos do presente para o passado. Para o array comum
ArrayNotSeries o resultado √© diferente - a medida que o √≠ndice cresce, n√≥s nos movemos do passado
para o presente.
<h3>Veja tamb√©m</h3>
ArrayIsDynamic, ArrayGetAsSeries, ArraySetAsSeries, ArrayIsSeries</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2042
Dire√ß√£o de Indexa√ß√£o em Arrays, Buffers e S√©ries Temporais
A indexa√ß√£o padr√£o de todos os arrays e buffers de indicador √© da esquerda para direita. O √≠ndice do
primeiro elemento √© sempre igual a zero. Assim, o primeiro elemento de um array ou buffer de
indicador com √≠ndice 0 est√° por padr√£o na posi√ß√£o mais a esquerda, enquanto o √∫ltimo elemento est√°
na posi√ß√£o mais a direita.
Um buffer de indicador √© um array din√¢mico de tipo double, cujo tamanho √© gerenciado pelos
terminais clientes, de modo que ele sempre corresponde ao n√∫mero de barras do indicador sobre o
qual est√° calculando. Um array din√¢mico usual de tipo double √© atribu√≠do como um buffer de indicador
usando a fun√ß√£o SetIndexBuffer(). Buffers de indicador n√£o requerem que seus tamanhos sejam
definidos usando a fun√ß√£o ArrayResize() - isso ser√° feito pelo sistema de execu√ß√£o do terminal.
S√©ries de tempo s√£o array com indexa√ß√£o reversa, isto √©, o primeiro elemento de uma s√©rie de tempo
est√° na posi√ß√£o mais a direita, e o √∫ltimo elemento est√° na posi√ß√£o mais a esquerda. Em uma s√©rie de
tempo sendo usada para armazenar dados de pre√ßos hist√≥ricos e que cont√©m informa√ß√µes de hora, os
dados mais recentes s√£o colocados na posi√ß√£o mais a direita da s√©rie de tempo, enquanto que os
dados mais antigos na posi√ß√£o mais a esquerda. 
Assim o elemento da s√©rie de tempo com √≠ndice 0 cont√©m a informa√ß√£o sobre a √∫ltima cota√ß√£o de um
ativo. Se uma s√©rie de tempo cont√©m dados sobre uma janela de tempo di√°ria, os dados correntes do
dia ainda n√£o terminado ficam localizados na posi√ß√£o zero, e na posi√ß√£o com √≠ndice 1 cont√©m os dados
de ontem.
<h3>Alterando a Dire√ß√£o de Indexa√ß√£o</h3>
A fun√ß√£o ArraySetAsSeries() permite alterar o m√©todo de acessar elementos de um array din√¢mico; no
entanto, a ordem f√≠sica de armazenamento de dados na mem√≥ria do computador n√£o √© alterada. Esta
fun√ß√£o simplesmente altera o m√©todo de endere√ßar elementos de um array, assim quando copiar um
array em um outro usando a fun√ß√£o ArrayCopy(), o conte√∫do do array recipiente n√£o depender√° da
dire√ß√£o de indexa√ß√£o no array fonte.
A dire√ß√£o de indexa√ß√£o n√£o pode ser alterada para arrays alocados estaticamente. Mesmo se um array
</p>
<pre><code class="language-mql5">
for passado como um par√¢metro para uma fun√ß√£o, tentar alterar a dire√ß√£o de indexa√ß√£o dentro desta
</code></pre>
<p>
fun√ß√£o n√£o produzir√° nenhum efeito.
Para buffers de indicador, assim como para arrays comuns, a dire√ß√£o de indexa√ß√£o pode ser definida
no sentido contr√°rio (como em s√©ries de tempo), isto √©, uma refer√™ncia √† posi√ß√£o zero no buffer de
indicador retornar√° o √∫ltimo valor no correspondente buffer de indicador e isso n√£o corresponder√° ao
valor do indicador na barra mais recente. Contudo, a localiza√ß√£o f√≠sica das barras do indicador n√£o
ser√° alterada.
<h3>Recebendo Dados de Pre√ßo em Indicadores</h3>
Cada indicador customizado deve necessariamente conter a fun√ß√£o OnCalculate(), cujos dados de
pre√ßo requeridos para calcular valores em buffers de indicadores s√£o passados. A dire√ß√£o de indexa√ß√£o
nestes arrays passados pode ser descoberta usando a fun√ß√£o ArrayGetAsSeries().
Arrays passados para a fun√ß√£o refletem dados de pre√ßo, isto √©, estes arrays t√™m o sinal de uma s√©rie
de pre√ßo e a fun√ß√£o ArrayIsSeries() retornar√° true ao verificar estes arrays. Contudo, de qualquer
forma a dire√ß√£o de indexa√ß√£o deve ser verificada somente pela fun√ß√£o ArrayGetAsSeries(). </p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2043
A fim de n√£o ficar dependente de valores default, a fun√ß√£o ArraySetAsSeries() deve ser
incondicionalmente chamada para os arrays com os quais voc√™ vai trabalhar, e definir a dire√ß√£o
requerida.
Recebendo Dados de Pre√ßo e Valores de Indicador
A dire√ß√£o de indexa√ß√£o padr√£o de todos os arrays em Expert Advisores, indicadores e scripts √© da
esquerda para direita. Se necess√°rio, em qualquer programa mql5 voc√™ pode solicitar valores de s√©ries
de tempo de qualquer ativo e janela de tempo, bem como valores de indicadores calculados sobre
qualquer ativo e janela de tempo.
Use as fun√ß√µes Copy...() para este prop√≥sito:
¬∑ CopyBuffer ‚Äì copiar valores de um buffer de indicador para um array de tipo double;
¬∑ CopyRates ‚Äì copiar hist√≥rico de pre√ßos para um array de estruturas MqlRates;
¬∑ CopyTime ‚Äì copiar valores de Hora para um array de tipo datetime;
¬∑ CopyOpen ‚Äì copiar valores de Abertura para um array de tipo double;
¬∑ CopyHigh ‚Äì copiar valores de M√°ximo para um array de tipo double;
¬∑ CopyLow ‚Äì copiar valores de M√≠nimo para um array de tipo double;
¬∑ CopyClose ‚Äì copiar valores de Fechamento para um array de tipo double;
¬∑ CopyTickVolume ‚Äì copiar volumes de tick para um array de tipo long;
¬∑ CopyRealVolume ‚Äì copiar volumes de capital (equity) para um array de tipo long;
¬∑ CopySpread ‚Äì copiar o hist√≥rico de spreads para um array de tipo int;
Todas estas fun√ß√µes trabalham de forma similar. Vamos considerar o mecanismo de obten√ß√£o de
dados no exemplo de CopyBuffer(). √â impl√≠cito que a dire√ß√£o de indexa√ß√£o dos dados requeridos √© de
s√©rie de tempo, e a posi√ß√£o com √≠ndice 0 (zero) armazena dados da barra corrente ainda incompleta. A
fim de obter acesso a estes dados n√≥s precisamos copiar o volume necess√°rio de dados em um array
recipiente, por exemplo, em um array de buffer. 
Para copiar n√≥s precisamos especificar a posi√ß√£o de in√≠cio no array fonte, in√≠cio a partir do qual dados
ser√£o copiados para o array recipiente. Em caso de sucesso, o n√∫mero especificado de elementos
ser√£o copiados para o array recipiente do array fonte (do buffer de indicador neste caso).
Independentemente do valor de indexa√ß√£o definido no array recipiente, a c√≥pia √© sempre realizada
como exibida na figura abaixo.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2044
Se √© esperado que um grande n√∫mero de itera√ß√µes seja tratado por um loop, √© recomend√°vel que se
verifique a ocorr√™ncia de uma finaliza√ß√£o de programa for√ßada usando a fun√ß√£o IsStopped().
</p>
<pre><code class="language-mql5">
int copied=CopyBuffer(ma_handle,// manipulador do indicador
                      0,        // O √≠ndice do buffer do indicador
                      0,        // Posi√ß√£o in√≠cio para copiar
                      number,   // N√∫mero de valores para copiar
                      Buffer    // O array que recebe os valores
                      );
</code></pre>
<p>
if(copied&lt;0) return;
</p>
<pre><code class="language-mql5">
int k=0;
</code></pre>
<p>
while(k&lt;copied &amp;&amp; !IsStopped())
</p>
<pre><code class="language-mql5">
  {
   //--- Obt√©m o valor para o √≠ndice k
   double value=Buffer[k];
   // ... 
   // trabalha com o valor
   k++;
</code></pre>
<p>
  }
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int per=10; // per√≠odo do expoente
int ma_handle;    // manipulador do indicador
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   ma_handle=iMA(_Symbol,0,per,0,MODE_EMA,PRICE_CLOSE);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o tick (ponto) de um Expert                                 |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   double ema[10];
   int copied=CopyBuffer(ma_handle,// manipulador do indicador
                         0,        // √≠ndice do buffer do indicador
                         0,        // posi√ß√£o de √≠nicio da c√≥pia
                         10,       // n√∫mero de valores para copiar
                         ema       // array que recebe os valores
                         );
   if(copied&lt;0) return;
// .... outro c√≥digo
</code></pre>
<p>
  }</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2045
<h3>Tamb√©m Veja</h3>
<h3>Organizando Acesso aos Dados</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2046
<h3>Organizando Acesso aos Dados</h3>
Nesta se√ß√£o, quest√µes associados a obten√ß√£o, armazenamento e solicita√ß√£o de dados de pre√ßos (s√©ries
de tempo) s√£o consideradas.
Recebendo Dados de um Servidor de Negocia√ß√£o
Antes de dados de pre√ßos ficarem dispon√≠veis no terminal MetraTrader 5, eles devem ser recebidos e
processados. Para receber dados, uma conex√£o com o servidor de negocia√ß√£o MetaTrader 5 deve ser
estabelecida. Dados s√£o recebidos na forma de blocos empacotados de barras de um minuto do
servidor sob a solicita√ß√£o de um terminal.
O mecanismo de refer√™ncia de servidor para solicitar dados n√£o depende de como a solicita√ß√£o foi
iniciada - por um usu√°rio ao navegar em um gr√°fico ou por meio de um programa na linguagem MQL5.
<h3>Armazenando Dados Intermedi√°rios</h3>
Dados recebidos de um servidor s√£o automaticamente desempacotados e salvos no formato
intermedi√°rio HCC. Os dados 
de 
cada 
ativo 
s√£o 
escritos 
em 
uma 
pasta 
separada:
terminal_directory\bases\server_name\history\symbol_name. Por exemplo, dados sobre EURUSD
recebidos 
do 
servidor 
<h3>MetaQuotes-Demo</h3>
ser√£o 
armazenados 
em
terminal_directory\bases\MetaQuotes-Demo\history\EURUSD\.
Os dados s√£o escritos em arquivos com extens√£o .hcc. Cada arquivo armazena dados de barras de um
minuto para um ano. Por exemplo, o arquivo nomeado 2009.hcc na pasta EURUSD cont√©m barras de
um minuto de EURUSD para o ano de 2009. Estes arquivos s√£o usados para preparar dados de pre√ßo
para todas as janelas de tempo e n√£o s√£o destinados para acesso direto.
Obtendo Dados em uma Janela de Tempo Necess√°ria a partir dos Dados
<h3>Intermedi√°rios</h3>
Os arquivo HCC intermedi√°rios s√£o usados como fonte de dados para construir dados de pre√ßo para
janelas de tempo solicitadas no formato HC. Dados de formato HC s√£o s√©ries de tempo que s√£o
maximamente preparados para acesso r√°pido. Eles s√£o criados sob solicita√ß√£o de um gr√°fico ou um
programa MQL5. O volume de dados n√£o deve exceder o valor do par√¢metro &quot;M√°x. barras no gr√°fico&quot;.
Os dados s√£o armazenados para posterior uso em arquivos com extens√£o hc.
Para economizar recursos, os dados em uma janela de tempo s√£o armazenados e guardamos em RAM
somente se necess√°rio. Se n√£o for chamado por um longo tempo, eles s√£o liberados da RAM e salvos
em um arquivo. Para cada janela de tempo, os dados s√£o preparados independentemente se existem
dados prontos ou n√£o para outras janelas de tempo. Regras para forma√ß√£o e acesso aos dados s√£o as
mesmas para todas as janelas de tempo. Isso significa que apesar da unidade de dados armazenada
em HCC ser de um minuto, a disponibilidade de dados HCC n√£o significa a disponibilidade de dados na
janela de tempo M1 como HC no mesmo volume.
O recebimento de novos dados de um servidor chama automaticamente a atualiza√ß√£o de dados de
pre√ßo usados em formato HC de todas as janelas de tempo. Isso tamb√©m leva ao rec√°lculo de todos os
indicadores que implicitamente usam estes dados como dados de entrada para c√°lculos.
<h3>Par√¢metro &quot;M√°x. barras no gr√°fico&quot;</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2047
O par√¢metro &quot;M√°x bars no gr√°fico&quot; restringe o n√∫mero de barras em formato HC dispon√≠vel para
gr√°ficos, indicadores e programas mql5. Isso √© v√°lido para todas as janelas de tempo dispon√≠veis e
serve, primeiramente, para economizar recursos do computador.
Ao definir um grande valor para este par√¢metro, deve ser lembrado que se dados de pre√ßo de hist√≥rico
longo para pequenas janelas de tempo estiverem dispon√≠veis, a mem√≥ria usada para armazenadas a
s√©rie de pre√ßos e buffers de indicadores podem se tornar centenas de megabytes e alcan√ßar a restri√ß√£o
de RAM do programa terminal cliente (2Gb para aplicativos 32-bit do MS Windows).
A altera√ß√£o do par√¢metro &quot;M√°x. barras no gr√°fico&quot; produz efeito ap√≥s o terminal cliente ser reiniciado.
A altera√ß√£o deste par√¢metro n√£o causa refer√™ncia autom√°tica a um servidor por dados adicionais, e
nem forma√ß√£o de barras adicionais de s√©ries de tempo. Dados de pre√ßo adicionais s√£o solicitados ao
servidor, e s√©ries de pre√ßo s√£o atualizadas levando em conta a nova limita√ß√£o, em caso de rolagem de
um gr√°fico para uma √°rea sem dados, ou quando dados s√£o solicitado por um programas MQL5 .
O volume de dados solicitados ao servidor corresponde ao n√∫mero solicitado de barras de uma da
janela de tempo com o par√¢metro &quot;Max. barras em gr√°fico&quot; levado em considera√ß√£o. A restri√ß√£o
definida por este par√¢metro n√£o √© absoluta, e em alguns casos o n√∫mero de barras dispon√≠veis para
uma janela de tempo pode ser um pouco maior que o valor corrente do par√¢metro.
<h3>Disponibilidade de Dados</h3>
A presen√ßa de dados no formato HCC ou mesmo no formato preparado HC n√£o significa sempre a
absoluta disponibilidade destes dados para serem exibidos em um gr√°fico ou usados em um programa
mql5.
Ao acessar dados de pre√ßos ou valores de indicadores a partir de um programa mql5 deve ser lembrado
que a sua disponibilidade em um certo momento do tempo ou iniciando a partir de um certo momento
de tempo n√£o √© garantida. Isso est√° relacionado com fato de que para economizar recursos, a c√≥pia
completa dos dados necess√°rios para um programa mql5 n√£o √© armazenada no MetaTrader 5; apenas
um acesso direto √† base de dados do terminal √© fornecida.
O hist√≥rico de pre√ßos para todas as janelas de tempo √© constru√≠do a partir de dados comuns em
formato HCC, e qualquer atualiza√ß√£o dos dados a partir de um servidor conduz √† atualiza√ß√£o de dados
para todas as janelas de tempo e ao rec√°lculo dos indicadores. Devido a isso, o acesso aos dados pode
ficar fechado, mesmo se estes dados estiverem dispon√≠veis a um momento atr√°s.
Sincroniza√ß√£o dos Dados do Terminal com os Dados do Servidor
J√° que um programa mql5 pode chamar dados de qualquer ativo e janela de tempo, existe a
possibilidade que os dados de uma s√©rie de tempo necess√°ria n√£o esteja formado ainda no terminal ou
o pre√ßo necess√°rio n√£o esteja sincronizado com o servidor de negocia√ß√£o. Neste caso √© dif√≠cil predizer
o tempo de lat√™ncia.
Algoritmos usando ciclos de lat√™ncia n√£o s√£o a melhor solu√ß√£o. A √∫nica exce√ß√£o neste caso s√£o os
scripts, porque eles n√£o nenhuma escolha de algoritmo alternativo porque eles n√£o tem manipuladores
de evento. Para indicadores customizados tais algoritmos, bem como quaisquer outros ciclos de
lat√™ncia s√£o fortemente n√£o recomendados, porque levam a finaliza√ß√£o do c√°lculo de todos os
indicadores e qualquer outro manipulador de dados de pre√ßo do ativo.
Para Expert Advisor e indicadores, √© melhor usar o modelo de eventos de manipula√ß√£o. Se durante a
manipula√ß√£o dos eventos OnTick() ou OnCalculate(), o recebimento de dados para a janela de tempo</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2048
requerida falhar, voc√™ deve sair do manipulador de evento, confiando na disponibilidade de acesso
durante a pr√≥xima chamada do manipulador.
Exemplo de um Script para Adicionar Hist√≥rico
Vamos considerar um exemplo de um script que executa uma solicita√ß√£o para receber hist√≥rico para o
ativo selecionado de um servidor de negocia√ß√£o. O script √© projetado para executar em um gr√°fico de
um ativo selecionado; a janela de tempo n√£o importa, porque como foi mencionado acima, dados de
pre√ßo s√£o recebidos de um servidor de negocia√ß√£o como pacotes de dados de um minuto, a partir dos
quais qualquer s√©rie de tempo predefinida √© constru√≠da.
Escreve todas as a√ß√µes relacionadas a recep√ß√£o de dados como uma fun√ß√£o separada,
<h3>CheckLoadHistory(symbol, timeframe, start_date):</h3>
</p>
<pre><code class="language-mql5">
int CheckLoadHistory(string symbol,ENUM_TIMEFRAMES period,datetime start_date)
  {
</code></pre>
<p>
  }
A fun√ß√£o CheckLoadHistory() √© projetada como uma fun√ß√£o universal que pode ser chamada de
qualquer programa (Expert Advisor, script ou indicador); e portanto ela solicita tr√™s par√¢metros de
entrada: nome do ativo, per√≠odo e data de inicio para indicar o come√ßo do hist√≥rico de pre√ßo que voc√™
necessita.
Insira as verifica√ß√µes necess√°rias no c√≥digo da fun√ß√£o antes de solicitar o hist√≥rico faltante.
Primeiramente, n√≥s devemos assegurar que o nome do ativo e valor de per√≠odo est√£o corretos:
</p>
<pre><code class="language-mql5">
   if(symbol==NULL || symbol==&quot;&quot;) symbol=Symbol();
   if(period==PERIOD_CURRENT)     period=Period();
</code></pre>
<p>
Ent√£o vamos nos assegurar que o ativo est√° dispon√≠vel na janela Observador de Mercado, isto √©, o
hist√≥rico para o ativo estar√° dispon√≠vel durante o envio de uma solicita√ß√£o a um servidor de
negocia√ß√£o. Se n√£o houver tal ativo no Observador de Mercado, adicionar ele usando a fun√ß√£o
SymbolSelect().
</p>
<pre><code class="language-mql5">
   if(!SymbolInfoInteger(symbol,SYMBOL_SELECT))
     {
      if(GetLastError()==ERR_MARKET_UNKNOWN_SYMBOL) return(-1);
      SymbolSelect(symbol,true);
     }
</code></pre>
<p>
Agora n√≥s devemos receber a data de in√≠cio do hist√≥rico dispon√≠vel para o par ativo/per√≠odo indicado.
Talvez, o valor do par√¢metro de entrada startdate, passado para CheckLoadHistory(), j√° esteja
dispon√≠vel no hist√≥rico; ent√£o a solicita√ß√£o a um servidor de negocia√ß√£o n√£o √© necess√°ria. A fim de
obter a primeira data para o ativo-per√≠odo, a fun√ß√£o SeriesInfoInteger() com o modificador
SERIES_FIRSTDATE √© usada.
</p>
<pre><code class="language-mql5">
   SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date);
   if(first_date&gt;0 &amp;&amp; first_date&lt;=start_date) return(1);
</code></pre>
<p>
A pr√≥xima importante verifica√ß√£o √© o tipo do programa, a partir do qual a fun√ß√£o √© chamada. Note que
enviar uma solicita√ß√£o de atualiza√ß√£o de s√©rie de tempo com o mesmo per√≠odo do indicador, que
chama a atualiza√ß√£o, n√£o √© desej√°vel. O problema de solicitar dados sobre o mesmo ativo-per√≠odo que
o do indicador est√° relacionado ao fato de que a atualiza√ß√£o de dados de hist√≥rico √© realizada na</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2049
mesma thread onde o indicador opera. Assim a possibilidade de ocorr√™ncia de conflito √© alta. Para
verificar isso use a fun√ß√£o MQL5InfoInteger() com o modificador MQL5_PROGRAM_TYPE.
</p>
<pre><code class="language-mql5">
   if(MQL5InfoInteger(MQL5_PROGRAM_TYPE)==PROGRAM_INDICATOR &amp;&amp; Period()==period &amp;&amp; Sym
      return(-4);
</code></pre>
<p>
Se todas as verifica√ß√µes tiverem passado com sucesso, fa√ßa a √∫ltima tentativa de acesso sem se
referir ao servidor de negocia√ß√£o Primeiramente, descubra a data de in√≠cio, para qual dados de minuto
no formato HCC est√£o dispon√≠veis. Solicite este valor usando a fun√ß√£o SeriesInfoInteger() com o
modificador SERIES_TERMINAL_FIRSTDATE e compare novamente ele com o valor do par√¢metro
start_date.
</p>
<pre><code class="language-mql5">
   if(SeriesInfoInteger(symbol,PERIOD_M1,SERIES_TERMINAL_FIRSTDATE,first_date))
     {
      //--- existe dados carregados para construir a s√©rie de tempo
      if(first_date&gt;0)
        {
         //--- for√ßa a constru√ß√£o da s√©rie de tempo
         CopyTime(symbol,period,first_date+PeriodSeconds(period),1,times);
         //--- verifica
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            if(first_date&gt;0 &amp;&amp; first_date&lt;=start_date) return(2);
        }
     }
</code></pre>
<p>
Se ap√≥s todas as verifica√ß√µes, a thread de execu√ß√£o estiver ainda no corpo da fun√ß√£o
CheckLoadHistory(), isso significa que existe uma necessidade de solicitar os dados de pre√ßo faltantes
ao servidor de negocia√ß√£o. Primeiro, retorne o valor de &quot;M√°x. barras no gr√°fico&quot; usando a fun√ß√£o
<h3>TerminalInfoInteger():</h3>
  int max_bars=TerminalInfoInteger(TERMINAL_MAXBARS);
N√≥s precisaremos dele para evitar solicitar dados extra. Ent√£o encontre a primeira data no sistema do
ativo no servidor de negocia√ß√£o (independentemente do per√≠odo) usando a j√° conhecida fun√ß√£o
SeriesInfoInteger() com o modificador SERIES_SERVER_FIRSTDATE.
</p>
<pre><code class="language-mql5">
   datetime first_server_date=0;
   while(!SeriesInfoInteger(symbol,PERIOD_M1,SERIES_SERVER_FIRSTDATE,first_server_date
      Sleep(5);
</code></pre>
<p>
J√° que a solicita√ß√£o √© uma opera√ß√£o ass√≠ncrona, a fun√ß√£o √© chamada no ciclo com uma espera de 5
milissegundos at√© a vari√°vel first_server_date receber um valor, ou a execu√ß√£o do ciclo ser terminada
por um usu√°rio (IsStopped() retornar√° true neste caso). Vamos indicar um valor correto da data de
in√≠cio, come√ßando a partir do qual n√≥s solicitamos dados de pre√ßo de um servidor de negocia√ß√£o.
</p>
<pre><code class="language-mql5">
   if(first_server_date&gt;start_date) start_date=first_server_date;
   if(first_date&gt;0 &amp;&amp; first_date&lt;first_server_date)
      Print(&quot;Aviso: primeira data de servidor &quot;,first_server_date,&quot; para&quot;,
</code></pre>
<p>
symbol,&quot; n√£o coincide com a primeira data de s√©rie &quot;,first_date);
Se a data de in√≠cio first_server_date do servidor for menor que o data de in√≠cio first_date do ativo em
formato HCC, a correspondente entrada ser√° impressa no di√°rio.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2050
Agora n√≥s estamos prontos para fazer uma solicita√ß√£o a um servidor de negocia√ß√£o por dados de pre√ßo
faltantes. Fa√ßa a solicita√ß√£o na forma de um ciclo e comece preenchendo seu corpo:
</p>
<pre><code class="language-mql5">
   while(!IsStopped())
     {
      //1. espere pela sincroniza√ß√£o entre a s√©rie de tempo reconstru√≠da e o hist√≥rico
      //2. receba o n√∫mero corrente de barra n desta s√©rie de tempo
      //    se bars for maior que Max_bars_in_char, n√≥s podem sair, o trabalho est√° te
      //3. obter a data de in√≠cio first_date na s√©rie de tempo reconstru√≠da e comparar
      //    se first_date for menor que start_date, n√≥s podemos sair, o trabalho est√° 
      //4. solicitar a um servidor uma nova parte do hist√≥rico - 100 barras come√ßando 
     }
</code></pre>
<p>
Os primeiros tr√™s pontos est√£o implementados pelos meios j√° conhecidos.
</p>
<pre><code class="language-mql5">
   while(!IsStopped())
     {
      //--- 1. esperar at√© o processo de reconstru√ß√£o da s√©rie de tempo acabar
      while(!SeriesInfoInteger(symbol,period,SERIES_SYNCHRONIZED) &amp;&amp; !IsStopped())
         Sleep(5);
      //--- 2. solicitar quantas barras n√≥s tempos
      int bars=Bars(symbol,period);
      if(bars&gt;0)
        {
         //--- barras mais que podem ser desenhadas no gr√°fico, sair
         if(bars&gt;=max_bars) return(-2); 
         //--- 3. retorne a data de in√≠cio corrente na s√©rie de tempo
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            // data de in√≠cio foi anterior a aquela solicitada, tarefa conclu√≠da
            if(first_date&gt;0 &amp;&amp; first_date&lt;=start_date) return(0);
        }
      //4. Solicitar a um servidor uma nova parte do hist√≥rico - 100 barras come√ßando 
     }
</code></pre>
<p>
Sobrou o quarto √∫ltimo ponto - solicitar hist√≥rico. N√≥s n√£o podemos referenciar a um servidor
diretamente, mas toda fun√ß√£o-Copy inicia automaticamente uma solicita√ß√£o de envio a um servidor,
se o hist√≥rico em formato HCC n√£o for suficiente. J√° que a hora da primeira data de in√≠cio na vari√°vel
first_date √© um simples e natural crit√©rio para avaliar o grau de execu√ß√£o de uma solicita√ß√£o, ent√£o a
forma mais f√°cil √© usar a fun√ß√£o CopyTime().
Ao chamar fun√ß√µes que copiam quaisquer dados de s√©ries de tempo, deve ser notado que o par√¢metro
start (n√∫mero da barra, come√ßando a partir do qual dados de pre√ßo devem ser copiados) deve sempre
estar dentro do hist√≥rico de terminal dispon√≠vel. Se voc√™ tiver somente 100 barras, √© in√∫til tentar
copiar 300 barras come√ßando da barra com o √≠ndice 500. Tal solicita√ß√£o ser√° entendida como um error
e n√£o ser√° tratada, isto √©, nenhum hist√≥rico adicional ser√° carregado de um servidor de negocia√ß√£o.
Esta √© a raz√£o porque n√≥s copiaremos 100 barras come√ßando da barra com o √≠ndice bars. Isso
fornecer√° uma carga suave de hist√≥rico faltando doe um servidor de negocia√ß√£o. Na verdade, um
pouco mais que as 100 barras solicitadas ser√£o carregadas, j√° que o servidor envia um hist√≥rico
superdimensionado.
</p>
<pre><code class="language-mql5">
   int copied=CopyTime(symbol,period,bars,100,times);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2051
Ap√≥s a opera√ß√£o de c√≥pia, n√≥s devemos analizar o n√∫mero de elementos copiados. Se a tentativa
falhar, ent√£o o valor copiado ser√° igual a null e o valor do contador fail_cnt ser√° aumentado em 1.
Ap√≥s 100 tentativas com falha, a opera√ß√£o da fun√ß√£o ser√° interrompida.
</p>
<pre><code class="language-mql5">
int fail_cnt=0;
</code></pre>
<p>
...
</p>
<pre><code class="language-mql5">
   int copied=CopyTime(symbol,period,bars,100,times);
   if(copied&gt;0)
     {
      //--- verifica dados
      if(times[0]&lt;=start_date)  return(0);  // o valor copiado √© menor, pronto
      if(bars+copied&gt;=max_bars) return(-2); // as barras s√£o mais do que se pode desen
      fail_cnt=0;
     }
   else
     {
      //--- n√£o mais que 100 tentativas falhando em sucess√£o
      fail_cnt++;
      if(fail_cnt&gt;=100) return(-5);
      Sleep(10);
     }
</code></pre>
<p>
Ent√£o, n√£o somente manipula√ß√£o correta da situa√ß√£o corrente em cada momento de execu√ß√£o est√°
implementada na fun√ß√£o, mas tamb√©m o c√≥digo de finaliza√ß√£o √© retornado, que pode ser tratado
depois chamando a fun√ß√£o CheckLoadHistory() para obten√ß√£o de informa√ß√µes adicionais. Por exemplo,
desta forma:
</p>
<pre><code class="language-mql5">
   int res=CheckLoadHistory(InpLoadedSymbol,InpLoadedPeriod,InpStartDate);
   switch(res)
     {
      case -1 : Print(&quot;Unknown symbol &quot;,InpLoadedSymbol);                     break;
      case -2 : Print(&quot;More requested bars than can be drawn in the chart&quot;); break;
      case -3 : Print(&quot;Execution stopped by user&quot;);                          break;
      case -4 : Print(&quot;Indicator mustn&#x27;t load its own data&quot;);                break;
      case -5 : Print(&quot;Loading failed&quot;);                                     break;
      case  0 : Print(&quot;All data loaded&quot;);                                    break;
      case  1 : Print(&quot;Already available data in timeseries are enough&quot;);    break;
      case  2 : Print(&quot;Timeseries is built from available terminal data&quot;);   break;
      default : Print(&quot;Execution result undefined&quot;);
     }
</code></pre>
<p>
O c√≥digo completo da fun√ß√£o pode ser encontrado no exemplo de um script que mostra a correta
organiza√ß√£o de acesso de quaisquer dados com a manipula√ß√£o de resultados de solicita√ß√£o.
<h3>Code:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                              TestLoadHistory.mq5 |
//|                         Copyright 2000-2024, MetaQuotes Ltd. |
//|                                              https://www.mql5.com |</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2052
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
#property copyright &quot;2009, MetaQuotes Software Corp.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.02&quot;
#property script_show_inputs
//--- par√¢metros de entrada
input string          InpLoadedSymbol=&quot;NZDUSD&quot;;   // Ativo a ser carregado
input ENUM_TIMEFRAMES InpLoadedPeriod=PERIOD_H1;  // Per√≠dio a ser carregado
input datetime        InpStartDate=D&#x27;2006.01.01&#x27;; // Data de in√≠cio
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
   Print(&quot;Start load&quot;,InpLoadedSymbol+&quot;,&quot;+GetPeriodName(InpLoadedPeriod),&quot;from&quot;,InpSta
//---
   int res=CheckLoadHistory(InpLoadedSymbol,InpLoadedPeriod,InpStartDate);
   switch(res)
     {
      case -1 : Print(&quot;Unknown symbol &quot;,InpLoadedSymbol);             break;
      case -2 : Print(&quot;Requested bars more than max bars in chart&quot;); break;
      case -3 : Print(&quot;Program was stopped&quot;);                        break;
      case -4 : Print(&quot;Indicator shouldn&#x27;t load its own data&quot;);      break;
      case -5 : Print(&quot;Load failed&quot;);                                break;
      case  0 : Print(&quot;Loaded OK&quot;);                                  break;
      case  1 : Print(&quot;Loaded previously&quot;);                          break;
      case  2 : Print(&quot;Loaded previously and built&quot;);                break;
      default : Print(&quot;Unknown result&quot;);
     }
//---
   datetime first_date;
   SeriesInfoInteger(InpLoadedSymbol,InpLoadedPeriod,SERIES_FIRSTDATE,first_date);
   int bars=Bars(InpLoadedSymbol,InpLoadedPeriod);
   Print(&quot;Primeira data &quot;,first_date,&quot; - &quot;,bars,&quot; barres&quot;);
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CheckLoadHistory(string symbol,ENUM_TIMEFRAMES period,datetime start_date)
  {
   datetime first_date=0;
   datetime times[100];
//--- verifica ativo e per√≠odo
   if(symbol==NULL || symbol==&quot;&quot;) symbol=Symbol();
   if(period==PERIOD_CURRENT)     period=Period();
//--- verifica se o ativo est√° selecionado no Observador de Mercado
   if(!SymbolInfoInteger(symbol,SYMBOL_SELECT))
     {</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2053
</p>
<pre><code class="language-mql5">
      if(GetLastError()==ERR_MARKET_UNKNOWN_SYMBOL) return(-1);
      SymbolSelect(symbol,true);
     }
//--- verifica se os dados est√£o presentes
   SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date);
   if(first_date&gt;0 &amp;&amp; first_date&lt;=start_date) return(1);
//--- n√£o pede para carregar seus pr√≥prios dados se ele for um indicador
   if(MQL5InfoInteger(MQL5_PROGRAM_TYPE)==PROGRAM_INDICATOR &amp;&amp; Period()==period &amp;&amp; Sym
      return(-4);
//--- segunda tentativa
   if(SeriesInfoInteger(symbol,PERIOD_M1,SERIES_TERMINAL_FIRSTDATE,first_date))
     {
      //--- existe dados carregados para construir a s√©rie de tempo
      if(first_date&gt;0)
        {
         //--- for√ßa a constru√ß√£o da s√©rie de tempo
         CopyTime(symbol,period,first_date+PeriodSeconds(period),1,times);
         //--- verifica
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            if(first_date&gt;0 &amp;&amp; first_date&lt;=start_date) return(2);
        }
     }
//--- m√°ximo de barras em um gr√°fico a partir de op√ß√µes do terminal
   int max_bars=TerminalInfoInteger(TERMINAL_MAXBARS);
//--- carrega informa√ß√µes de hist√≥rico do ativo
   datetime first_server_date=0;
   while(!SeriesInfoInteger(symbol,PERIOD_M1,SERIES_SERVER_FIRSTDATE,first_server_date
      Sleep(5);
//--- corrige data de in√≠cio para carga
   if(first_server_date&gt;start_date) start_date=first_server_date;
   if(first_date&gt;0 &amp;&amp; first_date&lt;first_server_date)
      Print(&quot;Aviso: primeira data de servidor &quot;,first_server_date,&quot; para &quot;,symbol,
            &quot; n√£o coincide com a primeira data de s√©rie &quot;,first_date);
//--- carrega dados passo a passo
   int fail_cnt=0;
   while(!IsStopped())
     {
      //--- espera pela constru√ß√£o da s√©rie de tempo
      while(!SeriesInfoInteger(symbol,period,SERIES_SYNCHRONIZED) &amp;&amp; !IsStopped())
         Sleep(5);
      //--- pede por construir barras
      int bars=Bars(symbol,period);
      if(bars&gt;0)
        {
         if(bars&gt;=max_bars) return(-2);
         //--- pede pela primeira data
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            if(first_date&gt;0 &amp;&amp; first_date&lt;=start_date) return(0);
        }</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2054
</p>
<pre><code class="language-mql5">
      //--- c√≥pia da pr√≥xima parte for√ßa carga de dados
      int copied=CopyTime(symbol,period,bars,100,times);
      if(copied&gt;0)
        {
         //--- verifica dados
         if(times[0]&lt;=start_date)  return(0);
         if(bars+copied&gt;=max_bars) return(-2);
         fail_cnt=0;
        }
      else
        {
         //--- n√£o mais que 100 tentativas com falha
         fail_cnt++;
         if(fail_cnt&gt;=100) return(-5);
         Sleep(10);
        }
     }
//--- interrompido
   return(-3);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna valor de string do per√≠odo¬†                              |
//+------------------------------------------------------------------+
string GetPeriodName(ENUM_TIMEFRAMES period)
  {
   if(period==PERIOD_CURRENT) period=Period();
//---
   switch(period)
     {
      case PERIOD_M1:  return(&quot;M1&quot;);
      case PERIOD_M2:  return(&quot;M2&quot;);
      case PERIOD_M3:  return(&quot;M3&quot;);
      case PERIOD_M4:  return(&quot;M4&quot;);
      case PERIOD_M5:  return(&quot;M5&quot;);
      case PERIOD_M6:  return(&quot;M6&quot;);
      case PERIOD_M10: return(&quot;M10&quot;);
      case PERIOD_M12: return(&quot;M12&quot;);
      case PERIOD_M15: return(&quot;M15&quot;);
      case PERIOD_M20: return(&quot;M20&quot;);
      case PERIOD_M30: return(&quot;M30&quot;);
      case PERIOD_H1:  return(&quot;H1&quot;);
      case PERIOD_H2:  return(&quot;H2&quot;);
      case PERIOD_H3:  return(&quot;H3&quot;);
      case PERIOD_H4:  return(&quot;H4&quot;);
      case PERIOD_H6:  return(&quot;H6&quot;);
      case PERIOD_H8:  return(&quot;H8&quot;);
      case PERIOD_H12: return(&quot;H12&quot;);
      case PERIOD_D1:  return(&quot;Daily&quot;);
      case PERIOD_W1:  return(&quot;Weekly&quot;);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2055
</p>
<pre><code class="language-mql5">
      case PERIOD_MN1: return(&quot;Monthly&quot;);
     }
//---
   return(&quot;per√≠odo desconhecido&quot;);
</code></pre>
<p>
  }</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2056
<h3>SeriesInfoInteger</h3>
Retorna informa√ß√µes sobre o estado de dados hist√≥ricos. Existem 2 variantes de chamada da fun√ß√£o.
Retorna diretamente o valor da propriedade.
long¬† SeriesInfoInteger(
</p>
<pre><code class="language-mql5">
   string¬†                    symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬†           timeframe,¬†      // per√≠odo
   ENUM_SERIES_INFO_INTEGER¬†  prop_id,¬†        // identificador da propriedade
   );
</code></pre>
<p>
Retorna true ou false dependendo do sucesso da execu√ß√£o da fun√ß√£o.
</p>
<pre><code class="language-mql5">
bool¬† SeriesInfoInteger(
   string¬†                    symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬†           timeframe,¬†      // per√≠odo
   ENUM_SERIES_INFO_INTEGER¬†  prop_id,¬†        // ID da propriedade
   long&amp;¬†                     long_var¬†        // vari√°vel a informa√ß√£o obtida
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
prop_id
[in]  Identificador da propriedade solicitada, valor da enumera√ß√£o ENUM_SERIES_INFO_INTEGER.
long_var
[out]  Vari√°vel para onde o valor da propriedade solicitada √© colocado.
<h3>Valor do Retorno</h3>
No primeiro caso, ela retorna valor do tipo long.
Para o segundo caso, ela retorna true, se a propriedade especificada estiver dispon√≠vel e seu valor √©
colocada na vari√°vel long_var, caso contr√°rio ela returna false. Para mais detalhes sobre um erro,
chame a fun√ß√£o GetLastError().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   Print(&quot;Total number of bars for the symbol-period at this moment = &quot;,
         SeriesInfoInteger(Symbol(),Period(),SERIES_BARS_COUNT));
   Print(&quot;The first date for the symbol-period at this moment = &quot;,
         (datetime)SeriesInfoInteger(Symbol(),Period(),SERIES_FIRSTDATE));</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2057
</p>
<pre><code class="language-mql5">
   Print(&quot;The first date in the history for the symbol-period on the server = &quot;,
         (datetime)SeriesInfoInteger(Symbol(),Period(),SERIES_SERVER_FIRSTDATE));
   Print(&quot;Symbol data are synchronized = &quot;,
         (bool)SeriesInfoInteger(Symbol(),Period(),SERIES_SYNCHRONIZED));
</code></pre>
<p>
  }</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2058
<h3>Bars</h3>
Retorna o n√∫mero de barras no hist√≥rico para um ativo e per√≠odo espec√≠ficos. Existe 2 variantes de
chamada da fun√ß√£o.
<h3>Solicita todas as barras do hist√≥rico</h3>
</p>
<pre><code class="language-mql5">
int¬† Bars(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe ¬†      // per√≠odo
   );
</code></pre>
<p>
Solicita as barras do hist√≥rico no intervalo de tempo selecionado
</p>
<pre><code class="language-mql5">
int¬† Bars(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   datetime¬†        start_time,¬†     // data e hora de in√≠cio
   datetime¬†        stop_time¬†       // data e hora de t√©rmino
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_time
[in]  Hora da barra correspondente ao primeiro elemento.
stop_time
[in]  Hora da barra correspondente ao √∫ltimo elemento.
<h3>Valor do Retorno</h3>
Se os par√¢metros start_time e stop_time estiverem definidos, a fun√ß√£o retorna o n√∫mero de barras
no intervalo de tempo especificado, caso contr√°rio retorna o n√∫mero total de barras.
<h3>Observa√ß√£o</h3>
Se os dados para a s√©rie de tempo com par√¢metros especificados n√£o estiverem formados no
terminal na hora que a fun√ß√£o Bars() for chamada, ou dados da s√©rie de tempo n√£o estiverem
sincronizados com um servidor de negocia√ß√£o no momento da chamada da fun√ß√£o, a fun√ß√£o retorna
o valor zero.
Ao solicitar o n√∫mero de barras, no intervalo estabelecido de datas, s√£o levados em conta apenas as
barras cujo tempo de abertura est√° dentro desse intervalo. Por exemplo, se o dia da semana √©
s√°bado, ao pedir o n√∫mero de barras semanais indicando start_time=√∫ltima_ter√ßa_feira e
stop_time=√∫ltima_sexta_feira, a fun√ß√£o retorna 0, pois, por um lado, o tempo de abertura no
timeframe semanal sempre coincide com um domingo e, por outro, n√£o h√° nenhuma barra semanal
que fique dentro do intervalo estabelecido.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2059
Exemplo de solicita√ß√£o do n√∫mero de todas as barras no hist√≥rico:
</p>
<pre><code class="language-mql5">
   int bars=Bars(_Symbol,_Period);
   if(bars&gt;0)
     {
      Print(&quot;Number of bars in the terminal history for the symbol-period at the momen
     }
   else  //sem barras dispon√≠veis
     {
      //--- dados sobre o ativo podem n√£o estar sincronizados com os dados no servidor
      bool synchronized=false;
      //--- contador de loop
      int attempts=0;
      // faz 5 tentativas de espera por sincroniza√ß√£o
      while(attempts&lt;5)
        {
         if(SeriesInfoInteger(Symbol(),0,SERIES_SYNCHRONIZED))
           {
            //--- sincroniza√ß√£o feita, sair
            synchronized=true;
            break;
           }
         //--- aumentar o contador
         attempts++;
         //--- espera 10 milissegundos at√© a pr√≥xima itera√ß√£o
         Sleep(10);
        }
      //--- sair do loop ap√≥s sincroniza√ß√£o
      if(synchronized)
        {
         Print(&quot;Number of bars in the terminal history for the symbol-period at the mo
         Print(&quot;The first date in the terminal history for the symbol-period at the mo
               (datetime)SeriesInfoInteger(Symbol(),0,SERIES_FIRSTDATE));
         Print(&quot;The first date in the history for the symbol on the server = &quot;,
               (datetime)SeriesInfoInteger(Symbol(),0,SERIES_SERVER_FIRSTDATE));
        }
      //--- sincroniza√ß√£o dos dados n√£o aconteceu
      else
        {
         Print(&quot;Failed to get number of bars for &quot;,_Symbol);
        }
     }
</code></pre>
<p>
Exemplo de solicita√ß√£o do n√∫mero de barras no intervalo estabelecido:
</p>
<pre><code class="language-mql5">
   int n;
   datetime date1 = D&#x27;2016.09.02 23:55&#x27;; // sexta-feira
   datetime date2 = D&#x27;2016.09.05 00:00&#x27;; // segunda-feira
   datetime date3 = D&#x27;2016.09.08 00:00&#x27;; // quinta-feira
   //---</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2060
</p>
<pre><code class="language-mql5">
   n=Bars(_Symbol,PERIOD_H1,D&#x27;2016.09.02 02:05&#x27;,D&#x27;2016.09.02 10:55&#x27;);
   Print(&quot;N√∫mero de barras: &quot;,n); // Mostra &quot;N√∫mero de barras: 8&quot;, na contagem levar√° 
   n=Bars(_Symbol,PERIOD_D1,date1,date2);
   Print(&quot;N√∫mero de barras: &quot;,n); // Mostra &quot;N√∫mero de barras: 1&quot;, pois o tempo de abe
   n=Bars(_Symbol,PERIOD_W1,date2,date3);
   Print(&quot;N√∫mero de barras: &quot;,n); // Mostra &quot;N√∫mero de barras: 0&quot;, pois o tempo de abe
</code></pre>
<p>
<h3>Veja Tamb√©m</h3>
<h3>Fun√ß√µes de Processamento de Eventos</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2061
<h3>BarsCalculated</h3>
Retorna o n√∫mero de dados calculados para o indicador especificado.
</p>
<pre><code class="language-mql5">
int¬† BarsCalculated(
   int¬†      indicator_handle,¬†    // handle do indicador
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
indicator_handle
[in]  O handle do indicador, retornado pela fun√ß√£o do indicador correspondente.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados calculados no buffer de indicador, ou -1 em caso de erro (dados
ainda n√£o calculados)
<h3>Observa√ß√£o</h3>
A fun√ß√£o √© √∫til quando √© necess√°rio obter os dados do indicador imediatamente ap√≥s sua cria√ß√£o (o
handle do indicador est√° dispon√≠vel).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   double Ups[];
//--- define a ordena√ß√£o de s√©rie de tempo para os arrays
   ArraySetAsSeries(Ups,true);
//--- cria handle para o indicador Fractal
   int FractalsHandle=iFractals(NULL,0);
//--- redefine o c√≥digo de erro
   ResetLastError();
//--- tenta copiar os valores do indicador
   int i,copied=CopyBuffer(FractalsHandle,0,0,1000,Ups);
   if(copied&lt;=0)
     {
      Sleep(50);
      for(i=0;i&lt;100;i++)
        {
         if(BarsCalculated(FractalsHandle)&gt;0)
            break;
         Sleep(50);
        }
      copied=CopyBuffer(FractalsHandle,0,0,1000,Ups);
      if(copied&lt;=0)
        {
         Print(&quot;Failed to copy upper fractals. Erro = &quot;,GetLastError(),
         &quot;i = &quot;,i,&quot;    copiado = &quot;,copied);
         return;
        }</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2062
</p>
<pre><code class="language-mql5">
       else
         Print(&quot;Upper fractals copied&quot;,
         &quot;i = &quot;,i,&quot;    copiado = &quot;,copied);
     }
   else Print(&quot;Upper fractals copied. ArraySize = &quot;,ArraySize(Ups));
</code></pre>
<p>
  }</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2063
<h3>IndicatorCreate</h3>
A fun√ß√£o retorna o handle de um indicador t√©cnico especificado criado baseado no array de par√¢metros
de tipo MqlParam.
</p>
<pre><code class="language-mql5">
int¬† IndicatorCreate(
   string¬†          symbol,¬†                           // nome do ativo
   ENUM_TIMEFRAMES¬† period,¬†                           // janela de tempo
   ENUM_INDICATOR ¬† indicator_type,¬†                   // tipo de indicador a partir d
   int¬†             parameters_cnt=0,¬†                 // n√∫mero de par√¢metros
   const MqlParam&amp;  parameters_array[]=NULL,¬†          // array de par√¢metros
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in] Nome de um ativo, sobre cujos dados o indicador √© calculado. NULL significa o ativo corrente.
period
[in]  O valor da janela de tempo pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES, 0
significa a janela de tempo corrente.
indicator_type
[in]  Tipo de indicador, pode ser um dos valores da enumera√ß√£o ENUM_INDICATOR.
parameters_cnt
[in] O n√∫mero de par√¢metros passados no array parameters_array[]. Os elementos do array t√™m
uma estrutura especial de tipo MqlParam. Por default, zero - par√¢metros s√£o passados. Se voc√™
especificar um n√∫mero n√£o zero de par√¢metros, o par√¢metro parameters_array √© obrigat√≥rio. Voc√™
n√£o pode passar mais que 64 par√¢metros.
parameters_array[]=NULL
[in]  Um array do tipo MqlParam, cujos elementos cont√©m o tipo e valor de cada par√¢metro de
</p>
<pre><code class="language-mql5">
input de um indicador t√©cnico.
</code></pre>
<p>
<h3>Valor de retorno</h3>
Retorna o handle de um indicador t√©cnico especificado, em caso de falha retorna INVALID_HANDLE.
<h3>Observa√ß√£o</h3>
Se o handle de indicador de tipo IND_CUSTOM for criado, o campo type do primeiro elemento do
array de par√¢metros de entrada parameters_array deve ter o valor TYPE_STRING da enumera√ß√£o
ENUM_DATATYPE, e o campo string_value do primeiro elemento deve conter o nome do indicador
customizado. O indicador customizado deve estar compilado (arquivo com extens√£o EX5) e
localizado no diret√≥rio MQL5/Indicators do terminal cliente ou em um subdiret√≥rio.
Indicadores que requerem teste s√£o definidos automaticamente a partir da chamada da fun√ß√£o
iCustom(), se o correspondente par√¢metro for definido atrav√©s de um string constante. Para todos
os outros casos (uso da fun√ß√£o IndicatorCreate() ou uso de uma string n√£o-constante no par√¢metro
de define o nome do indicador) a propriedade #property tester_indicator √© requerida:
</p>
<pre><code class="language-mql5">
#property tester_indicator &quot;indicator_name.ex5&quot;</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2064
Se primeira forma da chamada  for usada em um indicador customizado, voc√™ pode adicionalmente
indicar como √∫ltimo par√¢metro sobre quais dados o indicador ser√° calculado, ao passar os
par√¢metros de input. Se o par√¢metro &quot;Apply to&quot; n√£o for especificado explicitamente, o c√°lculo
default √© baseado no valores de PRICE_CLOSE.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
   MqlParam params[];
   int      h_MA,h_MACD;
//--- criar iMA(&quot;EURUSD&quot;,PERIOD_M15,8,0,MODE_EMA,PRICE_CLOSE);
   ArrayResize(params,4);
//--- define ma_period
   params[0].type         =TYPE_INT;
   params[0].integer_value=8;
//--- define ma_shift
   params[1].type         =TYPE_INT;
   params[1].integer_value=0;
//--- define ma_method
   params[2].type         =TYPE_INT;
   params[2].integer_value=MODE_EMA;
//--- define applied_price
   params[3].type         =TYPE_INT;
   params[3].integer_value=PRICE_CLOSE;
//--- criar MA
   h_MA=IndicatorCreate(&quot;EURUSD&quot;,PERIOD_M15,IND_MA,4,params);
//--- criar iMACD(&quot;EURUSD&quot;,PERIOD_M15,12,26,9,h_MA);
   ArrayResize(params,4);
//--- define ma_period r√°pido
   params[0].type         =TYPE_INT;
   params[0].integer_value=12;
//--- define ma_period lento
   params[1].type         =TYPE_INT;
   params[1].integer_value=26;
//--- define per√≠odo de suaviza√ß√£o por diferen√ßa
   params[2].type         =TYPE_INT;
   params[2].integer_value=9;
//--- define o handle do indicador como applied_price
   params[3].type         =TYPE_INT;
   params[3].integer_value=h_MA;
//--- criar MACD baseado em m√©dia m√≥vel
   h_MACD=IndicatorCreate(&quot;EURUSD&quot;,PERIOD_M15,IND_MACD,4,params);
//--- usa os indicadores
//--- . . .
//--- libera os indicatores (primeiro h_MACD)
   IndicatorRelease(h_MACD);
   IndicatorRelease(h_MA);
</code></pre>
<p>
  }</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2065
<h3>IndicatorParameters</h3>
Baseado no handle especificado, retorna o n√∫mero de par√¢metros de entrada do indicador, bem como
os valores e tipos dos par√¢metros.
</p>
<pre><code class="language-mql5">
int¬† IndicatorParameters(
   int¬†              indicator_handle,¬†    // handle do indicador
   ENUM_INDICATOR&amp; ¬† indicator_type,¬†      // uma vari√°vel para receber o tipo do indi
   MqlParam&amp;¬†        parameters[]    ¬†     // um array para receber par√¢metros
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
indicator_handle
[in]  O handle do indicador, para o qual voc√™ precisa saber o n√∫mero de par√¢metros sobre os quais
o indicador √© calculado.
indicator_type
[out]  Uma vari√°vel de tipo ENUM_INDICATOR, na qual o tipo do indicador ser√° escrito.
parameters[]
[out]  Um array din√¢mico para receber valores do tipo MqlParam, na qual a lista de par√¢metros do
indicador ser√° escrito. O tamanho do array √© retornado pela fun√ß√£o IndicatorParameters().
<h3>Valor do Retorno</h3>
O n√∫mero de par√¢metros de entrada do indicador com o handle especificado. No caso de um erro,
retorna -1. Para mais detalhes sobre o erro chame a fun√ß√£o GetLastError().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Programa Script da fun√ß√£o start (iniciar)¬†                       |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- O n√∫mero de janelas no gr√°fico (ao menos uma janela principal est√° sempre presen
   int windows=(int)ChartGetInteger(0,CHART_WINDOWS_TOTAL);
//--- Varre as janelas do gr√°fico
   for(int w=0;w&lt;windows;w++)
     {
      //--- O n√∫mero de indicadores nesta janela/sub-janela
      int total=ChartIndicatorsTotal(0,w);
      //--- Pega todos os indicadores na janela
      for(int i=0;i&lt;total;i++)
        {
         //--- Obt√©m o nome abreviado do indicador
         string name=ChartIndicatorName(0,w,i);
         //--- Obt√©m o handle do indicador
         int handle=ChartIndicatorGet(0,w,name);
         //--- Adicionar o log</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2066
</p>
<pre><code class="language-mql5">
         PrintFormat(&quot;Window=%d,  indicator #%d,  handle=%d&quot;,w,i,handle);
         //---
         MqlParam parameters[];
         ENUM_INDICATOR indicator_type;
         int params=IndicatorParameters(handle,indicator_type,parameters);
         //--- O cabe√ßalho da mensagem
         string par_info=&quot;Short name &quot;+name+&quot;, type &quot;
                         +EnumToString(ENUM_INDICATOR(indicator_type))+&quot;\r\n&quot;;
         //--- 
         for(int p=0;p&lt;params;p++)
           {
            par_info+=StringFormat(&quot;par√¢metro %d: type=%s, long_value=%d, double_value
                                   p,
                                   EnumToString((ENUM_DATATYPE)parameters[p].type),
                                   parameters[p].integer_value,
                                   parameters[p].double_value,
                                   parameters[p].string_value
                                   );
           }
         Print(par_info);
        }
      //--- Pronto para todos os indicadores da janela
     }
//---    
</code></pre>
<p>
  }
<h3>Tamb√©m Veja</h3>
<h3>ChartIndicatorGet()</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2067
<h3>IndicatorRelease</h3>
A fun√ß√£o remove um handle de indicador e libera o bloco de c√°lculo do indicador, se ele n√£o for usado
por ningu√©m mais.
</p>
<pre><code class="language-mql5">
bool¬† IndicatorRelease(
   int¬†      indicator_handle,¬†    // handle do indicador
   );
</code></pre>
<p>
<h3>Valor de retorno</h3>
Retorna true no caso de sucesso, caso contr√°rio retorna false.
<h3>Observa√ß√£o</h3>
A fun√ß√£o permite remover um handle de indicador, se ele n√£o mais for necess√°rio, deste modo,
economizando mem√≥ria . O handle √© removido imediatamente, o bloco de c√°lculo √© exclu√≠do em
algum momento (se ele n√£o for chamado por ningu√©m mais).
Durante o funcionamento do testador de estrat√©gias, a fun√ß√£o IndicatorRelease() n√£o √© executada.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                        Test_IndicatorRelease.mq5 |
//|                        Copyright 2010, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;2010, MetaQuotes Software Corp.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
//--- par√¢metros de entrada
input int                MA_Period=15;
input int                MA_shift=0;
input ENUM_MA_METHOD     MA_smooth=MODE_SMA;
input ENUM_APPLIED_PRICE price=PRICE_CLOSE;
//--- armazenar√° o handle de indicador
int MA_handle=INVALID_HANDLE;
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do Expert¬†                               |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- cria um handle de indicador
   MA_handle=iMA(Symbol(),0,MA_Period,MA_shift,MA_smooth,PRICE_CLOSE);
//--- exclui vari√°vel global
   if(GlobalVariableCheck(&quot;MA_value&quot;))
      GlobalVariableDel(&quot;MA_value&quot;);
//---
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2068
</p>
<pre><code class="language-mql5">
//| Fun√ß√£o tick (ponto) de um Expert                                 |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- se o valor da vari√°vel global n√£o existir
   if(!GlobalVariableCheck(&quot;MA_value&quot;))
     {
      //--- obt√©m o valor do indicador nas √∫ltimas duas barras
      if(MA_handle!=INVALID_HANDLE)
        {
         //--- array din√¢mico para valores do indicador
         double values[];
         if(CopyBuffer(MA_handle,0,0,2,values)==2 &amp;&amp; values[0]!=EMPTY_VALUE)
           {
            //--- lembra na vari√°vel global o valor da pen√∫ltima barra
            if(GlobalVariableSet(&quot;MA_value&quot;,values[0]))
              {
               //--- libera o handle do indicador
               if(!IndicatorRelease(MA_handle))
                  Print(&quot;IndicatorRelease() falhou. Error &quot;,GetLastError());
               else MA_handle=INVALID_HANDLE;
              }
            else
               Print(&quot;GlobalVariableSet falhou. Error &quot;,GetLastError());
           }
        }
     }
//---
</code></pre>
<p>
  }</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2069
<h3>CopyBuffer</h3>
Obt√©m dados de um buffer especificado de um certo indicador na quantidade necess√°ria.
A contagem de elementos de dados copiados (buffer de indicador com o √≠ndice buffer_num) da posi√ß√£o
de in√≠cio √© realizada do presente para o passado, isto √©, posi√ß√£o de in√≠cio 0 significa a barra corrente
(valor do indicador para a barra corrente).
Ao copiar uma quantidade ainda desconhecida de dados, √© recomendado usar um array din√¢mico como
um buffer[] recipiente, porque a fun√ß√£o CopyBuffer() tenta alocar o tamanho do array receptor ao
tamanho dos dados copiados. Se um buffer de indicador (array que √© pr√©-alocado para armazenar
valores de um indicador atrav√©s da fun√ß√£o SetIndexBufer()) for usado como um array recipiente
buffer[], uma copia parcial √© permitida. Um exemplo pode ser encontrado no indicador customizado
Awesome_Oscillator.mql5 no pacote padr√£o do terminal.
Se voc√™ precisar fazer uma c√≥pia parcial dos valores de um indicador em um outro array (um n√£o
buffer de indicador), voc√™ deve usar um array intermedi√°rio, para o qual o n√∫mero desejado √©
copiado. Ap√≥s isso, conduza uma c√≥pia elemento a elemento do requerido n√∫mero de valores para os
lugares requeridos em um array de recep√ß√£o a partir deste array intermedi√°rio.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyBuffer(
   int¬†      indicator_handle,¬†    // handle do indicador
   int¬†      buffer_num,¬†          // n√∫mero do buffer do indicador
   int¬†      start_pos,¬†           // posi√ß√£o de in√≠cio
   int¬†      count,¬†               // quantidade para copiar
   double¬†   buffer[]¬†             // array destino para copiar
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyBuffer(
   int¬†      indicator_handle,¬†    // handle do indicador</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2070
</p>
<pre><code class="language-mql5">
   int¬†      buffer_num,¬†          // n√∫mero do buffer do indicador
   datetime¬† start_time,¬†          // data e hora de in√≠cio
   int¬†      count,¬†               // quantidade para copiar
   double¬†   buffer[]              // array destino para copiar
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyBuffer(
   int¬†      indicator_handle,¬†    // handle do indicador
   int¬†      buffer_num,¬†          // n√∫mero do buffer do indicador
   datetime¬† start_time,¬†          // data e hora de in√≠cio
   datetime¬† stop_time,¬†           // data e hora de t√©rmino
   double ¬†  buffer[]              // array destino para copiar
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
indicator_handle
[in]  O handle do indicador, retornado pela fun√ß√£o do indicador correspondente.
buffer_num
[in]  O n√∫mero do buffer do indicador.
start_pos
[in]  A posi√ß√£o do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  Hora da barra, correspondente ao primeiro elemento.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento.
buffer[]
[out]  Array de tipo double.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2071
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//|                                              TestCopyBuffer3.mq5 |
//|                         Copyright 2000-2024, MetaQuotes Ltd. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright &quot;2009, MetaQuotes Software Corp.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
//---- plotar MA
#property indicator_label1  &quot;MA&quot;
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrRed
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- par√¢metros de entrada
input bool               AsSeries=true;
input int                period=15;
input ENUM_MA_METHOD     smootMode=MODE_EMA;
input ENUM_APPLIED_PRICE price=PRICE_CLOSE;
input int                shift=0;
//--- buffers do indicador
double                   MABuffer[];
int                      ma_handle;
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,MABuffer,INDICATOR_DATA);
   Print(&quot;Parameter AsSeries = &quot;,AsSeries);
   Print(&quot;Buffer do indicador ap√≥s SetIndexBuffer() √© timeseries = &quot;,
         ArrayGetAsSeries(MABuffer));
//--- define o nome abreviado do indicador
   IndicatorSetString(INDICATOR_SHORTNAME,&quot;MA(&quot;+period+&quot;)&quot;+AsSeries);
//--- define AsSeries(depende do par√¢metro de entrada)
   ArraySetAsSeries(MABuffer,AsSeries);
   Print(&quot;Buffer do indicador ap√≥s ArraySetAsSeries(MABuffer,true); √© timeseries = &quot;,
         ArrayGetAsSeries(MABuffer));
//---
   ma_handle=iMA(Symbol(),0,period,shift,smootMode,price);
   return(INIT_SUCCEEDED);
</code></pre>
<p>
  }</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2072
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &amp;time[],
                const double &amp;open[],
                const double &amp;high[],
                const double &amp;low[],
                const double &amp;close[],
                const long &amp;tick_volume[],
                const long &amp;volume[],
                const int &amp;spread[])
  {
//--- verifica se todos os dados est√£o calculados
   if(BarsCalculated(ma_handle)&lt;rates_total) return(0);
//--- n√≥s n√£o podemos copiar todos os dados
   int to_copy;
   if(prev_calculated&gt;rates_total || prev_calculated&lt;=0) to_copy=rates_total;
   else
     {
      to_copy=rates_total-prev_calculated;
      //--- o √∫ltimo valor √© sempre copiado
      to_copy++;
     }
//--- tenta copiar
   if(CopyBuffer(ma_handle,0,0,to_copy,MABuffer)&lt;=0) return(0);
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
</code></pre>
<p>
O exemplo acima ilustra como um buffer de indicador √© preenchido com os valores de um outro buffer
de indicador a partir de um indicador sobre o mesmo ativo/per√≠odo.
Veja uma exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2073
<h3>Tamb√©m Veja</h3>
<h3>Propriedades de Indicadores Customizados, SetIndexBuffer</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2074
<h3>CopyRates</h3>
Obt√©m dados hist√≥ricos de estrutura MqlRates de um ativo-per√≠odo especificado na quantidade
especificada no array rates_array. A ordena√ß√£o dos elementos dos dados copiados √© do presente para
o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyRates(
   string¬†          symbol_name,¬†      // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†        // per√≠odo
   int¬†             start_pos,¬†        // posi√ß√£o de in√≠cio
   int¬†             count,¬†            // quantidade de dados para copiar
   MqlRates         rates_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyRates(
   string¬†          symbol_name,¬†      // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†        // per√≠odo
   datetime¬†        start_time,¬†       // data e hora de in√≠cio
   int¬†             count,¬†            // quantidade de dados para copiar
   MqlRates         rates_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyRates(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2075
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†      // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†        // per√≠odo
   datetime¬†        start_time,¬†       // data e hora de in√≠cio
   datetime¬†        stop_time,¬†        // data e hora de t√©rmino
   MqlRates         rates_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_time
[in]  Hora da barra do primeiro elemento para copiar.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
rates_array[]
[out]  Array de tipo MqlRates.
<h3>Valor do Retorno</h3>
Retorna o n√∫mero de elementos copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2076
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
void OnStart()
  {
//---
   MqlRates rates[];
   ArraySetAsSeries(rates,true);
   int copied=CopyRates(Symbol(),0,0,100,rates);
   if(copied&gt;0)
     {
      Print(&quot;Barres copiados: &quot;+copied);
      string format=&quot;open = %G, high = %G, low = %G, close = %G, volume = %d&quot;;
      string out;
      int size=fmin(copied,10);
      for(int i=0;i&lt;size;i++)
        {
         out=i+&quot;:&quot;+TimeToString(rates[i].time);
         out=out+&quot; &quot;+StringFormat(format,
                                  rates[i].open,
                                  rates[i].high,
                                  rates[i].low,
                                  rates[i].close,
                                  rates[i].tick_volume);
         Print(out);
        }
     }
   else Print(&quot;Falha ao receber dados hist√≥ricos para o s√≠mbolo &quot;,Symbol());
</code></pre>
<p>
  }
Veja um exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2077
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.
<h3>Tamb√©m Veja</h3>
<h3>Estruturas e Classes, TimeToString, StringFormat</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2078
<h3>CopySeries</h3>
Obt√©m no conjunto de arrays especificado as s√©ries temporais sincronizadas da estrutura MqlRates
para o s√≠mbolo-per√≠odo especificado na quantidade especificada. Os itens da posi√ß√£o inicial s√£o
contados do presente para o passado, ou seja, uma posi√ß√£o inicial de 0 significa a barra atual.
Ao copiar antecipadamente uma quantidade desconhecida de dados, √© recomend√°vel usar como arrays
receptores uma matriz din√¢mica, j√° que se houver mais dados do que o array pode conter, √© feita uma
tentativa de redistribuir a matriz para que os dados solicitados se ajustem a todo o array.
Se uma quantidade pr√©-determinada de dados precisa ser copiada, √© melhor faz√™-lo em um buffer
alocado estaticamente, para evitar a aloca√ß√£o global desnecess√°ria de mem√≥ria.
N√£o importa que propriedade o array receptor tenha, as_series=true ou as_series=false, os dados
ser√£o copiados para que o elemento da s√©rie temporal mais antiga seja copiado para o in√≠cio da
mem√≥ria f√≠sica alocada ao array.
</p>
<pre><code class="language-mql5">
int¬† CopySeries(
   string¬†          symbol_name,¬†      // nome do s√≠mbolo
   ENUM_TIMEFRAMES¬† timeframe,¬†        // per√≠odo
   int¬†             start_pos,¬†        // onde come√ßamos 
   int¬†             count,¬†            // quanto copiamos
   ulong            rates_mask, ¬†      // combina√ß√£o de sinalizadores para indicar a s
   void&amp;            array1[],¬†         // matriz onde ser√£o copiados os dados da prime
   void&amp;            array2[]¬†          // matriz onde os dados da segunda s√©rie tempor
   ...
   );</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2079
<h3>Par√¢metros</h3>
symbol_name
[in]  S√≠mbolo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  N√∫mero do primeiro item copiado.
count
[in]  N√∫mero de itens a serem copiados.
rates_mask
[in]  Combina√ß√£o de sinalizadores a partir da enumera√ß√£o ENUM_COPY_RATES .
array1, array2,...
[out]  Matriz do tipo apropriado para recuperar as s√©ries temporais a partir da estrutura MqlRates.
A ordem dos arrays passados para a fun√ß√£o deve corresponder √† ordem dos campos na estrutura
MqlRates. 
<h3>Valor retornado</h3>
N√∫mero de elementos do array copiados ou -1 no caso de erro.
<h3>Observa√ß√£o</h3>
Se o intervalo de tempo solicitado estiver totalmente fora dos dados dispon√≠veis no servidor, a
fun√ß√£o retorna -1. Se os dados solicitados estiverem fora do escopo TERMINAL_MAXBARS (n√∫mero
m√°ximo de barras no gr√°fico), a fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados do indicador, caso as s√©ries temporais solicitadas ainda n√£o tenham sido
constru√≠das ou precisem ser baixadas do servidor, a fun√ß√£o retornar√° imediatamente -1, mas o
pr√≥prio processo de carregamento/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um EA ou script, ser√° iniciada um carregamento desde o servidor se o terminal
n√£o tiver esses dados localmente, ou ser√° iniciada a constru√ß√£o da s√©rie temporal necess√°ria se os
dados puderem ser constru√≠dos a partir do hist√≥rico local, mas ainda n√£o estiverem prontos. A
fun√ß√£o retornar√° a quantidade de dados que estar√£o prontos quando o tempo expirar, mas o
carregamento do hist√≥rico continuar√°, e na pr√≥xima vez que uma solicita√ß√£o semelhante for feita a
fun√ß√£o retornar√° mais dados.
<h3>Diferen√ßa entre CopySeries e CopyRates</h3>
A fun√ß√£o CopySeries permite obter apenas as s√©ries temporais necess√°rias de cada vez em diferentes
arrays especificados, enquanto todos est√£o sincronizados entre si. Isso significa que todos os valores
nos arrays resultantes em um √≠ndice espec√≠fico N pertencer√£o √† mesma barra no par
Symbol/Timeframe especificado. Nesse caso, o programador n√£o precisa garantir que todas as s√©ries
temporais recebidas sejam sincronizadas pelo tempo de abertura da barra.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2080
Ao contr√°rio de CopyRates, que retorna o conjunto completo de s√©ries temporais como um array
MqlRates, a fun√ß√£o CopySeries permite que o programador obtenha apenas as s√©ries temporais
necess√°rias como arrays separados. Para fazer isso, voc√™ precisa especificar uma combina√ß√£o de
sinalizadores para especificar o tipo de s√©rie temporal solicitado . A ordem dos arrays passados para a
fun√ß√£o deve corresponder √† ordem dos campos na estrutura MqlRates:
</p>
<pre><code class="language-mql5">
struct MqlRates
  {
   datetime time;         // in√≠cio de per√≠odo
   double   open;         // pre√ßo de abertura
   double   high;         // pre√ßo mais alto do per√≠odo
   double   low;          // pre√ßo mais baixo do per√≠odo
   double   close;        // pre√ßo de fechamento
   long     tick_volume;  // volume de tick
   int      spread;       // spread
   long     real_volume;  // volume de negocia√ß√£o
</code></pre>
<p>
  }
Assim, se for necess√°rio obter os valores das s√©ries temporais  time, close e real_volume para as
√∫ltimas 100 barras do Symbol/Timeframe atual, a chamada deve ser a seguinte:
datetime time[];
</p>
<pre><code class="language-mql5">
double   close[];
</code></pre>
<p>
long     volume[];
CopySeries(NULL,0,0,100,COPY_RATES_TIME|COPY_RATES_CLOSE|COPY_RATES_VOLUME_REAL,time,c
A ordem das matrizes √© importante &quot;time, close, volume&quot; ‚Äî deve estar de acordo com a ordem dos
campos na estrutura  MqlRates. J√° a ordem dos valores na m√°scara rates_mask n√£o importa, a
m√°scara poderia ser assim:
<h3>COPY_RATES_VOLUME_REAL|COPY_RATES_TIME|COPY_RATES_CLOSE</h3>
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//--- input parameters
input datetime InpDateFrom=D&#x27;2022.01.01 00:00:00&#x27;;
input datetime InpDateTo  =D&#x27;2023.01.01 00:00:00&#x27;;
input uint     InpCount   =20;
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart(void)
  {
//--- arrays para obter s√©ries temporais da estrutura de pre√ßos MqlRates
   double   open[];
   double   close[];
   float    closef[];
   datetime time1[], time2[];
//--- solicitamos pre√ßos de fechamento para um array do tipo double
   ResetLastError();</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2081
</p>
<pre><code class="language-mql5">
   int res1=CopySeries(NULL, PERIOD_CURRENT, 0, InpCount,
                       COPY_RATES_TIME|COPY_RATES_CLOSE, time1, close);
   PrintFormat(&quot;1. CopySeries  returns %d values. Error code=%d&quot;, res1, GetLastError()
   ArrayPrint(close);
  
//--- agora solicitamos mais pre√ßos de abertura e pre√ßos de fechamento em um array do 
   ResetLastError();
   int res2=CopySeries(NULL, PERIOD_CURRENT, 0, InpCount,
                       COPY_RATES_TIME|COPY_RATES_CLOSE|COPY_RATES_OPEN, time2, open, 
   PrintFormat(&quot;2. CopySeries  returns %d values. Error code=%d&quot;, res2, GetLastError()
   ArrayPrint(closef);
//--- comparamos os dados
   if((res1==res2) &amp;&amp; (time1[0]==time2[0]))
     {
      Print(&quot;  | Time             |    Open      | Close double | Close float |&quot;);
      for(int i=0; i&lt;10; i++)
        {
         PrintFormat(&quot;%d | %s |   %.5f    |   %.5f    |   %.5f   |&quot;,
                     i, TimeToString(time1[i]), open[i], close[i], closef[i]);
        }
     }
//--- Resultado
</code></pre>
<p>
1. CopySeries  returns 20 values. Error code=0
[ 0] 1.06722 1.06733 1.06653 1.06520 1.06573 1.06649 1.06694 1.06675 1.06684 1.0
[10] 1.06514 1.06557 1.06456 1.06481 1.06414 1.06394 1.06364 1.06386 1.06239 1.0
2. CopySeries  returns 20 values. Error code=0
[ 0] 1.06722 1.06733 1.06653 1.06520 1.06573 1.06649 1.06694 1.06675 1.06684 1.0
[10] 1.06514 1.06557 1.06456 1.06481 1.06414 1.06394 1.06364 1.06386 1.06239 1.0
  | Time             |    Open      | Close double | Close float |
0 | 2023.03.01 17:00 |   1.06660    |   1.06722    |   1.06722   |
1 | 2023.03.01 18:00 |   1.06722    |   1.06733    |   1.06733   |
2 | 2023.03.01 19:00 |   1.06734    |   1.06653    |   1.06653   |
3 | 2023.03.01 20:00 |   1.06654    |   1.06520    |   1.06520   |
4 | 2023.03.01 21:00 |   1.06520    |   1.06573    |   1.06573   |
5 | 2023.03.01 22:00 |   1.06572    |   1.06649    |   1.06649   |
6 | 2023.03.01 23:00 |   1.06649    |   1.06694    |   1.06694   |
7 | 2023.03.02 00:00 |   1.06683    |   1.06675    |   1.06675   |
8 | 2023.03.02 01:00 |   1.06675    |   1.06684    |   1.06684   |
9 | 2023.03.02 02:00 |   1.06687    |   1.06604    |   1.06604   |
</p>
<pre><code class="language-mql5">
//---
</code></pre>
<p>
  }
<h3>Ver tamb√©m</h3>
<h3>Estruturas e classes,  CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2082
<h3>CopyTime</h3>
A fun√ß√£o obt√©m em time_array o hist√≥rico de dados da hora de abertura de barras para o par ativo-
per√≠odo especificado na quantidade especificada. Deve ser notado que a ordena√ß√£o dos elementos √© do
presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyTime(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   int¬†             start_pos,¬†      // posi√ß√£o de in√≠cio
   int¬†             count,¬†          // quantidade de dados para copiar
   datetime¬†        time_array[]     // array destino para copiar as horas de abertura
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyTime(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   datetime¬†        start_time,¬†     // data e hora de in√≠cio
   int¬†             count,¬†          // quantidade de dados para copiar
   datetime¬†        time_array[]     // array destino para copiar horas de abertura
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyTime(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2083
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   datetime¬†        start_time,¬†     // data e hora de in√≠cio
   datetime¬†        stop_time,¬†      // data e hora de parada
   datetime¬†        time_array[]     // array destino para copiar as horas de abertura
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  A hora de in√≠cio para o primeiro elemento para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
time_array[]
[out]  Array de tipo datetime.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2084
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
Veja um exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2085
<h3>CopyOpen</h3>
A fun√ß√£o obt√©m em open_array os dados hist√≥ricos de pre√ßos de abertura de barras para o par ativo-
per√≠odo selecionado na quantidade especificada. Deve ser notado que a ordena√ß√£o dos elementos √© do
presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos  
</p>
<pre><code class="language-mql5">
int¬† CopyOpen(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   int¬†             start_pos,¬†      // posi√ß√£o de in√≠cio
   int¬†             count,¬†          // quantidade de dados para copiar
   double¬†          open_array[]     // array destino para copiar pre√ßos de abertura
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyOpen(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   datetime¬†        start_time,¬†     // data e hora de in√≠cio
   int¬†             count,¬†          // quantidade de dados para copiar
   double¬†          open_array[]     // array destino para pre√ßos de abertura de barra
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyOpen(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2086
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   datetime¬†        start_time,¬†     // data e hora de in√≠cio
   datetime¬†        stop_time,¬†      // data e hora de parada
   double¬†          open_array[]     // array destino para valores de abertura de barr
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  A hora de in√≠cio para o primeiro elemento para copiar.
stop_time
[in]  A hora de in√≠cio para o √∫ltimo elemento para copiar.
open_array[]
[out]  Array de tipo double.
<h3>Valor do Retorno</h3>
Retorna o n√∫mero de elementos no array ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2087
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
Veja um exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2088
<h3>CopyHigh</h3>
A fun√ß√£o obt√©m em high_array os dados hist√≥ricos dos pre√ßos de barra mais altos para o par ativo-
per√≠odo selecionado na quantidade especificada. Deve ser notado que a ordena√ß√£o dos elementos √© do
presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyHigh(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   int¬†             start_pos,¬†       // posi√ß√£o de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   double¬†          high_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyHigh(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   double¬†          high_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyHigh(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2089
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   datetime¬†        stop_time,¬†       // data e hora de parada
   double¬†          high_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  A hora de in√≠cio para o primeiro elemento para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
high_array[]
[out]  Array de tipo double.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2090
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property copyright &quot;2009, MetaQuotes Software Corp.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property description &quot;An example for output of the High[i] and Low[i]&quot;
#property description &quot;for a random chosen bars&quot;
double High[],Low[];
//+------------------------------------------------------------------+
//| Obt√©m M√≠nimo para o √≠ndice de barra especificado¬†                |
//+------------------------------------------------------------------+
double iLow(string symbol,ENUM_TIMEFRAMES timeframe,int index)
  {
   double low=0;
   ArraySetAsSeries(Low,true);
   int copied=CopyLow(symbol,timeframe,0,Bars(symbol,timeframe),Low);
   if(copied&gt;0 &amp;&amp; index&lt;copied) low=Low[index];
   return(low);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Obt√©m o M√°ximo para o √≠ndice de barra especificado¬†              |
//+------------------------------------------------------------------+
double iHigh(string symbol,ENUM_TIMEFRAMES timeframe,int index)
  {
   double high=0;
   ArraySetAsSeries(High,true);
   int copied=CopyHigh(symbol,timeframe,0,Bars(symbol,timeframe),High);
   if(copied&gt;0 &amp;&amp; index&lt;copied) high=High[index];
   return(high);
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o tick (ponto) de um Expert                                 |</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2091
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
void OnTick()
  {
//--- em cada tick n√≥s imprimimos os valores de M√°ximo e M√≠nimo para a barra com √≠ndic
//--- que seja igual ao segundo, no qual o tick chegou
   datetime t=TimeCurrent();
   int sec=t%60;
   printf(&quot;High[%d] = %G  Low[%d] = %G&quot;,
          sec,iHigh(Symbol(),0,sec),
          sec,iLow(Symbol(),0,sec));
</code></pre>
<p>
  }
Veja um exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2092
<h3>CopyLow</h3>
A fun√ß√£o obt√©m em low_array os dados hist√≥ricos de pre√ßos de barra m√≠nimos para o par ativo-per√≠odo
selecionado na quantidade especificada. Deve ser notado que a ordena√ß√£o dos elementos √© do
presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyLow(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   int¬†             start_pos,¬†      // posi√ß√£o de in√≠cio
   int¬†             count,¬†          // quantidade de dados para copiar
   double¬†          low_array[]      // array destino para copiar
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyLow(
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   datetime¬†        start_time,¬†     // data e hora de in√≠cio
   int¬†             count,¬†          // quantidade de dados para copiar
   double¬†          low_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyLow(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2093
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†    // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†      // per√≠odo
   datetime¬†        start_time,¬†     // data e hora de in√≠cio
   datetime¬†        stop_time,¬†      // data e hora de parada
   double¬†          low_array[]      // array destino para copiar
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
low_array[]
[out]  Array de tipo double.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2094
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
Veja um exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.
<h3>Tamb√©m Veja</h3>
<h3>CopyHigh</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2095
<h3>CopyClose</h3>
A fun√ß√£o obt√©m em close_array os dados hist√≥ricos de pre√ßos de fechamento de barra para o par
ativo-per√≠odo selecionado na quantidade especificada. Deve ser notado que a ordena√ß√£o dos
elementos √© do presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyClose(
   string¬†          symbol_name,¬†      // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†        // per√≠odo
   int¬†             start_pos,¬†        // posi√ß√£o de in√≠cio
   int¬†             count,¬†            // quantidade de dados para copiar
   double¬†          close_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyClose(
   string¬†          symbol_name,¬†      // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†        // per√≠odo
   datetime¬†        start_time,¬†       // data e hora de in√≠cio
   int¬†             count,¬†            // quantidade de dados para copiar
   double¬†          close_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyClose(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2096
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†      // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†        // per√≠odo
   datetime¬†        start_time,¬†       // data e hora de in√≠cio
   datetime¬†        stop_time,¬†        // data e hora de parada
   double¬†          close_array[]¬†     // array destino para copiar
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  A hora de in√≠cio para o primeiro elemento para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
close_array[]
[out]  Array de tipo double.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2097
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
Veja um exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2098
<h3>CopyTickVolume</h3>
A fun√ß√£o obt√©m em volume_array os dados hist√≥ricos de volumes de tick para o par ativo-per√≠odo
selecionado na quantidade especificada. Deve ser notado que a ordena√ß√£o dos elementos √© do
presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyTickVolume(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   int¬†             start_pos,¬†       // posi√ß√£o de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   long¬†            volume_array[]    // array destino para volumes de tick
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyTickVolume(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   long¬†            volume_array[]    // array destino para volumes de tick
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyTickVolume(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2099
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   datetime¬†        stop_time,¬†       // data e hora de parada
   long¬†            volume_array[]    // array destino para volumes de tick
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  A hora de in√≠cio para o primeiro elemento para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
volume_array[]
[out]  Array de tipo long.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2100
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
//---- plotar TickVolume
#property indicator_label1  &quot;TickVolume&quot;
#property indicator_type1   DRAW_HISTOGRAM
#property indicator_color1  C&#x27;143,188,139&#x27;
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- par√¢metros de entrada
input int      bars=3000;
//--- buffers do indicador
double         TickVolumeBuffer[];
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
void OnInit()
  {
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,TickVolumeBuffer,INDICATOR_DATA);
   IndicatorSetInteger(INDICATOR_DIGITS,0);
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                 const int prev_calculated,
                 const datetime &amp;time[],
                 const double &amp;open[],
                 const double &amp;high[],
                 const double &amp;low[],</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2101
</p>
<pre><code class="language-mql5">
                 const double &amp;close[],
                 const long &amp;tick_volume[],
                 const long &amp;volume[],
                 const int &amp;spread[])
  {
//---
   if(prev_calculated==0)
     {
      long timeseries[];
      ArraySetAsSeries(timeseries,true);
      int prices=CopyTickVolume(Symbol(),0,0,bars,timeseries);
      for(int i=0;i&lt;rates_total-prices;i++) TickVolumeBuffer[i]=0.0; 
      for(int i=0;i&lt;prices;i++) TickVolumeBuffer[rates_total-1-i]=timeseries[prices-1-
      Print(&quot;We have received the following number of TickVolume values: &quot;+prices);
     }
   else
     {
      long timeseries[];
      int prices=CopyTickVolume(Symbol(),0,0,1,timeseries);
      TickVolumeBuffer[rates_total-1]=timeseries[0]; 
     }  
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
Veja um exemplo detalhado de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de
Objetos. O script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas
√∫ltimas 1000 barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no
gr√°fico. Uma t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que
s√£o usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2102
<h3>CopyRealVolume</h3>
A fun√ß√£o obt√©m em volume_array os dados hist√≥ricos de volumes de negocia√ß√£o para o par ativo-
per√≠odo selecionado na quantidade especificada. Deve ser notado que a ordena√ß√£o dos elementos √© do
presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyRealVolume(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   int¬†             start_pos,¬†       // posi√ß√£o de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   long¬†            volume_array[]    // array destino para valores de volume
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopyRealVolume(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   long¬†            volume_array[]    // array destino para valores de volume
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopyRealVolume(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2103
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   datetime¬†        stop_time,¬†       // data e hora de parada
   long¬†            volume_array[]    // array destino para valores de volume
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  A hora de in√≠cio para o primeiro elemento para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
volume_array[]
[out]  Array de tipo long.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de¬†erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2104
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
Veja um exemplo de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de Objetos. O
script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas √∫ltimas 1000
barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no gr√°fico. Uma
t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que s√£o
usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2105
<h3>CopySpread</h3>
A fun√ß√£o obt√©m em spread_array os dados hist√≥ricos de valores de spread para o par selecionado
ativo-per√≠odo na quantidade especificada. Deve ser notado que a ordena√ß√£o dos elementos √© do
presente para o passado, isto √©, a posi√ß√£o de in√≠cio 0 significa a barra corrente.
Ao copiar uma quantidade desconhecida de dados, √© recomend√°vel usar um array din√¢mico como array
destino, porque se a quantidade solicitada de dados for menor (ou maior) que o comprimento do array
destino, a fun√ß√£o tenta realocar a mem√≥ria de qual forma que os dados solicitados caibam
completamente.
Se voc√™ souber a quantidade de dados que voc√™ precisa para copiar, √© melhor usar um buffer alocado
estaticamente, a fim de evitar a aloca√ß√£o de mem√≥ria excessiva.
N√£o importa qual seja a propriedade do array destino - como series=true ou como series=false. Os
dados ser√£o copiados de tal maneira que o elemento mais antigo ser√° localizado no in√≠cio da mem√≥ria
f√≠sica alocada para o array. Exitem 3 variantes de chamada da fun√ß√£o.
Chamar pela posi√ß√£o primeira e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopySpread(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   int¬†             start_pos,¬†       // posi√ß√£o de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   int¬†             spread_array[]    // array destino para valores de spread
   );
</code></pre>
<p>
Chamar pela data de in√≠cio e o n√∫mero de elementos requeridos
</p>
<pre><code class="language-mql5">
int¬† CopySpread(
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   int¬†             count,¬†           // quantidade de dados para copiar
   int¬†             spread_array[]    // array destino para valores de spread
   );
</code></pre>
<p>
Chamar pelas datas de in√≠cio e t√©rmino de um intervalo de tempo requerido
</p>
<pre><code class="language-mql5">
int¬† CopySpread(</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2106
</p>
<pre><code class="language-mql5">
   string¬†          symbol_name,¬†     // nome do ativo
   ENUM_TIMEFRAMES¬† timeframe,¬†       // per√≠odo
   datetime¬†        start_time,¬†      // data e hora de in√≠cio
   datetime¬†        stop_time,¬†       // data e hora de parada
   int¬†             spread_array[]    // array destino para valores de spread
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  Nome do ativo.
timeframe
[in]  Per√≠odo.
start_pos
[in]  A posi√ß√£o de in√≠cio do primeiro elemento para copiar.
count
[in]  Quantidade de dados para copiar.
start_time
[in]  A hora de in√≠cio para o primeiro elemento para copiar.
stop_time
[in]  Hora da barra, correspondente ao √∫ltimo elemento para copiar.
spread_array[]
[out]  Array de tipo int.
<h3>Valor do Retorno</h3>
Retorna a quantidade de dados copiados ou -1 no caso de um erro.
<h3>Observa√ß√£o</h3>
Se o intervalo inteiro de dados solicitados n√£o estiver dispon√≠vel no servidor, a fun√ß√£o retorna -1.
Se dados fora do TERMINAL_MAXBARS (n√∫mero m√°ximo de barras no gr√°fico) for solicitado, a
fun√ß√£o tamb√©m retornar√° -1.
Ao solicitar dados de um indicador, se as s√©ries de tempo solicitadas n√£o estiverem ainda
constru√≠das ou elas precisarem serem baixadas do servidor, a fun√ß√£o imediatamente retornar√° -1,
mas o processo de download/constru√ß√£o ser√° iniciado.
Ao solicitar dados de um Expert Advisor ou script, o download do servidor ser√° iniciado se o terminal
n√£o tiver estes dados localmente, ou a constru√ß√£o da s√©rie de tempo solicitada iniciar√°, se os dados
puderem ser constru√≠das a partir do hist√≥rico local mas eles n√£o estiverem prontos ainda. A fun√ß√£o
retornar√° a quantidade de dados que estar√° pronta no momento da expira√ß√£o do tempo limite, mas
o download do hist√≥rico continuar√°, e na pr√≥ximo solicita√ß√£o simular, a fun√ß√£o retornar√° mais
dados.
Ao solicitar dados atrav√©s da data de in√≠cio e do n√∫mero de elementos requeridos, somente dados
cuja data seja menor (anterior) ou igual a data especificada s√£o retornados. Isso significa que a
hora de abertura de qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2107
indicador, pre√ßos de Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre menor
ou igual ao valor especificado.
Ao solicitar dados em uma faixa especificada de datas, somente dados deste intervalo ser√£o
retornados. O intervalo √© definido e contado em segundos. Isso significa que a hora de abertura de
qualquer barra, para cujo valor √© retornado (volume, spread, valor no buffer de indicador, pre√ßos de
Abertura, M√°ximo, M√≠nimo, Fechamento ou Hora de Abertura) √© sempre dentro do intervalo
solicitado.
Assim, se o dia corrente for s√°bado, e em uma tentativa de copiar dados usando a janela de tempo
semanal, voc√™ especificar start_time=Last_Tuesday e stop_time=Last_Friday, a fun√ß√£o retornar√° 0,
porque a hora de abertura em uma janela de tempo semanal √© sempre domingo, e nenhum barra
semanal cair√° no intervalo especificado.
Se voc√™ precisar retornar o valor correspondente para a barra corrente incompleta, voc√™ pode usar a
primeira forma de chamada, especificando start_pos=0 e count=1.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
//---- plotar Spread
#property indicator_label1  &quot;Spread&quot;
#property indicator_type1   DRAW_HISTOGRAM
#property indicator_color1  clrRed
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- par√¢metros de entrada
input int      bars=3000;
//--- buffers do indicador
double         SpreadBuffer[];
//+------------------------------------------------------------------+
//| Fun√ß√£o de inicializa√ß√£o do indicador customizado¬†                |
//+------------------------------------------------------------------+
void OnInit()
  {
//--- mapeamento de buffers do indicador
   SetIndexBuffer(0,SpreadBuffer,INDICATOR_DATA);
   IndicatorSetInteger(INDICATOR_DIGITS,0);
//---
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Fun√ß√£o de itera√ß√£o do indicador customizado¬†                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                 const int prev_calculated,
                 const datetime &amp;time[],
                 const double &amp;open[],
                 const double &amp;high[],
                 const double &amp;low[],</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2108
</p>
<pre><code class="language-mql5">
                 const double &amp;close[],
                 const long &amp;tick_volume[],
                 const long &amp;volume[],
                 const int &amp;spread[])
  {
//---
   if(prev_calculated==0)
     {
      int spread_int[];
      ArraySetAsSeries(spread_int,true);
      int spreads=CopySpread(Symbol(),0,0,bars,spread_int);
      Print(&quot;We have received the following number of Spread values: &quot;,spreads);
      for (int i=0;i&lt;spreads;i++) 
      {
      SpreadBuffer[rates_total-1-i]=spread_int[i];
      if(i&lt;=30) Print(&quot;spread[&quot;+i+&quot;] = &quot;,spread_int[i]);
      }
     }
   else
     {
      double Ask,Bid;
      Ask=SymbolInfoDouble(Symbol(),SYMBOL_ASK);
      Bid=SymbolInfoDouble(Symbol(),SYMBOL_BID);
      Comment(&quot;Ask = &quot;,Ask,&quot;  Bid = &quot;,Bid);
      SpreadBuffer[rates_total-1]=(Ask-Bid)/Point();
     }
//--- valor retorno de prev_calculated para a pr√≥xima chamada
   return(rates_total);
</code></pre>
<p>
  }
Veja um exemplo de solicita√ß√£o de dados hist√≥ricos na se√ß√£o M√©todos de Vincula√ß√£o de Objetos. O
script dispon√≠vel nesta se√ß√£o mostra como obter os valores do indicador iFractals nas √∫ltimas 1000
barras e como exibir os √∫ltimos 10 fractais de alta e os √∫ltimos 10 fractais de baixa no gr√°fico. Uma
t√©cnica simular pode ser usada para todos os indicadores que t√™m dados faltantes e que s√£o
usualmente desenhados usando os seguintes estilos:
¬∑ DRAW_SECTION,
¬∑ DRAW_ARROW,
¬∑ DRAW_ZIGZAG,
¬∑ DRAW_COLOR_SECTION,
¬∑ DRAW_COLOR_ARROW,
¬∑ DRAW_COLOR_ZIGZAG.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2109
<h3>CopyTicks</h3>
A fun√ß√£o obt√©m, dentro da matriz ticks_array, ticks no formato MqlTick, al√©m disso a indexa√ß√£o √©
realizada do passado para o presente, ou seja, o tick com √≠ndice 0 √© o mais antigo na matriz. Para a
an√°lise de ticks, √© necess√°rio verificar o campo flags, que indica o que foi alterado nesse tick.
</p>
<pre><code class="language-mql5">
int¬† CopyTicks(
   string¬†          symbol_name,¬†          // nome do s√≠mbolo
   MqlTick&amp;         ticks_array[],¬†        // matriz para recebimento de ticks
   uint¬†            flags=COPY_TICKS_ALL,¬† // sinalizador que define o tipo de ticks o
   ulong            from=0,¬†               // data a partir da qual s√£o solicitados os
   uint¬†            count=0¬†               // n√∫mero de ticks que √© necess√°rio obter
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  S√≠mbolo.
ticks_array
[out]  Matriz do tipo MqlTick para recebimento de ticks.
flags
[in]  sinalizador que especifica o tipo de ticks solicitados. COPY_TICKS_INFO ‚Äì ticks chamados
pelas altera√ß√µes do Bid e/ou Ask, COPY_TICKS_TRADE ‚Äì ticks com altera√ß√µes em Last e Volume,
COPY_TICKS_ALL ‚Äì todos os ticks. Em qualquer tipo de solicita√ß√£o, nos restantes campos da
estrutura MqlTick s√£o acrescentados os valores do tick anterior. 
from
[in]  Data a partir da qual s√£o solicitados os ticks. √â especificada em milissegundos desde
01.01.1970. Se o par√¢metro from=0, s√£o entregues as √∫ltimas count de ticks.
count
[in]  N√∫mero de ticks solicitados. Se os par√¢metros from e count n√£o forem definidos, no matriz
ticks_array[] ser√£o registrados todos os √∫ltimos ticks dispon√≠veis, mas n√£o mais de 2 000.
<h3>Valor de retorno</h3>
N√∫erod de ticks copiados ou -1 em caso de OnCalculate() nos indicadores √© chamada ap√≥s a entrada
de cada tick. 
Nos EAs e scripts, a fun√ß√£o CopyTicks() pode esperar at√© 45 segundos antes de obter o
resultado: Em contraste com o indicador, cada EA e script opera em seu pr√≥prio thread e, portanto,
pode esperar 45 segundos at√© a conclus√£o da sincroniza√ß√£o. Se, durante este tempo, a quantidade
necess√°ria de ticks n√£o forem sincronizados, CopyTicks () ir√° retornar ticks dispon√≠veis, por tempo
esgotado, e continuar√° a sincroniza√ß√£o. A fun√ß√£o OnTick() nos EAs n√£o √© processador de ticks, ela
simplesmente notifica o EA sobre as mudan√ßas no mercado. Essas mudan√ßas podem ser um lote: o
terminal pode fazer simultaneamente alguns ticks, mas a fun√ß√£o OnTick () ser√° chamada somente
uma vez para notificar o EA do estado mais recente do mercado. 
Velocidade de retorno de dados: o terminal armazena, para cada s√≠mbolo, os √∫ltimos 4096 ticks no
cache para acesso r√°pido (para s√≠mbolos com livro de ofertas ser√£o 65536 ticks), as solicita√ß√µes de
esses dados s√£o feitas com maior velocidade. Ao solicitar ticks da sess√£o de negocia√ß√£o atual fora</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2110
dos limites do cache, a CopyTicks() chama os ticks que s√£o armazenados na mem√≥ria do terminal,
estas solicita√ß√µes exigem mais tempo de execu√ß√£o. As mais lentas s√£o as solicita√ß√µes de ticks para
outros dias, como, neste caso, os dados s√£o lidos a partir do disco.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
#property copyright &quot;Copyright 2000-2024, MetaQuotes Ltd.&quot;
#property link      &quot;https://www.mql5.com&quot;
#property version   &quot;1.00&quot;
#property script_show_inputs
//--- Requesting 100 million ticks to be sure we receive the entire tick history
input int      getticks=100000000; // The number of required ticks
//+------------------------------------------------------------------+
//| Fun√ß√£o de in√≠cio do programa script                              |
//+------------------------------------------------------------------+
void OnStart()
  {
//---  
   int     attempts=0;     // Contagem de tentativas
   bool    success=false;  // A flag de uma c√≥pia bem sucedida de ticks
   MqlTick tick_array[];   // Tick recebendo o array
   MqlTick lasttick;       // Para receber os √∫ltimos dados do tick
   SymbolInfoTick(_Symbol,lasttick);
//--- Fa√ßa 3 tentativas de receber ticks
   while(attempts&lt;3)
     {
      //--- Medi√ß√£o da hora de in√≠cio antes de receber os ticks
      uint start=GetTickCount();
//--- Solicitando o hist√≥rico de ticks desde 1970.01.01 00:00.001 (par√¢metro para=1 ms
      int received=CopyTicks(_Symbol,tick_array,COPY_TICKS_ALL,1,getticks);
      if(received!=-1)
        {
         //--- Mostrando informa√ß√µes sobre o n√∫mero de ticks e tempo gasto
         PrintFormat(&quot;%s: received %d ticks in %d ms&quot;,_Symbol,received,GetTickCount()-
         //--- Se o hist√≥rico de ticks √© sincronizado, o c√≥digo de erro √© igual a zero
         if(GetLastError()==0)
           {
            success=true;
            break;
           }
         else
            PrintFormat(&quot;%s: Ticks ainda n√£o est√£o sincronizados, %d ticks recebidos p
            _Symbol,received,GetTickCount()-start,_LastError);
        }
      //--- Contagem de tentativas
      attempts++;
      //--- Uma pausa de um segundo para aguardar o fim da sincroniza√ß√£o da base de da
      Sleep(1000);
     }</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2111
</p>
<pre><code class="language-mql5">
//--- A recep√ß√£o de ticks solicitados no in√≠cio do hist√≥rico de ticks falhou em tr√™s t
   if(!success)
     {
      PrintFormat(&quot;Error! Falha em receber %d ticks do %s em tr√™s tentativas&quot;,getticks
      return;
     }
   int ticks=ArraySize(tick_array);
//--- Mostrando a hora da primeira marca no array
   datetime firstticktime=tick_array[ticks-1].time;
   PrintFormat(&quot;Hor√°rio do √∫ltimo tick = %s.%03I64u&quot;,
               TimeToString(firstticktime,TIME_DATE|TIME_MINUTES|TIME_SECONDS),tick_ar
//--- Obtivemos o √∫ltimo tick no array
   datetime lastticktime=tick_array[0].time;
   PrintFormat(&quot;Hor√°rio do primeiro tick = %s.%03I64u&quot;,
               TimeToString(lastticktime,TIME_DATE|TIME_MINUTES|TIME_SECONDS),tick_arr
//---                                                           
   MqlDateTime today;
   datetime current_time=TimeCurrent();                         
   TimeToStruct(current_time,today);                            
   PrintFormat(&quot;current_time=%s&quot;,TimeToString(current_time));   
   today.hour=0;
   today.min=0;
   today.sec=0;
   datetime startday=StructToTime(today);
   datetime endday=startday+24*60*60;
   if((ticks=CopyTicksRange(_Symbol,tick_array,COPY_TICKS_ALL,startday*1000,endday*100
     {
      PrintFormat(&quot;CopyTicksRange(%s,tick_array,COPY_TICKS_ALL,%s,%s) failed, error %d
                  _Symbol,TimeToString(startday),TimeToString(endday),GetLastError());
      return;                                                                         
     }
   ticks=MathMax(100,ticks); 
//--- Mostrando os primeiros 100 ticks do √∫ltimo dia
   int counter=0;
   for(int i=0;i&lt;ticks;i++)
     {
      datetime time=tick_array[i].time;
      if((time&gt;=startday) &amp;&amp; (time&lt;endday) &amp;&amp; counter&lt;100)
        {
         counter++;
         PrintFormat(&quot;%d. %s&quot;,counter,GetTickDescription(tick_array[i]));
        }
     }
//--- Mostrando as primeiras 100 ofertas do √∫ltimo dia
   counter=0;
   for(int i=0;i&lt;ticks;i++)
     {
      datetime time=tick_array[i].time;</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2112
</p>
<pre><code class="language-mql5">
      if((time&gt;=startday) &amp;&amp; (time&lt;endday) &amp;&amp; counter&lt;100)
        {
         if(((tick_array[i].flags&amp;TICK_FLAG_BUY)==TICK_FLAG_BUY) || ((tick_array[i].fl
           {
            counter++;
            PrintFormat(&quot;%d. %s&quot;,counter,GetTickDescription(tick_array[i]));
           }
        }
     }
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna a descri√ß√£o de string de um tick                         |
//+------------------------------------------------------------------+
string GetTickDescription(MqlTick &amp;tick)
  {
   string desc=StringFormat(&quot;%s.%03d &quot;,
                            TimeToString(tick.time),tick.time_msc%1000);
//--- Checando flags
   bool buy_tick=((tick.flags&amp;TICK_FLAG_BUY)==TICK_FLAG_BUY);
   bool sell_tick=((tick.flags&amp;TICK_FLAG_SELL)==TICK_FLAG_SELL);
   bool ask_tick=((tick.flags&amp;TICK_FLAG_ASK)==TICK_FLAG_ASK);
   bool bid_tick=((tick.flags&amp;TICK_FLAG_BID)==TICK_FLAG_BID);
   bool last_tick=((tick.flags&amp;TICK_FLAG_LAST)==TICK_FLAG_LAST);
   bool volume_tick=((tick.flags&amp;TICK_FLAG_VOLUME)==TICK_FLAG_VOLUME);
//--- Verificar flags de negocia√ß√£o num primeiro tick
   if(buy_tick || sell_tick)
     {
      //--- Formando uma sa√≠da para o tick de negocia√ß√£o
      desc=desc+(buy_tick?StringFormat(&quot;Buy Tick: Last=%G Volume=%d &quot;,tick.last,tick.v
      desc=desc+(sell_tick?StringFormat(&quot;Sell Tick: Last=%G Volume=%d &quot;,tick.last,tick
      desc=desc+(ask_tick?StringFormat(&quot;Ask=%G &quot;,tick.ask):&quot;&quot;);
      desc=desc+(bid_tick?StringFormat(&quot;Bid=%G &quot;,tick.ask):&quot;&quot;);
      desc=desc+&quot;(Trade tick)&quot;;
     }
   else
     {
      //--- Forme uma sa√≠da diferente para um tick de informa√ß√£o
      desc=desc+(ask_tick?StringFormat(&quot;Ask=%G &quot;,tick.ask):&quot;&quot;);
      desc=desc+(bid_tick?StringFormat(&quot;Bid=%G &quot;,tick.ask):&quot;&quot;);
      desc=desc+(last_tick?StringFormat(&quot;Last=%G &quot;,tick.last):&quot;&quot;);
      desc=desc+(volume_tick?StringFormat(&quot;Volume=%d &quot;,tick.volume):&quot;&quot;);
      desc=desc+&quot;(Info tick)&quot;;
     }
//--- Retornando descri√ß√£o do tick
   return desc;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
/* Exemplo de sa√≠da
</code></pre>
<p>
Si-12.16: recebeu 11048387 ticks em 4937 ms</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2113
Hor√°rio do √∫ltimo tick = 2016.09.26 18:32:59.775
Hor√°rio do primeiro tick = 2015.06.18 09:45:01.000
1.  2016.09.26 09:45.249 Ask=65370 Bid=65370 (Info tick)
2.  2016.09.26 09:47.420 Ask=65370 Bid=65370 (Info tick)
3.  2016.09.26 09:50.893 Ask=65370 Bid=65370 (Info tick)
4.  2016.09.26 09:51.827 Ask=65370 Bid=65370 (Info tick)
5.  2016.09.26 09:53.810 Ask=65370 Bid=65370 (Info tick)
6.  2016.09.26 09:54.491 Ask=65370 Bid=65370 (Info tick)
7.  2016.09.26 09:55.913 Ask=65370 Bid=65370 (Info tick)
8.  2016.09.26 09:59.350 Ask=65370 Bid=65370 (Info tick)
9.  2016.09.26 09:59.678 Bid=65370 (Info tick)
10. 2016.09.26 10:00.000 Sell Tick: Last=65367 Volume=3 (Trade tick)
11. 2016.09.26 10:00.000 Sell Tick: Last=65335 Volume=45 (Trade tick)
12. 2016.09.26 10:00.000 Sell Tick: Last=65334 Volume=95 (Trade tick)
13. 2016.09.26 10:00.191 Sell Tick: Last=65319 Volume=1 (Trade tick)
14. 2016.09.26 10:00.191 Sell Tick: Last=65317 Volume=1 (Trade tick)
15. 2016.09.26 10:00.191 Sell Tick: Last=65316 Volume=1 (Trade tick)
16. 2016.09.26 10:00.191 Sell Tick: Last=65316 Volume=10 (Trade tick)
17. 2016.09.26 10:00.191 Sell Tick: Last=65315 Volume=5 (Trade tick)
18. 2016.09.26 10:00.191 Sell Tick: Last=65313 Volume=3 (Trade tick)
19. 2016.09.26 10:00.191 Sell Tick: Last=65307 Volume=25 (Trade tick)
20. 2016.09.26 10:00.191 Sell Tick: Last=65304 Volume=1 (Trade tick)
21. 2016.09.26 10:00.191 Sell Tick: Last=65301 Volume=1 (Trade tick)
22. 2016.09.26 10:00.191 Sell Tick: Last=65301 Volume=10 (Trade tick)
23. 2016.09.26 10:00.191 Sell Tick: Last=65300 Volume=5 (Trade tick)
24. 2016.09.26 10:00.191 Sell Tick: Last=65300 Volume=1 (Trade tick)
25. 2016.09.26 10:00.191 Sell Tick: Last=65300 Volume=6 (Trade tick)
26. 2016.09.26 10:00.191 Sell Tick: Last=65299 Volume=1 (Trade tick)
27. 2016.09.26 10:00.191 Bid=65370 (Info tick)
28. 2016.09.26 10:00.232 Ask=65297 (Info tick)
29. 2016.09.26 10:00.276 Sell Tick: Last=65291 Volume=31 (Trade tick)
30. 2016.09.26 10:00.276 Sell Tick: Last=65290 Volume=1 (Trade tick)
*/
<h3>Veja tamb√©m</h3>
SymbolInfoTick, Estrutura para recebimento de pre√ßos atuais, OnTick()</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2114
<h3>CopyTicksRange</h3>
A fun√ß√£o recebe, na matriz ticks_array, ticks em formato MqlTick, no intervalo de datas especificado.
Al√©m disso, a indexa√ß√£o √© realizada do passado para o presente, ou seja, o tick com √≠ndice 0 √© o mais
antigo na matriz. Para analisar o tick, √© necess√°rio verificar o campo flags, ele notifica sobre as
altera√ß√µes levadas a cabo.
</p>
<pre><code class="language-mql5">
int¬† CopyTicksRange(
   const string¬†    symbol_name,¬†          // nome do s√≠mbolo
   MqlTick&amp;         ticks_array[],¬†        // matriz para recebimento de ticks
   uint¬†            flags=COPY_TICKS_ALL,¬† // sinalizador que define o tipo de ticks o
   ulong            from_msc=0,¬†           // data a partir da qual s√£o solicitados os
   ulong¬†           to_msc=0¬†              // data em que s√£o solicitados os ticks
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol_name
[in]  S√≠mbolo.
ticks_array
[out] Matriz est√°tica ou din√¢mica MqlTick para recebimento de ticks. Se na matriz est√°tica n√£o
caberem todos os ticks do intervalo solicitado, ser√£o obtidos tantos ticks quanto caberem na
matriz. Al√©m disso, a fun√ß√£o gerar√° o erro ERR_HISTORY_SMALL_BUFFER (4407) .
flags
[in]  sinalizador que especifica o tipo de ticks solicitados. COPY_TICKS_INFO ‚Äì ticks chamados
pelas altera√ß√µes do Bid e/ou Ask, COPY_TICKS_TRADE ‚Äì ticks com altera√ß√µes em Last e Volume,
COPY_TICKS_ALL ‚Äì todos os ticks. Em qualquer tipo de solicita√ß√£o, nos restantes campos da
estrutura MqlTick s√£o acrescentados os valores do tick anterior. 
from_msc
[in]  Data a partir da qual s√£o solicitados os ticks. √â especificada em milissegundos desde
01.01.1970. Se o par√¢metro from_msc n√£o estiver especificado, s√£o enviados os ticks a partir do
in√≠cio do hist√≥rico. S√£o enviados os ticks com tempo &gt;= from_msc.
to_msc
[in]   Data na qual s√£o solicitados os ticks. Especificado em milissegundos desde 01.01.1970. Se o
par√¢metro to_msc n√£o estiver especificado, s√£o enviados todos os ticks do hist√≥rico.  N√∫mero de
ticks solicitados. S√£o enviados os ticks com tempo &lt;= to_msc.
<h3>Valor de retorno</h3>
N√∫mero de ticks copiados ou -1 em caso de erro. GetLastError() pode retornar os seguintes erros:
¬∑ ERR_HISTORY_TIMEOUT ‚Äì esgotado o tempo de espera de sincroniza√ß√£o, a fun√ß√£o enviou todo o
que havia.
¬∑ ERR_HISTORY_SMALL_BUFFER ‚Äì o buffer est√°tico √© muito pequeno, enviado tanto, quanto cabia
na matriz.
¬∑ ERR_NOT_ENOUGH_MEMORY ‚Äì n√£o h√° mem√≥ria suficiente para obter o hist√≥rico a partir do
intervalo especificado na matriz din√¢mica de ticks. Falha ao selecionar a quantidade certa de
mem√≥ria para uma matriz de ticks.</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2115
<h3>Observa√ß√£o</h3>
A fun√ß√£o CopyTicksRange() √© usada para solicitar ticks a partir de um intervalo antigo, por exemplo,
os ticks de um dia determinado no hist√≥rico. Enquanto a CopyTicks() permite definir apenas a data
de in√≠cio, por exemplo, obter todos os ticks desde o in√≠cio do m√™s at√© o momento atual.
<h3>Veja tamb√©m</h3>
SymbolInfoTick, Estrutura para recebimento de pre√ßos atuais, OnTick, CopyTicks</p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2116
iBars
Retorna o n√∫mero de barras - no hist√≥rico - do s√≠mbolo e do per√≠odo correspondentes.
</p>
<pre><code class="language-mql5">
int¬† iBars(
   const string¬†          symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES        timeframe ¬†      // per√≠odo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
<h3>Valor de retorno</h3>
N√∫mero de barras - no hist√≥rico - do s√≠mbolo e do per√≠odo correspondentes, mas n√£o mais do que o
especificado nas configura√ß√µes da plataforma pelo par√¢metro &quot;N√∫mero m√°x. de barras na
janela&quot; (&quot;Max bars in chart&quot;)
<h3>Exemplo:</h3>
  Print(&quot;Bar count on the &#x27;EURUSD,H1&#x27; is &quot;,iBars(&quot;EURUSD&quot;,PERIOD_H1));
<h3>Veja tamb√©m</h3>
<h3>Bars</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2117
iBarShift
Busca de barra segundo o tempo. A fun√ß√£o retorna o √≠ndice da barra na qual o tempo especificado
coincide.
</p>
<pre><code class="language-mql5">
int¬† iBarShift(
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   datetime¬†           time, ¬†          // tempo
   bool¬†               exact=false ¬†    // modo
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. PERIOD_CURRENT
significa o per√≠odo atual do gr√°fico atual.
time
[in]  Valor do tempo para a pesquisa.
exact=false
[in]  Valor retornado se a barra n√£o for encontrada para o tempo especificado. Se exact=false,
iBarShift retorna o √≠ndice da barra mais pr√≥xima cujo tempo de abertura √© menor do que o
especificado (time_open&lt;time). Se essa barra n√£o for encontrada (n√£o h√° hist√≥rico antes do
tempo especificado), a fun√ß√£o retornar√° -1. Se exact=true, n√£o √© pesquisada a barra mais pr√≥xima
e a fun√ß√£o iBarShift retorna imediatamente -1.
<h3>Valor de retorno</h3>
√çndice da barra que coincide com o tempo especificado. Se n√£o houver barra para o tempo
especificado (&quot;buraco&quot; no hist√≥rico), a fun√ß√£o retorna -1 ou o √≠ndice da barra mais pr√≥xima
(dependendo do par√¢metro exact).
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- data √© no domingo
   datetime time=D&#x27;2002.04.25 12:00&#x27;;
   string symbol=&quot;GBPUSD&quot;;
   ENUM_TIMEFRAMES tf=PERIOD_H1;
   bool exact=false;
//--- se n√£o houver barra para o tempo especificado, iBarShift retornar√° o √≠ndice da b
   int bar_index=iBarShift(symbol,tf,time,exact);
//--- verificamos o c√≥digo de erro ap√≥s chamada de iBarShift()</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2118
</p>
<pre><code class="language-mql5">
   int error=GetLastError();
   if(error!=0)
     {
      PrintFormat(&quot;iBarShift(): GetLastError=%d - data solicitada %s &quot;+
                  &quot;para %s %s no hist√≥rico dispon√≠vel n√£o encontrada&quot;,
                  error,TimeToString(time),symbol,EnumToString(tf));
      return;
     }
//--- fun√ß√£o iBarShift() executada com sucesso, imprimimos os resultados para exact=fa
   PrintFormat(&quot;1. %s %s %s(%s): bar index is %d (exact=%s)&quot;,
               symbol,EnumToString(tf),TimeToString(time),
               DayOfWeek(time),bar_index,string(exact));
   datetime bar_time=iTime(symbol,tf,bar_index);
   PrintFormat(&quot;Time of bar #%d is %s (%s)&quot;,
               bar_index,TimeToString(bar_time),DayOfWeek(bar_time));
//--- precisamos encontrar o √≠ndice da barra para o tempo especificado, se ele n√£o exi
   exact=true;
   bar_index=iBarShift(symbol,tf,time,exact);
//--- fun√ß√£o iBarShift() executada com sucesso, imprimimos os resultados para exact=tr
   PrintFormat(&quot;2. %s %s %s (%s):bar index is %d (exact=%s)&quot;,
               symbol,EnumToString(tf),TimeToString(time)
               ,DayOfWeek(time),bar_index,string(exact));
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna o nome do dia da semana                                   |
//+------------------------------------------------------------------+
string DayOfWeek(const datetime time)
  {
   MqlDateTime dt;
   string day=&quot;&quot;;
   TimeToStruct(time,dt);
   switch(dt.day_of_week)
     {
      case 0: day=EnumToString(SUNDAY);
      break;
      case 1: day=EnumToString(MONDAY);
      break;
      case 2: day=EnumToString(TUESDAY);
      break;
      case 3: day=EnumToString(WEDNESDAY);
      break;
      case 4: day=EnumToString(THURSDAY);
      break;
      case 5: day=EnumToString(FRIDAY);
      break;
      default:day=EnumToString(SATURDAY);
      break;
     }
//---</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2119
</p>
<pre><code class="language-mql5">
   return day;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
/* Resultado da execu√ß√£o
   1. GBPUSD PERIOD_H1 2018.06.10 12:00(SUNDAY): bar index is 64 (exact=false)
   Time of bar #64 is 2018.06.08 23:00 (FRIDAY)
   2. GBPUSD PERIOD_H1 2018.06.10 12:00 (SUNDAY):bar index is -1 (exact=true)
</code></pre>
<p>
*/ </p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2120
iClose
Retorna o valor do pre√ßo de fechamento da barra (indicado pelo par√¢metro shift) do gr√°fico
correspondente.
</p>
<pre><code class="language-mql5">
double¬† iClose(
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do pre√ßo de fechamento da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou
0 no caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2121
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopyClose, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2122
iHigh
Retorna o valor do pre√ßo m√°ximo da barra (especificado pelo par√¢metro shift) do gr√°fico
correspondente.
</p>
<pre><code class="language-mql5">
double¬† iHigh(
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do pre√ßo m√°ximo da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0 no
caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2123
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopyHigh, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2124
iHighest
Retorna o √≠ndice do maior valor encontrado (deslocamento relativo √† barra atual) do gr√°fico
correspondente.
</p>
<pre><code class="language-mql5">
int¬† iHighest(
   const string¬†       symbol,              // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†          // per√≠odo
   ENUM_SERIESMODE     type, ¬†              // identificador de timeseries
   int¬†                count=WHOLE_ARRAY,   // n√∫mero de itens
   int¬†                start=0 ¬†            // √≠ndice
</code></pre>
<p>
  );
<h3>Par√¢metros</h3>
symbol
[in]  S√≠mbolo em que ser√° realizada a pesquisa. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
type
[in]  Identificador de timeseries em que ser√° realizada a pesquisa. Pode ser qualquer um dos
valores ENUM_SERIESMODE.
count=WHOLE_ARRAY
[in]  N√∫mero de itens de timeseries (na dire√ß√£o tanto da barra atual quanto do aumento do
√≠ndice), entre os quais deve ser realizada a pesquisa.
start=0
[in]  √çndice (deslocamento em rela√ß√£o √† barra atual) da barra inicial a partir do qual come√ßa a
pesquisa do maior valor. Valores negativos s√£o ignorados e substitu√≠dos por um valor zero.
<h3>Valor de retorno</h3>
√çndice do maior valor encontrado (deslocamento em rela√ß√£o √† barra atual) do gr√°fico correspondente
ou -1 no caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   double val;
//--- c√°lculo do valor m√°ximo do pre√ßo Close em 20 barras consecutivas
//--- a partir do √≠ndice 4 e terminando no √≠ndice 23, inclusive no gr√°fico atual
   int val_index=iHighest(NULL,0,MODE_CLOSE,20,4);
   if(val_index!=-1) 
      val=High[val_index];
   else 
      PrintFormat(&quot;Erro ao chamar iHighest(). C√≥digo de erro=%d&quot;,GetLastError());</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2125
iLow
Retorna o valor do pre√ßo m√≠nimo da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente.
</p>
<pre><code class="language-mql5">
double¬† iLow(
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do pre√ßo m√≠nimo da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0 no
caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2126
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopyLow, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2127
iLowest
Retorna o √≠ndice do menor valor encontrado (deslocamento relativo √† barra atual) do gr√°fico
correspondente.
</p>
<pre><code class="language-mql5">
int¬† iLowest(
   const string¬†       symbol,              // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†          // per√≠odo
   ENUM_SERIESMODE     type, ¬†              // identificador de timeseries
   int¬†                count=WHOLE_ARRAY,   // n√∫mero de itens
   int¬†                start=0 ¬†            // √≠ndice
</code></pre>
<p>
  );
<h3>Par√¢metros</h3>
symbol
[in]  S√≠mbolo em que ser√° realizada a pesquisa. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 indica o per√≠odo do
gr√°fico atual.
type
[in]  Identificador de timeseries em que ser√° realizada a pesquisa. Pode ser qualquer um dos
valores ENUM_SERIESMODE.
count=WHOLE_ARRAY
[in]  N√∫mero de itens de timeseries (na dire√ß√£o tanto da barra atual quanto do aumento do
√≠ndice), entre os quais deve ser realizada a pesquisa.
start=0
[in]  √çndice (deslocamento em rela√ß√£o √† barra atual) da barra inicial a partir do qual come√ßa a
busca do menor valor. Valores negativos s√£o ignorados e substitu√≠dos por um valor zero.
<h3>Valor de retorno</h3>
√çndice do menor valor encontrado (deslocamento em rela√ß√£o √† barra atual) do gr√°fico
correspondente ou -1 no caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o
GetLastError().
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
   double val;
//--- pesquisa da barra com um valor m√≠nimo do volume real em 15 barras consecutivas
//--- a partir do √≠ndice 10 e terminando no √≠ndice 24, inclusive no gr√°fico atual
   int val_index=iLowest(NULL,0,MODE_REAL_VOLUME,15,10);
   if(val_index!=-1) 
      val=Low[val_index];
   else 
      PrintFormat(&quot;Erro ao chamar iLowest(). C√≥digo de erro=%d&quot;,GetLastError());</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2128
iOpen
Retorna o valor do pre√ßo de abertura da barra (indicado pelo par√¢metro shift) do gr√°fico
correspondente.
</p>
<pre><code class="language-mql5">
double¬† iOpen(
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do pre√ßo de abertura da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0
no caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2129
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopyOpen, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2130
iTime
Retorna o valor do tempo de abertura da barra (indicado pelo par√¢metro shift) do gr√°fico
correspondente.
datetime¬† iTime(
</p>
<pre><code class="language-mql5">
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do tempo de abertura da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0
no caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- data √© no domingo
   datetime time=D&#x27;2018.06.10 12:00&#x27;;
   string symbol=&quot;GBPUSD&quot;;
   ENUM_TIMEFRAMES tf=PERIOD_H1;
   bool exact=false;
//--- se n√£o houver barra para o tempo especificado, iBarShift retornar√° o √≠ndice da b
   int bar_index=iBarShift(symbol,tf,time,exact);
   PrintFormat(&quot;1. %s %s %s(%s): bar index is %d (exact=%s)&quot;,</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2131
</p>
<pre><code class="language-mql5">
               symbol,EnumToString(tf),TimeToString(time),DayOfWeek(time),bar_index,st
   datetime bar_time=iTime(symbol,tf,bar_index);
   PrintFormat(&quot;Time of bar #%d is %s (%s)&quot;,
               bar_index,TimeToString(bar_time),DayOfWeek(bar_time));
//PrintFormat(iTime(symbol,tf,bar_index));
//--- precisamos encontrar o √≠ndice da barra para o tempo especificado, se ele n√£o exi
   exact=true;
   bar_index=iBarShift(symbol,tf,time,exact);
   PrintFormat(&quot;2. %s %s %s (%s):bar index is %d (exact=%s)&quot;,
               symbol,EnumToString(tf),TimeToString(time),DayOfWeek(time),bar_index,st
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
//+------------------------------------------------------------------+
//| Retorna o nome do dia da semana                                   |
//+------------------------------------------------------------------+
string DayOfWeek(const datetime time)
  {
   MqlDateTime dt;
   string day=&quot;&quot;;
   TimeToStruct(time,dt);
   switch(dt.day_of_week)
     {
      case 0: day=EnumToString(SUNDAY);
      break;
      case 1: day=EnumToString(MONDAY);
      break;
      case 2: day=EnumToString(TUESDAY);
      break;
      case 3: day=EnumToString(WEDNESDAY);
      break;
      case 4: day=EnumToString(THURSDAY);
      break;
      case 5: day=EnumToString(FRIDAY);
      break;   
      default:day=EnumToString(SATURDAY);
      break;
     }
//---
   return day;
</code></pre>
<p>
  }
</p>
<pre><code class="language-mql5">
/* Resultado:
   1. GBPUSD PERIOD_H1 2018.06.10 12:00(SUNDAY): bar index is 64 (exact=false)
   Time of bar #64 is 2018.06.08 23:00 (FRIDAY)
   2. GBPUSD PERIOD_H1 2018.06.10 12:00 (SUNDAY):bar index is -1 (exact=true)
</code></pre>
<p>
*/  
<h3>Veja tamb√©m</h3>
<h3>CopyTime, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2132
iTickVolume
Retorna o valor do volume de tick (especificado pelo par√¢metro shift) do gr√°fico correspondente.
long¬† iTickVolume(
</p>
<pre><code class="language-mql5">
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do volume de tick da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0 no
caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2133
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopyTickVolume, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2134
iRealVolume
Retorna o valor do volume real da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente.
long¬† iRealVolume(
</p>
<pre><code class="language-mql5">
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
O valor do volume real da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0 no
caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2135
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopyRealVolume, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2136
iVolume
Retorna o valor do volume de tick (especificado pelo par√¢metro shift) do gr√°fico correspondente.
long¬† iVolume(
</p>
<pre><code class="language-mql5">
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do volume de tick da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0 no
caso de erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2137
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopyTickVolume, CopyRates</h3></p>
<p><h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2138
iSpread
Retorna o valor do spread da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente.
long  iSpread(
</p>
<pre><code class="language-mql5">
   const string¬†       symbol,          // s√≠mbolo
   ENUM_TIMEFRAMES     timeframe,¬†      // per√≠odo
   int¬†                shift ¬†          // deslocamento
   );
</code></pre>
<p>
<h3>Par√¢metros</h3>
symbol
[in]  Nome simb√≥lico do instrumento. NULL significa o s√≠mbolo atual.
timeframe
[in]  Per√≠odo. Pode ser um dos valores da enumera√ß√£o ENUM_TIMEFRAMES. 0 significa o per√≠odo
do gr√°fico atual.
shift
[in]  √çndice do valor recebido do timeseries (deslocamento - n√∫mero especificado de barras atr√°s -
em rela√ß√£o √† barra atual).
<h3>Valor de retorno</h3>
Valor do spread da barra (indicado pelo par√¢metro shift) do gr√°fico correspondente ou 0 no caso de
erro. Para mais informa√ß√µes sobre o erro, deve-se chamar a fun√ß√£o GetLastError().
<h3>Observa√ß√£o</h3>
A fun√ß√£o sempre retorna dados relevantes, para isso, a cada chamada, faz uma solicita√ß√£o aos
timeseries para o s√≠mbolo/per√≠odo especificado. Isso significa que, se n√£o houver dados prontos na
primeira chamada de fun√ß√£o, preparar o resultado poder√° levar algum tempo.
A fun√ß√£o n√£o armazena os resultados de chamadas anteriores, pois n√£o h√° cache local para retorno
r√°pido do valor.
<h3>Exemplo:</h3>
</p>
<pre><code class="language-mql5">
input int shift=0;
//+------------------------------------------------------------------+
//| Function-event handler &quot;tick&quot;                                    |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime time  = iTime(Symbol(),Period(),shift);
   double   open  = iOpen(Symbol(),Period(),shift);
   double   high  = iHigh(Symbol(),Period(),shift);
   double   low   = iLow(Symbol(),Period(),shift);
   double   close = iClose(NULL,PERIOD_CURRENT,shift);
   long     volume= iVolume(Symbol(),0,shift);
   int      bars  = iBars(NULL,0);</p>
<p></code></pre>
<p>
<h3>S√©ries Temporais e Acesso a Indicadores</h3>
¬© 2000-2025, MetaQuotes Ltd.
2139
</p>
<pre><code class="language-mql5">
   Comment(Symbol(),&quot;,&quot;,EnumToString(Period()),&quot;\n&quot;,
           &quot;Time: &quot;  ,TimeToString(time,TIME_DATE|TIME_SECONDS),&quot;\n&quot;,
           &quot;Open: &quot;  ,DoubleToString(open,Digits()),&quot;\n&quot;,
           &quot;High: &quot;  ,DoubleToString(high,Digits()),&quot;\n&quot;,
           &quot;Low: &quot;   ,DoubleToString(low,Digits()),&quot;\n&quot;,
           &quot;Close: &quot; ,DoubleToString(close,Digits()),&quot;\n&quot;,
           &quot;Volume: &quot;,IntegerToString(volume),&quot;\n&quot;,
           &quot;Bars: &quot;  ,IntegerToString(bars),&quot;\n&quot;
           );
</code></pre>
<p>
  }
<h3>Veja tamb√©m</h3>
<h3>CopySpread, CopyRates</h3>
</p>
        </article>
        
        <footer>
            <p>Documenta√ß√£o MQL5 - Fonte: MetaQuotes Ltd.</p>
        </footer>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function toggleSidebar() {
            document.querySelector('.sidebar').classList.toggle('open');
        }
        
        function filterNav() {
            const filter = document.getElementById('search').value.toLowerCase();
            const items = document.querySelectorAll('.nav-list li');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? '' : 'none';
            });
        }
    </script>
</body>
</html>